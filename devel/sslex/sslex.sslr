/*
    Dies ist die SSLEX-Grammatik. Ich habe sie dem GNU-flex-Scanner-Projekt entnommen
    und an meinen LR-Parser-Generator SSLR angepast.
    (c) 2003-2005 by Sven Schmidt
    s.schmidt@lboro.ac.uk

    Last modified: 21.04.2005
*/




%include
\{

//SSLEX intern initialisieren
#define SSLR_INIT


//NEA darf nur am Zeilenanfang stehen
#define BEGLINE_NEA 0
#define NORM_NEA    1


//für das Wiederholen von NEAen
#define _INFINITY   -1

//Zustände setzen
#define MARK_AS_NORMAL  0
#define MARK_AS_FINIT   1
#define MARK_AS_LA      2



//mit Zustandsminimierung
#undef MINDEA
#define MINDEA


//gebe erweiterte Debug-Meldungen aus
#define DEBUG_LEVEL2
#undef DEBUG_LEVEL2

\}


%definition


%union
{
    //Strings
    char    *name;

    int     i;

    //Charakter-Klassen
    int     *cclClass;

    //simples Zeichen
    char    character;

    //long
    long    l;

    //NEA_STR
    NEA_STR *neaStr;
}


//Den Terminalen und den Nicht-Terminalen semantische Typen zufügen.
%ntermType <i> scon scon_stk_ptr
%ntermType <neaStr> re re2 rule series singleton string flexrule
%ntermType <cclClass> fullccl ccl ccl_expr
%termType <name> NAME
%termType <neaStr> ANY
%termType <character> CHAR
%termType <l> NUMBER




    /**********************************************
     ** hier stehen Deklarationen, die später im **
     ** Header-File des erzeugten Parsers stehen **
     **********************************************/


    private:

    //Struktur für die Erzeugung der Debug-Informationen im generierten Scanner
    typedef struct
    {
        //Zeiger auf NEA
        NEA_STR *nea;

        //Index im Array mit den entsprechenden reg. Ausdrcken in Textform
        ulong   index;

    }DEBUG_STR;



    //Struktur für die Zustandsbergänge
    typedef struct
    {
        //Zeichen-Klasse, bestimmt den Übergang
        int     *cclClass;

        //jeweiliger Zustand ist ein Epsilon-Übergang
        bool    eps;

        //Index des Ziel-Zustandes
        ulong   bra;

    }BRA_STR;



    //Struktur für die NEA-Zustände
    typedef struct stateStr
    {
        //Nummer des Zustandes im Zustands-Array
        //-1: kein Übergang!
        ulong           state;

        //entsprechender NEA, nur bei Start-, End- und Lookahead-Zuständen
        NEA_STR         *nea;

        //hat epsilon-Übergänge
        bool            eps;

        //ist Finit-Zustand
        bool            finit;

        //mithilfe des folgenden Flags wird geprüft, ob die Regel jemals ausgeführt werden kann
        bool            isUseful;

        //ist Lookahead-End-Zustand
        bool            la;

        //Array mit den Übergängen
        BRA_STR         **braStr;

        //Anzahl der Übergänge von diesem NEA
        ulong           braStrCnt;

    }STATE_STR;



    //Struktur für die DEA-ZustandsÜbergangs-Tabelle
    typedef struct
    {
        //DEA-Index
        ulong   index;

        //Array mit der Breite cclWidth mit den Ziel-Zuständen
        ulong   *to;
    //vorher:   long    *to;

    }DTRAN;



    //Struktur zur Implementierung der Gruppen für die Zustands-Minimierung, s. Drachenbuch S. 172
    typedef struct
    {
        //Index dieser Gruppe
        long    index;

        //Index der Gruppe der Ziel-Zustände
        long    destIndex;

        //die zu dieser Gruppe gehörenden DEA-Zustände
        ulong   *DEAIndex;

        //Anazhl der DEA-Zustände in dieser Gruppe
        ulong   DEAIndexCnt;

        //Gruppe ist valid
        bool    valid;

        //enthält Finit-Zustände
        bool    finit;

        //enthält Lookahead-Zustände
        bool    la;

        //enthält den Start-Zustand
        bool    startGroup;

        //Zeiger auf den NEA, zu dem die akzeptierenden Zustände gehören, wenn akzeptierende Gruppe
        NEA_STR *finitNEA;

        //DEA-Index eines der Lookahead-Zustände
        ulong   laIndex;

    }GROUP_STR;



    //Struktur für die SC
    typedef struct
    {
        //Name der SC
        char        *name;

        //true: exclusive, sonst inclusive
        bool        type;

        //Array mit allen NEAen, die zu dieser SC gehören
        NEA_STR     **neaArr;

        //Anzahl der NEA_STR in neaArr
        long        neaArrCnt;

        //Anzahl der NEAen, die überall stehen dürfen
        long        nea1Anz;

        //Anzahl der NEAen, die nur am Zeilenanfang stehen dürfen
        long        nea2Anz;

        //DEA-Zustands-Übergangstabelle für die NEAen, die überall stehen dürfen
        DTRAN       **DTran1;

        //Anzahl der Zeilen in der DEA-Übergangstabelle
        ulong       DTran1Cnt;

        //DEA-Zustands-Übergangstabelle für die NEAen, die nur am Anfang stehen dürfen
        DTRAN       **DTran2;

        //Anzahl der Zeilen in der DEA-Übergangstabelle
        ulong       DTran2Cnt;

        //bei Zustandsminimierung: Array mit den Gruppen der DEA-Zustände
        GROUP_STR   **grp;

        //Anzahl der Gruppen
        ulong       grpCnt;

        //Start-Zustand des DEA mit NEAen, die überall stehen dürfen
        long        DEAIndex;

        //Start-Zustand der DEAen, die NUR am Zeilenanfang stehen dürfen
        long        begLineDEAIndex;

        //DEA-Zustand der NEAen, die überall stehen dürfen (nach Zustandsminimierung)
        long        firstStart;

        //DEA-Zustand der NEAen, die nur am Zeilenanfang stehen dürfen (nach Zustandsminimierung)
        long        secondStart;

    }SC_STR;



    //Struktur für die Erzeugung von e-Closure
    typedef struct
    {
        //Array mit den Indices, die einen Epsilon-Übergang zu to haben
        ulong   *from;

        //Anzahl der Indices in from
        ulong   fromCnt;

        //Array mit den Zuständen, die von from über Epsilon führen
        ulong   *to;

        //Anzahl der Indices in to
        ulong   toCnt;

    }ECLOS_STR;



    //Struktur für die Erzeugung von move (Drachenbuch S. 145)
    typedef struct
    {
        //Übergangszeichen
        uchar   jump;

        //Array mit den Indices, die einen Übergang mit jump nach to haben
        ulong   *from;

        //Anzahl der Indices in from
        ulong   fromCnt;

        //Array mit den Zuständen, die von from ber jump führen
        ulong   *to;

        //Anzahl der Indices in to
        ulong   toCnt;

    }MOVE_STR;



    //Struktur für eine Menge von NEA-Zuständen, die einem DEA-Zustand entspricht
    typedef struct
    {
        //Index dieser Zustandsmenge bzw. Index dieses DEA-Zustandes
        ulong   deaIndex;

        //markiert/unmarkiert
        bool    marked;

    }DSTATES;



    //Struktur für ALLE DEA-Zustände
    typedef struct
    {
        //Index des DEA-Zustands
        ulong   index;

        //Index der Gruppe, in der dieser DEA-Zustand ist
        ulong   groupIndex;

        //die zu diesem DEA-Zustand gehörenden NEA-Zustände
        ulong   *neaIndex;

        //Anzahl der NEA-Zustände
        ulong   neaIndexCnt;

        //ist Finit-Zustand
        bool    finit;

        //ist Lookahead-Zustand
        bool    la;

        //toter Zustand, benötigt für die DEA-Zustandsminimierung
        bool    dummy;

        //wenn es ein End-Zustand ist, dann die zugehörige NEA_STR eintragen
        NEA_STR *finitNEA;

        //wenn es ein Lookahead-Zustand ist, dann die zugehörige NEA_STR eintragen
        NEA_STR *laNEA;

    }DEA_STATES;



    /***********************
     ** private Variablen **
     ***********************/

    //Daten mit der Grammatik-Datei
    char            *data;

    //command-line Argumente
    ARGV_STR        *argv_str;

    //true: exclusive SC, sonst inclusive
    bool            xcluSC;

    //Stack mit den SC, die mit dem aktuellen NEA verbunden werden sollen
    SC_STR          **scStack;

    //Position auf dem SC-Stack
    long            scStackPos;

    //Struktur mit den in %definition definierten SC
    SC_STR          *scStr;

    //Anzahl der SC
    long            scStrAnz;

    //Fehler
    int             err;

    //trailing context
    bool            trailingContext;

    /*
        Wenn eine Aktion | als erstes Zeichen hat, dann sind die Aktionen gleich.
        Dazu werden die entsprechenden NEA_STR auf einen extra Stack gelegt.
    */
    NEA_STR         **neaStack;

    //Anzahl der Elemente in neaStack
    ulong           neaStackCnt;

    //Größe des Stacks
    ulong           neaStackMax;

    //DSTATES-Stack
    DSTATES         **dstatesStack;

    //Anzahl der Einträge in dstatesStack
    ulong           dstatesStackPos;

    //Array mit den Zeigern auf alle DEA-Zustände
    DEA_STATES      **DEAStates;

    //alle DEA-Zustände werden fortlaufend nummeriert
    ulong           DEAStatesCnt;

    //Zahl der erzeugten Gruppen bei DEA-Zustandsminimierung
    ulong           numberOfGroups;

    //7- oder 8-Bit Scanner erzeugen
    int             cclWidth;

    //Array mit den Zuständen
    STATE_STR       **stateStr;

    //Anzahl der Einträge in stateStr
    ulong           stateStrCnt;

    //den maximalen Gruppenindex merken
    ulong           maxGroupIndex;

    //zeigt an, ob Lookahead-Rules benutzt wurden
    bool            laUsed;

    //zeigt an, ob begin-of-line-Rules benutzt wurden
    bool            begLineUsed;

    //wird in outputCPPMinDEA erzeugt und dient zur Ausgabe der Aktionen
    NEA_STR         **finitNEA, **laNEA;

    //wird bei der Ausgabe der Debug-Infos benötigt
    ulong           debugStrPos;

    //Regeln zählen
    ulong           ruleCnt;



    /**********************
     ** private Methoden **
     **********************/

    //einen neuen NEA anfordern
    NEA_STR *getNewNEA( void );

    //einen neuen Zustand anfordern
    ulong getNewState( NEA_STR * );

    //neue Zeichenklasse anfordern
    int *cclInit( void );

    //eine Zeichenklasse gem. . (any-char) erzeugen
    int *cclAny( void );

    //einen Bereich wie [a-z] eintragen
    int *cclAddRange( int *, uchar, uchar );

    //ein Zeichen zu einer Zeichenklasse hinzufügen
    int *cclAdd( int *, uchar );

    //eine Zeichenklasse an eine andere anfügen
    int *cclAdd( int *, int * );

    //eine Zeichenklasse negieren
    int *cclNegate( int * );

    //eine vordefinierte Zeichenklasse installieren
    int *cclClass( int *, int );

    //eine Zeichenklasse kopieren
    int *cclCopy( int * );

    //einen Zustandsübergang mit cclStr erzeugen
    void mkBranch( ulong, ulong, int *, bool );

    //einen Zustand an einen NEA anhängen
    void mkBranch( NEA_STR *, int *, bool );

    //zwei NEAen verodern
    NEA_STR *mkor( NEA_STR *, NEA_STR * );

    //zwei NEAen verketten
    NEA_STR *mkLink( NEA_STR *, NEA_STR * );

    //einen NEA beliebig oft ausführbar machen
    NEA_STR *mkClos( NEA_STR * );

    //einen NEA mind. einmal ausführbar machen
    NEA_STR *mkPosClos( NEA_STR * );

    //einen NEA optional machen
    NEA_STR *mkOpt( NEA_STR * );

    //einen NEA mindestens min-mal ausführen, maximal max-mal
    NEA_STR *mkRepeat( NEA_STR *, int, int );

    //einen NEA genau min-mal ausführen
    NEA_STR *mkRepeat( NEA_STR *, int );

    //eine Kopie eines NEA erzeugen
    NEA_STR *mkCopy( NEA_STR * );

    //einen NEa mitsamt seinen Zuständen löschen
    void mkDelete( NEA_STR * );

    //einen NEA ausgeben
    void outputNEA( NEA_STR * );

    //einen Zustand setzen
    void setState( NEA_STR *, ulong, int );





    //eine in %definition definierte SC eintragen
    void insertSC( char *, bool );

    //eine in %definition definierte SC suchen
    int lookupSC( char * );

    //einen NEA an eine SC einfügen
    void insertSC( SC_STR *, NEA_STR * );

    //einen NEA an alle inclusive SC einfügen
    void insertInclSC( NEA_STR *nea );

    //prüfen, ob mit der SC bereits ein EOF-NEA verbunden ist
    bool insertEOFSC( SC_STR * );

    /*
        Den NEA-Stack vergrößern, wird benötig, falls mehrere NEAen diegleiche
        Aktion ausführen sollen (erstes Zeichen |).
    */
    void extendNEAStack( void );

    //einen NEA auf den NEA-Stack packen
    void insertNEAStack( NEA_STR * );

    //eine ECLOS_STR-Struktur vorbereiten
    ECLOS_STR *createEClos( void );

    //ECLOS_STR freigeben
    void removeEClos( ECLOS_STR * );

    /*
        Einen Zustand in eine ECLOS_STR-Struktur eintragen, von dem aus die Epsilon-Übergänge berechnet
        werden sollen.
    */
    void insertFromEClos( ECLOS_STR *, ulong );

    /*
        Mehrere Zustände in eine ECLOS_STR-Struktur eintragen, von denen aus die Epsilon-Übergänge
        berechnet werden sollen.
    */
    void insertFromEClos( ECLOS_STR *, ulong *, ulong );

    /*
        Einen Zustand in eine ECLOS_STR-Struktur eintragen, der von from aus über einen Epsilon-Übergänge
        erreicht wird.
    */
    void insertToEClos( ECLOS_STR *, ulong );

    /*
        Nun die Zustände bestimmen, die über Epsilon-Übergänge von from aus erreichbar sind und
        in to eintragen.
    */
    void generateEClos( ECLOS_STR * );

    //sucht einen Index in to
    bool findToEClos( ECLOS_STR *, ulong );

    //sucht einen Index in to
    bool findToMove( MOVE_STR *, ulong );

    /*
        Einen Zustand in eine MOVE_STR-Struktur eintragen, der von from aus über einen Übergang
        erreicht wird.
    */
    void insertToMove( MOVE_STR *, ulong );

    /*
        Mehrere Zustände in eine MOVE_STR-Struktur eintragen, von denen aus die Übergänge
        berechnet werden sollen.
    */
    void insertFromMove( MOVE_STR *, ulong *index, ulong );

    /*
        Einen Zustand in eine MOVE_STR-Struktur eintragen, von dem aus die Übergänge berechnet
        werden sollen.
    */
    void insertFromMove( MOVE_STR *, ulong );

    //eine MOVE_STR-Struktur vorbereiten
    MOVE_STR *createMove( uchar c );

    //Speicher für moevStr freigeben
    void removeMove( MOVE_STR * );

    /*
        Nun die Zustände bestimmen, die über c-Übergänge von from aus erreichbar sind und
        in to eintragen.
    */
    void generateMove( MOVE_STR * );



    //DSTATES wird als Stack implementiert.
    void initDStatesStack( void );

    //eine neue NEA-Zustandsmenge in DSTATES eintragen, d.h. einen neuen DEA-Zustand erzeugen
    long insertDStates( ulong *, ulong );

    //eine Menge von NEA-Zuständen, d.h. einen DEA-Zustand suchen
    long lookupDStates( ulong *, ulong );

    //DSTATES deinitialisieren
    void removeDStatesStack( void );

    //einen unmarkierten DEA-Zustand holen
    long getUnmarkedDStates( void );

    //einen unmarkierten DEA-Zustand markieren
    void markDStates( ulong );

    //einen Zustandsbergang in die DEA-Übergangstabelle eintragen
    void insertDTran( SC_STR *, int, long, long, uchar );

    //die DEA-Zustände ausgeben mit den zugehörigen NEA-Zuständen
    void outputDEAStates( void );

    //hier werden die Source-Files des Parsers erzeugt
    void generateFiles( void );

    //die Übergangstabelle ausgeben
    void outputCPPDTran( ofstream & );

    //die Übergangstabelle ausgeben, mit Minimierung der DEA-Zustandsmenge
    void outputCPPMinDEA( ofstream & );

    //das Header-File des erzeugten Scanners ausgeben
    void outputHHeader( ofstream & );

    //einen neuen DEA-Zustand
    ulong insertDEAState( ulong *, ulong, bool );

    /*
        Hier wird vor reg. Expressions gewarnt, bei denen der Start-Zustand des NEA einen
        epsilon-Übergang zum Finit-Zustand hat, was typischerweise bei Regeln der Art
        {REG. EXPR.}* auftritt.
    */
    void findDangerousRegExp( void );

    //finde Regeln, die nie ausgeführt werden
    void findNoRules( void );

    //gibt ein Zeichen aus, insbesondere die nicht-druckbaren in lesbarer Form
    void outputChar( uchar, char * );

    //aus den NEAen DEAen machen
    void NEA2DEA( void );

    //eine neue Gruppe für die Zustandsminimierung erzeugen
    GROUP_STR *createGROUP( void );

    //eine Gruppe löschen
    void deleteGROUP( GROUP_STR * );

    //einen DEA-Zustand aus einer Gruppe löschen
    void removeGROUP( GROUP_STR *, ulong );

    //einen DEA-Index zu einer Gruppe hinzufügen
    void insertGROUP( GROUP_STR *, ulong );

    //die speziellen Eigenschaften einer Gruppe übernehmen
    void fixGROUP( GROUP_STR *, GROUP_STR * );

    //eine Gruppe ausgeben
    void outputGROUP( GROUP_STR * );

    //tote Zustände finden
    void checkGROUP( SC_STR *, GROUP_STR **, ulong );

    //hier wird die DEA-Zustandsmenge minimiert, wie es im Drachen, S. 172 beschrieben ist
    void minDEA( void );

    //den Header des CPP-Files ausgeben
    void outputCPPHeader( ofstream & );

    //Aktionen ausgeben
    void outputAction( ofstream & );

    //<<EOF>>-NEAen ausgeben
    void outputEOF( ofstream & );

    //die Debug-Strukturen ausgeben
    void outputCPPDebug( ofstream & );

    //wandelt die Steuerzeichen in druckbare Zeichen
    char *toString( char * );

    //Informationen ausgeben
    void outputInfo( void );

    //Include-Anweisungen in das cpp-File ausgeben
    void outputIncl( ofstream & );

    //eigene Erweiterungen in das cpp-File ausgeben
    void outputExt( ofstream & );

    //den Speicher der Aktionen eines NEA freigeben
    void deleteAction( NEA_STR * );

    //weil es nicht möglich ist, einen Breakpoint im Destructor zu setzen
    void _temp( void );



    /*
        Diese Routine wird vom Konstruktor der SSLRParser-Klasse aufgerufen, wenn
        im %include-Teil das Makro SSLR_INIT definiert wurde.
    */
    void init( void );

    /*
        Diese Routine wird vom Destruktor der SSLRParser-Klasse aufgerufen, wenn
        im %include-Teil das Makro SSLR_INIT definiert wurde.
    */
    void deinit( void );



    public:

    /*
        Diese Funktion dient der Übergabe der Kommandozeilen-Argumente, die
        SSLR steuern.
    */
    void giveArgs( ARGV_STR * );




%grammar



//Haupt-Regel von SSLEX
goal                :   initlex sect1 sect2 initforrule
\{
    //die komplette Eingabe wurde erfolgreich gescannt

    //Fehler?
    if( !SSLR_anzError )
    {
        //prüfen, ob alle name definitions auch benutzt wurden
        SSLR_scanner->checkRegExp();

        //aus den NEAen DEAen machen
        NEA2DEA();

        //finde Regeln der Art {REG. EXPR.}* und gebe Warnungen aus
        findDangerousRegExp();

        //finde Regeln, die nie ausgeführt werden
        findNoRules();

#ifdef MINDEA
        //Zustandsmenge minimieren
        minDEA();
#endif

        //die Übergangstabelle als C++-Code ausgeben
        generateFiles();

        //Informationen ausgeben?
        if( argv_str->verbose == true )
            //ja
            outputInfo();
    }

    else
        //Meldung
        cout << "sslex: Terminate with " << SSLR_anzError << " error(s)!" << endl;
\}
                    ;

//Dient der Initialisierung von SSLEX, wird aufgerufen, bevor irgend etwas gemacht wird
initlex             :   'EPSILON'
\{
    //SSLEX initialisieren

    //7- oder 8-Bit-Scanner
    cclWidth = argv_str->cclWidth;

    //noch keine NEA-Zustände
    stateStrCnt = 0;
    stateStr = 0L;

    //noch keine NEA_STR auf Stack
    neaStackCnt = 0;
    neaStackMax = 0;
    neaStack = 0L;

    //SC-Stack
    scStack = 0L;
    scStackPos = 0;

    //noch keine SC
    scStrAnz = 0;
    scStr = 0L;

    //alle DEA-Zustände werden fortlaufend nummeriert
    DEAStatesCnt = 0;
    DEAStates = 0L;

    //keine Lookahead-Rules
    laUsed = false;

    //keine begin-of-line-Rules
    begLineUsed = false;

    //Regeln zählen
    ruleCnt = 0;


    //Speicher für NEA-Stack anfordern
    extendNEAStack();

    //SC INITIAL eintragen
    insertSC( "INITIAL", false );
\}
                    ;

sect1               :   'DEF' scsect1
\{
    //ab hier müssen alle SC definiert sein, nun Speicher für den SC-Stack anfordern
    scStack = new( SC_STR *[scStrAnz] );
    scStackPos = 0;
\}
                    |   'EPSILON'
\{
    /*
        Die Angabe von SC im %definition-Teil ist optional, dann aber wegen INITIAL - diese
        SC wird IMMER erzeugt - Speicher für den SC-Stack anfordern.
    */
    scStack = new( SC_STR *[scStrAnz] );
    scStackPos = 0;
\}
                    ;

//Haupt-Regel für die Definition der (incluive/exclusive) Start-Conditionen
scsect1             :   scsect1 startconddecl namelist1

//es gibt keine Start-Condition-Definitionen seitens des Benutzers
                    |   'EPSILON'
                    ;

//ist eine inclusive-Start-Condition
startconddecl       :   'SCDECL'
\{
    //ist eine inclusive SC
    xcluSC = false;
\}

//ist eine exclusive-Start-Condition
                    |   'XSCDECL'
\{
    //ist eine exclusive SC
    xcluSC = true;
\}
                    ;

/*
    Es können auch mehrere Namen von Start-Conditionen folgen, also
    %s SC1 SC2 SC3 ..
*/
namelist1           :   namelist1 'NAME'
\{
    //den Namen einer SC eintragen
    insertSC( $2, xcluSC );
\}
                    |   'NAME'
\{
    //den Namen einer SC eintragen
    insertSC( $1, xcluSC );
\}
                    ;

sect2               :   'SPEC' sc2
                    |   'EPSILON'
                    ;

//Parsed einen regulären Ausdruck, inklusive Angabe von Start-Conditionen
sc2                 :   sc2 scon initforrule flexrule 'NEWLINE'
\{
    //Position auf dem SC-Stack zurückgeben
    scStackPos = $2;
\}

//Diese Regel erlaubt die verschachtelte Benutzung der Start-Conditionen
                    |   sc2 scon 'BOPEN' sc2 'BCLOSE'
\{
    //Position auf dem SC-Stack zurückgeben
    scStackPos = $2;
\}
%error
{
    3:LA:OVERREAD(NEWLINE):DELETE:  "Lookahead operator not allowed!"
}

//kein regulärer Ausdruck
                    |   'EPSILON'
                    ;

//Das Erkennen eines regulären Ausdrucks initialisieren
initforrule         :   'EPSILON'
\{
    //es folgt ein reg. Ausdruck

    //erst einmal kein Lookahead-NEA
    trailingContext = false;
\}
                    ;

//regulärer Ausdruck
flexrule            :   'BEGLINE' rule
\{

    NEA_STR *nea = $2;
    int     i;

    //Regeln zählen
    ruleCnt++;

    //begin-of-line-Rules benutzt
    begLineUsed = true;

    //NEA darf nur am Anfang einer Zeile stehen
    nea->begLine = true;

    //die auszuführende Aktion holen
    nea->action = SSLR_scanner->getAction( nea->actionAnz );

    //den reg. Ausdruck als Text holen
    nea->regText = SSLR_scanner->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

    //reg. Ausdruck ausgeben
    cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


    //nun den NEA in die SC eintragen
    if( scStackPos )
    {
        //alle SC auf dem Stack
        for( i = 0; i < scStackPos; i++ )
            //eintragen
            insertSC( scStack[i], nea );
    }

    else
        //es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
        insertInclSC( nea );


    //Aktion |, d.h. die auszuführende Aktion folgt später?
    if( nea->action && ( nea->action[0][0] == '|' ) )
        //ja, NEA auf Stack
        insertNEAStack( nea );

    else
    {
        //Aktion auch an andere NEAen weitergeben?
        if( neaStackCnt )
        {
            //ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
            for( i = 0; i < neaStackCnt; i++ )
            {
                //den Speicher der alten Aktion freigeben
                deleteAction( neaStack[i] );

                //Aktionen anhängen
                neaStack[i]->action = nea->action;
                neaStack[i]->actionAnz = nea->actionAnz;
            }

            //Stack löschen
            neaStackCnt = 0;
        }
    }

    //auf Stack
    $$ = nea;
\}
                    |   rule
\{

    NEA_STR *nea = $1;
    int     i;

    //Regeln zählen
    ruleCnt++;

    //die auszuführende Aktion holen
    nea->action = SSLR_scanner->getAction( nea->actionAnz );

    //den reg. Ausdruck als Text holen
    nea->regText = SSLR_scanner->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

    //reg. Ausdruck ausgeben
    cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


    //nun den NEA in die SC eintragen
    if( scStackPos )
    {
        //alle SC auf dem Stack
        for( i = 0; i < scStackPos; i++ )
            //eintragen
            insertSC( scStack[i], nea );
    }

    else
        //es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
        insertInclSC( nea );


    //Aktion |, d.h. die auszuführende Aktion folgt später?
    if( nea->action && ( nea->action[0][0] == '|' ) )
        //ja, NEA auf Stack
        insertNEAStack( nea );

    else
    {
        //Aktion auch an andere NEAen weitergeben?
        if( neaStackCnt )
        {
            //ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
            for( i = 0; i < neaStackCnt; i++ )
            {
                //den Speicher der alten Aktion freigeben
                deleteAction( neaStack[i] );

                //Aktionen anhängen
                neaStack[i]->action = nea->action;
                neaStack[i]->actionAnz = nea->actionAnz;
            }

            //Stack löschen
            neaStackCnt = 0;
        }
    }

    //auf Stack
    $$ = nea;
\}
                    |   'EOF_OP'
\{
    //ist eine Regel, die am Ende der gesamten Eingabe ausgeführt wird
    NEA_STR *nea;
    int     i;

    //Regeln zählen
    ruleCnt++;

    //einen NEA erzeugen
    nea = getNewNEA();

    //ein EOF-NEA
    nea->eof = true;

    //die auszuführende Aktion holen
    nea->action = SSLR_scanner->getAction( nea->actionAnz );

    //den reg. Ausdruck als Text holen
    nea->regText = SSLR_scanner->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

    //reg. Ausdruck ausgeben
    cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


    //nun den NEA in die SC eintragen
    if( scStackPos )
    {
        //alle SC auf dem Stack
        for( i = 0; i < scStackPos; i++ )
            //eintragen
            insertSC( scStack[i], nea );
    }

    else
        //es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
        insertInclSC( nea );


    //Aktion |, d.h. die auszuführende Aktion folgt später?
    if( nea->action && ( nea->action[0][0] == '|' ) )
        //ja, NEA auf Stack
        insertNEAStack( nea );

    else
    {
        //Aktion auch an andere NEAen weitergeben?
        if( neaStackCnt )
        {
            //ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
            for( i = 0; i < neaStackCnt; i++ )
            {
                //den Speicher der alten Aktion freigeben
                deleteAction( neaStack[i] );

                //Aktionen anhängen
                neaStack[i]->action = nea->action;
                neaStack[i]->actionAnz = nea->actionAnz;
            }

            //Stack löschen
            neaStackCnt = 0;
        }
    }

    //auf Stack
    $$ = nea;
\}
                    ;

scon_stk_ptr        :   'EPSILON'
\{
    //Position auf dem SC-Stack zurückgeben
    $$ = scStackPos;
\}
                    ;

//Form <SC1,SC2,SC3,...>
scon                :   'SCOPEN' scon_stk_ptr namelist2 'SCCLOSE'
\{
    //Position auf dem SC-Stack zurückgeben
    $$ = $2;
\}

//Form <*>
                    |   'SCOPEN' 'SCALL' 'SCCLOSE'
\{

    //regulären Ausdruck in alle SC eintragen
    SC_STR  *sc;
    int     i, j;

    //Position merken
    $$ = scStackPos;

    //wurde die SC schon auf dem Stack gepackt?
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger
        sc = &scStr[i];

        //nur die eintragen, die nicht schon auf dem Stack sind
        for( j = 0; j < scStackPos; j++ )
        {
            //gleich?
            if( sc == scStack[j] )
                //ja
                break;
        }

        //war die SC schon auf dem Stack?
        if( j == scStackPos )
            //Zeiger auf SC auf Stack
            scStack[scStackPos++] = &scStr[i];
    }
\}

//keine Start-Condition, regulärer Ausdruck gilt für alle inclusive-Start-Conditionen!
                    |   'EPSILON'
\{
    //Position auf dem SC-Stack zurückgeben
    $$ = scStackPos;
\}
                    ;

namelist2           :   namelist2 'KOMMA' sconname
%error
{
    1:              "Comma expected in start condition!"
    2:SHIFT(NAME):  "Name expected in start condition list!"
}
                    |   sconname
                    ;

sconname            :   'NAME'
\{
    //den Namen einer SC auf den SC-Stack packen, zu der der folgende reg. Ausdruck gehören soll
    int scIndex, i;

    //wurde die SC überhaupt definiert?
    if( ( scIndex = lookupSC( $1 ) ) >= 0 )
    {
        //ja, wurde sie schon auf dem SC-Stack gepackt?
        for( i = 0; i < scStackPos; i++ )
        {
            //gleich?
            if( !strcmp( scStack[i]->name, $1 ) )
            {
                //ja, Meldung
                cerr << "sslex: line " << SSLR_line << ": Start condition " << $1 << " already on stack!" << endl;

                //raus hier
                break;
            }
        }

        //war sie schon auf dem Stack?
        if( i == scStackPos )
            //nein, auf den Stack schieben
            scStack[scStackPos++] = &scStr[scIndex];
    }

    else
    {
        //nein, Fehler
        cerr << "sslex: line " << SSLR_line << ": Start condition " << $1 << " not definied!" << endl;

        //Fehler
        err++;
    }

    //Speicher freigeben
    delete[] ( $1 );
\}
%error
{
    1:OVERREAD(SCCLOSE):    "Start conditions must be separated by a comma!"
}
                    ;

//zwei regulärere Ausdrücke verknüpfen
rule                :   re2 re
\{
    //Lookahead-NEA
    NEA_STR *nea;
    ulong   index = $1->endState;

    //Lookahead-Rule benutzt
    laUsed = true;

    //NEAen verlinken
    nea = mkLink( $1, $2 );

    //den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ändern
    setState( nea, index, MARK_AS_LA );

    //ist ein Lookahead-NEA
    nea->laState = true;

    //NEAen auf Stack
    $$ = nea;
\}

//zwei reg. Ausdrücke verknüpfen, dürfen aber nur am Ende einer Zeile stehen
                    |   re2 re 'ENDLINE'
\{
    /*
        reg. Ausdruck nur am Zeilenende, aber zweimal trailing context
    */
    NEA_STR *nea;
    ulong   index = $2->endState;
    int     *cclStr;

    //Lookahead-Rule benutzt
    laUsed = true;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //newline
    cclAdd( cclStr, '\n' );

    //beide NEAen verlinken
    nea = mkLink( $1, $2 );

    //nun einen Zustandsübergang erzeugen
    mkBranch( nea, cclStr, false );

    //den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ändern
    setState( nea, index, MARK_AS_LA );

    //ist ein Lookahead-NEA
    nea->laState = true;

    //NEAen auf Stack
    $$ = nea;

    //Fehler-Meldung ausgeben
    cerr << "sslex: line " << SSLR_line << ": Trailing context used twice!" << endl;

    //Fehler
    err++;
\}

//regulärer Ausdruck darf nur am Ende einer Zeile stehen
                    |   re 'ENDLINE'
\{
    //reg. Ausdruck nur am Zeilenende
    ulong   index = $1->endState;
    int     *cclStr;

    //Lookahead-Rule benutzt
    laUsed = true;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //newline
    cclAdd( cclStr, '\n' );

    //nun einen Zustandsübergang erzeugen
    mkBranch( $1, cclStr, false );

    //den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ändern
    setState( $1, index, MARK_AS_LA );

    //ist ein Lookahead-NEA
    $1->laState = true;

    //NEAen auf Stack
    $$ = $1;
\}

//regulärer Ausdruck
                    |   re
\{
    //NEAen auf Stack
    $$ = $1;
\}
                    ;

//zwei reguläre Ausdrücke "verodern"
re                  :   re 'OR' series
\{
    //NEAen verodern
    $$ = mkor( $1, $3 );
\}
                    |   series
\{
    //NEAen auf Stack
    $$ = $1;
\}
                    ;

//Lookahead-Symbol!
re2                 :   re 'LA'
\{
    //Lookahead-NEA

    //ist ein Lookahead-NEA
    $1->laState = true;

    //NEA auf Stack
    $$ = $1;
\}
                    ;

series              :   series singleton
\{
    //NEAen auf Stack
    $$ = mkLink( $1, $2 );
\}
                    |   singleton
\{
    //NEA auf Stack
    $$ = $1;
\}
                    ;

//beliebig oft
singleton           :   singleton 'MUL'
\{
    //NEA beliebig oft
    $$ = mkClos( $1 );
\}

//mind. einmal
                    |   singleton 'PLUS'
\{
    //NEA höchstens einmal ausführen
    $$ = mkPosClos( $1 );
\}

//höchstens einmal
                    |   singleton 'QUEST'
\{
    //NEA ist optional
    $$ = mkOpt( $1 );
\}

//regulärer Ausdruck min. bis max. mal
                    |   singleton 'BOPEN' 'NUMBER' 'KOMMA' 'NUMBER' 'BCLOSE'
\{
    //NEA vervielfachen

    //Wert OK?
    if( ( $3 > $5 ) || ( $3 <= 0 ) )
    {
        //Fehler
        cerr << "sslex: line " << SSLR_line << ": Bad iteration values!" << endl;

        //Fehler
        err++;

        //auf Stack
        $$ = $1;
    }

    else
    {
        //optional?
        if( $3 == 0 )
        {
            //negativ?
            if( $5 <= 0 )
            {
                //Fehler
                cerr << "sslex: line " << SSLR_line << ": Bad iteration values!" << endl;

                //Fehler
                err++;

                //auf Stack
                $$ = $1;
            }

            else
                //NEA vervielfachen
                $$ = mkRepeat( $1, $3, $5 );
        }

        else
            //NEA vervielfachen
            $$ = mkRepeat( $1, $3, $5 );
    }
\}

//reg. Ausdruck min. mal bis beliebig oft
                    |   singleton 'BOPEN' 'NUMBER' 'KOMMA' 'BCLOSE'
\{
    //NEA vervielfachen

    //Wert OK?
    if( $3 <= 0 )
    {
        //Fehler
        cerr << "sslex: line " << SSLR_line << ": Iteration value must be positive!" << endl;

        //Fehler
        err++;

        //auf Stack
        $$ = $1;
    }

    else
        //NEA vervielfachen
        $$ = mkRepeat( $1, $3, _INFINITY );
\}

//reg. Ausdruck genau ... mal
                    |   singleton 'BOPEN' 'NUMBER' 'BCLOSE'
\{
    //NEA vervielfachen

    //Wert OK?
    if( $3 <= 0 )
    {
        //Fehler
        cerr << "sslex: line " << SSLR_line << ": Iteration value must be positive!" << endl;

        //Fehler
        err++;

        //auf Stack
        $$ = $1;
    }

    else
        //NEA vervielfachen
        $$ = mkRepeat( $1, $3 );
\}

//irgendein Zeichen, ausser NEWLINE
                    |   'ANY'
\{
    NEA_STR     *nea;
    int         *cclClass;

    //einen NEA erzeugen
    nea = getNewNEA();

    //eine Zeichenklasse anlegen
    cclClass = cclAny();

    //Zustands-Übergang erzeugen
    mkBranch( nea, cclClass, false );

    //NEAen auf Stack
    $$ = nea;
\}

//Zeichenklasse
                    |   fullccl
\{
    NEA_STR     *nea;

    //einen NEA erzeugen
    nea = getNewNEA();

    //Zustands-Übergang erzeugen
    mkBranch( nea, $1, false );

    //NEAen auf Stack
    $$ = nea;
\}
                    |   'PREVCCL'

//einen String
                    |   'SOPEN' string 'SOPEN'
\{
    //NEAen auf Stack
    $$ = $2;
\}

//Priorität
                    |   'KLOPEN' re 'KLCLOSE'
\{
    //NEAen auf Stack
    $$ = $2;
\}

//ein einzelnes Zeichen
                    |   'CHAR'
\{
    NEA_STR     *nea;
    int         *cclClass;

    //einen NEA erzeugen
    nea = getNewNEA();

    //eine Zeichenklasse anlegen
    cclClass = cclInit();

    //Zeichen hinzufügen
    cclAdd( cclClass, $1 );

    //Zustands-Übergang erzeugen
    mkBranch( nea, cclClass, false );

    //NEAen auf Stack
    $$ = nea;
\}
                    ;

//Form [...]
fullccl             :   'COPEN' ccl 'CCLOSE'
\{
    //Zeichenklasse übernehmen
    $$ = $2;
\}

//negierte Zeichenklasse [^...]
                    |   'COPEN' 'NEGATE' ccl 'CCLOSE'
\{
    //Zeichenklasse negieren
    $$ = cclNegate( $3 );
\}
                    ;

//Form [A-Z], [0-9]
ccl                 :   ccl 'CHAR' 'MINUS' 'CHAR'
\{
    char    upper, lower;

    //Grenzen OK?
    if( $2 > $4 )
    {
        //Fehler
        cerr << "sslex: line " << SSLR_line << ": Wrong limits in character class!" << endl;

        //umdrehen
        lower = $4;
        upper = $2;

        //Fehler
        err++;
    }

    else
    {
        //Limits OK
        upper = $4;
        lower = $2;
    }

    //einen Zeichenbereich erzeugen
    $$ = cclAddRange( $1, lower, upper );
\}

//ein einzelnes Zeichen
                    |   ccl 'CHAR'
\{
    //ein Zeichen zu einer Zeichenklasse hinzufügen
    $$ = cclAdd( $1, $2 );
\}

//eine vordefinierte Zeichenklasse
                    |   ccl ccl_expr
\{
    //übernehmen
    $$ = cclAdd( $1, $2 );

    //zweite Zeichenklasse freigeben
    delete[] ( $2 );
\}

//leer
                    |   'EPSILON'
\{
    //Zeichenklasse anfordern
    $$ = cclInit();
\}
                    ;

//Buchstabe oder Ziffer
ccl_expr            :   'CCE_ALNUM'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isalnum
    cclClass( cclStr, CCE_ALNUM );

    //übergeben
    $$ = cclStr;
\}
//Buchstabe
                    |   'CCE_ALPHA'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isalpha
    cclClass( cclStr, CCE_ALPHA );

    //übergeben
    $$ = cclStr;
\}

//Space oder Tab
                    |   'CCE_BLANK'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isblank
    cclClass( cclStr, CCE_BLANK );

    //übergeben
    $$ = cclStr;
\}

//nicht-druckbare Zeichen
                    |   'CCE_CNTRL'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //iscntrl
    cclClass( cclStr, CCE_CNTRL );

    //übergeben
    $$ = cclStr;
\}

//Ziffer
                    |   'CCE_DIGIT'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isdigit
    cclClass( cclStr, CCE_DIGIT );

    //übergeben
    $$ = cclStr;
\}

//druckbare Zeichen, ohne Space
                    |   'CCE_GRAPH'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isgraph
    cclClass( cclStr, CCE_GRAPH );

    //übergeben
    $$ = cclStr;
\}

//Kleinbuchstaben
                    |   'CCE_LOWER'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //islower
    cclClass( cclStr, CCE_LOWER );

    //übergeben
    $$ = cclStr;
\}

//druckbare Zeichen, mit Space
                    |   'CCE_PRINT'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isprint
    cclClass( cclStr, CCE_PRINT );

    //übergeben
    $$ = cclStr;
\}

//Interpunktionszeichen
                    |   'CCE_PUNCT'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //ispunct
    cclClass( cclStr, CCE_PUNCT );

    //übergeben
    $$ = cclStr;
\}

//Space, \n, \r, \v, \f
                    |   'CCE_SPACE'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isspace
    cclClass( cclStr, CCE_SPACE );

    //übergeben
    $$ = cclStr;
\}

//Großbuchstabe
                    |   'CCE_UPPER'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isupper
    cclClass( cclStr, CCE_UPPER );

    //übergeben
    $$ = cclStr;
\}

//Hexadezimal
                    |   'CCE_XDIGIT'
\{
    int *cclStr;

    //eine Zeichenklasse erzeugen
    cclStr = cclInit();

    //isxdigit
    cclClass( cclStr, CCE_XDIGIT );

    //übergeben
    $$ = cclStr;
\}
                    ;

string              :   string 'CHAR'
\{
    //zwei NEAen verlinken
    NEA_STR     *nea;
    int         *cclClass;

    //einen NEA erzeugen
    nea = getNewNEA();

    //eine Zeichenklasse anlegen
    cclClass = cclInit();

    //Zeichen hinzufügen
    cclAdd( cclClass, $2 );

    //Zustands-Übergang erzeugen
    mkBranch( nea, cclClass, false );

    //beide NEAen verknüpfen
    $$ = mkLink( $1, nea );
\}
                    |   'EPSILON'
\{
    //einen NEA erzeugen
    $$ = getNewNEA();
\}
                    ;


%extension
\{


    //Hilfsroutinen für SSLR


void SSLRParser::giveArgs( ARGV_STR *argv )
{
    /*
        Diese Funktion dient der Übergabe der Kommandozeilen-Argumente, die
        SSLEX steuern.
    */

    //Argumente
    argv_str = argv;
}


void SSLRParser::init( void )
{
    /*
        Diese Routine wird vom Konstruktor der SSLRParser-Klasse aufgerufen, wenn
        im %include-Teil das Makro SSLR_INIT definiert wurde.
    */
}


void SSLRParser::deinit( void )
{
    /*
        Diese Routine wird vom Destruktor der SSLRParser-Klasse aufgerufen, wenn
        im %include-Teil das Makro SSLR_INIT definiert wurde.
    */

    //Speicher freigeben
    _temp();
}


void SSLRParser::_temp( void )
{
    //Speicher freigeben
    DEA_STATES  *dea;
    STATE_STR   *_s;
    NEA_STR     *nea;
    SC_STR      *sc, *_sc2;
    ulong       i, j, k, l;
    char        *tmp, **tmp2;

    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //den Namen freigeben, INITIAL überspringen, da static
        if( i )
            delete[] ( sc->name );

        //alle NEAen dieser SC
        for( j = 0; j < sc->neaArrCnt; j++ )
        {
            //Zeiger auf NEA
            nea = sc->neaArr[j];

            //Speicher freigeben?
            if( nea )
            {
                //Aktion
                if( nea->action )
                {
                    //Adresse merken
                    tmp2 = nea->action;

                    //auch in anderen NEA_STR löschen
                    for( k = i; k < scStrAnz; k++ )
                    {
                        //Zeiger auf SC
                        _sc2 = &scStr[k];

                        //alle NEAen
                        for( l = 0; l < _sc2->neaArrCnt; l++ )
                        {
                            //gleich?
                            if( _sc2->neaArr[l] && ( _sc2->neaArr[l] != nea ) && ( _sc2->neaArr[l]->action == nea->action ) )
                                //ja, zurücksetzen
                                _sc2->neaArr[l]->action = 0L;
                        }
                    }

                    //Speicher freigeben
                    deleteAction( nea );
                }

                //reg. Ausdruck als Text
                if( nea->regText )
                {
                    //Adresse merken
                    tmp = nea->regText;

                    //auch in anderen NEA_STR löschen
                    for( k = i; k < scStrAnz; k++ )
                    {
                        //Zeiger auf SC
                        _sc2 = &scStr[k];

                        //alle NEAen
                        for( l = 0; l < _sc2->neaArrCnt; l++ )
                        {
                            //gleich?
                            if( _sc2->neaArr[l] && ( _sc2->neaArr[l]->regText == nea->regText ) )
                                //ja, zurücksetzen
                                _sc2->neaArr[l]->regText = 0L;
                        }
                    }

                    //Speicher freigeben
                    delete[] ( tmp );

                    //zurücksetzen
                    nea->regText = 0L;
                }

                //NEA_STR auch in anderen SC
                for( k = i; k < scStrAnz; k++ )
                {
                    //Zeiger auf SC
                    _sc2 = &scStr[k];

                    //alle NEAen
                    for( l = 0; l < _sc2->neaArrCnt; l++ )
                    {
                        //gleich?
                        if( _sc2->neaArr[l] && ( _sc2->neaArr[l] == nea ) )
                            //ja, zurücksetzen
                            _sc2->neaArr[l] = 0L;
                    }
                }

                //NEA_STR freigeben
                delete( nea );
            }
        }

        //Array mit den NEAen freigeben
        if( sc->neaArr )
            delete[] ( sc->neaArr );

        //Übergangstabellen mit den NEAen freigeben, die überall stehen dürfen
        if( sc->DTran1 )
        {
            //alle Zustände
            for( j = 0; j < sc->DTran1Cnt; j++ )
            {
                delete[] ( sc->DTran1[j]->to );
                delete( sc->DTran1[j] );
            }

            //freigeben
            delete[] ( sc->DTran1 );
        }

        //Übergangstabellen mit den NEAen freigeben, die ausschließlich am Zeilenanfang stehen dürfen
        if( sc->DTran2 )
        {
            //alle Zustände
            for( j = 0; j < sc->DTran2Cnt; j++ )
            {
                delete[] ( sc->DTran2[j]->to );
                delete( sc->DTran2[j] );
            }

            //freigeben
            delete[] ( sc->DTran2 );
        }

        //Gruppe mit den NEAen freigeben, die überall stehen dürfen
        if( sc->grp )
        {
            //alle Zustände
            for( j = 0; j < sc->grpCnt; j++ )
            {
                delete[] ( sc->grp[j]->DEAIndex );
                delete( sc->grp[j] );
            }

            //freigeben
            delete[] ( sc->grp );
        }
    }

    //Speicher der SC freigeben
    delete[] ( scStr );

    //Stack mit den SC?
    if( scStack )
        delete[] ( scStack );


    //die NEA-Zustände freigeben?
    if( stateStr )
    {
        //alle NEA-Zustände
        for( i = 0; i < stateStrCnt; i++ )
        {
            //Zeiger auf Zustand
            _s = stateStr[i];

            //gibt es überhaupt Übergänge?
            if( _s->braStr )
            {
                //Zustandsübergänge freigeben
                for( j = 0; j < _s->braStrCnt; j++ )
                {
                    //Zeichenklasse freigeben
                    if( _s->braStr[j]->cclClass )
                        //Zeichenklasse freigeben
                        delete[] ( _s->braStr[j]->cclClass );

                    //freigeben
                    delete( _s->braStr[j] );
                }

                //Array mit den Zustandsübergängen freigeben
                delete[] ( _s->braStr );
            }

            //freigeben
            delete( _s );
        }

        //freigeben
        delete[] ( stateStr );
    }

    //die DEA-Zustände freigeben?
    if( DEAStates )
    {
        //alle DEA-Zustände
        for( i = 0; i < DEAStatesCnt; i++ )
        {
            //Zeiger auf DEA
            dea = DEAStates[i];

            //Zeiger mit den NEA-Zuständen freigeben
            delete[] ( dea->neaIndex );
            delete( dea );
        }

        //Speicher freigeben
        delete[] ( DEAStates );
    }

    //NEA-Stack freigeben?
    if( neaStack )
        delete[] ( neaStack );
}


void SSLRParser::deleteAction( NEA_STR *nea )
{
    //den Speicher der Aktionen eines NEA freigeben
    int i;

    //gibt es überhaupt welche?
    if( nea->actionAnz )
    {
        //alle Einträge
        for( i = 0; i < nea->actionAnz; i++ )
            //Speicher freigeben
            delete[] ( nea->action[i] );

        //Speicher freigeben
        delete[] ( nea->action );

        //initialisieren
        nea->action = 0L;
        nea->actionAnz = 0;
    }
}


NEA_STR *SSLRParser::getNewNEA( void )
{
    //einen neuen NEA anfordern
    NEA_STR *nea;
    ulong   state;

    //Speicher anfordern
    nea = new( NEA_STR );

    //initialisieren
    nea->regText = 0L;
    nea->action = 0L;
    nea->laState = false;
    nea->eof = false;
    nea->begLine = false;
    nea->line = 0;

    //mit einen epsilon-Zustand initialisieren
    state = getNewState( nea );

    //ist erster Zustand dieses NEA
    nea->startState = state;
    nea->endState = state;

    //Zustand ist Finit-Zustand
    setState( nea, state, MARK_AS_FINIT );

    //zurückliefern
    return( nea );
}


ulong SSLRParser::getNewState( NEA_STR *nea )
{
    //einen neuen Zustand anfordern
    STATE_STR   **tmp, *s;
    ulong       index;

    //genug Speicher anfordern
    tmp = new( STATE_STR *[stateStrCnt + 1] );

    //kopieren
    memcpy( tmp, stateStr, sizeof( STATE_STR * ) * stateStrCnt );

    //alten Speicherbereich freigeben
    if( stateStr )
        delete[] ( stateStr );

    //neue Adresse
    stateStr = tmp;

    //Speicher für die eigentliche STATE_STR anfordern
    s = new( STATE_STR );

    //Zeiger
    stateStr[stateStrCnt] = s;

    //Index merken
    index = stateStrCnt++;

    //Index merken
    s->state = index;

    //initialisieren
    s->braStrCnt = 0;
    s->braStr = 0L;
    s->eps = false;
    s->finit = false;
    s->la = false;
    s->isUseful = false;

    //den zugehörigen NEA eintragen
    s->nea = nea;

    //Index in stateStr zurückliefern
    return( index );
}


int *SSLRParser::cclInit( void )
{
    //neue Zeichenklasse anfordern
    int *tmp;

    //Speicher für Zeichenklasse
    tmp = new( int[cclWidth] );

    //initialisieren
    memset( tmp, 0, sizeof( int ) * cclWidth );

    //zurückliefern
    return( tmp );
}


int *SSLRParser::cclAny( void )
{
    //eine Zeichenklasse gem. . (any-char) erzeugen
    int     *tmp;

    //Zeichenklasse initialisieren
    tmp = cclInit();

    //alle bis auf \n
    cclAdd( tmp, '\n' );

    //negieren
    cclNegate( tmp );

    //zurückliefern
    return( tmp );
}


int *SSLRParser::cclAddRange( int *cclStr, uchar from, uchar to )
{
    //einen Bereich wie [a-z] eintragen
    uchar   i;

    //alle Zeichen eintragen
    for( i = from; i <= to; i++ )
        //hinzufügen
        cclAdd( cclStr, i );

    //zurückliefern
    return( cclStr );
}


int *SSLRParser::cclAdd( int *cclStr, uchar c )
{
    //ein Zeichen zu einer Zeichenklasse hinzufügen

    //Zeichen zu groß?
    if( ( c > 127 ) && ( cclWidth == _7BIT ) )
        //Fehlermeldung
        cerr << "SSLRParser::cclAdd: Line " << SSLR_line << ": Character " << c << " needs an 8 bit scanner!\n";

    else
        //eintragen
        cclStr[c] = 1;

    //zurückliefern
    return( cclStr );
}


int *SSLRParser::cclAdd( int *cclStr1, int *cclStr2 )
{
    //eine Zeichenklasse an eine andere anfügen
    int i;

    //alle Zeichen eintragen
    for( i = 0; i < cclWidth; i++ )
    {
        //Zeichen in zweiter Zeichenklasse gesetzt?
        if( cclStr2[i] )
            //ja, zur ersten hinzufügen
            cclAdd( cclStr1, i );
    }

    //zurückliefern
    return( cclStr1 );
}


int *SSLRParser::cclNegate( int *cclStr )
{
    //eine Zeichenklasse negieren
    int i;

    //alle Positionen
    for( i = 0; i < cclWidth; i++ )
        //gesetzt?
        cclStr[i] = !cclStr[i];

    //zurückliefern
    return( cclStr );
}


int *SSLRParser::cclCopy( int *cclClass )
{
    //eine Zeichenklasse kopieren
    int *tmp;

    //ist überhuapt etwas zu kopieren?
    if( cclClass )
    {
        //Speicher für Zeichenklasse
        tmp = new( int[cclWidth] );

        //kopieren
        memcpy( tmp, cclClass, sizeof( int ) * cclWidth );
    }

    else
        //nein
        tmp = 0L;

    //zurückliefern
    return( tmp );
}


int *SSLRParser::cclClass( int *cclStr, int type )
{
    //eine vordefinierte Zeichenklasse installieren
    int ( *isArr[12] )( int ) = { isgraph, isupper, isxdigit, isdigit, isalpha, isalnum, ispunct, isprint, isspace, islower, isblank, iscntrl };
    int isIndex, i;

    //welche vordef. Zeichenklasse?
    switch( type )
    {
        case CCE_GRAPH:
        {
            //isgrapgh
            isIndex = 0;
            break;
        }

        case CCE_UPPER:
        {
            //isupper
            isIndex = 1;
            break;
        }

        case CCE_XDIGIT:
        {
            //isxdigit
            isIndex = 2;
            break;
        }

        case CCE_DIGIT:
        {
            //isdigit
            isIndex = 3;
            break;
        }

        case CCE_ALPHA:
        {
            //isalpha
            isIndex = 4;
            break;
        }

        case CCE_ALNUM:
        {
            //isalnum
            isIndex = 5;
            break;
        }

        case CCE_PUNCT:
        {
            //ispunkt
            isIndex = 6;
            break;
        }

        case CCE_PRINT:
        {
            //isprint
            isIndex = 7;
            break;
        }

        case CCE_SPACE:
        {
            //isspace
            isIndex = 8;
            break;
        }

        case CCE_LOWER:
        {
            //islower
            isIndex = 9;
            break;
        }

        case CCE_BLANK:
        {
            //isblank
            isIndex = 10;
            break;
        }

        case CCE_CNTRL:
        {
            //iscntrl
            isIndex = 11;
            break;
        }

        default:
        {
            //unbekannte Zeichenklasse
//          cerr << "sslex: line " << SSLR_line << ": Illegal character class!\n";
            cerr << "sslex: Illegal character!\n";

            //Fehler
//          err++;
        }
    }

    //Zeichenklasse erzeugen
    for( i = 0; i < cclWidth; i++ )
    {
        //Zeichen eintragen?
        if( isascii( i ) && isArr[isIndex]( i ) )
            //ja
            cclStr[i] = 1;
    }

    //zurückliefern
    return( cclStr );
}


void SSLRParser::mkBranch( ulong from, ulong to, int *cclStr, bool eps )
{
    //einen Zustandsübergang mit cclStr erzeugen
    BRA_STR     **braStr, *bra;
    STATE_STR   *s1, *s2;

    //Zeiger holen
    s1 = stateStr[from];
    s2 = stateStr[to];

    //genug Speicher anfordern
    braStr = new( BRA_STR *[s1->braStrCnt + 1] );

    //kopieren
    memcpy( braStr, s1->braStr, sizeof( BRA_STR * ) * s1->braStrCnt );

    //alten Speicherbereich freigeben
    if( s1->braStr )
        delete[] ( s1->braStr );

    //neue Adresse
    s1->braStr = braStr;

    //Speicher für die eigentliche BRA_STR anfordern
    bra = new( BRA_STR );

    //Zeiger
    s1->braStr[s1->braStrCnt++] = bra;



    //nun bra initialisieren
    if( cclStr )
        //Zeichenklasse eintragen
        bra->cclClass = cclStr;

    else
        //keine Zeichen-Übergänge
        bra->cclClass = 0L;

    //epsilon-Übergang?
    if( eps == true )
        //ja, ein epsilon-Übergang von from nach to
        s1->eps = true;

    //übertragen
    bra->eps = eps;

    //Ziel-Zustand eintragen
    bra->bra = to;
}


void SSLRParser::mkBranch( NEA_STR *nea, int *cclStr, bool eps )
{
    //einen Zustand an einen NEA anhängen
    STATE_STR   *s1, *s2;
    ulong       index;

    //Zustand erzeugen
    index = getNewState( nea );

    //Zeiger holen
    s1 = stateStr[nea->endState];
    s2 = stateStr[index];

    //Zustandsübergang erzeugen
    mkBranch( nea->endState, index, cclStr, eps );

    //ist kein Finit-Zustand mehr
    setState( nea, nea->endState, MARK_AS_NORMAL );

    //Zustand index ist neuer End-Zustand des NEA
    nea->endState = index;

    //ist ein Finit-Zustand
    setState( nea, index, MARK_AS_FINIT );
}


NEA_STR *SSLRParser::mkor( NEA_STR *nea1, NEA_STR *nea2 )
{
    //zwei NEAen verodern
    ulong       startIndex, endIndex;

    //neuen Start-Zustand anfordern
    startIndex = getNewState( nea1 );

    //neuen End-Zustand anfordern
    endIndex = getNewState( nea1 );

    //eps-Übergang von startIndex zu den beiden Start-Zuständen des beiden NEAen
    mkBranch( startIndex, nea1->startState, 0L, true );
    mkBranch( startIndex, nea2->startState, 0L, true );

    //eps-Übergang von den End-Zuständen beider NEAen zum neuen End-Zustand
    mkBranch( nea1->endState, endIndex, 0L, true );
    mkBranch( nea2->endState, endIndex, 0L, true );


    //endIndex ist neuer End-Zustand des veroderten NEA
    setState( nea1, endIndex, MARK_AS_FINIT );

    //alte Finit-Zustände sind keine mehr
    setState( nea1, nea1->endState, MARK_AS_NORMAL );
    setState( nea1, nea2->endState, MARK_AS_NORMAL );

    //startIndex ist neuer Start-Zustand des veroderten NEA
    nea1->startState = startIndex;

    //neuen End-Zustand setzen
    nea1->endState = endIndex;

    //ist der zweite NEA ein NEA mit Lookahead?
    if( nea2->laState == true )
        //ja, so auch der neue
        nea1->laState = true;

    //zweite NEA-Struktur freigeben
    delete( nea2 );

    //veroderten NEA zurückliefern
    return( nea1 );
}


NEA_STR *SSLRParser::mkLink( NEA_STR *nea1, NEA_STR *nea2 )
{
    //zwei NEAen verketten
    STATE_STR   *indexStr;
    BRA_STR     *bra;
    long        *stack, *marked, stackPos = 0;
    long        index, neaDest;
    int         i;

    //eps-Übergang von End-Zustand des ersten NEA zum Start-Zustand des zweiten
    mkBranch( nea1->endState, nea2->startState, 0L, true );

    //alter Finit-Zustand des ersten NEA ist keiner mehr
    setState( nea1, nea1->endState, MARK_AS_NORMAL );

    //Finit-Zustand des zweiten NEA setzen, damit NEA_STR übergeben wird
    setState( nea1, nea2->endState, MARK_AS_FINIT );

    //neuen End-Zustand des NEA eintragen
    nea1->endState = nea2->endState;

    //ist der zweite NEA ein NEA mit Lookahead?
    if( nea2->laState == true )
        //ja, so auch der neue
        nea1->laState = true;

    //zweite NEA-Struktur freigeben
    delete( nea2 );


    //nun an alle NEA-Zustände, insbesondere an die von nea2, den Zeiger auf nea1 vererben


    //Speicher für den Zustands-Stack holen
    stack = new( long[stateStrCnt] );

    //Speicher um die bereits bearbeiteten Zustände zu markieren
    marked = new( long[stateStrCnt] );

    //initialisieren
    memset( marked, 0, sizeof( ulong ) * stateStrCnt );

    //diesen Zustand auf den Stack schieben
    stack[stackPos++] = nea1->startState;

    while( stackPos )
    {
        //Zustand vom Stack holen
        index = stack[--stackPos];

        //bereits markiert?
        if( !marked[index] )
        {
            //markieren
            marked[index]++;

            //Zeiger auf STATE_STR
            indexStr = stateStr[index];

            //nea eintragen
            indexStr->nea = nea1;

            //nun alle Zustandsübergänge des Zustands index
            for( i = 0; i < indexStr->braStrCnt; i++ )
            {
                //Zeiger auf BRA_STR
                bra = indexStr->braStr[i];

                //Ziel-Zustand
                neaDest = bra->bra;

                //Ziel-Zustand bereits markiert?
                if( !marked[neaDest] )
                    //nein, auf Stack
                    stack[stackPos++] = neaDest;
            }
        }
    }

    //Speicher wieder freigeben
    delete[] ( stack );
    delete[] ( marked );


    //veroderten NEA zurückliefern
    return( nea1 );
}


NEA_STR *SSLRParser::mkClos( NEA_STR *nea )
{
    //einen NEA beliebig oft ausführbar machen
    ulong       startIndex, endIndex;

    //neuen Start-Zustand anfordern
    startIndex = getNewState( nea );

    //neuen End-Zustand anfordern
    endIndex = getNewState( nea );

    //eps-Übergang von startIndex zum Start-Index des NEA
    mkBranch( startIndex, nea->startState, 0L, true );

    //eps-Übergang vom neuen Start-Zustand zum neuen End-Zustand
    mkBranch( startIndex, endIndex, 0L, true );

    //eps-Übergang vom alten End-Zustand zum neuen End-Zustand
    mkBranch( nea->endState, endIndex, 0L, true );

    //eps-Übergang vom alten End-Zustand zum alten Start-Zustand
    mkBranch( nea->endState, nea->startState, 0L, true );


    //ist ein Finit-Zustand
    setState( nea, endIndex, MARK_AS_FINIT );

    //alter Finit-Zustand ist keiner mehr
    setState( nea, nea->endState, MARK_AS_NORMAL );

    //neuen Start-Zustand setzen
    nea->startState = startIndex;

    //neuen End-Zustand setzen
    nea->endState = endIndex;

    //NEA zurückliefern
    return( nea );
}


NEA_STR *SSLRParser::mkPosClos( NEA_STR *nea )
{
    //einen NEA mind. einmal ausführbar machen
    ulong       startIndex, endIndex;

    //neuen Start-Zustand anfordern
    startIndex = getNewState( nea );

    //neuen End-Zustand anfordern
    endIndex = getNewState( nea );

    //eps-Übergang von startIndex zum Start-Index des NEA
    mkBranch( startIndex, nea->startState, 0L, true );

    //eps-Übergang vom alten End-Zustand zum neuen End-Zustand
    mkBranch( nea->endState, endIndex, 0L, true );

    //eps-Übergang vom alten End-Zustand zum alten Start-Zustand
    mkBranch( nea->endState, nea->startState, 0L, true );


    //ist ein Finit-Zustand
    setState( nea, endIndex, MARK_AS_FINIT );

    //alter Finit-Zustand ist keiner mehr
    setState( nea, nea->endState, MARK_AS_NORMAL );

    //neuen Start-Zustand setzen
    nea->startState = startIndex;

    //neuen End-Zustand setzen
    nea->endState = endIndex;

    //NEA zurückliefern
    return( nea );
}


NEA_STR *SSLRParser::mkOpt( NEA_STR *nea )
{
    //einen NEA optional machen
    ulong       startIndex, endIndex;

    //neuen Start-Zustand anfordern
    startIndex = getNewState( nea );

    //neuen End-Zustand anfordern
    endIndex = getNewState( nea );

    //eps-Übergang von startIndex zum Start-Index des NEA
    mkBranch( startIndex, nea->startState, 0L, true );

    //eps-Übergang vom neuen Start-Zustand zum neuen End-Zustand
    mkBranch( startIndex, endIndex, 0L, true );

    //eps-Übergang vom alten End-Zustand zum neuen End-Zustand
    mkBranch( nea->endState, endIndex, 0L, true );


    //ist ein Finit-Zustand
    setState( nea, endIndex, MARK_AS_FINIT );

    //alter Finit-Zustand ist keiner mehr
    setState( nea, nea->endState, MARK_AS_NORMAL );

    //neuen Start-Zustand setzen
    nea->startState = startIndex;

    //neuen End-Zustand setzen
    nea->endState = endIndex;

    //NEA zurückliefern
    return( nea );
}


NEA_STR *SSLRParser::mkRepeat( NEA_STR *nea, int value )
{
    //einen NEA genau value Mal ausführen
    NEA_STR     *cpyNEA, *base = mkCopy( nea );
    int         i;

    //mind. einmal?
    if( value > 1 )
    {
        //value mal
        for( i = 0; i < value - 1; i++ )
        {
            //NEA kopieren
            cpyNEA = mkCopy( base );

            //NEAen verbinden
            nea = mkLink( nea, cpyNEA );
        }
    }

    //Speicher freigeben
    mkDelete( base );

    //NEA zurückliefern
    return( nea );
}


NEA_STR *SSLRParser::mkRepeat( NEA_STR *nea, int min, int max )
{
    //einen NEA mindestens min-mal ausführen, maximal max-mal
    NEA_STR     *cpyNEA, *base = mkCopy( nea );
    ulong       endIndex, index;
    int         i;

    //neuen End-Zustand anfordern
    endIndex = getNewState( nea );

    //mind. einmal?
    if( max > min )
    {
        //min mal
        for( i = 1; i < max; i++ )
        {
            //NEA kopieren
            cpyNEA = mkCopy( base );

            //den End-Zustand merken
            index = nea->endState;

            //NEAen verbinden
            nea = mkLink( nea, cpyNEA );

            //i > min, d.h. optional?
            if( i >= min )
                //ja
                mkBranch( index, endIndex, 0L, true );
        }

        //min=0, d.h. auch kein mal erlaubt?
        if( !min )
            //ja, eps-Übergang vom Start-Zustand zum End-Zustand
            mkBranch( nea->startState, endIndex, 0L, true );

        //neuen End-Zustand
        mkBranch( nea->endState, endIndex, 0L, true );

        //alter Finit-Zustand ist keiner mehr
        setState( nea, nea->endState, MARK_AS_NORMAL );

        //neuen Finit-Zustand setzen
        setState( nea, endIndex, MARK_AS_FINIT );

        //neuen Finit-Zustand eintragen
        nea->endState = endIndex;
    }

    else if( max == _INFINITY )
    {
        //NEA min. min-mal, dann beliebig oft
        for( i = 1; i < min; i++ )
        {
            //NEA kopieren
            cpyNEA = mkCopy( base );

            //NEAen verbinden
            nea = mkLink( nea, cpyNEA );
        }

        //nun noch einen anfügen, diesen aber beliebig oft ausführbar machen
        cpyNEA = mkCopy( base );

        //beliebig oft ausführbar machen
        cpyNEA = mkClos( cpyNEA );

        //beide verbinden
        nea = mkLink( nea, cpyNEA );
    }

    //Speicher freigeben
    mkDelete( base );

    //NEA zurückliefern
    return( nea );
}


NEA_STR *SSLRParser::mkCopy( NEA_STR *nea )
{
    //eine Kopie eines NEA erzeugen
    STATE_STR   *indexStr, *toCopyStr;
    NEA_STR     *cpyNEA;
    BRA_STR     *bra;
    long        *stack, stackPos = 0;
    long        *transStates, index, toCopy, neaDest, dest;
    int         *cclClass, i;

    //neuen NEA anfordern
    cpyNEA = getNewNEA();

    //Speicher für den Zustands-Stack holen
    stack = new( long[stateStrCnt] );

    //in diesem Array steht die Nummer des Zustandes, den ein Zustand in nea hat, in cpyNEA
    transStates = new( long[stateStrCnt] );

    //initialisieren
    memset( transStates, -1, sizeof( long ) * stateStrCnt );

    //den Startzustand eintragen
    transStates[nea->startState] = cpyNEA->startState;

    //diesen Zustand auf den Stack schieben
    stack[stackPos++] = nea->startState;

    while( stackPos )
    {
        //Zustand vom Stack holen
        index = stack[--stackPos];

        //Gibt es diesen Zustand in cpyNEA schon?
        if( transStates[index] >= 0 )
            //ja, holen
            toCopy = transStates[index];

        else
        {
            //nein, erzeugen
            toCopy = getNewState( cpyNEA );

            //eintragen
            transStates[index] = toCopy;
        }

        //Zeiger auf STATE_STR
        indexStr = stateStr[index];
        toCopyStr = stateStr[toCopy];

        //nun alle Zustandsübergänge des Zustands index in cpyNEA erzeugen
        for( i = 0; i < indexStr->braStrCnt; i++ )
        {
            //Zeiger auf BRA_STR
            bra = indexStr->braStr[i];

            //Ziel-Zustand
            neaDest = bra->bra;

            //Ziel-Zustand erzeugen?
            if( transStates[neaDest] < 0 )
            {
                //ja, erzeugen
                dest = getNewState( cpyNEA );

                //eintragen
                transStates[neaDest] = dest;

                //Zeichenklasse kopieren
                cclClass = cclCopy( bra->cclClass );

                //Zustandsübergang erzeugen
                mkBranch( toCopy, dest, cclClass, bra->eps );

                //Zustand auf dem Stack schieben
                stack[stackPos++] = neaDest;
            }
        }

        //alle anderen Dinge kopieren
        toCopyStr->eps = indexStr->eps;
        toCopyStr->finit = indexStr->finit;
        toCopyStr->la = indexStr->la;
    }

    //NEA-Infos kopieren
    cpyNEA->action = nea->action;
    cpyNEA->endState = transStates[nea->endState];
    cpyNEA->laState = nea->laState;
    cpyNEA->regText = nea->regText;
    cpyNEA->startState = transStates[nea->startState];

    //Speicher wieder freigeben
    delete[] ( stack );
    delete[] ( transStates );

    //NEA zurückliefern
    return( cpyNEA );
}


void SSLRParser::mkDelete( NEA_STR *nea )
{
    //einen NEa mitsamt seinen Zuständen löschen
    STATE_STR   *indexStr;
    BRA_STR     *bra;
    long        *stack, stackPos = 0;
    long        index, neaDest;
    int         i, *marked;

    //Speicher für den Zustands-Stack holen
    stack = new( long[stateStrCnt] );

    //in diesem Array stehen die Zustände, die bereits gelöscht wurden
    marked = new( int[stateStrCnt] );

    //initialisieren
    memset( marked, 0, sizeof( int ) * stateStrCnt );

    //diesen Zustand auf den Stack schieben
    stack[stackPos++] = nea->startState;

    while( stackPos )
    {
        //Zustand vom Stack holen
        index = stack[--stackPos];

        //markiert?
        if( !marked[index] )
        {
            //markieren
            marked[index]++;

            //Zeiger auf STATE_STR
            indexStr = stateStr[index];

            //nun alle Zustandsübergänge des Zustands index in nea löschen
            for( i = 0; i < indexStr->braStrCnt; i++ )
            {
                //Zeiger auf BRA_STR
                bra = indexStr->braStr[i];

                //Ziel-Zustand
                neaDest = bra->bra;

                //schon markiert?
                if( !marked[neaDest] )
                    //nein, auf den Stack legen
                    stack[stackPos++] = neaDest;

                //Zeichenklasse löschen
                if( bra->cclClass )
                {
                    //Speicher freigeben
                    delete[] ( bra->cclClass );

                    //zurücksetzen
                    bra->cclClass = 0L;
                }

                //Zustandsübergangs-Struktur löschen
                delete( bra );

                //zurücksetzen
                bra = 0L;
            }

            //Array mit den Zustandsübergangs-Strukturen löschen
            if( indexStr->braStr )
            {
                //Speicher freigeben
                delete[] ( indexStr->braStr );

                //zurücksetzen
                indexStr->braStr = 0L;
            }

            /*
                STATE-STR dieses Zustands nicht löschnen, da sonst alle Zustandsübergänge angepasst
                werden müssten.
            */
            indexStr->nea = 0L;
        }
    }

    //Speicher wieder freigeben
    delete[] ( stack );
    delete[] ( marked );

    //NEA freigeben
    delete( nea );
}


void SSLRParser::setState( NEA_STR *nea, ulong state, int type )
{
    //einen Zustand setzen
    //MARK_AS_NORMAL: normaler Zustand
    //MARK_AS_FINIT: End-Zustand
    //MARK_AS_LA: Lookahead-Zustand
    STATE_STR   *s1;

    //Teuger
    s1 = stateStr[state];

    //Welcher ist es denn?
    switch( type )
    {
        case MARK_AS_NORMAL:
        {
            //normaler Zustand
            s1->finit = false;
            s1->la = false;
            s1->nea = nea;
            break;
        }

        case MARK_AS_FINIT:
        {
            //End-Zustand
            s1->finit = true;
            s1->la = false;
            s1->nea = nea;
            break;
        }

        case MARK_AS_LA:
        {
            //Lookahead-Zustand
            s1->finit = false;
            s1->la = true;
            s1->nea = nea;
            break;
        }

        default:
        {
            //Fehler
            cerr << "sslex: Illegal state in SSLRParser::setState!\n";

            //Fehler
//          err++;
        }
    }
}


void SSLRParser::outputNEA( NEA_STR *nea )
{
    //einen NEA ausgeben
    STATE_STR   *indexStr;
    BRA_STR     *bra;
    long        *stack, stackPos = 0;
    long        *doub, index;
    int         i, j;

    //den entsprechenden reg. Ausdruck ausgeben?
    if( nea->regText )
        //ja
        cout << "\n" << nea->regText << "\n";

    //Speicher für den Zustands-Stack holen
    stack = new( long[stateStrCnt] );

    //Zustände nicht doppelt ausgeben
    doub = new( long[stateStrCnt] );

    //initialisieren
    memset( doub, 0, sizeof( long ) * stateStrCnt );

    //Start-Zustand auf den Stack
    stack[stackPos++] = nea->startState;

    //ist es ein Lookahead-NEA?
    if( nea->laState == true )
        //ja
        cout << "Lookahead-NEA\n";

    while( stackPos )
    {
        //Zustand holen
        index = stack[--stackPos];

        //Zeiger auf STATE_STR
        indexStr = stateStr[index];

        //ausgeben?
        if( !doub[index] )
        {
            //ja, Zustandsnummer ausgeben
            cout << "\n\nZustand: " << index;

            //Start-Zustand?
            if( index == nea->startState )
                //ja
                cout << "\tStartzustand\n";

            else if( indexStr->la == true )
                //ist ein Lookahead-Zustand
                cout << "\tLookahead-Zustand\n";

            else if( index == nea->endState )
                //ja
                cout << "\tEnd-Zustand\n";

            else
                //normaler Zustand
                cout << "\n";

            //Zuständsübergänge ausgeben
            for( i = 0; i < indexStr->braStrCnt; i++ )
            {
                //Zeiger auf BRA_STR
                bra = indexStr->braStr[i];

                //ausgeben
                cout << "Übergang zu " << bra->bra << "\n";

                //gibt es eine?
                if( bra->cclClass )
                {
                    //Zeichenklasse ausgeben
                    cout << "Zeichenklasse\n";

                    //Zeichen ausgeben
                    for( j = 0; j < cclWidth; j++ )
                    {
                        //Zeichen gesetzt?
                        if( bra->cclClass[j] )
                        {
                            //druckbar?
                            if( isprint( j ) )
                                //ja, normal ausgeben
                                fprintf( stdout, "%c", j );

                            else
                                //ist ein nicht-druckbares Zeichen
                                cout << "," << j << ",";
                        }
                    }

                    //nächste Zeile
                    cout << "\n";
                }

                //Epsilon?
                if( bra->eps )
                    //ja
                    cout << "Epsilon\n";

                //auf Stack schieben
                stack[stackPos++] = bra->bra;
            }

            //markieren
            doub[index] = 1;
        }
    }

    //Speicher wieder freigeben
    delete[] ( stack );
    delete[] ( doub );
}


void SSLRParser::insertSC( char *name, bool type )
{
    //eine in %definition definierte SC eintragen
    SC_STR  *tmp, *sc;

    //schon definiert?
    if( lookupSC( name ) < 0 )
    {
        //Speicher anfordern
        tmp = new( SC_STR[scStrAnz + 1] );

        //alte Daten kopieren
        memcpy( tmp, scStr, sizeof( SC_STR ) * scStrAnz );

        //alten Speicherbereich freigeben
        if( scStr )
            delete[] ( scStr );

        //neue Adresse
        scStr = tmp;

        //Zeiger auf Struktur holen
        sc = &scStr[scStrAnz++];

        //initialisieren
        memset( sc, 0, sizeof( SC_STR ) );

        //eintragen
        sc->name = name;

        //Typ eintragen
        sc->type = type;
    }

    else
    {
        //Fehler
        cerr << "sslex: line " << SSLR_line << ": SC " << name << " already definied!\n";

        //Fehler
        err++;
    }
}


int SSLRParser::lookupSC( char *name )
{
    //eine in %definition definierte SC suchen
    int i;

    //alle Einträge
    for( i = 0; i < scStrAnz; i++ )
    {
        //Namen gleich
        if( !strcmp( scStr[i].name, name ) )
            //ja
            return( i );
    }

    //war nicht dabei
    return( -1 );
}


void SSLRParser::insertSC( SC_STR *scStr, NEA_STR *nea )
{
    //einen NEA an eine SC einfügen
    NEA_STR **tmp;
    bool    eof = nea->eof;

    //eof-NEA?
    if( ( eof == false ) || ( ( eof == true ) && ( ( insertEOFSC( scStr ) ) == false ) ) )
    {
        //genug Speicher anfordern
        tmp = new( NEA_STR *[scStr->neaArrCnt + 1] );

        //kopieren
        memcpy( tmp, scStr->neaArr, sizeof( NEA_STR * ) * scStr->neaArrCnt );

        //alten Speicher freigeben
        if( scStr->neaArr )
            delete[] ( scStr->neaArr );

        //Adressen
        scStr->neaArr = tmp;

        //NEA_STR eintragen
        scStr->neaArr[scStr->neaArrCnt++] = nea;

        //ist es ein NEA, der nur am Zeilenanfang stehen darf?
        if( nea->begLine == true )
            //ja
            scStr->nea2Anz++;

        else
            //nein, darf überall stehen
            scStr->nea1Anz++;
    }
}


void SSLRParser::insertInclSC( NEA_STR *nea )
{
    //einen NEA an alle inclusive SC einfügen
    SC_STR  *sc;
    long    i;
    bool    eof = nea->eof;

    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger
        sc = &scStr[i];

        //inclusive?
        if( sc->type == false )
        {
            //eof-NEA?
            if( ( eof == false ) || ( ( eof == true ) && ( ( insertEOFSC( sc ) ) == false ) ) )
                //genug Speicher anfordern
                insertSC( sc, nea );
        }
    }
}


bool SSLRParser::insertEOFSC( SC_STR *scStr )
{
    //prüfen, ob mit der SC bereits ein EOF-NEA verbunden ist
    bool    ex = false;
    int     j;

    //alle NEAen dieser SC
    for( j = 0; j < scStr->neaArrCnt; j++ )
    {
        //Hat diese SC schon einen NEA mit <<EOF>>-Regel?
        if( scStr->neaArr[j]->eof == true )
            //ja
            ex = true;
    }

    //gab es bereits einen NEA mit <<EOF>>?
    if( ex == true )
    {
        //Fehler
        cerr << "sslex: line " << SSLR_line << ": SC " << scStr->name << " already has an <<EOF>>-Rule!\n";

        //Fehler
        err++;
    }

    //alles OK
    return( ex );
}


void SSLRParser::extendNEAStack( void )
{
    /*
        den NEA-Stack vergrößern, wird benötig, falls mehrere NEAen diegleiche
        Aktion ausführen sollen (erstes Zeichen |).
    */
    NEA_STR **tmp;

    //Speicher anfordern
    tmp = new( NEA_STR *[neaStackCnt + 100] );

    //kopieren
    memcpy( tmp, neaStack, sizeof( NEA_STR * ) * neaStackCnt );

    //Speicher freigeben
    if( neaStack )
        delete[] ( neaStack );

    //Adresse
    neaStack = tmp;

    //neue Größe
    neaStackMax += 100;
}


void SSLRParser::insertNEAStack( NEA_STR *nea )
{
    //einen NEA auf den NEA-Stack packen
    if( neaStackCnt >= neaStackMax )
        //vergrößern
        extendNEAStack();

    //nun auf dem Stack packen
    neaStack[neaStackCnt++] = nea;
}


SSLRParser::ECLOS_STR *SSLRParser::createEClos( void )
{
    //eine ECLOS_STR-Struktur vorbereiten
    ECLOS_STR   *tmp;

    //Speicher anfordern
    tmp = new( ECLOS_STR );

    //initialisieren
    memset( tmp, 0, sizeof( ECLOS_STR ) );

    //zurückliefern
    return( tmp );
}


void SSLRParser::removeEClos( ECLOS_STR *eclosStr )
{
    //ECLOS_STR freigeben

    //Zustände?
    if( eclosStr->from )
        delete[] ( eclosStr->from );

    //Zustände?
    if( eclosStr->to )
        delete[] ( eclosStr->to );

    delete( eclosStr );
}


void SSLRParser::insertFromEClos( ECLOS_STR *eclosStr, ulong index )
{
    /*
        einen Zustand in eine ECLOS_STR-Struktur eintragen, von dem aus die Epsilon-Übergänge berechnet
        werden sollen.
    */
    ulong   *tmp, i;

    //genügend Speicher anfordern
    tmp = new( ulong[eclosStr->fromCnt + 1] );

    //kopieren
    memcpy( tmp, eclosStr->from, sizeof( ulong ) * eclosStr->fromCnt );

    //alten Speicher löschen
    if( eclosStr->from )
        delete[] ( eclosStr->from );

    //Zeiger
    eclosStr->from = tmp;


    //sortiert eintragen
    for( i = 0; i < eclosStr->fromCnt; i++ )
    {
        //vergleichen
        if( eclosStr->from[i] > index )
        {
            //an dieser Stelle eintragen
            memmove( &eclosStr->from[i + 1], &eclosStr->from[i], sizeof( ulong ) * ( eclosStr->fromCnt - i ) );

            //eintragen
            eclosStr->from[i] = index;

            //Ende
            break;
        }
    }

    //an letzter Stelle eintragen?
    if( i == eclosStr->fromCnt )
        //ja
        eclosStr->from[i] = index;

    //ein Zustand weiter
    eclosStr->fromCnt++;
}


void SSLRParser::insertFromEClos( ECLOS_STR *eclosStr, ulong *index, ulong anz )
{
    /*
        mehrere Zustände in eine ECLOS_STR-Struktur eintragen, von denen aus die Epsilon-Übergänge
        berechnet werden sollen.
    */
    ulong   i;

    //alle Zustände eintragen
    for( i = 0; i < anz; i++ )
        //eintragen
        insertFromEClos( eclosStr, index[i] );
}


void SSLRParser::insertToEClos( ECLOS_STR *eclosStr, ulong index )
{
    /*
        einen Zustand in eine ECLOS_STR-Struktur eintragen, der von from aus über einen Epsilon-Übergänge
        erreicht wird.
    */
    ulong   *tmp, i;

    //genügend Speicher anfordern
    tmp = new( ulong[eclosStr->toCnt + 1] );

    //kopieren
    memcpy( tmp, eclosStr->to, sizeof( ulong ) * eclosStr->toCnt );

    //alten Speicher löschen
    if( eclosStr->to )
        delete[] ( eclosStr->to );

    //Zeiger
    eclosStr->to = tmp;


    //sortiert eintragen
    for( i = 0; i < eclosStr->toCnt; i++ )
    {
        //vergleichen
        if( eclosStr->to[i] > index )
        {
            //an dieser Stelle eintragen
            memmove( &eclosStr->to[i + 1], &eclosStr->to[i], sizeof( ulong ) * ( eclosStr->toCnt - i ) );

            //eintragen
            eclosStr->to[i] = index;

            //Ende
            break;
        }
    }

    //an letzter Stelle eintragen?
    if( i == eclosStr->toCnt )
        //ja
        eclosStr->to[i] = index;

    //ein Zustand weiter
    eclosStr->toCnt++;
}


bool SSLRParser::findToEClos( ECLOS_STR *eclosStr, ulong index )
{
    //sucht einen Index in to
    ulong   i;
    bool    er = false;

    //alle Zustände in to
    for( i = 0; i < eclosStr->toCnt; i++ )
    {
        //Zustände gleich?
        if( eclosStr->to[i] == index )
        {
            //ja
            er = true;
            break;
        }
    }

    //zurückliefern
    return( er );
}


void SSLRParser::generateEClos( ECLOS_STR *eclosStr )
{
    /*
        Nun die Zustände bestimmen, die über Epsilon-Übergänge von from aus erreichbar sind und
        in to eintragen.
    */
    STATE_STR   *sc;
    BRA_STR     *braStr;
    ulong       *stack, stackPos = 0, i, index;

    //Speicher für den Stack anfordern
    stack = new( ulong[stateStrCnt] );

    //zuerst alle Zustände from selbst auf den Stack legen
    for( i = 0; i < eclosStr->fromCnt; i++ )
    {
        //auf Stack
        stack[stackPos++] = eclosStr->from[i];

        //initialisieren
        insertToEClos( eclosStr, eclosStr->from[i] );
    }

    //solange Zustände auf dem Stack sind
    while( stackPos )
    {
        //einen Index vom Stack holen
        index = stack[--stackPos];

        //Zeiger auf STATE_STR
        sc = stateStr[index];

        //alle Zustandsübergänge von index
        for( i = 0; i < sc->braStrCnt; i++ )
        {
            //Zeiger auf BRA_STR
            braStr = sc->braStr[i];

            //ist es ein epsilon-Übergang?
            if( braStr->eps == true )
            {
                //ja, schon enthalten?
                if( findToEClos( eclosStr, braStr->bra ) == false )
                {
                    //nein, eintragen
                    insertToEClos( eclosStr, braStr->bra );

                    //auf den Stack legen
                    stack[stackPos++] = braStr->bra;
                }
            }
        }
    }

    //Stack freigeben
    delete[] ( stack );
}


SSLRParser::MOVE_STR *SSLRParser::createMove( uchar c )
{
    //eine MOVE_STR-Struktur vorbereiten
    MOVE_STR    *tmp;

    //Speicher anfordern
    tmp = new( MOVE_STR );

    //initialisieren
    memset( tmp, 0, sizeof( MOVE_STR ) );

    //Zeichen eintragen
    tmp->jump = c;

    //zurückliefern
    return( tmp );
}


void SSLRParser::removeMove( MOVE_STR *moveStr )
{
    //Speicher für moevStr freigeben
    if( moveStr->to )
        delete[] ( moveStr->to );

    if( moveStr->from )
        delete[] ( moveStr->from );

    delete( moveStr );
}


void SSLRParser::insertFromMove( MOVE_STR *moveStr, ulong index )
{
    /*
        einen Zustand in eine MOVE_STR-Struktur eintragen, von dem aus die Übergänge berechnet
        werden sollen.
    */
    ulong   *tmp, i;

    //genügend Speicher anfordern
    tmp = new( ulong[moveStr->fromCnt + 1] );

    //kopieren
    memcpy( tmp, moveStr->from, sizeof( ulong ) * moveStr->fromCnt );

    //alten Speicher löschen
    if( moveStr->from )
        delete[] ( moveStr->from );

    //Zeiger
    moveStr->from = tmp;


    //sortiert eintragen
    for( i = 0; i < moveStr->fromCnt; i++ )
    {
        //vergleichen
        if( moveStr->from[i] > index )
        {
            //an dieser Stelle eintragen
            memmove( &moveStr->from[i + 1], &moveStr->from[i], sizeof( ulong ) * ( moveStr->fromCnt - i ) );

            //eintragen
            moveStr->from[i] = index;

            //Ende
            break;
        }
    }

    //an letzter Stelle eintragen?
    if( i == moveStr->fromCnt )
        //ja
        moveStr->from[i] = index;

    //ein Zustand weiter
    moveStr->fromCnt++;
}


void SSLRParser::insertFromMove( MOVE_STR *moveStr, ulong *index, ulong anz )
{
    /*
        mehrere Zustände in eine MOVE_STR-Struktur eintragen, von denen aus die Übergänge
        berechnet werden sollen.
    */
    ulong   i;

    //alle Zustände eintragen
    for( i = 0; i < anz; i++ )
        //eintragen
        insertFromMove( moveStr, index[i] );
}


void SSLRParser::insertToMove( MOVE_STR *moveStr, ulong index )
{
    /*
        einen Zustand in eine MOVE_STR-Struktur eintragen, der von from aus über einen Übergänge
        erreicht wird.
    */
    ulong   *tmp, i;

    //genügend Speicher anfordern
    tmp = new( ulong[moveStr->toCnt + 1] );

    //kopieren
    memcpy( tmp, moveStr->to, sizeof( ulong ) * moveStr->toCnt );

    //alten Speicher löschen
    if( moveStr->to )
        delete[] ( moveStr->to );

    //Zeiger
    moveStr->to = tmp;


    //sortiert eintragen
    for( i = 0; i < moveStr->toCnt; i++ )
    {
        //vergleichen
        if( moveStr->to[i] > index )
        {
            //an dieser Stelle eintragen
            memmove( &moveStr->to[i + 1], &moveStr->to[i], sizeof( ulong ) * ( moveStr->toCnt - i ) );

            //eintragen
            moveStr->to[i] = index;

            //Ende
            break;
        }
    }

    //an letzter Stelle eintragen?
    if( i == moveStr->toCnt )
        //ja
        moveStr->to[i] = index;

    //ein Zustand weiter
    moveStr->toCnt++;
}


bool SSLRParser::findToMove( MOVE_STR *moveStr, ulong index )
{
    //sucht einen Index in to
    ulong   i;
    bool    er = false;

    //alle Zustände in to
    for( i = 0; i < moveStr->toCnt; i++ )
    {
        //Zustände gleich?
        if( moveStr->to[i] == index )
        {
            //ja
            er = true;
            break;
        }
    }

    //zurückliefern
    return( er );
}


void SSLRParser::generateMove( MOVE_STR *moveStr )
{
    /*
        Nun die Zustände bestimmen, die über moveStr->jump-Übergänge von from aus erreichbar sind und
        in to eintragen.
    */
    STATE_STR   *sc;
    BRA_STR     *braStr;
    ulong       i, j, index;
    uchar       c = moveStr->jump;

    //solange Zustände auf dem Stack sind
    for( j = 0; j < moveStr->fromCnt; j++ )
    {
        //einen Index vom Stack holen
        index = moveStr->from[j];

        //Zeiger auf STATE_STR
        sc = stateStr[index];

        //alle Zustandsübergänge von index
        for( i = 0; i < sc->braStrCnt; i++ )
        {
            //Zeiger auf BRA_STR
            braStr = sc->braStr[i];

            //ist es ein epsilon-Übergang?
            if( braStr->cclClass && braStr->cclClass[c] )
            {
                //ja, schon enthalten?
                if( findToMove( moveStr, braStr->bra ) == false )
                    //nein, eintragen
                    insertToMove( moveStr, braStr->bra );
            }
        }
    }
}


void SSLRParser::initDStatesStack( void )
{
    //DSTATES wird als Stack implementiert.

    //initalisieren
    dstatesStack = 0L;
    dstatesStackPos = 0;
}


void SSLRParser::removeDStatesStack( void )
{
    //DSTATES deinitialisieren
    ulong   i;

    //Speicher belegt?
    if( dstatesStack )
    {
        //alle Elemente auf dem Stack entfernen
        for( i = 0; i < dstatesStackPos; i++ )
            //freigeben
            delete( dstatesStack[i] );

        //freigeben
        delete[] ( dstatesStack );
    }

    //keine Elemente auf dem Stack
    dstatesStackPos = 0;
    dstatesStack = 0L;
}


long SSLRParser::insertDStates( ulong *index, ulong anz )
{
    //eine neue NEA-Zustandsmenge in DSTATES eintragen, d.h. einen neuen DEA-Zustand erzeugen
    DSTATES     *tmp, **tmp2;
    long        deaIndex;

    //gibt es den DEA-Zustand schon?
    if( ( deaIndex = lookupDStates( index, anz ) ) < 0 )
    {
        //den DEA-Zustand erzeugen
        deaIndex = insertDEAState( index, anz, false );

        //ist noch nicht enthalten
        tmp2 = new( DSTATES *[dstatesStackPos + 1] );

        //schon auf dem Stack enthaltende Zeiger kopieren
        memcpy( tmp2, dstatesStack, sizeof( DSTATES * ) * dstatesStackPos );

        //alten Speicher freigeben
        if( dstatesStack )
            delete[] ( dstatesStack );

        //Zeiger
        dstatesStack = tmp2;

        //neue DSTATES-Struktur anlegen
        tmp = new( DSTATES );

        //unmarkiert
        tmp->marked = false;

        //Index des DEA-Zustandes
        tmp->deaIndex = deaIndex;

        //auf dem Stack
        dstatesStack[dstatesStackPos++] = tmp;
    }

    //DEA-Zustands-Index zurückliefern
    return( deaIndex );
}


ulong SSLRParser::insertDEAState( ulong *index, ulong anz, bool dummy )
{
    //einen neuen DEA-Zustand
    DEA_STATES  **tmp1, *tmp2;
    STATE_STR   *s;
    ulong       i;

    //genug Speicher
    tmp1 = new( DEA_STATES *[DEAStatesCnt + 1] );

    //kopieren
    memcpy( tmp1, DEAStates, sizeof( DEA_STATES * ) * DEAStatesCnt );

    //alten Speicher freigeben
    if( DEAStates )
        delete[] ( DEAStates );

    //Zeiger
    DEAStates = tmp1;

    //Speicher für eine DEA_STATES-Struktur
    tmp2 = new( DEA_STATES );

    //Speicher für die NEA-Zustände
    tmp2->neaIndex = new( ulong[anz] );

    //kopieren
    memcpy( tmp2->neaIndex, index, sizeof( ulong ) * anz );

    //Anzahl der NEA-Zustände
    tmp2->neaIndexCnt = anz;

    //Index dieses DEA-Zustandes
    tmp2->index = DEAStatesCnt;

    //kein NEA
    tmp2->finitNEA = 0L;
    tmp2->laNEA = 0L;

    //Default
    tmp2->la = false;
    tmp2->finit = false;

    //ist es ein toter Zustand, der für die Zustandsminimierung benötigt wird?
    if( dummy == true )
        //ja
        tmp2->dummy = true;

    else
        //nein
        tmp2->dummy = false;

    //prüfen, ob es ein Finit-Zustand ist
    for( i = 0; i < anz; i++ )
    {
        //Zeiger auf NEA-Zustand
        s = stateStr[index[i]];

        //Finit-Zustand?
        if( s->finit == true )
        {
            //ja
            tmp2->finit = true;

            //NEA_STR eintragen?
            if( !tmp2->finitNEA )
                //ja, immer nur den ersten!
                tmp2->finitNEA = s->nea;
        }

        //Lookahead-Zustand?
        if( s->la == true )
        {
            //ja
            tmp2->la = true;

            //NEA_STR eintragen?
            if( !tmp2->laNEA )
                //ja, immer nur den ersten!
                tmp2->laNEA = s->nea;
        }
    }

    //eintragen
    DEAStates[DEAStatesCnt] = tmp2;

    //Index des Zustands zurückliefern
    return( DEAStatesCnt++ );
}


long SSLRParser::lookupDStates( ulong *index, ulong anz )
{
    //eine Menge von NEA-Zuständen, d.h. einen DEA-Zustand suchen
    DEA_STATES  *dea;
    DSTATES     *d;
    ulong       i;

    //alle bisherigen DEA-Zustände
    for( i = 0; i < dstatesStackPos; i++)
    {
        //Zeiger
        d = dstatesStack[i];

        //Zeiger auf DEA-Zustand
        dea = DEAStates[d->deaIndex];

        //Anzahl der Einträge gleich?
        if( anz == dea->neaIndexCnt )
        {
            //ja, vergleichen
            if( !memcmp( index, dea->neaIndex, sizeof( ulong ) * anz ) )
                //den DEA-Zustand gibt es bereits
                return( d->deaIndex );
        }
    }

    //den DEA-Zustand gibt es noch nicht
    return( -1 );
}


long SSLRParser::getUnmarkedDStates( void )
{
    //einen unmarkierten DEA-Zustand holen
    DSTATES     *d;
    ulong       i;

    //alle bisherigen DEA-Zustände
    for( i = 0; i < dstatesStackPos; i++)
    {
        //Zeiger
        d = dstatesStack[i];

        //unmarkiert?
        if( d->marked == false )
            //ja
            return( i );
    }

    //es gibt keine unmarkierten DEA-Zustände mehr
    return( -1 );
}


void SSLRParser::markDStates( ulong index )
{
    //einen unmarkierten DEA-Zustand markieren
    DSTATES     *d = dstatesStack[index];

    //markieren
    d->marked = true;
}


void SSLRParser::insertDTran( SC_STR *sc, int type, long from, long to, uchar c )
{
    //einen Zustandsübergang in die DEA-Übergangstabelle eintragen
    DTRAN   **tmp1, *tmp2, **myDTran;
    ulong   i, *myDTranCnt, index;

    //NEA darf nur am Zeilenanfang stehen?
    if( type == BEGLINE_NEA )
    {
        //ja
        myDTran = sc->DTran2;

        //Anzahl der bisherigen Zustände
        myDTranCnt = &sc->DTran2Cnt;

        //Index des Zustands in der Tabelle
        index = from - sc->begLineDEAIndex;
    }

    else
    {
        //NEA darf überall stehen
        myDTran = sc->DTran1;

        //Anzahl der bisherigen Zustände
        myDTranCnt = &sc->DTran1Cnt;

        //Index des Zustands in der Tabelle
        index = from - sc->DEAIndex;
    }



    //neue Zeile erzeugen?
    if( !myDTran || ( ( *myDTranCnt - 1 ) < index ) )
    {
        //genug Speicher für alle Zeilen
        tmp1 = new( DTRAN *[index + 1] );

        //initialisieren
        memset( tmp1, 0, sizeof( DTRAN * ) * ( index + 1 ) );

        //umkopieren
        memcpy( tmp1, myDTran, sizeof( DTRAN * ) * *myDTranCnt );

        //Speicher für alle leeren Zeilen anfordern
        for( i = 0; i < ( index + 1 ); i++ )
        {
            //leer?
            if( !tmp1[i] )
            {
                //ja, Speicher anfordern
                tmp2 = new( DTRAN );

                //initialisieren
                memset( tmp2, 0, sizeof( DTRAN ) );

                //Speicher für die Übergänge
                tmp2->to = new( ulong[cclWidth] );
#warning    tmp2->to = new( ulong[cclWidth] );

                //löschen
                memset( tmp2->to, 0, sizeof( int ) * cclWidth );

                //DEA-Index
                tmp2->index = from;

                //eintragen
                tmp1[i] = tmp2;

                //zählen
                (*myDTranCnt)++;
            }
        }

        //alten Speicher freigeben
        if( myDTran )
            delete[] ( myDTran );

        //Adresse
        myDTran = tmp1;
    }

    //Übergang eintragen
    myDTran[index]->index = from;
    myDTran[index]->to[c] = to;

    //NEA darf nur am Zeilenanfang stehen?
    if( type == BEGLINE_NEA )
        //ja
        sc->DTran2 = myDTran;

    else
        //NEA darf überall stehen
        sc->DTran1 = myDTran;
}


void SSLRParser::NEA2DEA( void )
{
    //die NEAen in DEAen wandeln
    DEA_STATES  *dea;
    ECLOS_STR   *eclosStr;
    MOVE_STR    *moveStr;
    NEA_STR     *nea;
    SC_STR      *sc;
    ulong       i, j, k;
    ulong       dDEAIndex;
    uchar       c;
    long        dstatesIndex, newDEAIndex;
    char        hexChar[10];

    //Meldung?
    if( argv_str->verbose == true )
        //Meldung
        cout << "sslex: Generating dea states...\n";

    //alle DEA-Zustände werden fortlaufend nummeriert
    DEAStatesCnt = 0;
    DEAStates = 0L;

    //die DEA-Übergangstabelle aller SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

#ifdef DEBUG
        //Debug-Meldung
        cout << "SC: " << sc->name << "\n";
#endif

        //gibt es überhaupt NEAen, die überall stehen dürfen?
        if( sc->nea1Anz )
        {
            //den Start-Index des DEA merken, bei dem die NEA auch am Zeilenanfang stehen dürfen
            sc->DEAIndex = DEAStatesCnt;

            //WICHTIG: DSTATES initialisieren
            initDStatesStack();

            //e-clos für den ersten Zustand des DEA initialisieren
            eclosStr = createEClos();

            //der erste DEA-Zustand ist e-closure (Start-Zustände aller NEAen dieser SC)
            //keine <<EOF>>-NEAen!
            for( j = 0; j < sc->neaArrCnt; j++ )
            {
                //Zeiger auf NEA
                nea = sc->neaArr[j];

                //<<EOF>>-NEA?
                if( nea->eof == false )
                {
                    //zuerst ohne NEAen, die nur am Zeilenanfang stehen dürfen
                    if( nea->begLine == false )
                    {
                        //Zustand eintragen
                        insertFromEClos( eclosStr, nea->startState );
#ifdef DEBUG
                        //NEA ausgeben
                        outputNEA( sc->neaArr[j] );
#endif
                    }
                }
            }

            //e-clos generieren
            generateEClos( eclosStr );

            //diese Zustandsmenge in DSTATES eintragen
            insertDStates( eclosStr->to, eclosStr->toCnt );

            //Speicher für eclos freigeben
            removeEClos( eclosStr );

            //solange unmarkierte DEA-Zustände auf dem Stack sind
            while( ( dstatesIndex = getUnmarkedDStates() ) >= 0 )
            {
                //markieren
                markDStates( dstatesIndex );

                //Zeiger auf DSTATES
                dea = DEAStates[dstatesStack[dstatesIndex]->deaIndex];

                //alle Zeichen
                for( k = 0; k < cclWidth; k++ )
                {
                    //für Debug-Zwecke
                    c = k;

                    //move( deaIndex, k ) bilden
                    moveStr = createMove( k );

                    //die NEA-Zustände des DEA-Zustandes deaIndex eintragen
                    insertFromMove( moveStr, dea->neaIndex, dea->neaIndexCnt );

                    //Übergänge generieren
                    generateMove( moveStr );

                    //nun e-closure( move( deaIndex, k ) ) bilden
                    eclosStr = createEClos();

                    //Zustände eintragen
                    insertFromEClos( eclosStr, moveStr->to, moveStr->toCnt );

                    //generieren
                    generateEClos( eclosStr );

                    //Wurden Zustände erzeugt?
                    if( eclosStr->toCnt )
                    {
                        //diese neue NEA-Zustandsmenge ist ein DEA-Zustand, eintragen
                        newDEAIndex = insertDStates( eclosStr->to, eclosStr->toCnt );
#ifdef DEBUG
                        //Zeichen ausgeben
                        outputChar( k, hexChar );

                        //Debug-Meldung
                        cout << "DTran[" << dea->index << "][" << hexChar << "] = " << newDEAIndex << "\n";
#endif
                        //in DEA-Zustandsübergangstabelle eintragen
                        insertDTran( sc, NORM_NEA, dea->index, newDEAIndex, k );
                    }

                    else
                        //dieser Zustand hat für das Eingabesymbol k keinen Übergang
                        //in DEA-Zustandsübergangstabelle eintragen
                        insertDTran( sc, NORM_NEA, dea->index, -1, k );

                    //Speicher für eclos freigeben
                    removeEClos( eclosStr );

                    //Speicher für moevStr freigeben
                    removeMove( moveStr );
                }
            }

#ifdef DEBUG
            //die DEA-Zustände ausgeben
            outputDEAStates();
#endif
            //DSTATES deinitialisieren
            removeDStatesStack();
        }

        /*
            An diese Stelle wird auch gesprungen, wenn sc->nea1Anz = 0, d.h. wenn die SC keine
            NEAen hat, die überall stehen dürfen. In diesem Falle hat die SC für diese NEAen nur
            den "tote" Zustand. Dies wird bei der Zustandsminimierung in der Routine minDEA
            benötigt.
            Für die NEAen, die nur am Zeilenanfang stehen dürfen, ist dies nicht notwendig, da dann
            die NEAen aktiv sein werden, die überall stehen dürfen.
        */

        //nun einen toten Zustand d erzeugen, s. Drache S. 172, für die Zustandsminimierung
        dDEAIndex = insertDEAState( 0L, 0, true );

        //hat die SC keine NEAen, die überall stehen dürfen?
        if( !sc->nea1Anz )
            //nein, toter Zustand d ist zugleich Startzustand der NEAen, die überall stehen dürfen
            sc->DEAIndex = dDEAIndex;

        //alle Zeichen
        for( k = 0; k < cclWidth; k++ )
            //in DEA-Zustandsübergangstabelle eintragen
            insertDTran( sc, NORM_NEA, dDEAIndex, dDEAIndex, k );




        //hat die SC NEAen, die ausschließlich am Zeilenanfang stehen dürfen?
        if( sc->nea1Anz || sc->nea2Anz )
        {
            //Nun die NEAen betrachten, die ausschließlich am Zeilenanfang stehen dürfen!

            //den Start-Index des DEA merken, bei dem die NEA auch am Zeilenanfang stehen dürfen
            sc->begLineDEAIndex = DEAStatesCnt;


            //WICHTIG: DSTATES initialisieren
            initDStatesStack();

            //e-clos für den ersten Zustand des DEA initialisieren
            eclosStr = createEClos();

            //der erste DEA-Zustand ist e-closure(Start-Zustände aller NEAen dieser SC)
            //keine <<EOF>>-NEAen!
            for( j = 0; j < sc->neaArrCnt; j++ )
            {
                //Zeiger auf NEA
                nea = sc->neaArr[j];

                //<<EOF>>-NEA?
                if( nea->eof == false )
                {
                    //Zustand eintragen
                    insertFromEClos( eclosStr, sc->neaArr[j]->startState );
#ifdef DEBUG
                    //NEA ausgeben
                    outputNEA( sc->neaArr[j] );
#endif
                }
            }

            //e-clos generieren
            generateEClos( eclosStr );

            //diese Zustandsmenge in DSTATES eintragen
            insertDStates( eclosStr->to, eclosStr->toCnt );

            //Speicher für eclos freigeben
            removeEClos( eclosStr );

            //solange unmarkierte DEA-Zustände auf dem Stack sind
            while( ( dstatesIndex = getUnmarkedDStates() ) >= 0 )
            {
                //markieren
                markDStates( dstatesIndex );

                //Zeiger auf DSTATES
                dea = DEAStates[dstatesStack[dstatesIndex]->deaIndex];

                //alle Zeichen
                for( k = 0; k < cclWidth; k++ )
                {
                    //move( deaIndex, k ) bilden
                    moveStr = createMove( k );

                    //die NEA-Zustände des DEA-Zustandes deaIndex eintragen
                    insertFromMove( moveStr, dea->neaIndex, dea->neaIndexCnt );

                    //Übergänge generieren
                    generateMove( moveStr );

                    //nun e-closure( move( deaIndex, k ) ) bilden
                    eclosStr = createEClos();

                    //Zustände eintragen
                    insertFromEClos( eclosStr, moveStr->to, moveStr->toCnt );

                    //generieren
                    generateEClos( eclosStr );

                    //wurden Zustände erzeugt?
                    if( eclosStr->toCnt )
                    {
                        //diese neue NEA-Zustandsmenge ist ein DEA-Zustand, eintragen
                        newDEAIndex = insertDStates( eclosStr->to, eclosStr->toCnt );
#ifdef DEBUG
                        //Zeichen ausgeben
                        outputChar( k, hexChar );

                        //Debug-Meldung
                        cout << "DTran[" << dea->index << "][" << hexChar << "] = " << newDEAIndex << "\n";
#endif
                        //in DEA-Zustandsübergangstabelle eintragen
                        insertDTran( sc, BEGLINE_NEA, dea->index, newDEAIndex, k );
                    }

                    else
                        //dieser Zustand hat für das Eingabesymbol k keinen Übergang
                        //in DEA-Zustandsübergangstabelle eintragen
                        insertDTran( sc, BEGLINE_NEA, dea->index, -1, k );

                    //Speicher für eclos freigeben
                    removeEClos( eclosStr );

                    //Speicher für moevStr freigeben
                    removeMove( moveStr );
                }
            }

#ifdef DEBUG
            //die DEA-Zustände ausgeben
            outputDEAStates();
#endif
            //DSTATES deinitialisieren
            removeDStatesStack();
        }

        /*
            An diese Stelle wird auch gesprungen, wenn sc->nea1Anz = 0, d.h. wenn die SC keine
            NEAen hat, die überall stehen dürfen. In diesem Falle hat die SC für diese NEAen nur
            den "tote" Zustand. Dies wird bei der Zustandsminimierung in der Routine minDEA
            benötigt.
            Für die NEAen, die nur am Zeilenanfang stehen dürfen, ist dies nicht notwendig, da dann
            die NEAen aktiv sein werden, die überall stehen dürfen.
        */

        //nun einen toten Zustand d erzeugen, s. Drache S. 172, für die Zustandsminimierung
        dDEAIndex = insertDEAState( 0L, 0, true );

        //hat die SC keine NEAen?
        if( !sc->nea1Anz && !sc->nea2Anz )
            //nein, toter Zustand d ist zugleich Startzustand der NEAen, die nur am Zeilenanfang
            //stehen dürfen
            sc->begLineDEAIndex = dDEAIndex;

        //alle Zeichen
        for( k = 0; k < cclWidth; k++ )
            //in DEA-Zustandsübergangstabelle eintragen
            insertDTran( sc, BEGLINE_NEA, dDEAIndex, dDEAIndex, k );
    }
}


void SSLRParser::findDangerousRegExp( void )
{
    /*
        Hier wird vor reg. Expressions gewarnt, bei denen der Start-Zustand des NEA einen
        epsilon-Übergang zum Finit-Zustand hat, was typischerweise bei Regeln der Art
        {REG. EXPR.}* auftritt.
    */
    DEA_STATES  *dea;
    STATE_STR   *ffinits, *s;
    NEA_STR     *ffinitNea, *nea;
    BRA_STR     *braStr;
    SC_STR      *sc;
    ulong       *stack, stackPos = 0, state, ffinit, baseState, endIndex;
    ulong       *marked;
    ulong       i = 0, k, l, j;
    long        dest;

    //Meldung?
    if( argv_str->verbose == true )
        //ja
        cout << "sslex: Searching for dangerous regular expressions..." << endl;

    //Speicher für den Stack
    stack = new( ulong[stateStrCnt] );

    //wenn ein Zustand geprüft wurde, wird er markiert, um Endelos-Schleifen zu vermeiden
    marked = new( ulong[stateStrCnt] );

    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf Start-Condition
        sc = &scStr[i];

        //hat die SC überhaupt NEAen?
        if( sc->neaArrCnt )
        {
            //Array für die Markierungen initialisieren
            memset( marked, 0, sizeof( ulong ) * DEAStatesCnt );

            //alle NEAen dieser SC prüfen
            for( j = 0; j < sc->neaArrCnt; j++ )
            {
                //Zeiger auf NEA_STR
                nea = sc->neaArr[j];

                //Zeiger auf STATE_STR des Start-Zustandes des NEA
                s = stateStr[nea->startState];

                //hat der NEA einen epsilon-Übergang vom Start-Zustand?
                if( s->eps )
                {
                    //den Stack-Pointer zurücksetzen
                    stackPos = 0;

                    //den Start-Zustand des NEA auf den Stack schieben
                    stack[stackPos++] = nea->startState;

                    //solange Zustände auf dem Stack sind
                    while( stackPos )
                    {
                        //Zustand holen
                        state = stack[--stackPos];

                        //schon markiert?
                        if( !marked[state] )
                        {
                            //Zeiger auf STATE_STR des Start-Zustandes des NEA
                            s = stateStr[state];

                            //markieren
                            marked[state]++;

                            //hat dieser Zustand epsilon-Übergänge?
                            if( s->eps )
                            {
                                //der NEA hat für state epsilon-Übergänge, alle Zustands-Übergänge von state prüfen
                                for( k = 0; k < s->braStrCnt; k++ )
                                {
                                    //Zeiger auf Übergangs-Struktur
                                    braStr = s->braStr[k];

                                    //ist es ein epsilon-Übergang?
                                    if( braStr->eps == true )
                                    {
                                        //ist ein epsilon-Übergang

                                        //ist der Ziel-Zustand der Finit-Zustand des NEA?
                                        if( braStr->bra == nea->endState )
                                        {
                                            //ja, Warnung ausgeben
                                            cerr << "sslex: WARNING: Dangerous regular expression " << nea->regText << " in line " << nea->line << "!" << endl;

                                            //Prüfung für diesen NEA beendet
                                            stackPos = 0;
                                            break;
                                        }

                                        //nein, auf den Stack schieben
                                        stack[stackPos++] = braStr->bra;

                                        //diesen markieren
                                        marked[state]++;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //Speicher freigeben
    delete[] ( stack );
    delete[] ( marked );
}


void SSLRParser::findNoRules( void )
{
    /*  Finde Regeln, die nie ausgeführt werden. Hat ein DEA-Finit-Zustand mehrere NEA-Finit-Zustände, die
        zu verschiedenen NEAen gehören (und damit zu verschiedenen Aktionen), so wird der zuerst eingetragene
        bevorzugt.
    */
    DEA_STATES  *dea;
    STATE_STR   *ffinits, *s;
    NEA_STR     *ffinitNea, *nea;
    SC_STR      *sc;
    ulong       *stack, stackPos = 0, state, ffinit, baseState, endIndex;
    ulong       *marked;
    ulong       i = 0, k, l, j;
    long        dest;

    //Meldung?
    if( argv_str->verbose == true )
        //ja
        cout << "sslex: Searching for never matching rules..." << endl;

    //Speicher für den Stack
    stack = new( ulong[DEAStatesCnt * cclWidth] );

    //wenn ein Zustand geprüft wurde, wird er markiert, um Endelos-Schleifen zu vermeiden
    marked = new( ulong[DEAStatesCnt] );

    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf Start-Condition
        sc = &scStr[i];

        //hat die SC überhaupt NEAen?
        if( sc->neaArrCnt )
        {
            //Array für die Markierungen initialisieren
            memset( marked, 0, sizeof( ulong ) * DEAStatesCnt );

            //hat die SC NEAen, die überall stehen dürfen?
            if( sc->DTran1Cnt )
            {
                //Start-Zustand der NEAen, die überall stehen dürfen, auf den Stack
                stack[stackPos++] = baseState = sc->DEAIndex;

                //solange Zustände auf dem Stack sind
                while( stackPos )
                {
                    //Zustand holen
                    state = stack[--stackPos];

                    //schon markiert?
                    if( !marked[state] )
                    {
                        //markieren
                        marked[state]++;

                        //prüfen, ob dieser DEA-Zustand mehrere NEA-Finit-Zustände besitzt
                        dea = DEAStates[state];

                        //hat er Finit-Zustände?
                        if( dea->finit == true )
                        {
                            //alle NEA-Zustände
                            for( j = 0, ffinit = 0; j < dea->neaIndexCnt; j++ )
                            {
                                //Zeiger auf STATE_STR
                                s = stateStr[dea->neaIndex[j]];

                                //ist es ein NEA-Finit-Zustand?
                                if( s->finit == true )
                                {
                                    //der erste Finit-Zustand?
                                    if( !ffinit )
                                    {
                                        //ja, merken
                                        ffinit = 1;

                                        //Regel wird ausgeführt
                                        s->isUseful = true;

                                        //STATE_STR merken
                                        ffinits = s;

                                        //die NEA-Strukur merken
                                        ffinitNea = s->nea;
                                    }

                                    else
                                    {
                                        //DEA-Zustand beinhaltet mehrere NEA-Finit-Zustände
                                        nea = s->nea;

                                        //zeige Konflikte zwischen reg. Ausdrücken?
                                        if( argv_str->showConflicts == true )
                                            //Meldung
                                            cerr << "sslex: WARNING: Conflict between reg. Expession " << ffinitNea->regText << ", SSLR_line " << ffinitNea->line << ", and reg. Expression " << nea->regText << ", SSLR_line " << nea->line << "!\n";
                                    }
                                }
                            }
                        }


                        //Ziel-Zustände auf dem Stack
                        for( k = 0; k < cclWidth; k++ )
                        {
                            //Zustand holen
                            dest = sc->DTran1[state - baseState]->to[k];

                            //hat dieser DEA-Zustand einen Übergang für k?
                            if( dest >= 0 )
                            {
                                //ja, Zustand bereits markiert?
                                if( !marked[dest] )
                                {
                                    //nein, ist dieser Zustand bereits auf dem Stack?
                                    for( l = 0; l < stackPos; l++ )
                                    {
                                        //Zustand dest?
                                        if( stack[l] == dest )
                                            //ja, nicht schieben
                                            break;
                                    }

                                    //Zustand schon auf dem Stack?
                                    if( l == stackPos )
                                        //nein
                                        stack[stackPos++] = dest;
                                }
                            }
                        }
                    }
                }
            }


            //nun die NEAen, die ausschließlich am Zeilenanfang stehen dürfen
            if( sc->DTran2Cnt )
            {
                //Array für die Markierungen initialisieren
//              memset( marked, 0, sizeof( ulong ) * DEAStatesCnt );

                //Start-Zustand der NEAen, die ausschließlich am Zeilenanfang stehen dürfen, auf den Stack
                stack[stackPos++] = baseState = sc->begLineDEAIndex;

                //solange Zustände auf dem Stack sind
                while( stackPos )
                {
                    //Zustand holen
                    state = stack[--stackPos];

                    //schon markiert?
                    if( !marked[state] )
                    {
                        //markieren
                        marked[state]++;

                        //prüfen, ob dieser DEA-Zustand mehrere NEA-Finit-Zustände besitzt
                        dea = DEAStates[state];

                        //hat er Finit-Zustände?
                        if( dea->finit == true )
                        {
                            //alle NEA-Zustände
                            for( j = 0, ffinit = 0; j < dea->neaIndexCnt; j++ )
                            {
                                //Zeiger auf STATE_STR
                                s = stateStr[dea->neaIndex[j]];

                                //ist es ein NEA-Finit-Zustand?
                                if( s->finit == true )
                                {
                                    //der erste Finit-Zustand?
                                    if( !ffinit )
                                    {
                                        //ja, merken
                                        ffinit = 1;

                                        //Regel wird ausgeführt
                                        s->isUseful = true;

                                        //STATE_STR merken
                                        ffinits = s;

                                        //die NEA-Strukur merken
                                        ffinitNea = s->nea;
                                    }

                                    else
                                    {
                                        //DEA-Zustand beinhaltet mehrere NEA-Finit-Zustände
                                        nea = s->nea;

                                        //zeige Konflikte zwischen reg. Ausdrücken?
                                        if( argv_str->showConflicts == true )
                                            //Meldung
                                            cerr << "sslex: WARNING: Conflict between reg. Expession " << ffinitNea->regText << ", SSLR_line " << ffinitNea->line << ", and reg. Expression " << nea->regText << ", SSLR_line " << nea->line << "!\n";
                                    }
                                }
                            }
                        }


                        //Ziel-Zustände auf dem Stack
                        for( k = 0; k < cclWidth; k++ )
                        {
                            //Zustand holen
                            dest = sc->DTran2[state - baseState]->to[k];

                            //hat dieser DEA-Zustand einen Übergang für k?
                            if( dest >= 0 )
                            {
                                //ja, Zustand bereits markiert?
                                if( !marked[dest] )
                                {
                                    //nein, ist dieser Zustand bereits auf dem Stack?
                                    for( l = 0; l < stackPos; l++ )
                                    {
                                        //Zustand dest?
                                        if( stack[l] == dest )
                                            //ja, nicht schieben
                                            break;
                                    }

                                    //Zustand schon auf dem Stack?
                                    if( l == stackPos )
                                        //nein
                                        stack[stackPos++] = dest;
                                }
                            }
                        }
                    }
                }
            }


            //den End-Zustand berechnen
            if( sc->begLineDEAIndex >= 0 )
                //ja
                endIndex = sc->begLineDEAIndex + sc->DTran2Cnt - 1;

            else
                //hat keine NEAen, die ausschließlich am Zeilenanfang stehen müssen
                endIndex = sc->DEAIndex + sc->DTran1Cnt - 1;

            //nach nicht erreichbaren Zuständen suchen
            for( k = sc->DEAIndex; k <= endIndex; k++ )
            {
                //Zeiger auf DEA-Struktur
                dea = DEAStates[k];

                //unmarkierter Zustand?
                if( !marked[k] && ( dea->dummy == false ) )
                    //ja, Meldung
                    cerr << "sslex: DEA-State " << k << " in start condition " << sc->name << " will never be reached!" << endl;
            }
        }
    }

    //Speicher freigeben
    delete[] ( stack );
    delete[] ( marked );


    //prüfen, ob es Regeln gibt, die niemals ausgeführt werden
    for( i = 0; i < stateStrCnt; i++ )
    {
        //Zeiger auf NEA-Zustand
        s = stateStr[i];

        //Finit-Zustand?
        if( ( s->finit == true ) && ( s->isUseful == false ) && ( s->nea ) && ( s->nea->eof == false ) )
            //Regel wird nie ausgeführt
            cerr << "sslex: WARNING: line " << s->nea->line << ": Rule " << s->nea->regText << " will never be matched!" << endl;
    }
}


void SSLRParser::outputDEAStates( void )
{
    //die DEA-Zustände ausgeben mit den zugehörigen NEA-Zuständen
    DEA_STATES  *dea;
    DSTATES     *d;
    ulong       i, j;

    //die DEA-Zustände befinden sich in dstatesStack
    for( i = 0; i < dstatesStackPos; i++ )
    {
        //Zeiger auf DSTATES
        d = dstatesStack[i];

        //Zeiger auf DEA-Zustand
        dea = DEAStates[d->deaIndex];

        //ausgeben
        cout << "DEA(" << d->deaIndex << ") = { ";

        //alle NEA-Zustände
        for( j = 0; j < dea->neaIndexCnt; j++ )
            cout << " " << dea->neaIndex[j] << " ";

        //abschließen
        cout << "}\n";
    }
}


void SSLRParser::outputCPPMinDEA( ofstream &file )
{
    /*
        Die Übergangstabelle ausgeben, mit Minimierung der DEA-Zustandsmenge. Jede Gruppe entspricht
        einem neuen DEA-Zustand (sofern sie nicht disabled ist).
    */
    DEA_STATES  *dea;
    GROUP_STR   **grp, *tmp, *destGrp;
    NEA_STR     *nea;
    SC_STR      *sc;
    ulong       *transTable, *transState, baseDEAState = 0, index, state, dest;
    ulong       baseState, base1State, end1State, base2State, end2State;
    char        widthPuffer[10], *regText;
    int         i, j, k, l, width;


    //die Breite eines Zustandes bestimmen
    sprintf( widthPuffer, "%ld", numberOfGroups );
    width = strlen( widthPuffer );

    //Mindestbreite: 4
    if( width < 4 )
        width = 4;


    //Übersetzt Gruppen-Indices in DEA-Zustände
    transState = new( ulong[maxGroupIndex] );

    //Übersetzt die Gruppen-Indices in laufende Nummern
    transTable = new( ulong[maxGroupIndex] );

    //für die Erzeugung der Accept-Tabelle
    finitNEA = new( NEA_STR *[numberOfGroups] );

    //initialisieren
    memset( finitNEA, 0, sizeof( NEA_STR * ) * numberOfGroups );

    //für die Erzeugung der Lookahead-Tabelle
    laNEA = new( NEA_STR *[numberOfGroups] );

    //initialisieren
    memset( laNEA, 0, sizeof( NEA_STR * ) * numberOfGroups );


    //Header ausgeben
    file << "\n//Transition-Table\n";
    file << "long SSLEXScanner::ssLexTable[SSLEX_STATE][CCLWIDTH] = \n{\n";

    //alle Zeichen ausgeben
    file << "/*\n";

    //alle Zeichen ausgeben
    for( i = j = k = 0; i < cclWidth; i++, j++, k++ )
    {
        //alle 32 Zeichen einen Zeilenwechsel
        if( k == 32 )
        {
            //ja
            file << "\n";
            k = 0;
        }

        //Breite setzen
        file.width( width );

        //Zeichen schreiben
        outputChar( i, widthPuffer );

        //Zeichen ist druckbar
        file << widthPuffer;

        //letztes Element?
        if( j < 127 )
            //Komma ausgeben
            file << ",";
    }

    //abschließen
    file << "\n*/\n";



    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger
        sc = &scStr[i];


        //Anfangs- und Endzustand der NEAen, die überall stehen dürfen
        base1State = sc->DEAIndex;
        end1State = base1State + sc->DTran1Cnt - 1;

        //Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen dürfen
        base2State = sc->begLineDEAIndex;
        end2State = base2State + sc->DTran2Cnt - 1;


        //transTable initialisieren
        memset( transTable, 0, sizeof( ulong ) * maxGroupIndex );


        /*
            Die erste Gruppe ist der neue Startzustand der NEAen, die überall stehen dürfen.
            Die zweite Gruppe ist der neue Startzustand der NEAen, die nur am Zeilenanfang stehen dürfen.
        */

        //Zeiger auf Gruppen-Strukturen
        grp = sc->grp;

        //Start-Zustand merken
        baseState = baseDEAState;


        //die neuen DEA-Zustände in die SC eintragen
        sc->firstStart = baseState;
        sc->secondStart = baseState + 1;


        //transTable aufbereiten
        for( j = 0; j < sc->grpCnt; j++ )
        {
            //Zeiger auf Gruppe
            tmp = grp[j];

            //laufende Nummer
            transTable[tmp->index] = j;

            //Gruppe valid?
            if( tmp->valid == true )
                //Da jede Gruppe einer Menge von äquivalenten DEA-Zuständen entspricht, wird jeder
                //Gruppe ein neuer "DEA-Zustand" zugewiesen.
                transState[tmp->index] = baseDEAState++;
        }

        //SC ausgeben
        file << "\n//Startcondition: " << sc->name << "\n";

        //alle Gruppen
        for( l = 0; l < sc->grpCnt; l++ )
        {
            //ist die Gruppe disabled?
            if( grp[l]->valid == true )
            {
                //nein, aus der Gruppe einen repräsentativen Zustand nehmen
                index = grp[l]->DEAIndex[0];

                //Zeiger auf DEA-Struktur
                dea = DEAStates[index];

                //aktueller Zustand
                state = transState[grp[l]->index];

                //state darf nicht >= max sein
                assert( state < numberOfGroups );

                //ist dieser Zustand ein akzeptierender Zustand?
                if( dea->finit == true )
                    //ja, Zeiger auf NEA merken
                    finitNEA[state] = dea->finitNEA;

                //ist dieser Zustand ein Lookahead-Zustand?
                if( dea->la == true )
                    //ja, markieren
                    laNEA[state] = dea->laNEA;

                //aktuellen Zustand ausgeben
                file << "/* " << state << " */\n{\n";

                //alle Zeichen
                for( j = k = 0; j < cclWidth; j++, k++ )
                {
                    //alle 32 Zeichen einen Zeilenwechsel
                    if( k == 32 )
                    {
                        //ja
                        file << "\n";
                        k = 0;
                    }

                    //ausgeben
                    file.width( width );

                    //Index des Zielzustands
                    if( index <= end1State )
                        dest = sc->DTran1[index - base1State]->to[j];

                    else
                        dest = sc->DTran2[index - base2State]->to[j];

                    //DEA-Struktur des Ziel-Zustands
                    dea = DEAStates[dest];

                    //Gruppe des Zielzustands
                    destGrp = grp[transTable[dea->groupIndex]];

                    //ist die Gruppe valid?
                    if( ( destGrp->valid == true ) && ( dea->dummy == false ) )
                        //ausgeben
                        file << transState[destGrp->index];

                    else
                        //kein Übergang
                        file << "-1";

                    //letztes Element?
                    if( j < ( cclWidth - 1 ) )
                        //Komma ausgeben
                        file << ",";
                }

                //letztes Element?
                if( state < ( numberOfGroups - 1 ) )
                    //Komma ausgeben
                    file << "\n},\n";

                else
                    //ohne Komma ausgeben
                    file << "\n}\n";
            }
        }
    }


    //abschließen
    file << "\n};\n";

    //nun das Array für die Accept-Zustände erzeugen
    file << "\n//Accept-Array\n";
    file << "ulong SSLEXScanner::ssLexAccept[SSLEX_STATE] = \n{\n";

    //alle DEA-Zustände
    for( i = 0; i < numberOfGroups; i++ )
    {
        //Zustand ausgeben
        file << "/* " << i << " */\n";

        //Zeiger auf den entsprechenden NEA
        nea = finitNEA[i];

        //Finit-Zustand?
        if( nea )
        {
            //ja, reg. Text des zugehörigen NEA ausgeben

            //reg. Ausdruck in Textform anpassen
            regText = toString( nea->regText );

            //ausgeben
            file << "\n//Line " << nea->line << ": " << regText << "\n";
            file << i;

            //Speicher freigeben
            delete[] ( regText );
        }

        else
            //nein
            file << "0";

        //letzter Zustand?
        if( i < ( numberOfGroups - 1 ) )
            //nein, Komma
            file << ",\n";
    }

    //abschliessen
    file << "\n};\n\n";


    //gibt es Lookahead-NEAs?
    if( laUsed == true )
    {
        //nun das Array für die Lookahead-Zustände erzeugen
        file << "\n//Lookahead-Array\n";
        file << "ulong SSLEXScanner::ssLexLA[SSLEX_STATE] = \n{\n";

        //alle DEA-Zustände
        for( i = 0; i < numberOfGroups; i++ )
        {
            //Zustand ausgeben
            file << "/* " << i << " */\n";

            //Zeiger auf den entsprechenden NEA
            nea = laNEA[i];

            //Lookahead-Zustand?
            if( nea )
            {
                //reg. Ausdruck in Textform anpassen
                regText = toString( nea->regText );

                //reg. Text des zugehörigen NEA ausgeben
                file << "\n//Line " << nea->line << ": " << regText << "\n";
                file << "1";

                //Speicher freigeben
                delete[] ( regText );
            }

            else
                //nein
                file << "0";

            //letzter Zustand?
            if( i < ( numberOfGroups - 1 ) )
                //nein, Komma
                file << ",\n";
        }

        //abschliessen
        file << "\n};\n\n";
    }


    //Speicher freigeben
    delete[] ( transTable );
    delete[] ( transState );
}


void SSLRParser::outputCPPDebug( ofstream &file )
{
    //die Debug-Strukturen ausgeben
    DEA_STATES  *dea;
    STATE_STR   *s;
    GROUP_STR   **grp;
    DEBUG_STR   *debugStr, *d;
    NEA_STR     *nea;
    SC_STR      *sc;
    ulong       k, l, index, anzNEA = 0, cnt, DEACnt;
    ulong       *marked, *anzRegExp;
    long        i, j;
    char        *regText;

    //Debug-Makro ausgeben
    file << "\n#ifdef SSLEX_DEBUG\n";

    //initialisieren
    debugStrPos = 0;

    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //Anzahl der NEAen dieser SC
        anzNEA += sc->neaArrCnt;
    }

    //Speicher für die DEBUG_STR anfordern
    debugStr = new( DEBUG_STR[anzNEA] );

    //nun die DEBUG_STR füllen
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //alle NEAen
        for( j = 0; j < sc->neaArrCnt; j++ )
        {
            //Zeiger auf NEA
            nea = sc->neaArr[j];

            //ist die NEA-Struktur bereits eingetragen?
            for( k = 0; k < debugStrPos; k++ )
            {
                //schon da?
                if( debugStr[k].nea == nea )
                    //ja
                    break;
            }

            //war sie schon eingetragen?
            if( k ==debugStrPos )
            {
                //nein, eintragen
                debugStr[debugStrPos].index = debugStrPos;
                debugStr[debugStrPos++].nea = nea;
            }
        }
    }


    //die Debug-Struktur ausgeben
    file << "\n//Structure with regular expressions in text form\n";
    file << "char *SSLEXScanner::regText[regTextSize] = {\n";

    //alle Einträge
    for( i = 0; i < debugStrPos; i++ )
    {
        //Zeiger
        d = &debugStr[i];

        //reg. Ausdruck in Textform anpassen
        regText = toString( d->nea->regText );

        //ausgeben
        file << "\"" << regText << "\"";

        //letzter Eintrag?
        if( i < ( debugStrPos - 1 ) )
            //nein
            file << ",";

        //ausgeben
        file << "\t// " << d->nea->regText << ", line " << d->nea->line << "\n";

        //Speicher freigeben
        delete[] ( regText );
    }

    //abschließen
    file << "};\n\n";



    //markierte Indices nicht ausgeben
    marked = new( ulong[debugStrPos] );

    //Anzahl der assoziierten regulären Ausdrücke eines Zustands merken
    anzRegExp = new( ulong[numberOfGroups] );

    //nun die Arrays mit den Indices in regText ausgeben
    file << "\n//Array with indices in regText\n";

    //alle SC
    for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //Zeiger auf Gruppen-Array
        grp = sc->grp;

        //alle Gruppen ( = reduzierte DEA-Zustände ) einer SC
        for( j = 0; j < sc->grpCnt; j++ )
        {
            //ist die Gruppe disabled?
            if( grp[j]->valid == true )
            {
                //ausgeben
                file << "ulong SSLEXScanner::regTextIndex" << DEACnt << "[] = { ";

                //inizialisieren
                memset( marked, 0, sizeof( ulong ) * debugStrPos );

                //aus der Gruppe einen repräsentativen Zustand nehmen
                index = grp[j]->DEAIndex[0];

                //Zeiger auf DEA-Struktur
                dea = DEAStates[index];

                //alle NEA-Zustände dieses NEA-Zustands
                for( k = cnt = 0; k < dea->neaIndexCnt; k++ )
                {
                    //Zeiger auf NEA-Zustand
                    s = stateStr[dea->neaIndex[k]];

                    //den NEA dieses Zustands in DEBUG_STR suchen
                    for( l = 0; l < debugStrPos; l++ )
                    {
                        //gleich?
                        if( ( debugStr[l].nea == s->nea ) && !marked[l] )
                        {
                            //ja, ausgeben
                            if( cnt )
                                file << ", ";

                            //Index ausgeben
                            file << l;

                            //markieren
                            marked[l]++;

                            //Zähler
                            cnt++;
                        }
                    }
                }

                //Anzahl der regulären Ausdrücke merken
                anzRegExp[DEACnt++] = cnt;

                //abschliessen
                file << " };\n";
            }
        }
    }




    //nun die DEBUG_STR ausgeben
    file << "\n\n//Structure with debugging information\n";
    file << "SSLEXScanner::SSLEXDebugStr SSLEXScanner::debugStr[SSLEX_STATE] = {\n";

    //alle SC
    for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //Zeiger auf Gruppen-Array
        grp = sc->grp;

        //alle Gruppen ( = reduzierte DEA-Zustände ) einer SC
        for( j = 0; j < sc->grpCnt; j++ )
        {
            //ist die Gruppe disabled?
            if( grp[j]->valid == true )
            {
                //ausgeben
                file << "{ " << DEACnt << ", regTextIndex" << DEACnt << ", " << anzRegExp[DEACnt] << " }";

                //nächster DEA-Zustand
                DEACnt++;

                //mit Komma abschliessen?
                if( DEACnt < numberOfGroups )
                    //ja
                    file << ",\n";

                else
                    //ist letzter Eintrag
                    file << "\n";
            }
        }
    }

    //abschließen
    file << "};\n\n";



    //nun das Array mit den reg. Ausdrücken bei Akzeptieren
    file << "\n//Array with regular expression at accepting\n";
    file << "char *SSLEXScanner::acceptRegText[SSLEX_STATE] = { ";

    //alle SC
    for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //Zeiger auf Gruppen-Array
        grp = sc->grp;

        //alle Gruppen ( = reduzierte DEA-Zustände ) einer SC
        for( j = 0; j < sc->grpCnt; j++ )
        {
            //ist die Gruppe disabled?
            if( grp[j]->valid == true )
            {
                //aus der Gruppe einen repräsentativen Zustand nehmen
                index = grp[j]->DEAIndex[0];

                //Zeiger auf DEA-Struktur
                dea = DEAStates[index];

                //akzepierend?
                if( dea->finit == true )
                {
                    //ja, reg. Ausdruck in Textform anpassen
                    regText = toString( dea->finitNEA->regText );

                    //ausgeben
                    file << "\"" << regText << "\"";

                    //Speicher freigeben
                    delete[] ( regText );
                }

                else
                    //ist kein akzeptierender Zustand
                    file << "0L";

                //folgen noch welche?
                if( DEACnt < ( numberOfGroups - 1 ) )
                    //Komma ausgeben
                    file << ",\n";

                else
                    //nein
                    file << "\n";

                //DEA-Zustände zählen
                DEACnt++;
            }
        }
    }

    //abschließen
    file << "\n};\n";


    //Debug-Makro ausgeben
    file << "#endif\n";


    //Start-Conditionen ausgeben
    file << "\n";
    file << "//name of the start conditions\n";
    file << "char *SSLEXScanner::scName[] = {\n";

    //die Namen der Start-Conditionen ausgeben
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //ausgeben
        file << "\t\"" << sc->name << "\", " << "\"NL_" << sc->name << "\"";

        //folgen noch welche?
        if( i < ( scStrAnz - 1 ) )
            //Komma ausgeben
            file << ",\n";
    }

    //abschließen
    file << "\n};\n";





    //Speicher freigeben
    delete[] ( debugStr );
    delete[] ( marked );
    delete[] ( anzRegExp );
}


char *SSLRParser::toString( char *text )
{
    //wandelt die Steuerzeichen in druckbare Zeichen
    ulong   len = strlen( text ), cnt = 0;
    char    *tmp, *pos;

    //doppelt soviel Speicher genügt
    tmp = new( char[2 * len + 1] );

    //Null-Byte
    tmp[0] = 0;

    //Anfang merken
    pos = tmp;

    while( text[cnt] )
    {
        //Steuerzeichen?
        switch( text[cnt] )
        {
            case '\"':
            {
                //Anführungszeichen
                *pos++ = '\\';
                *pos++ = '"';
                *pos = 0;
                break;
            }

            case '\\':
            {
                //druckbar machen
                *pos++ = '\\';
                *pos++ = '\\';

                //Null-Byte
                *pos = 0;
                break;
            }

            default:
                //Zeichen kopieren
                *pos++ = text[cnt];
        }

        //nächstes Zeichen
        cnt++;
    }

    //Null-Byte
    *pos = 0;

    //String zurückliefern
    return( tmp );
}


void SSLRParser::outputAction( ofstream &file )
{
    //Aktionen ausgeben
    NEA_STR     *nea;
    SC_STR      *sc;
    ulong       i, j, k, *fArr;

    //für Fehlerbehandlung
    file << "\n";
    file << "//Table for error handling\n";
    file << "int SSLEXScanner::err[scSize][CCLWIDTH] = { 0 };\n";
    file << "\n";
    file << "\n";




    //die Zustände ausgeben, an denen ein Wechsel der Start-Conditionen stattfindet, ausgeben
    file << "\n";
    file << "//state of start conditions\n";
    file << "ulong SSLEXScanner::scIndex[] = {\n";

    //die Namen der Start-Conditionen ausgeben
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //ausgeben
        file << "\t" << sc->firstStart << ",";

        //SC als Namen im Kommentar ausgeben
        file << " //" << sc->name << "\n";

        //ausgeben
        file << "\t" << sc->secondStart;

        //folgen noch welche?
        if( i < ( scStrAnz - 1 ) )
            //Komma ausgeben
            file << ",";

        //ausgeben
        file << " //NL_" << sc->name << "\n";
    }

    //abschließen
    file << "};\n";


    //Speicher für das Array, das angibt, welche Finit-Zustände bereits bearbeitet wurden
    fArr = new( ulong[numberOfGroups] );

    //initialisieren
    memset( fArr, 0, sizeof( ulong ) * numberOfGroups );


file << "\n";
file << "\n";
file << "SSLEXScanner::SSLEXScanner( char *data, ulong size )\n";
file << "{\n";
file << "   //initialize SSLEX\n";
file << "\n";
file << "   //no data?\n";
file << "   if( !data )\n";
file << "   {\n";
file << "       //error\n";
file << "       cerr << \"sslex: SSLEXScanner::SSLEXScanner: No data!\\n\";\n";
file << "\n";
file << "       //exit\n";
file << "       exit( 1 );\n";
file << "   }\n";
file << "\n";
file << "   //save length of text\n";
file << "   basePosLength = size;\n";
file << "\n";
file << "   //copy text to analyze due to unput\n";
file << "   pos = basePos = new( char[basePosLength + 1] );\n";
file << "\n";
file << "   //copy to analyze string. This is nesessary as there are zero-bytes allowed in scanning\n";
file << "   //text. But this would couse strlen to return only the length till the next zero-byte!\n";
file << "   memcpy( pos, data, sizeof( char ) * basePosLength );\n";
file << "   pos[basePosLength] = 0;\n";
file << "\n";
file << "   //end of scanning\n";
file << "   end = pos + basePosLength;\n";
file << "\n";
file << "   //start-condition INITIAL\n";
file << "   state = baseState = INITIAL;\n";
file << "\n";
file << "   //init with SSLEX_YYTEXTSIZE bytes\n";
file << "   yyTextLen = SSLEX_YYTEXTSIZE;\n";
file << "   yyText = new( char[yyTextLen + 1] );\n";
file << "   yyLeng = 0;\n";
file << "\n";
file << "   //SSLEX automatically counts line numbers\n";
file << "   yyLineno = 1;\n";
file << "\n";
file << "   //last accepting state\n";
file << "   lastAcceptingState = -1;\n";
file << "\n";
file << "   //do not concatenate token\n";
file << "   concatenate = false;\n";
file << "\n";
file << "   //no start conditions on stack\n";
file << "   scStackSize = 0;\n";
file << "   scStackPos = 0;\n";
file << "   scStack = 0L;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "   //inizialize user defined variables\n";
file << "   init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "SSLEXScanner::~SSLEXScanner()\n";
file << "{\n";
file << "   //free memory\n";
file << "   if( yyText )\n";
file << "       delete[] ( yyText );\n";
file << "\n";
file << "   if( scStack )\n";
file << "       delete[] ( scStack );\n";
file << "\n";
file << "   //free old text\n";
file << "   if( basePos )\n";
file << "       delete[] ( basePos );\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "   //deinizialize user defined variables\n";
file << "   deinit();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::reset( void )\n";
file << "{\n";
file << "   //reset the whole scanner\n";
file << "\n";
file << "   //start position\n";
file << "   pos = basePos;\n";
file << "\n";
file << "   //end of scanning\n";
file << "   end = pos + basePosLength;\n";
file << "\n";
file << "   //need memory for yyText?\n";
file << "   if( !yyText )\n";
file << "   {\n";
file << "       //init with SSLEX_YYTEXTSIZE bytes\n";
file << "       yyTextLen = SSLEX_YYTEXTSIZE;\n";
file << "       yyText = new( char[yyTextLen + 1] );\n";
file << "   }\n";
file << "\n";
file << "   //start-condition INITIAL\n";
file << "   state = baseState = INITIAL;\n";
file << "\n";
file << "   //no token\n";
file << "   yyLeng = 0;\n";
file << "\n";
file << "   //SSLEX automatically counts line numbers\n";
file << "   yyLineno = 1;\n";
file << "\n";
file << "   //last accepting state\n";
file << "   lastAcceptingState = -1;\n";
file << "\n";
file << "   //do not concatenate token\n";
file << "   concatenate = false;\n";
file << "\n";
file << "   //no start conditions on stack\n";
file << "   scStackPos = 0;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "   //inizialize user defined variables\n";
file << "   init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::reset( char *data, ulong size )\n";
file << "{\n";
file << "   //reset the whole scanner and give him new input\n";
file << "\n";
file << "   //no data?\n";
file << "   if( !data )\n";
file << "   {\n";
file << "       //error\n";
file << "       cerr << \"sslex: SSLEXScanner::reset: No data!\\n\";\n";
file << "\n";
file << "       //exit\n";
file << "       exit( 1 );\n";
file << "   }\n";
file << "\n";
file << "   //free old text\n";
file << "   if( basePos )\n";
file << "       delete[] ( basePos );\n";
file << "\n";
file << "   //save length of text\n";
file << "   basePosLength = size;\n";
file << "\n";
file << "   //copy text to analyze due to unput\n";
file << "   pos = basePos = new( char[basePosLength + 1] );\n";
file << "\n";
file << "   //copy to analyze string. This is nesessary as there are zero-bytes allowed in scanning\n";
file << "   //text. But this would couse strlen to return only the length till the next zero-byte!\n";
file << "   memcpy( pos, data, sizeof( char ) * basePosLength );\n";
file << "   pos[basePosLength] = 0;\n";
file << "\n";
file << "   //end of scanning\n";
file << "   end = pos + basePosLength;\n";
file << "\n";
file << "   //start-condition INITIAL\n";
file << "   state = baseState = INITIAL;\n";
file << "\n";
file << "   //need memory for yyText?\n";
file << "   if( !yyText )\n";
file << "   {\n";
file << "       //init with SSLEX_YYTEXTSIZE bytes\n";
file << "       yyTextLen = SSLEX_YYTEXTSIZE;\n";
file << "       yyText = new( char[yyTextLen + 1] );\n";
file << "   }\n";
file << "\n";
file << "   //no token\n";
file << "   yyLeng = 0;\n";
file << "\n";
file << "   //SSLEX automatically counts line numbers\n";
file << "   yyLineno = 1;\n";
file << "\n";
file << "   //last accepting state\n";
file << "   lastAcceptingState = -1;\n";
file << "\n";
file << "   //do not concatenate token\n";
file << "   concatenate = false;\n";
file << "\n";
file << "   //no start conditions on stack\n";
file << "   scStackPos = 0;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "   //inizialize user defined variables\n";
file << "   init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLEXScanner::yyLex( SSLR_TYPE *attributeStr )\n";
file << "{\n";
file << "   //start scanning\n";
file << "   unsigned char   c;\n";
file << "\n";
file << "   //Basis-Position für das Lexem\n";
file << "   startPos = pos;\n";
file << "\n";
file << "   //setup some stuff\n";
file << "   yyDoBeforeRule();\n";
file << "\n";
file << "   while( pos <= end )\n";
file << "   {\n";
file << "       //Zeichen\n";
file << "       c = *pos;\n";

    //7-Bit-Scanner?
    if( argv_str->cclWidth == _7BIT )
    {
        //Fehler abfangen
file << "\n";
file << "       //when we use a 7 bit scanner\n";
file << "       if( c > 127 )\n";
file << "       {\n";
file << "           //we need a 8 bit scanner\n";
file << "           cerr << \"SSLEXScanner::yyLex: Line \" << yyLineno << \": You need a 8 bit scanner to match the character \" << c << \"!\\n\";\n";
file << "\n";
file << "           //skip character\n";
file << "           pos++;\n";
file << "           continue;\n";
file << "       }\n";
    }

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Makro
        file << "\n#ifdef SSLEX_DEBUG";

        //ja
        file << "\n";
        file << "       //print debugging information\n";
        file << "       mainDebug( c );\n";

        //Debug-Makro
        file << "#endif\n";
    }


file << "\n";
file << "       //schieben?\n";
file << "       if( ssLexTable[state][c] >= 0 )\n";
file << "       {\n";

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Makro
        file << "\n#ifdef SSLEX_DEBUG\n";

        //ja
        file << "           //print debugging information\n";
        file << "           shiftDebug( c );\n";

        //Debug-Makro
        file << "#endif\n\n";
    }

file << "           //akzeptieren?\n";
file << "           if( ssLexAccept[state] )\n";
file << "           {\n";
file << "               //ja, merken\n";
file << "               lastAcceptingState = state;\n";
file << "               lastAcceptingPos = pos;\n";
file << "           }\n";
file << "\n";

    //wurden Lookahead-Regeln benutzt?
    if( laUsed == true )
    {
        //ja
        file << "           //Lookahead-Zustand?\n";
        file << "           if( ssLexLA[state] )\n";
        file << "               //ja, merken\n";
        file << "               lastLAPos = pos;\n";
        file << "\n";
    }

file << "           //shift new state\n";
file << "           state = ssLexTable[state][c];\n";
file << "\n";
file << "           //nächstes Zeichen\n";
file << "           pos++;\n";
file << "       }\n";
file << "\n";
file << "       else\n";
file << "       {\n";
file << "           //akzeptieren\n";
file << "           do\n";
file << "           {\n";

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Makro
        file << "\n#ifdef SSLEX_DEBUG\n";

        //ja
        file << "               //print debugging information\n";
        file << "               acceptDebug();\n";

        //Debug-Makro
        file << "#endif\n\n";
    }

file << "               switch( ssLexAccept[state] )\n";
file << "               {\n";

    //nun alle Aktionen ausgeben
    for( i = 0; i < numberOfGroups; i++ )
    {
        //den ersten Eintrag finden
        if( finitNEA[i] && !fArr[i] )
        {
            //ja, Zeiger auf NEA_STR
            nea = finitNEA[i];

            //markieren
            fArr[i] = 1;

            //entsprechenden reg. Ausdruck ausgeben
            file << "\t\t\t\t\t//" << nea->regText << "\n";

            //ausgeben
            file << "\t\t\t\t\tcase " << i << ":\n";

            //alle Zustände mit gleicher Aktion ausgeben
            for( j = i + 1; j < numberOfGroups; j++ )
            {
                //gleich?
                if( finitNEA[j] == nea )
                {
                    //ja, markieren
                    fArr[j] = 1;

                    //case ausgeben
                    file << "\t\t\t\t\tcase " << j << ":\n";
                }
            }

            //in einem Block
            file << "\t\t\t\t\t{\n";

            //ist es ein Lookahead-NEA?
            if( nea->laState == true )
                //erst die Position zurücksetzen, bevor yyText geschrieben wird
                file << "\t\t\t\t\t\t//set position back\n\t\t\t\t\t\tpos = lastLAPos;\n\n";

            //yyText setzen
            file << "\t\t\t\t\t\t//setup yyText\n\t\t\t\t\t\tsetupyyText();\n\n";

            //alle Aktionen
            for( k = 0; k < nea->actionAnz; k++ )
                //ausgeben
                file << nea->action[k];

            //break
            file << "\t\t\t\t\t\tbreak;\n";

            //Block schließen
            file << "\t\t\t\t\t}\n\n";
        }
    }

file << "\n";
file << "                   default:\n";
file << "                   {\n";
file << "                       //unable to accept, backtracking or error\n";
file << "                       if( lastAcceptingState >= 0 )\n";
file << "                       {\n";
file << "                           //set back to last accept position\n";
file << "                           state = lastAcceptingState;\n";
file << "                           pos = lastAcceptingPos;\n";

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Makro ausgeben
        file << "\n#ifdef SSLEX_DEBUG";

        //Meldung ausgeben
        file << "\n";
        file << "                           //backtracking\n";
        file << "                           cout << \"Backtracking, set new state \" << state << \"\\n\";\n";

        //Debug-Makro ausgeben
        file << "#endif";
    }

file << "\n";
file << "                           //now accept with last accept position\n";
file << "                           continue;\n";
file << "                       }\n";
file << "\n";
file << "                       else\n";
file << "                       {\n";
file << "                           //error\n";
file << "                           error( *startPos );\n";
file << "\n";
file << "                           //remove character\n";
file << "                           pos++;\n";
file << "                       }\n";
file << "\n";
file << "                       break;\n";
file << "                   }\n";
file << "               }\n";
file << "\n";
file << "               //setup some stuff\n";
file << "               yyDoBeforeRule();\n";
file << "\n";
file << "               //exit while-loop\n";
file << "               break;\n";
file << "\n";
file << "           }while( 1 );\n";
file << "\n";
file << "           //Ende der Eingabe erreicht?\n";
file << "           if( pos == end )\n";
file << "               //ja\n";
file << "               break;\n";
file << "       }\n";
file << "   }\n";
file << "\n";
file << "   //call eof-rules\n";
file << "   return( endOfLine() );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyDoBeforeRule( void )\n";
file << "{\n";
file << "   //set some stuff before a new rule is scanned\n";
file << "\n";
file << "   //reset\n";
file << "   lastAcceptingState = -1;\n";
file << "\n";
file << "   //base position for lexem\n";
file << "   startPos = pos;\n";
file << "\n";
file << "   //are we at the beginning of a line?\n";
file << "   if( ( pos == basePos ) || ( pos[-1] == '\\n' ) )\n";
file << "       //setup state\n";
file << "       state = setupState( baseState );\n";
file << "\n";
file << "   else\n";
file << "       //base-State\n";
file << "       state = baseState;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::error( uchar c )\n";
file << "{\n";
file << "   //simple error handling routine\n";
file << "   ulong       i;\n";
file << "   char        *transChar[] = {\n";
file << "     \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "    \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "   \"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "      \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "      \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "      \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "      \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "      \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "      \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "      \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "      \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "      \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "      \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "      \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "      \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "      \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "      \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "      \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "      \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "      \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "      \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "      \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "      \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "      \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "   //get current sc\n";
file << "   for( i = 0; i < scSize; i++ )\n";
file << "   {\n";
file << "       //equal?\n";
file << "       if( scIndex[i] == baseState )\n";
file << "           break;\n";
file << "   }\n";
file << "\n";
file << "   //did already an error occur in that sc?\n";
file << "   if( !err[i][c] )\n";
file << "   {\n";
file << "       //No, print an error message\n";


    //Debug-Version?
    if( argv_str->debug == true )
        //ja, auch den Namen der SC ausgeben
        file << "       cerr << \"line \" << yyLineno << \": SC \" << scName[i] << \": Illegal character \" << transChar[c] << \"!\\n\";\n";

    else
        //nein, nur Fehlermeldung
        file << "       cerr << \"line \" << yyLineno << \": Illegal character \" << transChar[c] << \"!\\n\";\n";


file << "\n";
file << "       //mark to avoid ever lasting loops\n";
file << "       err[i][c]++;\n";
file << "   }\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setupYYLineno( char *beg, char *end )\n";
file << "{\n";
file << "   //setup yyLineno\n";
file << "   ulong   len = end - beg, i;\n";
file << "   int     nl = 0;\n";
file << "\n";
file << "   //count newlines\n";
file << "   for( i = 0; i < len; i++ )\n";
file << "   {\n";
file << "       //newline?\n";
file << "       if( beg[i] == '\\n' )\n";
file << "           nl++;\n";
file << "   }\n";
file << "\n";
file << "   //add to yyLineno\n";
file << "   yyLineno += nl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setupyyText( void )\n";
file << "{\n";
file << "   //insert text in yytext\n";
file << "   ulong   len;\n";
file << "   char    *tmp;\n";
file << "\n";
file << "   //reg. expression one-character?\n";
file << "   if( pos == startPos )\n";
file << "       //yes, move to next character\n";
file << "       pos++;\n";
file << "\n";
file << "   //get length of lexem\n";
file << "   yyLeng = pos - startPos;\n";
file << "\n";
file << "   //concatenate token? (yyMore)\n";
file << "   if( concatenate == true )\n";
file << "   {\n";
file << "       //yes, append\n";
file << "       len = strlen( yyText );\n";
file << "\n";
file << "       //enough space?\n";
file << "       if( yyTextLen <= ( yyLeng + len ) )\n";
file << "       {\n";
file << "           //extend memory\n";
file << "\n";
file << "           //fix yyTextLen\n";
file << "           yyTextLen = yyLeng + len;\n";
file << "\n";
file << "           //get enough memory für lexem\n";
file << "           tmp = new( char[yyTextLen + SSLEX_YYTEXTSIZE] );\n";
file << "\n";
file << "           //copy string\n";
file << "           strcpy( tmp, yyText );\n";
file << "\n";
file << "           //release memory\n";
file << "           if( yyText )\n";
file << "               delete[] ( yyText );\n";
file << "\n";
file << "           //copy adress\n";
file << "           yyText = tmp;\n";
file << "       }\n";
file << "\n";
file << "       //append\n";
file << "       strncat( yyText, startPos, yyLeng );\n";
file << "\n";
file << "       //zero\n";
file << "       yyText[yyLeng + len] = 0;\n";
file << "\n";
file << "       //set up yyLeng\n";
file << "       yyLeng += len;\n";
file << "\n";
file << "       //next time we want to set up yyText as usual\n";
file << "       concatenate = false;\n";
file << "   }\n";
file << "\n";
file << "   else\n";
file << "   {\n";
file << "       //enough space?\n";
file << "       if( yyTextLen <= yyLeng )\n";
file << "       {\n";
file << "           //extend memory\n";
file << "           if( yyText )\n";
file << "               delete[] ( yyText );\n";
file << "\n";
file << "           //fix yyTextLen\n";
file << "           yyTextLen = yyLeng;\n";
file << "\n";
file << "           //get enough memory für lexem\n";
file << "           yyText = new( char[yyTextLen + SSLEX_YYTEXTSIZE] );\n";
file << "       }\n";
file << "\n";
file << "       //insert\n";
file << "       strncpy( yyText, startPos, yyLeng );\n";
file << "\n";
file << "       //end with zere\n";
file << "       yyText[yyLeng] = 0;\n";
file << "   }\n";
file << "\n";
file << "   //setup yyLineno\n";
file << "   setupYYLineno( startPos, pos );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::setupState( ulong baseState )\n";
file << "{\n";
file << "   //setup state for begin-of-line-rules\n";
file << "   ulong   state = baseState, i;\n";
file << "\n";
file << "   //test if the current state is valid\n";
file << "   switch( baseState )\n";
file << "   {\n";


    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //Namen der SC ausgeben
        file << "\t\tcase " << sc->name << ":\n";
    }

    /*
        Wenn der Scanner auf ein Newline-Zeichen trifft, soll er den Startzustand nehmen, in dem auch die
        NEAen aktiviert sind, die ausschließlich am Zeilenanfang stehen dürfen.
        Dies ist der Zustand, der nach dem Startzustand der NEAen steht, die überall stehen dürfen.
        Ein schlichtes state++; genügt also.
        Hier wird trotzdem mit case gearbeitet, falls sich ein Zustand einschleicht, zu dem keine
        Startcondition gehört.
    */

    //den Basis-Zustand setzen
    file << "       {\n";
    file << "           //it is right the next state;\n";
    file << "           state++;\n";
    file << "           break;\n";
    file << "       }\n";


file << "\n";
file << "       default:\n";
file << "       {\n";
file << "           //ups, unknown start condition\n";
file << "           cerr << \"SSLEXScanner::setupState: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "           exit( 1 );\n";
file << "       }\n";
file << "   }\n";
file << "\n";

        //Debug-Version?
        if( argv_str->debug == true )
        {
            //Debug-Makro ausgeben
            file << "#ifdef SSLEX_DEBUG\n";

            //ja
            file << "   //get current sc\n";
            file << "   for( i = 0; i < scSize; i++ )\n";
            file << "   {\n";
            file << "       //equal?\n";
            file << "       if( scIndex[i] == baseState )\n";
            file << "           break;\n";
            file << "   }\n";
            file << "\n";
            file << "   //print debugging information\n";
            file << "   cout << \"switch to \" << scName[i] << \"\\n\";\n";

            //Debug-Makro ausgeben
            file << "#endif\n\n";
        }

file << "   //return state\n";
file << "   return( state );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setStartCondition( ulong state )\n";
file << "{\n";
file << "   //set a new start condition\n";
file << "   switch( state )\n";
file << "   {\n";


    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //hat die SC überhaupt NEAen?
        if( sc->neaArrCnt )
        {
            //Index des Start-Zustandes ausgeben
            file << "\t\tcase " << sc->name << ":\n";

            //den Basis-Zustand setzen
            file << "       {\n";
            file << "           //set new start condition\n";
            file << "           baseState = " << sc->name << ";\n";
            file << "           break;\n";
            file << "       }\n\n";
        }
    }

file << "\n";
file << "       default:\n";
file << "       {\n";
file << "           //unknown start condition\n";
file << "           cerr << \"SSLEXScanner::setStartCondition: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "\n";
file << "           //ignore call\n";
file << "           break;\n";
file << "       }\n";
file << "   }\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::getYYLeng( void )\n";
file << "{\n";
file << "   //return length of yyText\n";
file << "   return( yyLeng );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::getYYLineno( void )\n";
file << "{\n";
file << "   //return line number\n";
file << "   return( yyLineno );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char *SSLEXScanner::getYYText( void )\n";
file << "{\n";
file << "   //return yyText\n";
file << "   return( yyText );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char *SSLEXScanner::yyStrCpy( char *txt )\n";
file << "{\n";
file << "   //return txt in it's own memory\n";
file << "   ulong   len;\n";
file << "   char    *tmp;\n";
file << "\n";
file << "   //length of txt\n";
file << "   len = strlen( txt );\n";
file << "\n";
file << "   //get memory for txt\n";
file << "   tmp = new( char[len + 1] );\n";
file << "\n";
file << "   //copy\n";
file << "   strcpy( tmp, txt );\n";
file << "\n";
file << "   //zero\n";
file << "   tmp[len] = 0;\n";
file << "\n";
file << "   //return\n";
file << "   return( tmp );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyLess( int n )\n";
file << "{\n";
file << "   //returns all but the first n characters of yyText back to the input\n";
file << "\n";
file << "   //check\n";
file << "   if( ( n < 0 ) || ( n > yyLeng ) )\n";
file << "   {\n";
file << "       //bad n\n";
file << "       cerr << \"SSLEXScanner::yyLess: Line \" << yyLineno << \": Bad argument!\\n\";\n";
file << "\n";
file << "       //ignore\n";
file << "       return;\n";
file << "   }\n";
file << "\n";
file << "   //zero\n";
file << "   yyText[n] = 0;\n";
file << "\n";
file << "   //return to input spring\n";
file << "   pos -= ( yyLeng - n );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyPushState( ulong newState )\n";
file << "{\n";
file << "   /*\n";
file << "       Pushes the current start condition onto the top of the start condition stack\n";
file << "       and switches to newState as though you have used BEGIN( newState ).\n";
file << "   */\n";
file << "\n";
file << "   //enough memory\n";
file << "   if( scStackPos == scStackSize )\n";
file << "       //enlarge start condition stack\n";
file << "       enlargeSCStack();\n";
file << "\n";
file << "   //put on stack\n";
file << "   scStack[scStackPos++] = baseState;\n";
file << "\n";
file << "   //switch to new state\n";
file << "   BEGIN( newState );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyPopState( void )\n";
file << "{\n";
file << "   //pops the top of the start condition stack and switches to it\n";
file << "\n";
file << "   //underflow?\n";
file << "   if( scStackPos <= 0 )\n";
file << "       //error\n";
file << "       cerr << \"SSLEXScanner::yyPopState: Line \" << yyLineno << \": Start condition stack underflow!\\n\";\n";
file << "\n";
file << "   else\n";
file << "   {\n";
file << "       //get new SC state\n";
file << "       ulong   newState = scStack[--scStackPos];\n";
file << "\n";
file << "       //switch to it\n";
file << "       BEGIN( newState );\n";
file << "\n";
file << "       //set new state\n";
file << "       state = newState;\n";
file << "   }\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::yyTopState( void )\n";
file << "{\n";
file << "   //returns the top of the start condition stack without altering its contents\n";
file << "   return( scStack[scStackPos - 1] );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::enlargeSCStack( void )\n";
file << "{\n";
file << "   //enlarge start condition stack\n";
file << "   ulong   *tmp;\n";
file << "\n";
file << "   //get enough memory\n";
file << "   tmp = new( ulong[scStackSize + SCStackSize] );\n";
file << "\n";
file << "   //copy old content\n";
file << "   memcpy( tmp, scStack, sizeof( ulong ) * scStackSize );\n";
file << "\n";
file << "   //free old memory?\n";
file << "   if( scStack )\n";
file << "       //yes\n";
file << "       delete[] ( scStack );\n";
file << "\n";
file << "   //set new adress\n";
file << "   scStack = tmp;\n";
file << "\n";
file << "   //add size\n";
file << "   scStackSize += SCStackSize;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyUnput( unsigned char c )\n";
file << "{\n";
file << "   //puts the character c back to the input stream\n";
file << "   ulong   len = basePosLength++;\n";
file << "   int     diff = pos - basePos;\n";
file << "   char    *txt;\n";
file << "\n";
file << "   //get enough memory to push back character\n";
file << "   txt = new( char[len + 2] );\n";
file << "\n";
file << "   //copy to current position\n";
file << "   memcpy( txt, basePos, sizeof( char ) * diff );\n";
file << "\n";
file << "   //now insert c\n";
file << "   txt[diff] = c;\n";
file << "\n";
file << "   //append rest of the input\n";
file << "   memcpy( &txt[diff + 1], pos, sizeof( char ) * ( len - diff ) );\n";
file << "\n";
file << "   //zero\n";
file << "   txt[len + 1] = 0;\n";
file << "\n";
file << "   //free old memory\n";
file << "   delete[] ( basePos );\n";
file << "\n";
file << "   //set new position\n";
file << "   pos = startPos = &txt[diff];\n";
file << "\n";
file << "   //set new end\n";
file << "   end = &txt[len + 1];\n";
file << "\n";
file << "   //set new beginning\n";
file << "   basePos = txt;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyUnput( char *str )\n";
file << "{\n";
file << "   //puts the string str back to the input stream\n";
file << "   ulong   len = basePosLength, strLen = strlen( str );\n";
file << "   int     diff = pos - basePos;\n";
file << "   char    *txt;\n";
file << "\n";
file << "   //get enough memory to push back character\n";
file << "   txt = new( char[len + strLen + 1] );\n";
file << "\n";
file << "   //copy to current position\n";
file << "   memcpy( txt, basePos, sizeof( char ) * diff );\n";
file << "\n";
file << "   //now append str\n";
file << "   strcpy( &txt[diff], str );\n";
file << "\n";
file << "   //append rest of the input\n";
file << "   memcpy( &txt[strLen + diff], pos, sizeof( char ) * ( len - diff ) );\n";
file << "\n";
file << "   //zero\n";
file << "   txt[len + strLen] = 0;\n";
file << "\n";
file << "   //free old memory\n";
file << "   delete[] ( basePos );\n";
file << "\n";
file << "   //set new position\n";
file << "   pos = startPos = &txt[diff];\n";
file << "\n";
file << "   //set new end\n";
file << "   end = &txt[len + strLen + 1];\n";
file << "\n";
file << "   //set new beginning\n";
file << "   basePos = txt;\n";
file << "\n";
file << "   //correct basePosLength\n";
file << "   basePosLength += strLen;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char SSLEXScanner::yyInput( void )\n";
file << "{\n";
file << "   //return the next character to be scanned\n";
file << "   return( *pos++ );\n";
file << "}\n";
file << "\n";
file << "\n";

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Makro ausgeben
        file << "#ifdef SSLEX_DEBUG\n";

file << "void SSLEXScanner::mainDebug( unsigned char c )\n";
file << "{\n";
file << "   //print debugging information\n";
file << "   SSLEXDebugStr   *d = &debugStr[state];\n";
file << "   ulong           i;\n";
file << "   char            tmp[200], *transChar[] = {\n";
file << "     \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "    \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "   \"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "      \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "      \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "      \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "      \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "      \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "      \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "      \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "      \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "      \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "      \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "      \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "      \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "      \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "      \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "      \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "      \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "      \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "      \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "      \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "      \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "      \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "   //get current sc\n";
file << "   for( i = 0; i < scSize; i++ )\n";
file << "   {\n";
file << "       //equal?\n";
file << "       if( scIndex[i] == baseState )\n";
file << "           break;\n";
file << "   }\n";
file << "\n";
file << "   //current line\n";
file << "   cout << endl << \"current line: \" << getYYLineno() << endl;\n";
file << "\n";
file << "   //print the next 40 chars of the input\n";
file << "   txtFilter( pos, tmp, 40 );\n";
file << "   cout << \"current pos: \" << tmp << endl;\n";
file << "\n";
file << "   //current SC\n";
file << "   cout << \"current start condition: \" << scName[i] << endl;\n";
file << "\n";
file << "   //current state\n";
file << "   cout << \"current state: \" << state << endl;\n";
file << "\n";
file << "   //current character\n";
file << "   cout << \"current character: \" << transChar[c] << endl;\n";
file << "\n";
file << "   //print assocciated regular expression\n";
file << "   cout << \"associated regular expressions:\" << endl;\n";
file << "\n";
file << "   //all associated reg. expressions\n";
file << "   for( i = 0; i < d->indexCnt; i++ )\n";
file << "       //print\n";
file << "       cout << regText[d->index[i]] << endl;\n";
file << "\n";
file << "   //print ssLexTable\n";
file << "   cout << \"ssLexTable[\" << state << \"][\" << transChar[c] << \"] = \" << ssLexTable[state][c] << endl << endl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::shiftDebug( unsigned char c )\n";
file << "{\n";
file << "   //print debugging information\n";
file << "   SSLEXDebugStr   *d = &debugStr[state];\n";
file << "   ulong           i;\n";
file << "   char        *transChar[] = {\n";
file << "     \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "    \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "   \"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "      \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "      \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "      \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "      \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "      \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "      \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "      \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "      \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "      \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "      \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "      \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "      \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "      \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "      \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "      \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "      \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "      \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "      \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "      \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "      \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "      \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "   //shift?\n";
file << "   cout << \"shift ssLexTable[\" << state << \"][\" << transChar[c] << \"] = \" << ssLexTable[state][c] << \"\\n\";\n";
file << "\n";
file << "   //accepting state?\n";
file << "   if( ssLexAccept[state] )\n";
file << "       //yes\n";
file << "       cout << \"ssLexAccept[\" << state << \"] = \" << ssLexAccept[state] << \" -> \" << acceptRegText[ssLexAccept[state]] << \"\\n\";\n";
file << "\n";

        //Lookahead-Rules benutzt?
        if( laUsed == true )
        {
            //ja, ausgeben
            file << "   //lookahead state?\n";
            file << "   if( ssLexLA[state] )\n";
            file << "       //yes\n";
            file << "       cout << \"lookahead state\\n\";\n";
            file << "\n";
        }

file << "   //all associated reg. expressions\n";
file << "   for( i = 0; i < d->indexCnt; i++ )\n";
file << "       //print\n";
file << "       cout << regText[d->index[i]] << \"\\n\";\n";
file << "\n";
file << "   //newline\n";
file << "   cout << \"\\n\";\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::acceptDebug( void )\n";
file << "{\n";
file << "   //print debugging information\n";
file << "\n";
file << "   //accept?\n";
file << "   if( ssLexAccept[state] )\n";
file << "       //yes\n";
file << "       cout << \"accepting with \" << acceptRegText[ssLexAccept[state]] << \"\\n\";\n";
file << "\n";
file << "   else\n";
file << "       //backtrack\n";
file << "       cout << \"backtracking to state \" << lastAcceptingState << \"\\n\";\n";
file << "\n";
file << "   //newline\n";
file << "   cout << \"\\n\";\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::txtFilter( char *from, char *to, ulong cnt )\n";
file << "{\n";
file << "   //copy cnt bytes from from to to, but transform escape sequences into\n";
file << "   //readable text form\n";
file << "   ulong   i;\n";
file << "   char    c, tmp[10];\n";
file << "\n";
file << "   //init\n";
file << "   *to = 0;\n";
file << "\n";
file << "   //as long as there is another char\n";
file << "   for( i = 0; i < cnt; i++ )\n";
file << "   {\n";
file << "       //get char\n";
file << "       c = *from++;\n";
file << "\n";
file << "       //is it printable?\n";
file << "       if( !isprint( c ) )\n";
file << "       {\n";
file << "           //transform into readable\n";
file << "           switch( c )\n";
file << "           {\n";
file << "               //newline?\n";
file << "               case '\\n':\n";
file << "               {\n";
file << "                   //newline\n";
file << "                   strcat( to, \"\\\\n\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "\n";
file << "               //Backspace\n";
file << "               case '\\b':\n";
file << "               {\n";
file << "                   //Backspace\n";
file << "                   strcat( to, \"\\\\b\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "\n";
file << "               //Linefeed\n";
file << "               case '\\f':\n";
file << "               {\n";
file << "                   //Linefeed\n";
file << "                   strcat( to, \"\\\\f\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "\n";
file << "               //carriage return\n";
file << "               case '\\r':\n";
file << "               {\n";
file << "                   //carriage return\n";
file << "                   strcat( to, \"\\\\r\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "\n";
file << "               //Tabulator\n";
file << "               case '\\t':\n";
file << "               {\n";
file << "                   //Tabulator\n";
file << "                   strcat( to, \"\\\\t\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "\n";
file << "#if __STDC__\n";
file << "               //bing\n";
file << "               case '\\a':\n";
file << "               {\n";
file << "                   //bing\n";
file << "                   strcat( to, \"\\\\a\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "\n";
file << "               //vertical tab\n";
file << "               case '\\v':\n";
file << "               {\n";
file << "                   //vertical tab\n";
file << "                   strcat( to, \"\\\\v\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "#else\n";
file << "               //bing\n";
file << "               case '\\a':\n";
file << "               {\n";
file << "                   //bing\n";
file << "                   strcat( to, \"\\\\007\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "\n";
file << "               //vertical tab\n";
file << "               case '\\v':\n";
file << "               {\n";
file << "                   //vertical tab\n";
file << "                   strcat( to, \"\\\\013\" );\n";
file << "                   break;\n";
file << "               }\n";
file << "#endif\n";
file << "\n";
file << "               default:\n";
file << "               {\n";
file << "                   //neither of the above\n";
file << "                   sprintf( tmp, \"%x\", c );\n";
file << "\n";
file << "                   //append\n";
file << "                   strcat( to, tmp );\n";
file << "               }\n";
file << "           }\n";
file << "       }\n";
file << "\n";
file << "       else\n";
file << "       {\n";
file << "           //yes, printable\n";
file << "           sprintf( tmp, \"%c\", c );\n";
file << "\n";
file << "           //append\n";
file << "           strcat( to, tmp );\n";
file << "       }\n";
file << "   }\n";
file << "}\n";

        //Debug-Makro ausgeben
        file << "#endif\n\n";
    }

    //Speicher freigeben
    delete[] ( finitNEA );
    delete[] ( laNEA );
    delete[] ( fArr );
}


void SSLRParser::outputIncl( ofstream &file )
{
    //Include-Anweisungen in das cpp-File ausgeben
    char    *incl = SSLR_scanner->getInclude(), *beg;
    ulong   len;

    //gibt es include-Anweisungen?
    if( incl )
    {
        //am Anfang das \{ löschen
        while( !( ( incl[0] == '\\' ) && ( incl[1] == '{' ) ) )
            incl++;

        //löschen
        incl = &incl[2];

        //die Länge der Include-Anweisungen
        len = strlen( incl );

        //merken
        beg = &incl[len - 2];

        //am Ende das \{ löschen
        while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
            beg--;

        //das Ende hat \}, abschneiden
        *beg = 0;

        //ausgeben
        file << incl;
    }
}


void SSLRParser::outputExt( ofstream &file )
{
    //eigene Erweiterungen in das cpp-File ausgeben
    char    *ext = SSLR_scanner->getExtension(), *beg;
    ulong   len;

    //gibt es Extensionen?
    if( ext )
    {
        //am Anfang das \{ löschen
        while( !( ( ext[0] == '\\' ) && ( ext[1] == '{' ) ) )
            ext++;

        //löschen
        ext = &ext[2];

        //die Länge der eigenen Erweiterungen
        len = strlen( ext );

        //merken
        beg = &ext[len - 2];

        //am Ende das \{ löschen
        while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
            beg--;

        //das Ende hat \}, abschneiden
        *beg = 0;

        //ausgeben
        file << ext;
    }
}


void SSLRParser::outputCPPDTran( ofstream &file )
{
    //die Übergangstabelle ausgeben, ohne Minimierung der DEA-Zustandsmenge
    DEA_STATES  *dea;
    SC_STR      *sc;
    ulong       state = 0, i;
    char        widthPuffer[512];
    int         j, k, l, width;

    //die Breite eines Zustandes bestimmen
    sprintf( widthPuffer, "%ld", DEAStatesCnt );
    width = strlen( widthPuffer );

    //Mindestbreite: 3
    if( width < 3 )
        width = 3;

    //Header ausgeben
    file << "\n//Transition-Table\n";
    file << "long SSLEXScanner::ssLexTable[SSLEX_STATE][CCLWIDTH] = \n{\n";

    //alle Zeichen ausgeben
    file << "/*\n";

    //alle Zeichen ausgeben
    for( i = j = k = 0; i < cclWidth; i++, j++, k++ )
    {
        //alle 32 Zeichen einen Zeilenwechsel
        if( k == 32 )
        {
            //ja
            file << "\n";
            k = 0;
        }

        //Breite setzen
        file.width( width );

        //Zeichen schreiben
        outputChar( i, widthPuffer );

        //Zeichen ist druckbar
        file << widthPuffer;

        //letztes Element?
        if( j < 127 )
            //Komma ausgeben
            file << ",";
    }

    //abschließen
    file << "\n*/\n";

    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger
        sc = &scStr[i];

        //hat die SC eine Übergangstabelle für NEAen, die überall stehen dürfen?
        if( sc->DTran1 )
        {
            //ja, ausgeben
            file << "\n//Startcondition: " << sc->name << "\n";

            //alle Zustände dieses DEA dieser SC für NEAen, die überall stehen dürfen
            for( l = 0; l < sc->DTran1Cnt; l++ )
            {
                //ausgeben
                file << "/* " << state++ << " */\n{\n";

                //alle Zeichen
                for( j = k = 0; j < cclWidth; j++, k++ )
                {
                    //alle 32 Zeichen einen Zeilenwechsel
                    if( k == 32 )
                    {
                        //ja
                        file << "\n";
                        k = 0;
                    }

                    //ausgeben
                    file.width( width );
                    file << sc->DTran1[l]->to[j];

                    //letztes Element?
                    if( j < 127 )
                        //Komma ausgeben
                        file << ",";
                }

                //letztes Element?
                if( state < ( DEAStatesCnt - 1 ) )
                    //Komma ausgeben
                    file << "\n},\n";

                else
                    //ohne Komma ausgeben
                    file << "\n}\n";

                //Zustände zählen
//              state++;
            }
        }

        //hat die SC eine Übergangstabelle für NEAen, die nur am Zeilenanfang stehen dürfen?
        if( sc->DTran2 )
        {
            //alle Zustände dieses DEA dieser SC für NEAen, die nur am Zeilenanfang stehen dürfen
            for( l = 0; l < sc->DTran2Cnt; l++ )
            {
                //Start-Zustand der NEAen ausgeben, die nur am Zeilenanfang stehen dürfen?
                if( state == sc->begLineDEAIndex )
                    //ja
                    file << "/* " << "BOL-Startcondition: " << sc->name << " /*\n";

                //ausgeben
                file << "/* " << state++ << " */\n{\n";

                //alle Zeichen
                for( j = k = 0; j < cclWidth; j++, k++ )
                {
                    //alle 32 Zeichen einen Zeilenwechsel
                    if( k == 32 )
                    {
                        //ja
                        file << "\n";
                        k = 0;
                    }

                    //ausgeben
                    file.width( width );
                    file << sc->DTran2[l]->to[j];

                    //letztes Element?
                    if( j < 127 )
                        //Komma ausgeben
                        file << ",";
                }

                //letztes Element?
                if( state < ( DEAStatesCnt - 1 ) )
                    //Komma ausgeben
                    file << "\n},\n";

                else
                    //ohne Komma ausgeben
                    file << "\n}\n";

                //Zustände zählen
//              state++;
            }
        }
    }

    //abschließen
    file << "\n};\n";





    //nun das Array für die Accept-Zustände erzeugen
    file << "\n//Accept-Array\n";
    file << "ulong SSLEXScanner::ssLexAccept[SSLEX_STATE] = \n{\n";

    //alle DEA-Zustände
    for( i = 0; i < DEAStatesCnt; i++ )
    {
        //Zustand ausgeben
        file << "/* " << i << " */\n";

        //Zeiger auf Zustand
        dea = DEAStates[i];

        //Finit-Zustand?
        if( ( dea->finit == true ) && ( dea->finitNEA ) )
        {
            //ja, reg. Text des zugehörigen NEA ausgeben
            file << "\n/* Line " << dea->finitNEA->line << ": " << dea->finitNEA->regText << " */\n";
            file << dea->index;
        }

        else
            //nein
            file << "0";

        //letzter Zustand?
        if( i < ( DEAStatesCnt - 1 ) )
            //nein, Komma
            file << ",\n";
    }

    //abschliessen
    file << "\n};\n\n";




    //nun das Array für die Lookahead-Zustände erzeugen
    file << "\n//Lookahead-Array\n";
    file << "ulong SSLEXScanner::ssLexLA[SSLEX_STATE] = \n{\n";

    //alle DEA-Zustände
    for( i = 0; i < DEAStatesCnt; i++ )
    {
        //Zustand ausgeben
        file << "/* " << i << " */\n";

        //Zeiger auf Zustand
        dea = DEAStates[i];

        //Finit-Zustand?
        if( ( dea->la == true ) && ( dea->laNEA ) )
        {
            //ja, reg. Text des zugehörigen NEA ausgeben
            file << "\n/* Line " << dea->laNEA->line << ": " << dea->laNEA->regText << " */\n";
            file << dea->index;
        }

        else
            //nein
            file << "0";

        //letzter Zustand?
        if( i < ( DEAStatesCnt - 1 ) )
            //nein, Komma
            file << ",\n";
    }

    //abschliessen
    file << "\n};\n\n";
}



void SSLRParser::outputHHeader( ofstream &file )
{
    //das Header-File ausgeben
    SC_STR  *sc;
    ulong   i, cnt;
    char    **userDefHeader;
    int     userDefHeaderCnt, j;


file << "/***************************************************************************\n";
file << "                          sslexscanner.h  -  description\n";
file << "                             -------------------\n";
file << "    begin                : Mon Feb 24 2003\n";
file << "    copyright            : (C) 2003 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLEXSCANNER_H\n";
file << "#define SSLEXSCANNER_H\n";
file << "\n";
file << "\n";

file << "/**\n";
file << "\t@author SSLEX V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Version
        file << "/****************************\n";
        file << "* This is the debug-version *\n";
        file << "****************************/\n\n\n";

        //Debug-Makro
        file << "//define debug-macro\n";
        file << "#define SSLEX_DEBUG\n";
        file << "//#undef SSLEX_DEBUG\n\n\n";
    }

    else
    {
        //ist nicht die Debug-Version
        file << "/********************************\n";
        file << "* This is the non-debug-version *\n";
        file << "********************************/\n\n\n";
    }

file << "\n";
file << "using namespace std;\n";
file << "\n";
file << "#include <stdio.h>\n";
file << "#include <stdlib.h>\n";
file << "#include <iostream>\n";
file << "#include <string.h>\n";
file << "#include \"sslrtermdef.h\"\n";
file << "\n";
file << "\n";
file << "//type definition\n";
file << "typedef unsigned long  ulong;\n";
file << "typedef unsigned char  uchar;\n";
file << "\n";
file << "\n";


    //Header ausgeben
    file << "\n//Start-States of the different start conditions\n";

    //alle SC
    for( i = cnt = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //Index des Start-Zustandes ausgeben
        file << "#define " << sc->name << "\t" << sc->firstStart << "\n";

        //merken
        cnt++;
    }

    //abschliessen
    file << "\n\n";

    //Anzahl der Zustände
    file << "//Number of DEA-States\n#define\tSSLEX_STATE\t" << numberOfGroups << "\n\n";

    //7- oder 8-Bit-Scanner
    file << "//7- or 8-bit scanner\n#define\tCCLWIDTH\t" << cclWidth << "\n\n";

    //erlaubt Zugriff auf die Start-Condition
    file << "//current start condition\n";
    file << "#define\tYY_START\tbaseState\n";
    file << "#define\tYYSTATE\t\tYY_START\n\n";

    //Anzahl der Start-Conditionen
    file << "\n";
    file << "//number of start conditions\n";
    file << "#define scSize\t" << ( 2 * cnt ) << "\n";
    file << "\n";

    /*
        Der Benutzer kann eigene Variablen im erzeugten Header-File deklarieren, die u.U. auch
        initialisiert werden müssen.
        Dazu definiert man im %include-Teil das Makro SSLEX_INIT. Es wird dann eine Routine
        void init( void ); aufgerufen, die der Benutzer im %extension-Teil definieren muss.
        Defaultmäßig wird dies deaktiviert.
    */
    file << "//do not inizialize user defined variables per default\n";
    file << "#undef SSLEX_INIT\n";
    file << "\n\n";

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Makro ausgeben
        file << "//in case of the debug version\n";
        file << "#ifdef SSLEX_DEBUG\n";
        file << "//size of array with regular expressions\n";
        file << "#define regTextSize\t" << debugStrPos << "\n";
        file << "#endif\n";
    }

file << "\n";
file << "class SSLEXScanner\n";
file << "{\n";
file << "public:\n";
file << "\n";

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Struktur für die Ausgabe der Debug-Infors ausgeben
        file << "//in case of the debug version\n";
        file << "#ifdef SSLEX_DEBUG\n";
        file << "\t//Structure with debugging information\n";
        file << "\ttypedef struct\n";
        file << "\t{\n";
        file << "\t\t//DEA-State\n";
        file << "\t\tulong  state;\n";
        file << "\n";
        file << "\t\t//assocciated regular expressions in this state\n";
        file << "\t\tulong  *index;\n";
        file << "\n";
        file << "\t\t//number of assocciated regular expressions\n";
        file << "\t\tulong  indexCnt;\n";
        file << "\n";
        file << "\t}SSLEXDebugStr;\n";
        file << "#endif\n\n";
    }

file << "   //initialize SSLEX\n";
file << "   SSLEXScanner( char *, ulong );\n";
file << "   ~SSLEXScanner();\n";
file << "\n";
file << "   //Methods for public access\n";
file << "\n";
file << "   //start scanning\n";
file << "   int yyLex( SSLR_TYPE *attributeStr = 0L );\n";
file << "\n";
file << "   //return line number\n";
file << "   ulong getYYLineno( void );\n";
file << "\n";
file << "   //return length of yyText\n";
file << "   ulong getYYLeng( void );\n";
file << "\n";
file << "   //return yyText\n";
file << "   char *getYYText( void );\n";
file << "\n";
file << "   //reset the whole scanner\n";
file << "   void reset( void );\n";
file << "\n";
file << "   //reset the whole scanner and give him new input\n";
file << "   void reset( char *, ulong );\n";
file << "\n";
file << "\n";
file << "private:\n";
file << "\n";
file << "   //Base state of SSLEX, i.e. beginning state of a start condition\n";
file << "   ulong                   baseState;\n";
file << "\n";
file << "   //current state\n";
file << "   ulong                   state;\n";
file << "\n";
file << "   //Begin of scanning text\n";
file << "   char                    *basePos;\n";
file << "\n";
file << "   //length of scanning text\n";
file << "   ulong                   basePosLength;\n";
file << "\n";
file << "   //current scanning position\n";
file << "   char                    *pos;\n";
file << "\n";
file << "   //end of scanning text\n";
file << "   char                    *end;\n";
file << "\n";
file << "   //Position of the beginning of a lexem\n";
file << "   char                    *startPos;\n";
file << " \n";
file << "   //last accepting position in scanning text\n";
file << "   char                    *lastAcceptingPos;\n";
file << "\n";
file << "   //last accepting state in scanning text\n";
file << "   long                    lastAcceptingState;\n";
file << "\n";
file << "   //Table for error handling\n";
file << "   static int              err[scSize][CCLWIDTH];\n";
file << "\n";
file << "   //transition table\n";
file << "   static long             ssLexTable[SSLEX_STATE][CCLWIDTH];\n";
file << "\n";
file << "   //Accept-Array\n";
file << "   static ulong            ssLexAccept[SSLEX_STATE];\n";
file << "\n";

    //gab es Lookahead-NEAen?
    if( laUsed == true )
    {
        //ja, ausgeben
file << "   //Position of last occurence of a lookahead state\n";
file << "   char                    *lastLAPos;\n";
file << "\n";
file << "   //Lookahead-Array\n";
file << "   static ulong            ssLexLA[SSLEX_STATE];\n";
file << "\n";
    }

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Makro ausgeben
        file << "#ifdef SSLEX_DEBUG\n";

        //ja
        file << "   //structure with debugging info\n";
        file << "   static SSLEXDebugStr    debugStr[SSLEX_STATE];\n";
        file << "\n";
        file << "   //array with the regular expressions in text form\n";
        file << "   static char             *regText[regTextSize];\n";
        file << "\n";
        file << "   //Array with indices in regText\n";
        file << "   static ulong            *regTextIndex[SSLEX_STATE];\n";
        file << "\n";

        //die Indices in regText ausgeben
        file << "   //Array with indices in regText\n";

        //alle Gruppen
        for( i = 0; i < numberOfGroups; i++ )
        {
            //die Indices in regText ausgeben
            file << "   static ulong    regTextIndex" << i << "[];";
            file << "\n";
        }

        file << "\n";
        file << "   //Array with regular expression at accepting\n";
        file << "   static char             *acceptRegText[SSLEX_STATE];\n";

        //Debug-Makro
        file << "#endif\n\n";
    }


file << "   //name of the start conditions\n";
file << "   static char             *scName[SSLEX_STATE];\n";
file << "\n";
file << "   //state of start conditions\n";
file << "   static ulong            scIndex[];\n";
file << "\n";
file << "   //memory for yyText\n";
file << "   ulong                   yyTextLen;\n";
file << "\n";
file << "   //yyText: holds the accepted lexem\n";
file << "   char                    *yyText;\n";
file << "\n";
file << "   //length of yyText\n";
file << "   ulong                   yyLeng;\n";
file << "\n";
file << "   //SSLEX automatically counts line numbers\n";
file << "   ulong                   yyLineno;\n";
file << "\n";
file << "   //concatenate token\n";
file << "   bool                    concatenate;\n";
file << "\n";
file << "   //size of start condition stack\n";
file << "   ulong                   scStackSize;\n";
file << "\n";
file << "   //numer of start xonditions on stack\n";
file << "   long                    scStackPos;\n";
file << "\n";
file << "   //start condition stack\n";
file << "   ulong                   *scStack;\n";
file << "\n";
file << "\n";

    //benutzerdefinierte Daten holen
    userDefHeader = SSLR_scanner->getUserDefHeader( userDefHeaderCnt );

    //alle Zeilen
    for( j = 0; j < userDefHeaderCnt; j++ )
        //ausgeben
        file << userDefHeader[j];


file << "\n";
file << "\n";
file << "private:\n";
file << "\n";
file << "   //insert text in yytext\n";
file << "   void setupyyText( void );\n";
file << "\n";
file << "   //setup yyLineno\n";
file << "   void setupYYLineno( char *, char * );\n";
file << "\n";
file << "   //setup state for begin-of-line-rules\n";
file << "   ulong setupState( ulong );\n";
file << "\n";
file << "   //set a new start condition\n";
file << "   void setStartCondition( ulong );\n";
file << "\n";
file << "   //return txt in it's own memory\n";
file << "   char *yyStrCpy( char *txt );\n";
file << "\n";
file << "   //returns all but the first n characters of yyText back to the input\n";
file << "   void yyLess( int );\n";
file << "\n";
file << "   //enlarge start condition stack\n";
file << "   void enlargeSCStack( void );\n";
file << "\n";
file << "   /*\n";
file << "       Pushes the current start condition onto the top of the start condition stack\n";
file << "       and switches to newState as though you have used BEGIN( newState ).\n";
file << "   */\n";
file << "   void yyPushState( ulong );\n";
file << "\n";
file << "   //pops the top of the start condition stack and switches to it\n";
file << "   void yyPopState( void );\n";
file << "\n";
file << "   //returns the top of the start condition stack without altering its contents\n";
file << "   ulong yyTopState( void );\n";
file << "\n";
file << "   //puts the character c back to the input stream\n";
file << "   void yyUnput( unsigned char );\n";
file << "   void yyUnput( char * );\n";
file << "\n";
file << "   //return the next character to be scanned\n";
file << "   char yyInput( void );\n";
file << "\n";
file << "   //call eof-rules\n";
file << "   int endOfLine( void );\n";
file << "\n";
file << "   //handle simple errors\n";
file << "   void error( uchar c );\n";
file << "\n";
file << "   //set some stuff before a new rule is scanned\n";
file << "   void yyDoBeforeRule( void );\n";


    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Makro ausgeben
        file << "\n#ifdef SSLEX_DEBUG";

        //ja
        file << "\n";
        file << "   //print debugging information\n";
        file << "   void mainDebug( unsigned char );\n";
        file << "\n";
        file << "   //print debugging information\n";
        file << "   void shiftDebug( unsigned char );\n";
        file << "\n";
        file << "   //print debugging information\n";
        file << "   void acceptDebug( void );\n";
        file << "\n";
        file << "   //copy cnt bytes from from to to, but transform escape sequences into\n";
        file << "   //readable text form\n";
        file << "   void txtFilter( char *, char *, ulong );\n";

        //Debug-Makro
        file << "#endif\n";
    }


file << "};\n";
file << "\n";
file << "#endif\n";
}


void SSLRParser::generateFiles( void )
{
    //Hier werden die Klassenfiles des Scanners erzeugt.
    ofstream    cppFile( "sslexscanner.cpp" );
    ofstream    hFile( "sslexscanner.h" );

    //Meldung?
    if( argv_str->verbose == true )
        //Meldung
        cout << "sslex: Generating output files...\n";

    //den Header für das CPP-File ausgeben
    outputCPPHeader( cppFile );

    //etwaige Include-Anweisungen einfügen
    outputIncl( cppFile );

    //die Übergangstabelle ausgeben
#ifdef MINDEA
    outputCPPMinDEA( cppFile );
#else
    outputCPPDTran( cppFile );
#endif

    //Debug-Informationen ausgeben?
    if( argv_str->debug == true )
        //die Debug-Strukturen ausgeben
        outputCPPDebug( cppFile );

    //Aktionen ausgeben
    outputAction( cppFile );

    //<<EOF>>-NEAen ausgeben
    outputEOF( cppFile );

    //etwaige eigene Erweiterungen einfügen
    outputExt( cppFile );

    //das Header-File ausgeben
    outputHHeader( hFile );
}


void SSLRParser::outputChar( uchar c, char *dest )
{
    //gibt ein Zeichen aus, insbesondere die nicht-druckbaren in lesbarer Form
    char    *transChar[] = {
      "\\0",   "\\1",   "\\2",   "\\3",   "\\4",   "\\5",   "\\6",  "\\a",  "\\b",  "\\t",  "\\n",  "\\v",
     "\\f",  "\\r", "0x0e", "0x0f", "0x10", "0x11", "0x12", "0x13", "0x14", "0x15", "0x16", "0x17",
    "0x18", "0x19", "0x1a", "0x1b", "0x1c", "0x1d", "0x1e", "0x1f",    " ",    "!",   "\"",    "#",
       "$",    "%",    "&",    "'",    "(",    ")",    "*",    "+",    ",",    "-",    ".",    "/",
       "0",    "1",    "2",    "3",    "4",    "5",    "6",    "7",    "8",    "9",    ":",    ";",
       "<",    "=",    ">",    "?",    "@",    "A",    "B",    "C",    "D",    "E",    "F",    "G",
       "H",    "I",    "J",    "K",    "L",    "M",    "N",    "O",    "P",    "Q",    "R",    "S",
       "T",    "U",    "V",    "W",    "X",    "Y",    "Z",    "[",   "\\",    "]",    "^",    "_",
       "`",    "a",    "b",    "c",    "d",    "e",    "f",    "g",    "h",    "i",    "j",    "k",
       "l",    "m",    "n",    "o",    "p",    "q",    "r",    "s",    "t",    "u",    "v",    "w",
       "x",    "y",    "z",    "{",    "|",    "}",    "~",   "DEL",
       "128",  "129",  "130",  "131",  "132",  "133",  "134",  "135",  "136",  "137",   "138", "139",
       "140",  "141",  "142",  "143",  "144",  "145",  "146",  "147",  "148",  "149",   "150", "151",
       "152",  "153",  "154",  "155",  "156",  "157",  "158",  "159",  "160",  "161",   "162", "163",
       "164",  "165",  "166",  "167",  "168",  "169",  "170",  "171",  "172",  "173",   "174", "175",
       "176",  "177",  "178",  "179",  "180",  "181",  "182",  "183",  "184",  "185",   "186", "187",
       "188",  "189",  "190",  "191",  "192",  "193",  "194",  "195",  "196",  "197",   "198", "199",
       "200",  "201",  "202",  "203",  "204",  "205",  "206",  "207",  "208",  "209",   "210", "211",
       "212",  "213",  "214",  "215",  "216",  "217",  "218",  "219",  "220",  "221",   "222", "223",
       "224",  "225",  "226",  "227",  "228",  "229",  "230",  "231",  "232",  "233",   "234", "235",
       "236",  "237",  "238",  "239",  "240",  "241",  "242",  "243",  "244",  "245",   "246", "247",
       "248",  "249",  "250",  "251",  "252",  "253",  "254" };

    //Zeichen eintragen
    strcpy( dest, transChar[c] );
}


SSLRParser::GROUP_STR *SSLRParser::createGROUP( void )
{
    //eine neue Gruppe für die Zustandsminimierung erzeugen
    GROUP_STR   *tmp;

    //Speicher anfordern
    tmp = new( GROUP_STR );

    //initialisieren
    memset( tmp, 0, sizeof( GROUP_STR ) );

    //beinhaltet keinen Finit-Zustand
    tmp->finit = false;

    //beinhaltet keinen Lookahead-Zustand
    tmp->la = false;

    //Gruppe ist valid
    tmp->valid = true;

    //kein Start-Zustand
    tmp->startGroup = false;

    //zurückliefern
    return( tmp );
}


void SSLRParser::deleteGROUP( GROUP_STR *groupStr )
{
    //eine Gruppe löschen

    //sind DEA-Zustände eingetragen?
    if( groupStr->DEAIndex )
        //ja, Speicher freigeben
        delete[] ( groupStr->DEAIndex );

    //Speicher freigeben
    delete( groupStr );
}


void SSLRParser::insertGROUP( GROUP_STR *groupStr, ulong index )
{
    //einen DEA-Index zu einer Gruppe hinzufügen
    DEA_STATES  *dea = DEAStates[index];
    ulong       *tmp;
    ulong       i;

    /*
        ACHTUNG: In insertGROUP wird in die DEA-Struktur des einzutragenden
        DEA-Zustand der Gruppen-Index eingetragen. So kann man leicht feststellen,
        in welcher Gruppe ein DEA-Zustand ist!
    */


    //ist dieser Zustand bereits in der Gruppe?
    for( i = 0; i < groupStr->DEAIndexCnt; i++ )
    {
        //Zustand?
        if( groupStr->DEAIndex[i] == index )
            //ja
            break;
    }

    //gleich?
    if( i == groupStr->DEAIndexCnt )
    {
        //genug Speicher
        tmp = new( ulong[groupStr->DEAIndexCnt + 1] );

        //umkopieren
        memcpy( tmp, groupStr->DEAIndex, sizeof( ulong ) * groupStr->DEAIndexCnt );

        //alten Speicher löschen
        if( groupStr->DEAIndex )
            delete[] ( groupStr->DEAIndex );

        //eintragen
        groupStr->DEAIndex = tmp;

        //an letzter Stelle eintragen
        groupStr->DEAIndex[groupStr->DEAIndexCnt] = index;

        //Gruppen-Index eintragen
        dea->groupIndex = groupStr->index;

        //ist es ein Finit-Zustand?
        if( dea->finit == true )
        {
            //setzen
            groupStr->finit = true;

            //NEA in Gruppe eintragen
            groupStr->finitNEA = dea->finitNEA;
        }

        //ist es ein Lookahead-Zustand?
        if( dea->la == true )
        {
            //setzen
            groupStr->la = true;

            //DEA-Index merken
            groupStr->laIndex = index;
        }

        //ein Zustand weiter
        groupStr->DEAIndexCnt++;
    }
}

/*
void SSLRParser::moveGROUP( GROUP_STR *from, GROUP_STR *to )
{
    //eine Gruppe kopieren
    ulong   i;

    //alle Zustände
    for( i = 0; i < from->DEAIndexCnt; i++ )
        //eintragen
        insertGROUP( to, from->DEAIndex[i] );

    //Eigenschaften übertragen
    to->finit = from->finit;
    to->finitNEA = from->finitNEA;
    to->la = from->la;
    to->startGroup = from->startGroup;
    to->valid = from->valid;

    //eine invalide Gruppe darf hier nicht bearbeitet werden
    assert( from->valid == true );
}
*/

void SSLRParser::fixGROUP( GROUP_STR *from, GROUP_STR *to )
{
    //die speziellen Eigenschaften einer Gruppe übernehmen
    to->finit = from->finit;
    to->finitNEA = from->finitNEA;
    to->la = from->la;
    to->valid = from->valid;

    //eine invalide Gruppe darf hier nicht bearbeitet werden
    assert( from->valid == true );

    /*
        WICHTIG: Da nur eine Gruppe den Start-Zustand haben kann, darf diese Eigenschaft NICHT
        vererbt werden!
    */
}


void SSLRParser::removeGROUP( GROUP_STR *groupStr, ulong index )
{
    //einen DEA-Index aus einer Gruppe löschen
    ulong   i;

    //alle DEA-Zustände
    for( i = 0; i < groupStr->DEAIndexCnt; i++ )
    {
        //vergleichen
        if( groupStr->DEAIndex[i] == index )
        {
            //ja, löschen
            memmove( &groupStr->DEAIndex[i], &groupStr->DEAIndex[i+1], sizeof( ulong ) * ( groupStr->DEAIndexCnt - i - 1 ) );

            //Anzahl der Zustände korrigieren
            groupStr->DEAIndexCnt--;

            //Ende
            break;
        }
    }
}


void SSLRParser::outputGROUP( GROUP_STR *groupStr )
{
    //eine Gruppe ausgeben
    ulong   j, l;
    char    widthPuffer[10];
    int     width;

    //Breite bestimmen
    sprintf( widthPuffer, "%ld", DEAStatesCnt );
    width = strlen( widthPuffer );

    //Gruppen-Index ausgeben
    cout << "\nGruppe: " << groupStr->index << ", ";

    //Gruppe mit Startzustand?
    if( groupStr->startGroup == true )
        //ja
        cout << "Startgruppe, ";

    //eine Gruppe mit akzeptierenden Zuständen?
    if( groupStr->finit == true )
        //ja
        cout << "akzeptierend, " << groupStr->finitNEA->regText << "\n";

    else
        //nein
        cout << "nicht-akzeptierend\n";

    //Meldung
    cout << "Zustände dieser Gruppe:\n";

    //alle Zustände dieser Gruppe
    for( l = j = 0; l < groupStr->DEAIndexCnt; l++, j++ )
    {
        //neue Zeile?
        if( j == 20 )
        {
            //ja
            cout << "\n";
            j = 0;
        }

        //Breite setzen
        cout.width( width + 1 );
        cout << groupStr->DEAIndex[l];
    }

    //Platz lassen
    cout << "\n\n";
}


void SSLRParser::checkGROUP( SC_STR *sc, GROUP_STR **grpStr, ulong grpStrCnt )
{
    //tote Zustände finden
    DEA_STATES  *dea, *destDEA;
    GROUP_STR   *grp, *destGrp;
    DTRAN       *dt;
    ulong       *transTable, i, max;
    ulong       *stack, stackPos = 0, *marked, index;
    ulong       grpIndex, destGrpIndex, repState, destState;
    ulong       base1State, end1State, base2State, end2State;
    int         k, l, dead, invalid, changed;

    //Anfangs- und Endzustand der NEAen, die überall stehen dürfen
    base1State = sc->DEAIndex;
    end1State = base1State + sc->DTran1Cnt - 1;

    //Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen dürfen
    base2State = sc->begLineDEAIndex;
    end2State = base2State + sc->DTran2Cnt - 1;


    //Zeiger der letzten Gruppe
    grp = grpStr[grpStrCnt - 1];

    //maximalen Index merken
    max = grp->index + 1;

    //Speicher für die Umwandlung der Gruppen-Indeces
    transTable = new( ulong[max] );

    //initialisieren
    memset( transTable, max, sizeof( ulong ) * max );

    //alle Gruppen
    for( i = 0; i < grpStrCnt; i++ )
    {
        //Zeiger auf Gruppe
        grp = grpStr[i];

        //Gruppen-Index eintragen
        transTable[grp->index] = i;
    }


    //Speicher für den Zustands-Stack
    stack = new( ulong[DEAStatesCnt] );

    //Speicher zum markieren der Grupppen
    marked = new( ulong[max] );

    //initialisieren
    memset( marked, 0, sizeof( ulong ) * max );

    do
    {
        //Repräsentativen Zustand aus der Gruppe mit dem Startzustand pushen.
        stack[stackPos++] = base1State;
        stack[stackPos++] = base2State;

        //zurücksetzen
        changed = 0;

        //solange Zustände da sind
        while( stackPos )
        {
            //Zustand holen
            index = stack[--stackPos];

            //Zeiger auf DEA-Struktur
            dea = DEAStates[index];

            //Gruppen-Index von index
            grpIndex = dea->groupIndex;

            //grpIndex darf nicht > max sein
            assert( grpIndex < max );

            //ist die Gruppe bereits markiert?
            if( !marked[transTable[grpIndex]] )
            {
                //nein, markieren und prüfen
                marked[transTable[grpIndex]]++;

                //Zeiger auf diese Gruppe
                grp = grpStr[transTable[grpIndex]];

                //repräsentativen Zustand aus dieser Gruppe holen
                repState = grp->DEAIndex[0];

                //Zeiger auf Übergangs-Tabelle dieses Zustands
                if( repState <= end1State )
                    dt = sc->DTran1[repState - base1State];

                else
                    dt = sc->DTran2[repState - base2State];

                //für Übergänge zu toten Zuständen
                dead = 0;

                //für Übergänge zu invaliden Gruppen
                invalid = 0;

                //alle Zeichen
                for( k =0; k < cclWidth; k++ )
                {
                    //Ziel-Zustand holen
                    destState = dt->to[k];

                    //DEA-Struktur
                    destDEA = DEAStates[destState];

                    //Gruppen-Index dieses Zustands
                    destGrpIndex = destDEA->groupIndex;

                    //Zeiger auf Gruppe
                    destGrp = grpStr[transTable[destGrpIndex]];

                    //schon markiert?
                    if( !marked[transTable[destGrpIndex]] )
                    {
                        //nein, schon auf Stack?
                        for( l = 0; l < stackPos; l++ )
                        {
                            //gleich?
                            if( stack[l] == destState )
                                //schon auf dem Stack
                                break;
                        }

                        //war der Zustand schon auf dem Stack?
                        if( l == stackPos )
                            //nein, eintragen
                            stack[stackPos++] = destState;
                    }

                    //gleiche Gruppe?
                    if( destGrpIndex == grpIndex )
                        //ja
                        dead++;

                    //Ziel-Gruppe invalid?
                    if( destGrp->valid == false )
                        //ja, merken
                        invalid++;
                }

                //Übergänge zur selben Gruppe für alle Zeichen?
                if( ( dead == cclWidth ) && ( grp->finit == false ) && ( grp->startGroup == false ) )
                {
                    //ja, Gruppe ist invalid
                    grp->valid = false;

                    //invalide Gruppen werden übersprungen und zählen daher nicht (Ausnahme sind Gruppen,
                    //die Startzustände beinhalten)
                    numberOfGroups--;
                }

                //alle Übergänge zu einer invaliden Gruppe?
                if( ( invalid == cclWidth ) && ( grp->finit == false ) )
                {
                    //ja, Gruppe ist invalid
                    grp->valid = false;

                    //invalide Gruppen werden übersprungen und zählen daher nicht (Ausnahme sind Gruppen,
                    //die Startzustände beinhalten)
                    numberOfGroups--;

                    //nochmal, für die Sprünge zu dieser Gruppe
                    changed++;
                }
            }
        }

    }while( changed );

    //wurden alle Gruppen markiert?
    for( i = 0; i < grpStrCnt; i++ )
    {
        //Zeiger auf Gruppe
        grp = grpStr[i];

        //markiert und keine Gruppe, die einen Startzustand enthält?
        if( !marked[transTable[grp->index]] )
        {
            //nein, Meldung ausgeben
            cout << "SSLRParser::checkGROUP: SC " << sc->name << ": Group " << grp->index << " not marked!\n";

            //invalide Gruppen werden ünersprungen und zählen daher nicht
            numberOfGroups--;

            //invalide Gruppe
            grp->valid = false;
        }
    }

    //Speicher freigeben
    delete[] ( transTable );
    delete[] ( stack );
    delete[] ( marked );
}


void SSLRParser::minDEA( void )
{
    /*
        Hier wird die DEA-Zustandsmenge minimiert, wie es im Drachen, S. 172 beschrieben ist.

        Die Startzustände der NEAen, die überall stehen dürfen, sowie die derer, die nur am Zeilenanfang
        stehen dürfen, kommen auf JEDEN Fall in zwei unterschiedliche Gruppen. Somit können sie nicht in
        einem Zustand zu liegen kommen. Wichtig ist zu beachten, dass einer von beiden, oder gar beide,
        Finit-Zustände sein können. Und trotzdem MÜSSEN sie in unterschiedliche Gruppe liegen.
    */
    DEA_STATES  *dea;
    GROUP_STR   **stack, *acceptGroup, *aGrp, *nGrp, *stGrp;
    GROUP_STR   *firstGroup, *secondGroup, *nonAcceptGroup;
    NEA_STR     *nea;
    SC_STR      *sc;
    ulong       stackPos = 0, refDest, dest;
    ulong       base1State, end1State, base2State, end2State;
    ulong       groupCnt, state;
    ulong       *tmpStack, tmpStackCnt;
    DTRAN       **DTran1, **DTran2, *d, *dt, *refDTran;
    uchar       c;
    char        hexChar[10];
    int         i, j, k, l, changed;

    //Meldung?
    if( argv_str->verbose == true )
        //Meldung
        cout << "sslex: Minimizing dea states...\n";

    //den maximalen Gruppenindex merken
    maxGroupIndex = 0;

    //auf dem Stack werden die Gruppen abgelegt
    stack = new( GROUP_STR *[DEAStatesCnt + 1] );

    /*
        Problem: Seien die Zustände 13, 24, 36 und 47 zusammen in einer Gruppe. Zustände 24 und 47 seien
        äquivalent. Es gilt (13,\n)=24 und (36,\n)=47. Wird nun Zustand 10 aus der Gruppe gelöscht,
        dann sind 10 und 47 kurzzeitig in verschiedene Gruppen. Der Test (13,\n)=24 und (36,\n)=47
        führt dann dazu, dass die Zustände 13 und 36 getrennt werden, obwohl sie zu Zuständen übergehen,
        die eigentlich in eine Gruppe gehören.

        Abhilfe: Die zu trennenden Zustände werden erst auf einen extra Stack geschoben. Erst, nachdem
        alle anderen Zustände der Gruppe getestet wurden, werden die zu löschenden Zustände auch wirklich
        entfernt. So werden die Verhältnisse während des Tests nicht verfälscht!
    */
    tmpStack = new( ulong[DEAStatesCnt] );

    //noch keine Gruppe erzeugt
    numberOfGroups = 0;


    //alle Start-Conditionen
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //Gruppen-Zähler
        groupCnt = 0;

        //Stack-Position zurücksetzen
        stackPos = 0;

        //Anfangs- und Endzustand der NEAen, die überall stehen dürfen
        base1State = sc->DEAIndex;
        end1State = base1State + sc->DTran1Cnt - 1;

        //Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen dürfen
        base2State = sc->begLineDEAIndex;
        end2State = base2State + sc->DTran2Cnt - 1;


        //reduzierte Übergangstabelle
        DTran1 = sc->DTran1;

        //alle Zustände, die für k keinen Übergang haben, bekommen ihn für d
        for( l = 0; l < sc->DTran1Cnt; l++ )
        {
            //Zeiger auf DTran
            dt = DTran1[l];

            //alle Übergänge
            for( k = 0; k < cclWidth; k++ )
            {
                //kein Übergang?
                if( dt->to[k] == -1 )
                    //ja, Übergang zu toten Zustand d
                    dt->to[k] = end1State;
            }
        }


        //reduzierte Übergangstabelle
        DTran2 = sc->DTran2;


        //alle Zustände, die für k keinen Übergang haben, bekommen ihn für d
        for( l = 0; l < sc->DTran2Cnt; l++ )
        {
            //Zeiger auf DTran
            dt = DTran2[l];

            //alle Übergänge
            for( k = 0; k < cclWidth; k++ )
            {
                //kein Übergang?
                if( dt->to[k] == -1 )
                    //ja, Übergang zu toten Zustand d
                    dt->to[k] = end2State;
            }
        }


        /*
            An dieser Stelle werden die Gruppen für die Zustandsminimierung erzeugt.
            Genauso wie es sich bei DEA-Zuständen um eine Menge von NEA-Zuständen handelt, handelt
            es sich bei einer Gruppe um eine Menge von DEA-Zuständen.

            In der ersten Gruppe befindet sich der Startzustand für die NEAen, die überall stehen
            dürfen. In der zweiten Gruppe befindet sich der Startzustand der NEAen, die nur
            am Zeilenanfang stehen dürfen.
            Alle DEA-Finit-Zustände, die zu ein und demselben NEA gehören, kommen zusammen in eine
            Gruppe. WICHTIG: die kann auch die erste oder zweite Gruppe sein, wenn der entsprechende
            Start-Zustand zugleich ein Finit-Zustand ist.

            Hat eine SC keine NEAen, werden nur die Dummy-DEA-Zustanände eingetragen. Sie haben für
            alle Eingabezeichen KEINE Übergänge, führen also zu Fehlermeldungen während des
            Scannings und können so wertvolle Hilfe beim Debuggen liefern.
            Hat eine SC keine NEAen, die überall stehen dürfen bzw. hat sie nur welche, die am
            Zeilenanfang stehen dürfen, so hat die erste Gruppe nur einen Dummy-Zustand.
        */

        //Gruppe mit den nicht-akzeptierenden Zuständen
        nonAcceptGroup = 0L;


        //erste Gruppe mit den Startzustand der NEAen, die überall stehen dürfen
        firstGroup = createGROUP();

        //den Index der Gruppe setzen
        firstGroup->index = groupCnt++;

        //den Startzustand in die Gruppe eintragen
        insertGROUP( firstGroup, base1State );

        //Gruppe beinhaltet den Startzustand
        firstGroup->startGroup = true;

        //auf den Stack
        stack[stackPos++] = firstGroup;

        //ist der Startzustand ein Finit-Zustand?
        if( firstGroup->finit == false )
            //ja, alle anderen nicht-akzeptierenden Zustände in diese Gruppe eintragen
            nonAcceptGroup = firstGroup;


        //zweite Gruppe mit dem Startzustand der NEAen, die nur am Zeilenanfang stehen dürfen
        secondGroup = createGROUP();

        //den Index der Gruppe setzen
        secondGroup->index = groupCnt++;

        //den Startzustand in die Gruppe eintragen
        insertGROUP( secondGroup, base2State );

        //Gruppe beinhaltet den Startzustand
        secondGroup->startGroup = true;

        //auf den Stack
        stack[stackPos++] = secondGroup;

        //ist der Startzustand ein Finit-Zustand?
        if( !nonAcceptGroup && ( secondGroup->finit == false ) )
            //ja, alle anderen nicht-akzeptierenden Zustände in diese Gruppe eintragen
            nonAcceptGroup = secondGroup;

        else if( !nonAcceptGroup )
        {
            //jeweils beide Startzustände sind zugleich Finit-Zustände
            nonAcceptGroup = createGROUP();

            //den Index der Gruppe setzen
            nonAcceptGroup->index = groupCnt++;

            //auf den Stack
            stack[stackPos++] = nonAcceptGroup;

            //Gruppen zählen
            numberOfGroups++;
        }

        //Zahl der erzeugten Gruppen
        numberOfGroups += 2;





        /*
            Die Finit-Zustände der NEAen, die überall stehen dürfen, kommen in eine Gruppe, die alle
            zum selben NEA gehören.
            Jeder NEA hat genau einen Finit-Zustand!
        */
        for( l = base1State; l <= end1State; l++ )
        {
            //DEA-Zustand
            dea = DEAStates[l];

            //akzeptierender Zustand?
            if( dea->finit == true )
            {
                //entsprechenden NEA holen
                nea = dea->finitNEA;

                //ist die Gruppe auf dem Stack?
                for( j = 0; j < stackPos; j++ )
                {
                    //Zeiger auf Gruppe
                    acceptGroup = stack[j];

                    //richtige Gruppe?
                    if( acceptGroup->finitNEA == nea )
                    {
                        //ja, hier eintragen
                        insertGROUP( acceptGroup, l );

                        //Schleife verlassen
                        break;
                    }
                }

                //war die Gruppe auf dem Stack?
                if( j == stackPos )
                {
                    //nein, Gruppe erzeugen
                    acceptGroup = createGROUP();

                    //Index setzen
                    acceptGroup->index = groupCnt++;

                    //ja, hier eintragen
                    insertGROUP( acceptGroup, l );

                    //NEA eintragen
                    acceptGroup->finitNEA = nea;

                    //ist eine Gruppe mit akzeptierenden Zuständen
                    acceptGroup->finit = true;

                    //auf Stack
                    stack[stackPos++] = acceptGroup;

                    //Zahl der erzeugten Gruppen
                    numberOfGroups++;
                }
            }

            else
                //nicht-akzeptierender Zustand
                insertGROUP( nonAcceptGroup, l );
        }




        /*
            Die Finit-Zustände der NEAen, die nur am Zeilenanfang stehen dürfen, kommen in eine Gruppe,
            die alle zum selben NEA gehören.
            Jeder NEA hat genau einen Finit-Zustand!
        */
        for( l = base2State; l <= end2State; l++ )
        {
            //DEA-Zustand
            dea = DEAStates[l];

            //akzeptierender Zustand?
            if( dea->finit == true )
            {
                //entsprechenden NEA holen
                nea = dea->finitNEA;

                //ist die Gruppe auf dem Stack?
                for( j = 0; j < stackPos; j++ )
                {
                    //Zeiger auf Gruppe
                    acceptGroup = stack[j];

                    //richtige Gruppe?
                    /*
                        Der Startzustand der NEAen, die nur am Zeilenanfang stehen dürfen, darf nicht
                        in Gruppe j=0 eingetragen werden, denn dort steht der Startzustand der NEAen, die
                        überall stehen dürfen!
                    */
                    if( ( acceptGroup->finitNEA == nea ) && j )
                    {
                        //ja, hier eintragen
                        insertGROUP( acceptGroup, l );

                        //Schleife verlassen
                        break;
                    }
                }

                //war die Gruppe auf dem Stack?
                if( j == stackPos )
                {
                    //nein, Gruppe erzeugen
                    acceptGroup = createGROUP();

                    //Index setzen
                    acceptGroup->index = groupCnt++;

                    //ja, hier eintragen
                    insertGROUP( acceptGroup, l );

                    //NEA eintragen
                    acceptGroup->finitNEA = nea;

                    //ist eine Gruppe mit akzeptierenden Zuständen
                    acceptGroup->finit = true;

                    //auf Stack
                    stack[stackPos++] = acceptGroup;

                    //Zahl der erzeugten Gruppen
                    numberOfGroups++;
                }
            }

            else
            {
                //nicht-akzeptierender Zustand

                //Startzustand der NEAen, die nur am Zeilenanfang stehen dürfen?
                //dieser ist ja bereits in der zweiten Gruppe enthalten und darf nicht in eine
                //andere Gruppe eingetragen werden.
                if( l != base2State )
                    //nein
                    insertGROUP( nonAcceptGroup, l );
            }
        }




        //Zustandsgruppen trennen
        do
        {
            //keine Änderungen
            changed = 0;
#ifdef DEBUG
            //Gruppen ausgeben
            for( j = 0; j < stackPos; j++ )
            {
                //Zeiger auf Gruppe
                stGrp = stack[j];

                //Meldung
                outputGROUP( stGrp );
            }
#endif

            //alle Gruppen
            for( j = 0; j < stackPos; j++ )
            {
                /*
                    Zustände werden nicht unmittelbar aus einer Gruppe gelöscht. Sie werden erst in tmpStack
                    eingetragen und erst NACH dem kompletten Test aller Zustände einer Gruppe aus dieser
                    gelöscht. S. oben!
                */
                tmpStackCnt = 0;


                //neue Gruppe erzeugen für akzeptierende Zustände
                aGrp = createGROUP();
                aGrp->index = groupCnt++;

                //neue Gruppe erzeugen für nicht-akzeptierende Zustände
                nGrp = createGROUP();
                nGrp->index = groupCnt++;

                //Zeiger auf Gruppe
                stGrp = stack[j];


                //alle Zustände dieser Gruppe mit dem ersten vergleichen
                //gehört der Referenzzustand zu den NEAen, die überall stehen dürfen?
                if( stGrp->DEAIndex[0] <= end1State )
                    //ja
                    refDTran = DTran1[stGrp->DEAIndex[0] - base1State];

                else
                    //nein, gehört zu den NEAen, die nur am Zeilenanfang stehen dürfen
                    refDTran = DTran2[stGrp->DEAIndex[0] - base2State];

                //die Zustandsübergänge des Referenzzustands mit allen anderen in seiner
                //Gruppe vergleichen
                for( l = 1; l < stGrp->DEAIndexCnt; l++ )
                {
                    //Zeiger auf DTran
                    if( stGrp->DEAIndex[l] <= end1State )
                        //Zustand gehört zu den NEAen, die überall stehen dürfen
                        d = DTran1[stGrp->DEAIndex[l] - base1State];

                    else
                        //Zustand gehört zu den NEAen, die nur am Zeilenanfang stehen dürfen
                        d = DTran2[stGrp->DEAIndex[l] - base2State];

                    //alle Zustandsübergänge
                    for( k = 0; k < cclWidth; k++ )
                    {
                        //für Debug-Zwecke
                        c = k;

                        //Ziel-Gruppe von Zustand 1
                        refDest = DEAStates[refDTran->to[k]]->groupIndex;

                        //Ziel-Gruppe von Zustand l
                        dest = DEAStates[d->to[k]]->groupIndex;

                        //ungleich?
                        if( refDest != dest )
                        {
#ifdef DEBUG
                            //Zeichen ausgeben
                            outputChar( c, hexChar );

                            //Debug-Meldung
                            cout << "Gruppe " << stGrp->index << ":\n";
                            cout << "(" << stGrp->DEAIndex[0] << "," << hexChar << ")=" << refDTran->to[k] << " in " << refDest << "\n";
                            cout << "(" << stGrp->DEAIndex[l] << "," << hexChar << ")=" << d->to[k] << " in " << dest << "\n";

//                          cout << c << ": insert Zustand " << stGrp->DEAIndex[l] << " in  Gruppe " << grp->index << "...\n";
                            cout << c << ": delete Zustand " << stGrp->DEAIndex[l] << " aus Gruppe " << stGrp->index << "...\n\n";
#endif
                            /*
                                ACHTUNG: In insertGROUP wird in die DEA-Struktur des einzutragenden
                                DEA-Zustands der Gruppen-Index eingetragen. So kann man leicht feststellen,
                                in welcher Gruppe ein DEA-Zustand ist!
                            */
                            tmpStack[tmpStackCnt++] = stGrp->DEAIndex[l];

                            //raus aus der k Schleife
                            break;
                        }
                    }
                }

                /*
                    Jetzt sind alle Zustände der Gruppe geprüft. Nun die zu löschenden Zustände
                    auch wirklich aus der Gruppe entfernen.
                */
                for( k = 0; k < tmpStackCnt; k++ )
                {
                    //Zustand holen
                    state = tmpStack[k];

                    //ist es ein akzeptierender Zustand?
                    if( DEAStates[state]->finit == true )
                        //in die Gruppe der akzeptierenden Zustände eintragen
                        insertGROUP( aGrp, state );

                    else
                        //in die Gruppe der nicht-akzeptierenden Zustände eintragen
                        insertGROUP( nGrp, state );

                    //Zustand aus Gruppe löschen
                    removeGROUP( stGrp, state );
                }


                //wurde eine Gruppe aufgespalten?
                if( !aGrp->DEAIndexCnt )
                    //nein, Speicher freigeben
                    deleteGROUP( aGrp );

                else
                {
                    //ja, Gruppe auf Stack
                    stack[stackPos++] = aGrp;

                    //die speziellen Eigenschaften der Gruppe aktGrp übernehmen
                    fixGROUP( stGrp, aGrp );

                    //Zahl der erzeugten Gruppen
                    numberOfGroups++;

                    //markieren
                    changed++;
                }

                //wurde eine Gruppe aufgespalten?
                if( !nGrp->DEAIndexCnt )
                    //nein, Speicher freigeben
                    deleteGROUP( nGrp );

                else
                {
                    //ja, Gruppe auf Stack
                    stack[stackPos++] = nGrp;

                    //die speziellen Eigenschaften der Gruppe aktGrp übernehmen
                    fixGROUP( stGrp, nGrp );

                    //Zahl der erzeugten Gruppen
                    numberOfGroups++;

                    //markieren
                    changed++;
                }
            }

        }while( changed );

        //größten Gruppenindex nehmen
        maxGroupIndex = ( groupCnt > maxGroupIndex ) ? groupCnt : maxGroupIndex;

#ifdef DEBUG
        //Gruppen ausgeben
        for( j = 0; j < stackPos; j++ )
        {
            //Zeiger auf Gruppe
            stGrp = stack[j];

            //Meldung
            outputGROUP( stGrp );
        }
#endif

        //Gruppe überprüfen
        checkGROUP( sc, stack, stackPos );

        //Gruppen in die SC eintragen
        sc->grp = new( GROUP_STR *[stackPos] );

        //Zeiger auf die Gruppen-Strukturen
        for( j = 0; j < stackPos; j++ )
            //Zeiger auf Gruppe
            sc->grp[j] = stack[j];

        //Anzahl der Gruppen eintragen
        sc->grpCnt = stackPos;
    }

    //Speicher freigeben
    delete[] ( stack );
    delete[] ( tmpStack );
}


void SSLRParser::outputCPPHeader( ofstream &file )
{
    //den Header des CPP-Files ausgeben

    //Header des cpp-Files
file << "/***************************************************************************\n";
file << "                          sslexscanner.cpp  -  description\n";
file << "                             -------------------\n";
file << "    copyright            : (C) 2002 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#include \"sslexscanner.h\"\n";
file << "#include <iostream>\n";
file << "\n";
file << "\n";

    //Debug-Version?
    if( argv_str->debug == true )
    {
        //Debug-Version
        file << "/****************************\n";
        file << "* This is the debug-version *\n";
        file << "****************************/\n\n\n";
    }

    else
    {
        //ist nicht die Debug-Version
        file << "/********************************\n";
        file << "* This is the non-debug-version *\n";
        file << "********************************/\n\n\n";
    }

file << "\n";
file << "\n";
file << "//Define macro ECHO\n";
file << "#define ECHO   cout << yyText\n";
file << "\n";
file << "//set a new start condition in user-defined action\n";
file << "#define BEGIN  setStartCondition\n";
file << "\n";
file << "//current start condition\n";
file << "#define YY_START   baseState\n";
file << "\n";
file << "//yyTerminate\n";
file << "#define yyTerminate()  return( ACCEPT )\n";
file << "\n";
file << "\n";
file << "//concatenate lexem\n";
file << "#define yyMore()   concatenate = true\n";
file << "\n";
file << "\n";
file << "//Size of start condition stack\n";
file << "#define SCStackSize    100\n";
file << "\n";
file << "\n";
file << "//enlargement for yyText if neccesary\n";
file << "#define SSLEX_YYTEXTSIZE   (8*1024)\n";
file << "\n\n";
}


void SSLRParser::outputEOF( ofstream &file )
{
    //<<EOF>>-NEAen ausgeben
    NEA_STR *nea;
    SC_STR  *sc;
    ulong   i, j, k;

file << "int SSLEXScanner::endOfLine( void )\n";
file << "{\n";
file << "   //call eof-rules\n";
file << "\n";
file << "   //action depends on start condition\n";
file << "   switch( baseState )\n";
file << "   {\n";

    //alle SC
    for( i = 0; i < scStrAnz; i++ )
    {
        //Zeiger auf SC
        sc = &scStr[i];

        //den Namen der SC ausgeben
        file << "       case " << sc->name << ":\n";
        file << "       {\n";

        //hat die SC einen EOF-NEA?
        for( j = 0; j < sc->neaArrCnt; j++ )
        {
            //Zeiger auf NEA
            nea = sc->neaArr[j];

            //<<EOF>>?
            if( nea->eof == true )
            {
                //ja, ausgeben

                //alle Aktionen
                for( k = 0; k < nea->actionAnz; k++ )
                    //ausgeben
                    file << nea->action[k];

                //abschließen
                file << "\n\t\t}\n\n";

                //Schleife verlassen
                break;
            }
        }

        //hatte die SC <<EOF>>-NEAen?
        if( j == sc->neaArrCnt )
        {
            //nein, die hatte keine
file << "           //default action\n";
file << "           yyTerminate();\n";
file << "\n";
file << "           break;\n";
file << "       }\n";
file << "\n";
        }
    }

file << "\n";
file << "       default:\n";
file << "       {\n";
file << "           //Unknown start condition\n";
file << "           cerr << \"SSLEXScanner::endOfLine: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "\n";
file << "           //ignore\n";
file << "           break;\n";
file << "       }\n";
file << "   }\n";
file << "\n";
file << "   //this should never be executed!\n";
file << "   return( 0 );\n";
file << "}\n";
file << "\n\n";

}


void SSLRParser::outputInfo( void )
{
    //Informationen ausgeben

    //Anzahl der Regeln
    cout << "sslex: Number of rules: " << ruleCnt << "\n";

    //Anzahl der NEA-Zustände
    cout << "sslex: Number of nea states: " << stateStrCnt << "\n";

    //Anzahl der DEA-Zustände
    cout << "sslex: Number of dea states before minDEA: " << DEAStatesCnt << ", after: " << numberOfGroups << "\n";

    //Zahl der SC
    cout << "sslex: Number of start conditions: " << scStrAnz << "\n\n";
}

\}

