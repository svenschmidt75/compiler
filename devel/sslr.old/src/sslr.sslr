/*
	Dies ist die sslr-Grammatik.
	(c) 2005 by Sven Schmidt
	s.schmidt@lboro.ac.uk
*/


%include
\{
	//SSLR initialisieren
	#define SSLR_INIT

\}


/*
	Die später verwendeten semantischen Typen müssen hier definiert sein.
	Der Attribut-Parsestack besteht aus diesen Elementen.
*/
%union
{
	//Strings
	char		*name;

	//einfache Zahl
	int			integer;
}


%definition


//hier werden den Nicht-Terminalen semantische Typen zugewiesen
%ntermType <integer> ntermDef
%ntermType <name> semanticAction errorMsg startUnion

//hier werden den Terminalen semantische Typen zugewiesen
%termType <name> TERMINAL NON_TERMINAL IDENT SEMACT STRING UNION
%termType <integer> NUMBER




	/**********************************************
	 ** hier stehen Deklarationen, die später im **
	 ** Header-File des erzeugten Parsers stehen **
	 **********************************************/


	private:

	//Hier werden die Produktionen abgelegt, ohne die rechte Seite.
	//Die rechten Seiten sind in PROD2_STR abgelegt.
	typedef struct
	{
		//Index der Produktion in der Hash-Tabelle
		long	hash_index;

		//Index der ersten Alternative in PROD2_STR
		long	prod2_index;

		//Anzahl der Alternativen dieser Produktion
		int		altAnz;

	}PROD_STR;



	//Hier werden die zu den Produktionen gehörenden rechten Seiten abgelegt.
	typedef struct
	{
		//Index der Produktion in PROD_STR
		long			prod_index;

		//Anzahl der Elemente auf der rechten Seite dieser Alternative
		int				riAnz;

		//Index der Hash-Einträge
		long			*right;

		//Priorität der Alternative
		int				priority;

		//String mit semantischer Aktion
		char			*semAct;

		//Zeile, in der die semantische Aktion angegeben wurde
		unsigned long	semActLine;

		//false: normale semantische Aktion, true: embedded semantic action
		bool			isEmbeddedSemAct;

		//falls in Folge eines Reduce-Reduce-Fehlers mit dieser ALternative nie reduziert wird
		int				reduce;

	}PROD2_STR;



	//%union
	typedef struct
	{
		/*
			Beispiel:
				int		a;
				long	b;
				bool	c;
		*/

		//Typen
		char		**type;

		//Bezeichner
		char		**id;

		/*
			Die union-Angabe wird zwar gescannt um die Richtigkeit der semantischen Typen zu bestimmen,
			aber in den Quelltext wird die Angabe des Grammatik-Files unverändert übernommen, weil sonst
			z.B. Pointer und Kommentare verschwinden würden.
		*/
		char		*text;

		//Anzahl der Elemente
		int			anz;

	}UNION_STR;



	//Hier stehen die Terminale, die mit einer bestimmten Fehleraktion verbunden sind
	typedef struct
	{
		//Terminal, bei dem eine bestimmte Fehleraktion ausgeführt werden soll
		long	terminal;

		//0: Fehleraktion bei diesem Terminal, 1: bei allen anderen (Negation)
		int		neg;

	}ERRTERM_STR;



	//%error
	/*
		Man hat die Möglichkeit, die Fehler-Behandlung beim Parsen zu beeinflussen.
		Aufbau:
			%error
			{
				Poition des Punktes eines Elementes:Aktion:Fehlermeldung
			}

			Aktion:
				ESHIFT(TERMINAL):		TERMINAL einfügen
				EPOP(TERMINAL):			solange Zustände vom Parse-Stack entfernen,
										bis TERMINAL geschoben werden darf
				EDELETE:				ein Terminal löschen
				EOVERREAD(TERMINAL):	bis TERMINAL erscheint, alles überlesen
				EEXIT:					Parsing beenden
				ESEM:					semantische Aktionen trotz Fehler zulassen
	*/
	typedef struct
	{
		//Index der Produktion in PROD_STR
		long		prod_index;

		//Nummer der Alternative, also Index in der PROD2_STR
		long		prod2_index;

		//Position des Punktes (LR-Item)
		int			dot;

		//ESHIFT(TERMINAL)
		long		shift;

		//EPOP(TERMINAL)
		long		pop;

		//EOVERREAD(TERMINAL)
		long		overread;

		//ESEM
		int			sem;

		//EEXIT
		int			exit;

		//EDELETE
		int			del;

		//Fehlermeldung
		char		*msg;

		//Zeile der Deklaration
		long		line;

		//gibt an, für welche Terminale diese Fehlerangabe gilt
		int			*tArr;

		//Terminale, verbunden mit Fehleraktionen
		ERRTERM_STR	*errTermStr;

		//Anzahl der ERRTERM_STR-Strukturen
		int			errTermStrAnz;

	}ERROR_STR;



	//EBNF-Stack für die Analyse der Grammatik
	typedef struct
	{
		//Index der Produktion in PROD_STR
		long	prod_index;

		//Index der Alternative in PROD2_STR
		long	prod2_index;

		//Nummer der Alternativen
		int		altCount;

		//Priorität der aktuellen Alternative
		int		pPriority;

	}EBNF_STACK;



	//Struktur für EIN LR(0/1)-Element
	typedef struct
	{
		//Index in PROD2_STR
		long		prod2_index;

		//Position des Punktes im LR-Item
		int			dot;

		//Hülle, die aus diesem Item durch Sprung erzeugt wird
		long		jumpTo;

		//Lookahead-Terminale
		Terminal	*la;

		//spontan generierte Terminale bei LALR
		Terminal	*lalr;

	}LR_STR;



	//Hülle-Struktur
	typedef struct
	{
		//Anzahl der Kerne
		int		anzCore;

		//Anzahl der LR(0)-Elemente
		int		anzElem;

		//LR(0/1)-Elemente
		LR_STR	*lr_str;

		/*
			Wenn für diese Hülle gilt:

				this = Sprung( i, X ),

				dann ist from = i und elem = X.
		*/
		long	from;
		long	elem;

		//Index dieser Hülle in hulle_str
		long	hulleIndex;

	}HULLE_STR;



	//LR-Tabelle
	typedef struct
	{
		/*
			1: Fehler
			2: Shift
			3: Reduce
			4: Akzeptieren
		*/
		int		state;

		/*
			bei Shift: zu schiebender Zustand
			bei Reduce: Index der Alternative, d.h. prod2_index
		*/
		long	value;

		//bei Shift: Hash-Index des Terminals, bei dem geschoben wird
		long	termHashIndex;

	}LR_TAB;



	//Struktur für semantische Aktionen u.a. wegen embedded actions wie bei YACC
	typedef struct
	{
		//Text mit semantischer Aktion
		char	*semAct;

		//Zeilennummer
		long	line;

	}SEMACT_STR;




	//links-assoziativ
	static const int			isLeftAssoc = 1;

	//rechts-assoziativ
	static const int			isRightAssoc = 2;

	//nicht-assoziativ
	static const int			isNonAssoc = 3;

	//Number of lr states
	static const int			CORE = 0;
	static const int			ITEM = 1;

	static const int			LR_ERROR = 1;
	static const int			LR_SHIFT = 2;
	static const int			LR_REDUCE = 3;
	static const int			LR_ACCEPT = 4;

	//Informationen über das Grammatik-File
	struct stat					st;

	//Hash-Tabelle
	hashClass					*hash_tab;

	//Array für die Produktionen
	PROD_STR					*prod_str;

	//Anzahl der Produktionen
	int							prod_anz;

	//Array für alle rechten Seiten
	PROD2_STR					*prod2_str;

	//Anzahl aller rechten Seiten
	int							prod2_anz;

	//Array für die %error-Angaben
	ERROR_STR					*error_str;

	//Anzahl der Einträge in error_str
	int							error_anz;

	/*
		Die Verwendung der Terminale/Nichtterminale wird geprüft. In diesem Array
		sind die Hash-Indices aufgereiht.
	*/
	long						*check;

	//Anzahl der Einträge in check
	long						anzCheck;

	//für %union-Definition
	UNION_STR					*unionStr;

	//Argumente
	ARGV_STR					*argv_str;

	//Hash-Index von EPSILON
	long						epsHashIndex;

	//Hash-Index von ACCEPT
	long						acceptHashIndex;

	//Check-Terminal # bei Generierung von LALR-Parsern
	long						lalrHashIndex;

	//Array mit allen Hüllen
	HULLE_STR					**hulle_str;

	//Anzahl der Hüllen
	long						hulle_anz;

	//Anzahl aller Kerne
	long						coreAnz;

	//LR-Tabelle
	LR_TAB						**lrTab;

	//Sprung-Tabelle
	int							**jumpTab;

	//Array mit den Hash-Indices aller Terminale
	long						*termArr;

	//Anzahl der Einträge in termArr
	int							termArrCount;

	//Array mit den Hash-Indices aller Nichtterminale
	long						*ntermArr;

	//Anzahl der Einträge in ntermArr
	int							ntermArrCount;

	//Anzahl der Shift-Reduce-Fehler
	int							srError;

	//Anzahl der Reduce-Reduce-Fehler
	int							rrError;

	//Zähler für semantische Aktionen
	int							semActCnt;

	//Struktur für semantische Aktionen
	SEMACT_STR					semActStr;

	//es gibt eine einzutragende semantische Aktion
	bool						semAct;

	//Priorität eines Terminals
	int							priority;

	//Alternativen haben Prioritäten
	int							pPriority;

	//Assoziativität eines Terminals
	int							assocDef;

	//Definition einer %union-Struktur
	bool						unionDef;

	//Index der Produktion in PROD_STR
	long						prod_index;

	//Index der Alternative in PROD2_STR
	long						prod2_index;

	//%ntermDef, also für Nicht-Terminale, oder %termDef für Terminale in %definition
	int							typeDef;

	//Fehler währen des Parsens
	int							err;

	/*
		Wenn %termDef/%ntermDef <semantischer Typ> (in der %definition-Sektion)
		angegeben wurde, dann prüfen, ob dieser semantische Typ auch in der
		%union-Struktur angegeben wurde.
	*/

	int							semIndex;

	//Index des Elements in der HASH_TAB
	long						hash_index;

	/*
		Die Priorität eines Terminals wird indirekt durch %left/%right angegeben: Je tiefer die
		Angabe steht, desto größer ist die Priorität des Terminals.
	*/
	unsigned long				priLine;

	//Anzahl der Alternativen der aktuellen Produktion prod_index
	int							altCount;

	/*
		Bei der Verwendung von EBNF-Symbolen treten Hierachien auf,
		für die diverse Informationen gesichert werden müssen.
	*/
	EBNF_STACK					*ebnfStack;

	//Stack-Pointer für den EBNF-Stack
	int							ebnfSP;

	/*
		Bei der Verwendung von eingebetteten semantischen Aktionen
		sowie bei der verwendung von EBNF-Symbolen müssen
		dummy-Nichtterminale eingeschoben werden, die hier
		auxsym heissen.
	*/
	char						*auxsym;

	//Zähler für die Anzahl der auxsym-Nichtterminale
	int							auxsym_count;


	/*
		Bei der Angabe der Grammatik kann man Fehlerangeben machen, diese
		Struktur enthält pro Alternative und Position des Punktes in einem
		LR-Item diese Informationen.
	*/
	ERROR_STR					*errorStr;

	//Index der aktuellen errorStr
	long						errorIndex;

	//gibt an, ob die Terminale negiert werden sollen
	bool						errorNeg;



	/*******************
	* private Methoden *
	*******************/

	//Überprüfung der (Nicht)Terminals
	void setCheck( long );

	//Neues %union-Paar eintragen
	void insertUnion( char *, char * );

	//Index des Type der semantischen Aktion in unionStr finden
	int getSemIndex( char * );

	//eine neue Produktion anfordern
	long getNewProd( void );

	//eine neue Alternative anfordern
	long getNewProd2( long );

	//ein Elemente in eine rechte Seite einer Alternative eintragen
	void insertElement( long, long, long );

	//die Fehleraktionen auf doppelte EInträge prüfen
	int checkErrorStr( void );

	//PROD2_STR sortieren
	void sortProd2Str( void );

	//Grammatik in Datei ausgeben
	void outputGrammar( void );

	//alle Alternativen ausgeben
	void outputAllAlt( void );

	//eine Alternativen ausgeben
	void outputAlt( ostream &, long );

	//eine Hülle ausgeben
	void outputHulle ( HULLE_STR * );

	//ein LR-Item ausgeben
	void outputItem( long, int, ofstream & );

	//Start-Produktion eintragen
	void insertStartProd( long &, long & );

	//(Nicht)Terminale überprüfen
	int checkAll( void );

	//prüfen, ob mit allen Alternativen reduziert wurde
	int checkAllReduce( void );

	//alle FIRST-Mengen bilden
	void genAllFirst( void );

	//hier werden die FIRST-Mengen eines Terminals/Nichtterminals erzeugt
	void genFirst( Terminal *, int, long * );

	//alle FOLLOW-Mengen bilden
	void genAllFollow( void );

	//prüft, ob die Hülle h schon in hulle_str enthalten ist
	int cmpLR0Hulle( HULLE_STR * );

	//prüft, ob die Hülle h schon in hulle_str enthalten ist
	int cmpLR1Hulle( HULLE_STR * );

	//alle Hüllen der SLR und LALR bilden
	void genLR0Hulle( void );

	//alle Hüllen der LR
	void genLR1Hulle( void );

	//LR(0)-Kern in HULLE h eintragen
	void insertItem( HULLE_STR *, long, int, int );

	//LR(1)-Kern in HULLE h eintragen
	void insertItem( HULLE_STR *, long, int, int, Terminal * );

	//eine HULLE_STR-Struktur erzeugen
	HULLE_STR *createHulle( void );

	//eine HULLE_STR-Struktur löschen
	void deleteHulle( HULLE_STR * );

	//prüft, ob in h der LR(0)-Kern schon enthalten ist
	int findItem( HULLE_STR *, long, int );

	//prüft, ob in h der LR(1)-Kern schon enthalten ist
	int findItem( HULLE_STR *, long, int, Terminal * );

	//eine Hülle in die Sammlung von Elementen eintragen
	void insertHulle( HULLE_STR * );

	//LR(0)-Items der Hülle erzeugen
	void genLR0Items( HULLE_STR * );

	//LR(1)-Items der Hülle erzeugen
	void genLR1Items( HULLE_STR * );

	//hier werden die Hüllen erzeugt, die sich durch Spring( h, X ) ergeben
	void makeLR0Jump( HULLE_STR * );

	//hier werden die Hüllen erzeugt, die sich durch Spring( h, X ) ergeben
	void makeLR1Jump( HULLE_STR * );

	//aus der Sammlung der LR(0)-Elemente die Lookaheads anfügen
	void genLALR( void );

	//die Hülle erzeugen, die sich durch Sprung( I0, index ) ergibt
	void genLR0Jump( HULLE_STR *, HULLE_STR *, long );

	//die Hülle erzeugen, die sich durch Sprung( I0, index ) ergibt
	void genLR1Jump( HULLE_STR *, HULLE_STR *, long );

	//Terminale ausgeben
	void outputTerminal( Terminal * );

	//Index der Hülle in die entsprechenden Elemente von I0 eintragen, die durch Sprung( I0, elem )
	//erzeugt wird.
	void setJump( HULLE_STR *, long, long );

	//hier werden die LR(0)-Kerne beider Hüllen verglichen
	bool cmp2LR0Hulle( HULLE_STR *, HULLE_STR * );

	//wandelt die LR(1)-Hüllen in LR(0)-Hüllen
	void LR2LALR( void );

	//Hülle löschen
	void delHulle( HULLE_STR * );

	//LR-Tabelle erzeugen
	void LRTab( void );

	//einen Reduce-Eintrag erzeugen
	void setReduce( int, long, Terminal * );

	//einen Shift-Eintrag erzeugen und dabei Shift-Reduce-Fehler behandeln
	void setShift( int, long, int );

	//hier werden die Source-Files des Parsers erzeugt
	void generateFiles( void );

	//LR-Tabelle in Datei ausgeben
	void outputLRTab( ofstream & );

	//Sprung-Tabelle ausgeben
	void outputJumpTab( ofstream & );

	/*
		Der Scanner liefert ja Tokens zum Parser zurück, die im Prinzip
		für die Auswahl der nächsten Aktion (schieben/reduzieren) benötigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	void outputTermDefHFile( ofstream & );

	//Header-File ausgeben
	void outputHFile( ofstream & );

	//Terminal-Defines als enum ausgeben
	void outputCPPTerminal( ofstream & );

	//die Alternativen in die cpp-Datei ausgeben.
	void outputAlternatives( ofstream & );

	//Follow-Mengen in cpp-File ausgeben
	void outputFollow( ofstream & );

	//die SSLR_NTERM_STR ausgeben
	void outputNtermStr( ofstream & );

	//die Namen der Terminale ausgeben, nur im debug-mode
	void outputTermName( ofstream & );

	//hier wird die komplette Fehlerbehandlung ausgegeben
	void outputErrorRecovery( ofstream & );

	//den Header des cpp-Files ausgeben
	void outputCPPHeader( ofstream & );

	//alle übrigen Routinen des cpp-Files ausgeben
	void outputCPPEnd( ofstream & );

	//erzeuge eine neue ERROR_STR und liefere den Index zurück
	int getErrorStr( void );

	//fügt eine ERRTERM_STR zu einer ERROR_STR hinzu.
	int insertErrTermStr( ERROR_STR *, long, int );

	//semantische Aktionen ausgeben
	void outputSemAct( ofstream & );

	//Include-Anweisungen in das cpp-File ausgeben
	void outputIncl( ofstream & );

	//eigene Erweiterungen in das cpp-File ausgeben
	void outputExt( ofstream & );

	//doppelte Alternativen finden
	int findDoubleAlt( void );

	//fügt ein auxsym-Nichtterminal auf rechter Seite von prod2_index ein für eine embedded semantic
	//action.
	void insertEmbeddedSemanticAction( long, long, long, int & );

	/*
		Diese Routine wird vom Konstruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	void init( void );

	/*
		Diese Routine wird vom Destruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	void deinit( void );



	public:

	/*
		Diese Funktion dient der Übergabe der Kommandozeilen-Argumente, die
		SSLR steuern.
	*/
	void giveArgs( ARGV_STR * );



%grammar


goal
	:	initSSLR union sect1 sect2
\{
	//die komplette Eingabe wurde erfolgreich geparst, nun die LR-Tabellen erzeugen

	//Meldung?
	if( argv_str->verbose )
		//ja, start-Produktion nicht mitzählen
		cout << "sslr: " << prod_anz - 1 << " productions analyzed!" << endl;

	//(Nicht)Terminale checken
	err += checkAll();

	//die PROD2_STR sortieren
	sortProd2Str();

	//finde doppelte Alternativen innerhalb einer Produktion
	err += findDoubleAlt();

	//alles OK?
	if( !err )
	{
		//ja, die ERROR_STR prüfen
		checkErrorStr();

		//Grammatik ausgeben
		outputGrammar();

		//FIRST-Mengen berechnen
		genAllFirst();

		//FOLLOW-Mengen berechnen
		genAllFollow();

		//welchen Parser-Typ erzeugen?
		if( argv_str->type == SLR )
			//SLR-Parser erzeugen
			genLR0Hulle();

		else if( argv_str->type == LALR )
		{
#ifndef LR2LALR
			//LALR-Parser erzeugen
			genLR0Hulle();

			//Die Lookaheads erzeugen
			genLALR();
#else
			/*
				Es gibt zu Debuggingzwecken auch die Möglichkeit, erst die LR(1)-Items zu erzeugen,
				und dann diese zu den LALR-Items zusammenzufassen.
			*/

			//LR(1)-Hüllen erzeugen
			genLR1Hulle();

			//LR(1)-Hüllen in LR(0)-Hüllen mit Lookaheads
			LR2LALR();
#endif
		}

		else if( argv_str->type == LR )
			//LR-Parser erzeugen
			genLR1Hulle();

		//LR-Tabelle erzeugen
		LRTab();

		//Hüllen ausgeben?
		if( argv_str->showHulle )
		{
			//Zeiger auf HULLE_STR
			HULLE_STR	*h;

			//Hüllen ausgeben
			for( unsigned long i = 0; i < hulle_anz; i++ )
			{
				//Zeiger auf Hülle
				h = hulle_str[i];

				//ausgeben
				outputHulle( h );
			}
		}

		//Quell-Files des Parsers erzeugen
		generateFiles();
	}

	else
		//Abbruch-Meldung ausgeben
		cerr << "\n\nsslr: Aborting..." << endl;

	//prüfen, ob mit allen Alternativen reduziert wurde
	checkAllReduce();

	//das war's
//	return( err );
\}
	;


//dient der Initialisierung von SSLR
initSSLR
	:	'EPSILON'
\{
	//hier wird SSLR initialisiert

	/*
		Terminalen wird per %left, %right, %nonassoc eine Assoziativität sowie eine
		Priorität zugewiesen. Je später ein Terminal erscheint, deste höher ist seine
		Priorität, z.b.

		%left ADD SUB
		%right MUL DIV

		ADD und SUB haben gleiche Priorität und sind links-assoziativ, wohingegen MUL und DIV
		rechts-assoziativ sind und höhere Priorität haben.
	*/
	priority = 0;

	/*
		Die Priorität eines Terminals wird indirekt durch %left/%right angegeben: Je tiefer die
		Angabe steht, desto größer ist die Priorität des Terminals.
	*/
	priLine = 0;


	/*
		Wenn eingebettete semantische Aktionen auftreten, oder EBNF-Symbole benutzt werden,
		so wird dafür auf der rechten Seite ein dummy-Nicht-Terminal auxsym eingetragen.
	*/
	auxsym_count = 1;


	//für die kommende Alternative wurde noch keine Priorität festgelegt
	pPriority = 0;

	//noch keine Fehler
	err = 0;

	//es wurde noch keine %union-Struktur angegeben
	unionDef = false;

	/*
		Bei der Verwendung von EBNF-Symbolen treten Hierachien auf,
		für die diverse Informationen gesichert werden müssen.
	*/
	ebnfStack = new( EBNF_STACK[100] );

	//Stack-Pointer für den EBNF-Stack
	ebnfSP = 0;


	/*
		Bei der Verwendung von eingebetteten semantischen Aktionen
		sowie bei der verwendung von EBNF-Symbolen müssen
		dummy-Nichtterminale eingeschoben werden, die hier
		auxsym heissen.
	*/
	auxsym = new( char[11] );

	//Zähler für die Anzahl der auxsym-Nichtterminale
	auxsym_count = 1;



	//Speicher für die %union-Angabe
	unionStr = new( UNION_STR );
	memset( unionStr, 0, sizeof( UNION_STR ) );


	//falls kein semantischer Typ angegeben wird
	insertUnion( "", "" );

	//keine semantische Aktion
	semAct = false;

	//Start-Produktion eintragen
	insertStartProd( prod_index, prod2_index );
\}
	;


/*
	Die %union-Angabe soll auch geparst werden, da die semantischen Typen extrahiert werden können,
	um später die Angaben in %termType und %ntermType vergleichen zu können.
*/
union
	:	startUnion 'BOPEN' unionBody 'BCLOSE'
\{
	/*
		Den Inhalt der %union-Angabe merken, denn dieser wird später unverändert ins Header-File
		des generierten Parsers aufgenommen. Das dieser hier geparst wird liegt daran, dass die Typen
		ja in %ntermDef/%termDef benutzt werden, und dies wird geprüft.
	*/
	unionStr->text = $1;
\}
	|	'EPSILON'
	;


startUnion
	:	'UNION'
\{
	//es wurde eine %union-Struktur angegeben
	unionDef = true;

	//den Inhalt der %union-Angabe weitergeben
	$$ = $1;
\}
	;


unionBody
	:	unionBody unionBody2
	|	unionBody2
	;


unionBody2
	:	'IDENT' 'IDENT' 'SEMIKOLON'
\{
	//einen neuen Eintrag in der unionStr eintragen
	insertUnion( $1, $2 );

\}
	|	'IDENT' 'AST' 'IDENT' 'SEMIKOLON'
\{
	//einen neuen Eintrag in der unionStr eintragen
	insertUnion( $1, $3 );
\}
	;



/*********************************
 ********** %definition **********
 *********************************/


sect1
	:	'DEFINITION' definition1
	;


//Zuweisung von semantischen Typen und Assoziativität
definition1
	:	definition1 definition2
	|	definition2
	|	'EPSILON'
	;


//Zuweisung von semantischen Typen und Assoziativität
definition2

		//%termType <i> TERM1 TERM2 ...
		//ntermType <k> nterm1 nterm2 ...
	:	ntermDef semType namelist1

		//%left ADD SUB ...
	|	associativity namelist2
	;



ntermDef
		//es folgen Anweisungen für ein Nichtterminal
	:	'NTERM_TYPE'
\{
		//Nicht-Terminal
		typeDef = SSLR_NTERM;
\}
	|	'TERM_TYPE'
\{
		//Terminal
		typeDef = SSLR_TERM;
\}
	;


semType
	:	'semTypeOpen' 'IDENT' 'semTypeClose'
\{
	/*
		In $2 steht eine Zeichenkette (<name>), die den semantischen Typ
		gem. der %union-Angabe enthält.
	*/

	//Typ für semantische Aktion, sollte in %union definiert sein.

	//%union schon angegeben?
	if( !unionDef )
	{
		//nein
		cerr << "sslr: ERROR: line " << SSLR_line << ": %union missing!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//den Eintrag in unionStr finden
		if( ( semIndex = getSemIndex( $2 ) ) < 0 )
		{
			//Typ nicht in %union definiert
			cerr << "sslr: ERROR: line " << SSLR_line << ": Type for semantic action " << $2 << " not defined in %union!" << endl;

			//Fehler
			err++;
		}
	}
\}

	|	'EPSILON'
\{
	//ohne Angabe von semantischen Typen, Warnung ausgeben
	cerr << "sslr: line " << SSLR_line << ": No semantic type given!" << endl;
\}
	;


//Priorität für ein Terminal festlegen
associativity
	:	'LEFT_ASSOC'
\{
	//links-assoziativ
	assocDef = LEFT_ASSOC;
\}
	|	'RIGHT_ASSOC'
\{
	//rechts-assoziativ
	assocDef = RIGHT_ASSOC;
\}
	|	'NON_ASSOC'
\{
	//nicht-assoziativ
	assocDef = NON_ASSOC;
\}
	;


/*
	Bei der Zuweisung von semantischen Typen folgen i.d.R. mehrere (Nicht)Terminale, gefolgt
	von einem Leerzeichen, also z.B.
	%ntermType nterm1 nterm2 ...
*/
namelist1
	:	namelist1 'IDENT'
\{
	int	type;

	//Element in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $2 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//%termType: Terminal wird definiert
	//%ntermType: Nicht-Terminal wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//Index des Eintrags in unionStr in die Hash-Tabelle eintragen
	hash_tab->setUnionType( hash_index, semIndex );

	//ist es ein Terminal oder ein Nicht-Terminal?
	if( typeDef == SSLR_TERM )
	{
		//ist ein Terminal
		type = hash_tab->setType( hash_index, SSLR_TERM );

		//etwa schon als Nicht-Terminal definiert?
		if( type != SSLR_TERM )
		{
			//Fehler, Terminal wurde schon als Nicht-Terminal definiert

			//Name des Nichtterminals
			char *name = hash_tab->getName( hash_index );

			//Fehlermeldung
			cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

			//Fehler
			err++;
		}
	}

	else
	{
		//ist ein Nicht-Terminal
		type = hash_tab->setType( hash_index, SSLR_NTERM );

		//etwa schon als Terminal definiert?
		if( type != SSLR_NTERM )
		{
			//Fehler, Nicht-Terminal wurde schon als Terminal definiert

			//Name des Terminals
			char *name = hash_tab->getName( hash_index );

			//Fehlermeldung
			cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

			//Fehler
			err++;
		}
	}
\}
	|	'IDENT'
\{
	int	type;

	//Element in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $1 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//%termType: Terminal wird definiert
	//%ntermType: Nicht-Terminal wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//Index des Eintrags in unionStr in die Hash-Tabelle eintragen
	hash_tab->setUnionType( hash_index, semIndex );

	//ist es ein Terminal oder ein Nicht-Terminal?
	if( typeDef == SSLR_TERM )
	{
		//ist ein Terminal
		type = hash_tab->setType( hash_index, SSLR_TERM );

		//etwa schon als Nicht-Terminal definiert?
		if( type != SSLR_TERM )
		{
			//Fehler, Terminal wurde schon als Nicht-Terminal definiert

			//Name des Nicht-Terminals
			char *name = hash_tab->getName( hash_index );

			//Fehlermeldung
			cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

			//Fehler
			err++;
		}
	}

	else
	{
		//ist ein Nicht-Terminal
		type = hash_tab->setType( hash_index, SSLR_NTERM );

		//etwa schon als Terminal definiert?
		if( type != SSLR_NTERM )
		{
			//Fehler, Nicht-Terminal wurde schon als Terminal definiert

			//Name des Terminals
			char *name = hash_tab->getName( hash_index );

			//Fehlermeldung
			cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

			//Fehler
			err++;
		}
	}
\}
	;


/*
	Bei der Zuweisung von Prioritäten und Assoziativitäten folgen i.d.R. mehrere Terminale, gefolgt
	von einem Leerzeichen, also z.B.
	%ntermType nterm1 nterm2 ...
*/
namelist2
	:	namelist2 'IDENT'
\{
	//in assocDef steht die Assoziativität dieses Terminals

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $2 );

	//Terminal wird definiert
//	hash_tab->setDefined( hash_index, SSLR_line );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Assoziativität eintragen
	hash_tab->setAssociation( hash_index, assocDef );

	//Priorität erhöhen
	if( SSLR_line > priLine )
	{
		//ja, erhöhen
		priority++;
		priLine = SSLR_line;
	}

	//Priorität eintragen
	hash_tab->setPriority( hash_index, priority );
\}
	|	'IDENT'
\{
	//in assocDef steht die Assoziativität dieses Terminals

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $1 );

	//Terminal wird definiert
//	hash_tab->setDefined( hash_index, SSLR_line );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Assoziativität eintragen
	hash_tab->setAssociation( hash_index, assocDef );

	//Priorität erhöhen
	if( SSLR_line > priLine )
	{
		//ja, erhöhen
		priority++;
		priLine = SSLR_line;
	}

	//Priorität eintragen
	hash_tab->setPriority( hash_index, priority );
\}
	;



/******************************
 ********** %grammar **********
 ******************************/


sect2
	:	'GRAMMAR' sc2
	|	'EPSILON'
	;


sc2
	:	sc2 sslrRule 'END_OF_PRODUCTION'
\{
	/*
		Es folgt eine neue Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Anzahl der Alternativen dieser Produktion eintragen
	prod_str[prod_index].altAnz = altCount;

	//Priorität der Produktion eintragen
	prod2_str[prod2_index].priority = pPriority;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//Nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}
\}
	|	sslrRule 'END_OF_PRODUCTION'
\{
	/*
		Es folgt eine neue Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Anzahl der Alternativen dieser Produktion eintragen
	prod_str[prod_index].altAnz = altCount;

	//Priorität der Produktion eintragen
	prod2_str[prod2_index].priority = pPriority;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//Nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}
\}
	;


sslrRule
	:	newProduction 'SEP' rightSide
	;


newProduction
	:	'IDENT'
\{
	//Hier kann erst der Wert der Name der Produktion eingetragen werden

	//Produktion in die Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $1 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//Produktion wurde definiert
	hash_tab->setProdDef( hash_index );


	/*
		Wenn dies die erste Produktion ist, dann diese in die rechte Seite der
		Start-Produktion "start" eintragen.
	*/
	if( !prod_index )
	{
		//ja, eintragen
		insertElement( prod_index, prod2_index, hash_index );

		//eine Alternative
		prod_str[prod_index].altAnz = 1;

		//Produktion wurde benutzt
		hash_tab->setUsed( hash_index );
	}


	//Start-Produktion "start" nicht erlaubt
	if( !strcmp( hash_tab->getName( hash_index ), "start" ) )
	{
		//Fehler
		err++;

		//Meldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Production start reserved!" << endl;
	}



	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index der Produktion eintragen
	prod_str[prod_index].hash_index = hash_index;

	//ist ein Nichtterminal
	int type = hash_tab->setType( hash_index, SSLR_NTERM );

	//vorher schon mal als Terminal definiert?
	if( type != SSLR_NTERM )
	{
		//Fehler, Produktion wurde schon als Terminal definiert

		//Name des Nicht-Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Nonterminal " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

		//Fehler
		err++;
	}

	//PROD2_STR anfordern, für die nächste Alternative
	prod2_index = getNewProd2( prod_index );

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;

	//Meldung ausgeben
	if( argv_str->verbose )
		cout << "sslr: line " << SSLR_line << ": Analyze " << $1 << "..." << endl;
\}
	;


rightSide
	:	item1 precedence error
	|	rightSide newAlternative item1 precedence error
	;


newAlternative
	:	'NEW_ALTERNATIVE'
\{
	/*
		Es folgt eine neue Alternative zu einer bestehenden Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//nächste Produktion
	altCount++;

	//Priorität der Produktion eintragen
	prod2_str[prod2_index].priority = pPriority;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}

	//PROD2_STR für eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//die Alternative hat noch keine Priorität
	pPriority = 0;
\}
	;


item1
	:	item1 rhs
	|	rhs
	;

rhs
	:	ebnfKLOpen rightSide ebnfKLClose
	|	ebnfBOpen rightSide ebnfBClose
	|	ebnfEOpen rightSide ebnfEClose
	|	item2
	;

item2
	:	item2 item3
	|	item3
	;

item3
	:	'TERMINAL'
\{
	//Terminal auf rechte Seite der aktuellen Alternative prod2_index eintragen

	//ist es ein reserviertes Terminal?
	if( !strcmp( $1, "LALR" ) )
	{
		//nein, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $1 );

	//ist es ein EPSILON, dass nicht als erstes Element auf der rechten Seite steht?
	if( ( prod2_str[prod2_index].riAnz ) && ( hash_index == epsHashIndex ) )
	{
		//Fehler
		cerr << "sslr: ERROR: line " << SSLR_line << ": EPSILON must always be the only element on the right side!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//semantische Aktion vorher eintragen?
		if( semAct == true )
		{
			//ja
			insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

			//zurücksetzen
			semAct = false;
		}

		//für Fehlerbehandlung merken
		setCheck( hash_index );

		//Terminal benutzt
		hash_tab->setUsed( hash_index );

		//Terminal in rechte Seite der aktuellen Alternative eintragen
		insertElement( prod_index, prod2_index, hash_index );

		//ist ein Terminal
		int type = hash_tab->setType( hash_index, SSLR_TERM );

		//wurde das Terminal früher bereits als Nicht-Terminal definiert?
		if( type != SSLR_TERM )
		{
			//Fehler, Terminal wurde schon als Nicht-Terminal definiert

			//Name des Nicht-Terminals
			char *name = hash_tab->getName( hash_index );

			//Fehlermeldung
			cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

			//Fehler
			err++;
		}

		//Priorität übernehmen
		pPriority = hash_tab->getPriority( hash_index );
	}
\}
	|	'NON_TERMINAL'
\{
	//Nicht-Terminal auf rechte Seite der Alternative eintragen

	//gibt es eine semantische Aktion, die einzutragen ist, bevor das Nicht-Terminal eingetragen wird?
	if( semAct == true )
	{
		//ja, es gibt eine eingebettete semantische Aktion
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//Nicht-Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $1 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//Nicht-Terminal benutzt
	hash_tab->setUsed( hash_index );

	//ist ein Nicht-Terminal
	int type = hash_tab->setType( hash_index, SSLR_NTERM );

	//wurde das Nicht-Terminal vorher als Terminal definiert?
	if( type != SSLR_NTERM )
	{
		//Fehler, Nicht-Terminal wurde schon als Terminal definiert

		//Name des Nichtterminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Nonterminal " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

		//Fehler
		err++;
	}

	//Nicht-Terminal in rechte Seite der Alternative prod2_index eintragen
	insertElement( prod_index, prod2_index, hash_index );
\}
	|	semanticAction
	;


semanticAction
	:	'SEMACT'
\{
	//eine Alternative ist mit einer semantischen Aktion verbunden

	//%union schon angegeben?
	if( !unionDef )
	{
		//Nein
		cerr << "sslr: ERROR: line " << SSLR_line << ": Semantic action useless without %union!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//schon eine semantische Aktion in der Struktur, d.h. doppeltes Auftreten?
		if( semAct == true )
		{
			//doppelte semantische Aktion
			cerr << "sslr: ERROR: line " << SSLR_line << ": Double semantic action!" << endl;

			//Fehler
			err++;
		}

		else
		{
			//semantische Aktionen übertragen
			semActStr.semAct = $1;

			//Zeile merken
			semActStr.line = SSLR_line;

			//semantische Aktion wurde definiert
			semAct = true;

			//Zähler
			semActCnt++;
		}
	}
\}
	;


ebnfKLOpen
	:	'KLOPEN'
\{
	/*
		Hier wird das EBNF-Symbol ( benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 ( 'TERM1' | 'TERM2' ) prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym1 prod3
				;

		auxsym1
				:	'TERM1'
				|	'TERM2'
				;
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist eine eingebettete semantische Aktion
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP].altCount = altCount;
	ebnfStack[ebnfSP++].pPriority = pPriority;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//Priorität dieser Produktion initialisieren
	pPriority = 0;

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
\}
	;


ebnfBOpen
	:	'BOPEN'
\{
	/*
		Hier wird das EBNF-Symbol { benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 { 'TERM1' | 'TERM2' } prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym_1 prod3
				;

		auxsym_1
				:	'TERM1' auxsym_1
				|	'TERM2' auxsym_1
				|	'EPSILON'
				;

		{} bedeutet also beliebig oft.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}


	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP].altCount = altCount;
	ebnfStack[ebnfSP++].pPriority = pPriority;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );


	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//Priorität dieser Produktion initialisieren
	pPriority = 0;

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
\}
	;


ebnfEOpen
	:	'EOPEN'
\{
	/*
		Hier wird das EBNF-Symbol [ benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 [ 'TERM1' | 'TERM2' ] prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym1 prod3
				;

		auxsym1
				:	'TERM1'
				|	'TERM2'
				|	'EPSILON'
				;

		[] bedeutet also optional, also einmal oder keinmal.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP].altCount = altCount;
	ebnfStack[ebnfSP++].pPriority = pPriority;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//Priorität dieser Produktion initialisieren
	pPriority = 0;

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
\}
	;


ebnfKLClose
	:	'KLCLOSE'
\{
	//schliessendes EBNF-Symbol )

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols )!" << endl;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;

	//Priorität der Produktion eintragen
	prod2_str[prod2_index].priority = pPriority;

	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
	pPriority = ebnfStack[ebnfSP].pPriority;
\}
	;


ebnfBClose
	:	'BCLOSE'
\{
	//schliessendes EBNF-Symbol }
	long	baseProd2Index, count;

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols }!" << endl;

	//Priorität der Produktion eintragen
	prod2_str[prod2_index].priority = pPriority;


	//prod2_index der ersten Alternative der Produktion
	baseProd2Index = prod_str[prod_index].prod2_index;

	//nun das auxsym selbst als letztes Element auf rechter Seite eintragen,
	//damit beliebiges Ausführen möglich ist
	for( count = baseProd2Index; count < ( baseProd2Index + altCount ); count ++ )
		//auxsym auf rechter Seite eintragen
		insertElement( prod_index, count, prod_str[prod_index].hash_index );


	/*
		Nun EPSILON als Alternative in die aktuelle Produktion eintragen, da {} ja
		belibieg oft bedeutet.
	*/
	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Priorität der Produktion eintragen
	prod2_str[prod2_index].priority = 0;

	//EPSILON in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//EPSILON ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen
	altCount++;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;


	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
	pPriority = ebnfStack[ebnfSP].pPriority;
\}
	;

ebnfEClose
	:	'ECLOSE'
\{
	//schliessendes EBNF-Symbol ]

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols ]!" << endl;

	//Priorität der Produktion eintragen
	prod2_str[prod2_index].priority = pPriority;


	/*
		Nun EPSILON als Alternative in die aktuelle Produktion eintragen, da [] ja
		optional bedeutet.
	*/
	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Priorität der Produktion eintragen
	prod2_str[prod2_index].priority = 0;

	//EPSILON in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//EPSILON ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen
	altCount++;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;


	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
	pPriority = ebnfStack[ebnfSP].pPriority;
\}
	;


precedence
	:	'PREC' 'TERMINAL'
\{
	/*
		Man kann durch Angabe von %prec die Prioriät des Terminals auf die
		Priorität der aktuellen Alternative übertragen.
	*/

	//Zeiger auf PROD_STR
	PROD_STR *p1 = &prod_str[prod_index];

	//Hash-Index des Terminals holen
	hash_index = hash_tab->insert( $2 );

	//Terminal wird benutzt
	hash_tab->setUsed( hash_index );

	//Priorität der aktuellen Alternative holen
	int pri = prod2_str[prod2_index].priority;

	//Priorität der Alternative > Priorität des Terminals?
	if( pri <=  hash_tab->getPriority( hash_index ) )
	{
		//Nein, übernehmen
		int	pPriority = hash_tab->getPriority( hash_index );

		//Priorität der aktuellen Alternative setzen
		prod2_str[prod2_index].priority = pPriority;
	}

	else
		//Meldung
		cerr << "sslr: Warning: line " << SSLR_line << ": Priority of " << hash_tab->getName( p1->hash_index ) << " > than priority of " << hash_tab->getName( hash_index ) << "!" << endl;
\}
	|	'EPSILON'
	;


error
	:	startError 'BOPEN' errorBody 'BCLOSE'
	|	'EPSILON'
	;


startError
	:	'ERROR'
\{
	//es folgt eine %error-Struktur

	//eine ERROR_STR anfordern
	errorIndex = getErrorStr();

	//Zeiger auf die ERROR_STR
	errorStr = &error_str[errorIndex];

	//Index der Produktion eintragen
	errorStr->prod_index = prod_index;

	//Index der Alternative in PROD2_STR eintragen
	errorStr->prod2_index = prod2_index;

	//die Zeile merken
	errorStr->line = SSLR_line;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	;


errorBody
	:	errorBody errorBody2
	|	errorBody2
	;


errorBody2
	:	'NUMBER' 'DB' termList 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $5;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	'NUMBER' 'DB' termList 'DB' errorAction 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $7;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	'NUMBER' 'DB' negTerm 'KLOPEN' termList 'KLCLOSE' 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $8;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	'NUMBER' 'DB' negTerm 'KLOPEN' termList 'KLCLOSE' 'DB' errorAction 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $10;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	'NUMBER' 'DB' errorAction 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $5;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	'NUMBER' 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $3;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	;


negTerm
	:	'NOT'
\{
	//Terminal-Angaben negieren
	errorNeg = true;
\}
	;


termList
	:	termList 'COMMA' 'TERMINAL'
\{
	//Index des Terminals holen
	hash_index = hash_tab->insert( $3 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//negieren?
	if( errorNeg == true )
		//ERRTERM_STR in errorStr eintragen
		insertErrTermStr ( errorStr, hash_index, 1 );

	else
		//nicht negieren
		insertErrTermStr ( errorStr, hash_index, 0 );
\}
	|	'TERMINAL'
\{
	//Index des Terminals holen
	hash_index = hash_tab->insert( $1 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//negieren?
	if( errorNeg == true )
		//ERRTERM_STR in errorStr eintragen
		insertErrTermStr ( errorStr, hash_index, 1 );

	else
		//nicht negieren
		insertErrTermStr ( errorStr, hash_index, 0 );
\}
	;


errorAction
	:	errorAction 'DB' errorAction2
	|	errorAction2
	;


errorAction2
	:	'OVERREAD' 'KLOPEN' 'TERMINAL' 'KLCLOSE'
\{
	//Terminale in der Eingabe löschen, nis das Terminal geschoben werden darf

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $3 );

	//schon in der ERROR_STR enthalten?
	if( errorStr->overread )
		//es war schon eine OVERREAD(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used overread(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->overread = hash_index;
\}
	|	'SHIFT' 'KLOPEN' 'TERMINAL' 'KLCLOSE'
\{
	//ein Terminal auf den Parse-Stack schieben

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $3 );

	//schon in der ERROR_STR enthalten?
	if( errorStr->shift )
		//es war schon eine SHIFT(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used shift(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->shift = hash_index;
\}
	|	'POP' 'KLOPEN' 'TERMINAL' 'KLCLOSE'
\{
	//Zustände vom Parse-Stack löschen, bis Terminal geschoben werden darf

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $3 );

	//schon in der ERROR_STR enthalten?
	if( errorStr->pop )
		//es war schon eine POP(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used pop(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->pop = hash_index;
\}
	|	'EXIT'
\{
	//das Parsen abbrechen
	if( errorStr->exit++ )
		//wurde schon einmal verwendet
		cerr << "sslr: Warning: line " << SSLR_line << ": EXIT already used!" << endl;

\}
	|	'DELETE'
\{
	//es soll der nächste Eingebesymbol aus der Eingabe entfernt werden
	errorStr->del++;
\}
	|	'SEM'
\{
	//semantische Aktionen trotz Fehlers weiterführen
	if( errorStr->sem++ )
		//schon eingetragen
		cerr << "sslr: Warning: line " << SSLR_line << ": SEM already used!" << endl;
\}
	;

errorMsg
	:	'STRING'
\{
		//Fehlermeldung zurückliefern
		$$ = $1;
\}
	|	'EPSILON'
\{
		//es wurde keine Fehlermeldung angegeben
		$$ = 0L;
\}
	;



%extension
\{


	//Hilfsroutinen für SSLR


void SSLRParser::giveArgs( ARGV_STR *argv )
{
	/*
		Diese Funktion dient der Übergabe der Kommandozeilen-Argumente, die
		SSLR steuern.
	*/

	//Argumente
	argv_str = argv;
}


void SSLRParser::init( void )
{
	/*
		Diese Routine wird vom Konstruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	anzCheck = 0;
	check = 0L;
	prod_anz = 0;
	prod_str = 0L;
	prod2_anz = 0;
	prod2_str = 0L;
	error_anz = 0;
	error_str = 0L;
	hulle_str = 0L;
	hulle_anz =  0;
	coreAnz = 0;
	srError = 0;
	rrError = 0;
	semActCnt = 0;
	termArr = 0L;
	ntermArr = 0L;
	unionStr = 0L;
	lrTab = 0L;
	jumpTab = 0L;
	hash_tab = 0L;

	//Speicher für die Hash-Tabelle anfordern
	hash_tab = new( hashClass );
}


void SSLRParser::deinit( void )
{
	/*
		Diese Routine wird vom Destruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/

	//Speicher freigeben
	delete( hash_tab );
	delete( unionStr );
	delete( auxsym );
}


void SSLRParser::insertEmbeddedSemanticAction( long prod_index, long prod2_index, long line, int &auxsymCount )
{
	//fügt ein auxsym-Nichtterminal auf rechter Seite von prod2_index ein für eine embedded semantic
	//action.
	PROD2_STR	*p2;
	long		hash_index;
	char		auxsym[11];

	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsymCount++ );

	//in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//Produktion wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//Nichtterminal wird benutzt
	hash_tab->setUsed( hash_index );

	//Nichtterminal wird definiert
	hash_tab->setDefined( hash_index, line );

	//Ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );


	//auxsym-Produktion auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );


	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index des Nichtterminals eintragen
	prod_str[prod_index].hash_index = hash_index;

	//PROD2_STR anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeiger auf PROD2_STR
	p2 = &prod2_str[prod2_index];

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Priorität der Produktion eintragen
	p2->priority = 0;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//Ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = 1;



	//semantische Aktion eintragen
	p2->semAct = semActStr.semAct;

	//Zeile merken
	p2->semActLine = semActStr.line;

	//ist eine embedded semantic action
	p2->isEmbeddedSemAct = true;
}


int SSLRParser::findDoubleAlt( void )
{
	//doppelte Alternativen finden
	PROD_STR	*p1;
	PROD2_STR	*p2, *p3;
	char		*name;
	int			i, j, k, l, err = 0, ri;

	//Alle Produktionen
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//Alle rechten Seiten
		ri = p1->altAnz;

		//Alle Alternativen
		for( j = p1->prod2_index; j < ( p1->prod2_index + ri ); j++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[j];

			//Alle aneren Alternativen
			for( k = j + 1; k < ( p1->prod2_index + ri ); k++ )
			{
				//Zeiger auf PROD2_STR
				p3 = &prod2_str[k];

				//Anzahl der Elemente gleich?
				if( p2->riAnz == p3->riAnz )
				{
					//die rechten Seiten von p2 und p3 vergleichen
					for( l = 0; l < p2->riAnz; l++ )
					{
						//Elemente gleich?
						if( p2->right[l] != p3->right[l] )
							//Nein
							break;
					}

					//gleich, wenn l = p2->riAnz
					if( l == p2->riAnz )
					{
						//Alternativen sind gleich
						cerr << "sslr: ERROR: Alternativen " << ( j - p1->prod2_index  + 1 ) << " und " << ( k - p1->prod2_index + 1 ) << " gleich in Produktion " << name << "!" << endl;

						//Fehler
						err++;
					}
				}
			}
		}
	}

	//zurück
	return( err );
}


int SSLRParser::getErrorStr( void )
{
	//Erzeuge eine neue ERROR_STR und liefere den Index zurück
	ERROR_STR	*tmp;

	//eine neue ERROR_STR anfordern
	tmp = new( ERROR_STR[error_anz + 1] );

	//Inhalt kopieren
	memmove( tmp, error_str, sizeof( ERROR_STR ) * error_anz );

	//Initalisieren
	memset( &tmp[error_anz], 0, sizeof( ERROR_STR ) );

	//Adressen
	error_str = tmp;

	//Index zurückliefern
	return( error_anz++ );
}


int SSLRParser::insertErrTermStr( ERROR_STR *errStr, long terminal, int neg )
{
	//fügt eine ERRTERM_STR zu einer ERROR_STR hinzu
	ERRTERM_STR		*tmp, *tmp2;
	int				i;

	//Alle ERRTERM_STR prüfen, ob das Terminal schon da ist
	for( i = 0; i < errStr->errTermStrAnz; i++ )
	{
		//Zeiger auf die ERRTERM_STR holen
		tmp = &errStr->errTermStr[i];

		//Terminle gleich?
		if( tmp->terminal == terminal )
		{
			//gleich
			cerr << "sslr: Warning: line " << errStr->line << ": Terminal " << hash_tab->getName( terminal ) << " already used in user-defined error-action!" << endl;

			//zurück
			return( -1 );
		}
	}

	//ERRTERM_STR erzeugen und zu errStr hinzufügen

	//eine neue ERRTERM_STR anfordern
	tmp = new( ERRTERM_STR[errStr->errTermStrAnz + 1] );

	//eintragen
	tmp2 = &tmp[errStr->errTermStrAnz];
	tmp2->terminal = terminal;
	tmp2->neg = neg;

	//Inhalt kopieren
	memmove( tmp, errStr->errTermStr, sizeof( ERRTERM_STR ) * errStr->errTermStrAnz );

	//Adressen
	errStr->errTermStr = tmp;

	//Index zurückliefern
	return( errStr->errTermStrAnz++ );
}


void SSLRParser::insertStartProd( long &prod_index, long &prod2_index )
{
	//Start-Produktion eintragen
	long	hash_index;

	//EPSILON eintragen
	epsHashIndex = hash_tab->insert( "EPSILON" );

	//Ist ein Terminal
	hash_tab->setType( epsHashIndex, SSLR_TERM );

	//ACCEPT eintragen
	acceptHashIndex = hash_tab->insert( "ACCEPT" );

	//Ist ein Terminal
	hash_tab->setType( acceptHashIndex, SSLR_TERM );

	//Check-Index für LALR-Parser
	lalrHashIndex = hash_tab->insert( "LALR" );

	//Ist ein Terminal
	hash_tab->setType( lalrHashIndex, SSLR_TERM );



	//Startproduktion in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "start" );

	//Ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//Nichtterminal wird definiert
	hash_tab->setDefined( hash_index, 0 );

	//für Fehlerbehandlung merken
//	setCheck( hash_index );

	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//Hash-Index des Nichtterminals eintragen
	prod_str[prod_index].hash_index = hash_index;

	//PROD2_STR anfordern
	prod2_index = getNewProd2( prod_index );

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;
}


void SSLRParser::setCheck( long hash_index )
{
	//Hash-Index in Liste eintragen zur allgemeinen Überprüfung
	long	i, *tmp;

	//Alle durchgehen
	for( i = 0; i < anzCheck; i++ )
	{
		//Gleich?
		if( check[i] == hash_index )
			//Ja
			return;

		else if( check[i] > hash_index )
		{
			//Mehr Speicher
			tmp = new( long[anzCheck + 1] );

			//umkopieren
			memcpy( tmp, check, sizeof( long ) * i );
			tmp[i] = hash_index;
			memcpy( &tmp[i+1], &check[i], sizeof( long ) * ( anzCheck - i ) );

			//ein Eintrag mehr
			anzCheck++;

			//Speicher freigeben
			if( check )
				delete[] ( check );

			//Zeiger
			check = tmp;

			//Schleife verlassen
			break;
		}
	}

	//Leer?
	if( i == anzCheck )
	{
		//Ja, anhängen

		//Mehr Speicher
		tmp = new( long[anzCheck + 1] );

		//umkopieren
		memcpy( tmp, check, sizeof( long ) * anzCheck );
		tmp[anzCheck] = hash_index;

		//ein Eintrag mehr
		anzCheck++;

		//Speicher freigeben
		if( check )
			delete[] ( check );

		//Zeiger
		check = tmp;
	}
}


int SSLRParser::checkAllReduce( void )
{
	//prüfen, ob mit allen Alternativen reduziert wurde
	/*
		Hier wird geprüft, ob
		- jemals mit einer Alternative reduziert wird
	*/
	PROD2_STR	*pStr;
	int			i, err = 0;

	//prüfen, ob mit allen Alternativen auch reduziert wurde
	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf Struktur
		pStr = &prod2_str[i];

		//wurde reduziert?
		if( pStr->reduce <= 0 )
		{
			//Nein, Warnung ausgeben
			cerr << "sslr: ERROR: Never reduced with ";

			//rechte Seite ausgeben
			outputAlt( cerr, i );

			//Meldung
			cerr << "!" << endl;

			//Fehler
			err++;
		}
	}

	//Wenn Fehler, zurückgeben
	return( err );
}


int SSLRParser::checkAll( void )
{
	/*
		Hier wird geprüft, ob
		- (Nicht)Terminale definiert wurden
		- (Nicht)Terminale benutzt wurden
		- (Nicht)Terminale schon als Terminale benutzt wurden
		- Mehrfachdefinitionen
	*/
	char	*id[3] = { "", "Terminal", "Nonterminal" }, *name;
	int		type, i, err = 0;
	int		tc = 0, nc = 0;

	//Alle eingetragenen Elemente
	for( i = 0; i < anzCheck; i++ )
	{
		//Typ holen
		type = hash_tab->getType( check[i] );

		//Terminal?
		if( type == SSLR_TERM )
			//Ja
			tc++;

		//Nichtterminal?
		else if( type == SSLR_NTERM )
			//Ja
			nc++;

		//Name holen
		name = hash_tab->getName( check[i] );

		//Definiert?
		if( !hash_tab->getDefined( check[i] ) )
		{
			//Element wurde nicht definiert
			cerr << "sslr: Warning: " << id[type] << " " << name << " not defined!" << endl;

			//Fehler
//			err++;
		}

		//benutzt?
		if( hash_tab->getUsed( check[i] ) == false )
		{
			//Element wurde nicht benutzt
			cerr << "sslr: ERROR: " << id[type] << " " << name << " not used!" << endl;

			//Fehler
			err++;
		}

		//mehrfach benutzt?
		if( hash_tab->getDefined( check[i] ) > 1 )
		{
			//Element wurde nicht benutzt
			cerr << "sslr: ERROR: " << id[type] << " " << name << " more than once defined!" << endl;

			//Fehler
			err++;
		}

		//Produktion definiert?
		if( ( type == SSLR_NTERM ) && ( hash_tab->getProdDef( check[i] ) == false ) )
		{
			//Produktion wurde nicht definiert
			cerr << "sslr: ERROR: Production " << name << " not defined!" << endl;

			//Fehler
			err++;
		}
	}

	//Speicher für das Array für die Terminale
	termArr = new( long[tc + 1] );

	//Speicher für das Array für die Nichtterminale
	ntermArr = new( long[nc + 1] );

	//Anazhl der Einträge merken
	termArrCount = tc + 1;
	ntermArrCount = nc + 1;

	//start-Produktion als erste Produktion eintragen
	ntermArr[0] = prod_str[0].hash_index;

	//Index in der LR-Tabelle eintragen
	hash_tab->setLRTabIndex( ntermArr[0], 0 );

	//Hash-Indices aus checkArr
	for( i = 0, tc = 0, nc = 1; i < anzCheck; i++ )
	{
		//Name holen
		name = hash_tab->getName( check[i] );

		//Typ holen
		type = hash_tab->getType( check[i] );

		//Terminal?
		if( type == SSLR_TERM )
		{
			//Ja, eintragen
			termArr[tc] = check[i];

			//Index in der LR-Tabelle eintragen
			hash_tab->setLRTabIndex( check[i], tc++ );
		}

		//Nichtterminal?
		else if( type == SSLR_NTERM )
		{
			//Ja
			ntermArr[nc] = check[i];

			//Index in der LR-Tabelle eintragen
			hash_tab->setLRTabIndex( check[i], nc++ );
		}
	}

	//ACCEPT als letztes Terminal eintragen
	termArr[tc] = acceptHashIndex;

	//Index in der LR-Tabelle eintragen
	hash_tab->setLRTabIndex( acceptHashIndex, tc );

	//Wenn Fehler, zurückgeben
	return( err );
}


void SSLRParser::insertUnion( char *type, char *id )
{
	//Neuen Union-Eintrag
	char	**t1, **t2;
	int		i;

	//Speicher für die Typen
	t1 = new( char *[unionStr->anz + 1] );

	//Speicher für die Bezeichner
	t2 = new( char *[unionStr->anz + 1] );

	//kopieren
	for( i = 0; i < unionStr->anz; i++ )
	{
		//Nur die Adressen kopieren
		t1[i] = unionStr->type[i];
		t2[i] = unionStr->id[i];
	}

	//den alten Speicher freigeben
	if( unionStr->type )
		delete[] ( unionStr->type );

	if( unionStr->id )
		delete[] ( unionStr->id );

	//Speicher für neue Einträge
	t1[unionStr->anz] = new( char[strlen( type ) + 1] );
	t2[unionStr->anz] = new( char[strlen( id ) + 1] );

	//Strings kopieren
	strcpy( t1[unionStr->anz], type );
	strcpy( t2[unionStr->anz], id );

	//ein weiterer Eintrag
	unionStr->anz++;

	//Adressen kopieren
	unionStr->type = t1;
	unionStr->id = t2;
}


int SSLRParser::getSemIndex( char *name )
{
	//In name steht der Typ zur semantischen Aktion. Den Index in unionStr suchen.
	/*
		Beispiel:
			%union
			{
				int		a;
			}

		In name steht nun a, den Index in unionStr zurückliefern.
	*/
	UNION_STR	*h = unionStr;
	int			i;

	//Alle Einträge durchgehen
	for( i = 0; i < h->anz; i++ )
	{
		//Vergleichen
		if( !strcmp( h->id[i], name ) )
			//gefunden
			return( i );
	}

	//nicht gefunden
	return( -1 );
}


long SSLRParser::getNewProd( void )
{
	//PROD_STR anfordern
	PROD_STR	*tmp;

	//Speicher für PROD_STR anfordern
	tmp = new( PROD_STR[prod_anz + 1] );

	//kopieren
	memmove( tmp, prod_str, sizeof( PROD_STR ) * prod_anz );

	//alten Speicher freigeben
	if( prod_str )
		delete[] ( prod_str );

	//Adressen
	prod_str = tmp;

	//Initialisieren
	memset( &prod_str[prod_anz], 0, sizeof( PROD_STR ) );

	//Index der ersten Alternative in PROD2_STR eintragen
	prod_str[prod_anz].prod2_index = prod2_anz;

	//Index zurückliefern
	return( prod_anz++ );
}


long SSLRParser::getNewProd2( long prod_index )
{
	//PROD2_STR anfordern
	PROD2_STR	*tmp;

	//Speicher für PROD2_STR anfordern
	tmp = new( PROD2_STR[prod2_anz + 1] );

	//kopieren
	memmove( tmp, prod2_str, sizeof( PROD2_STR ) * prod2_anz );

	//alten Speicher freigeben
	if( prod2_str )
		delete[] ( prod2_str );

	//Adressen
	prod2_str = tmp;

	//Initialisieren
	memset( &prod2_str[prod2_anz], 0, sizeof( PROD2_STR ) );

	//Index der Produktion in PROD_STR
	prod2_str[prod2_anz].prod_index = prod_index;

	//zurück setzen
	prod2_str[prod2_anz].reduce = 0;

	//Index zurückliefern
	return( prod2_anz++ );
}


void SSLRParser::insertElement( long prod_index, long prod2_index, long hash_index )
{
	//Element auf der rechten Seite der Produktion eintragen
//	PROD_STR	*p1 = &prod_str[prod_index];
	PROD2_STR	*p2 = &prod2_str[prod2_index];
	long		*tmp;

	//Index der Produktion eintragen
	p2->prod_index = prod_index;

	//Speicher für die Elemente anfordern
	tmp = new( long[p2->riAnz + 1] );

	//kopieren
	memmove( tmp, p2->right, sizeof( long ) * p2->riAnz );

	//alten Speicher freigeben
	if( p2->right )
		delete[] ( p2->right );

	//Adressen
	p2->right = tmp;

	//Index des Elemente in der rechten Seite eintragen
	p2->right[p2->riAnz++] = hash_index;
}


int SSLRParser::checkErrorStr( void )
{
	//Die ERROR_STR prüfen
	ERRTERM_STR	*errTermStr;
	PROD2_STR	*p2;
	ERROR_STR	*a, *b;
	long		hashSize;
	char		*name;
	int			i, j, k, l, m, termIndex, pass = 0;
	int			*errArr1, *errArr2, errArr1Cnt = 0, errArr2Cnt = 0;
	int			*tArr, err = 0;

	//Gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		//Die Größe der Hash-Tabelle holen
		hashSize = hash_tab->getHashTabSize();

		//Speicher für die schon bereits behandelten ERROR_STR
		errArr1 = new( int[error_anz] );
		errArr2 = new( int[error_anz] );

		//Initialisieren
		memset( errArr2, 0, sizeof( int ) * error_anz );

		//Speicher für die Terminal-Prüfung
		tArr = new( int[termArrCount] );


		//Alle ERROR_STR
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			a = &error_str[i];

			//Speicher für die Terminal-Prüfung
			a->tArr = new( int[termArrCount] );

			//Array für die Prüfung der Doppeldeutigkeit bei den Terminalen
			memset( a->tArr, 0, sizeof( int ) * termArrCount );
		}


		//Alle ERROR_STR
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			a = &error_str[i];

			//Schon bearbeitet?
			if( ( errArr2Cnt ) && ( errArr2[i] ) )
				//Ja
				continue;

			//aufnehmen
			errArr1[errArr1Cnt++] = i;

			//verhindert ein doppeltes Prüfen dieser ERROR_STR
			errArr2[i] = 1;
			errArr2Cnt++;

			//Alle anderen ERROR_STR aufnehmen, die daselbe Item behandeln
			for( j = i + 1; j < error_anz; j++ )
			{
				//Zeiger auf ERROR_STR
				b = &error_str[j];

				//Gleiche Items?
				if( ( a->prod2_index == b->prod2_index ) && ( a->dot == b->dot ) )
				{
					//Ja, aufnehmen
					errArr1[errArr1Cnt++] = j;

					//verhindert ein doppeltes Prüfen dieser ERROR_STR
					errArr2[j] = 1;
					errArr2Cnt++;
				}
			}

			/*
				Zwei Passes: beim ersten werden die negierten Terminale untersucht, beim zweiten die
				nicht-negierten.
				Es werden doppelte Terminale überprüft, etc.
			*/
			pass = 0;

			//Alle ERROR_STR durchgehen
			for( k = 0, pass = 0; ( k < errArr1Cnt ) && ( pass < 2 ); k++ )
			{
				//Zeiger auf ERROR_STR
				b = &error_str[errArr1[k]];

				//mit Terminalen assoziierten Fehleraktionen?
				if( b->errTermStrAnz )
				{
					//Ja, die betreffenden Terminale eintragen
					for( l = 0; l < b->errTermStrAnz; l++ )
					{
						//Zeiger auf ERRTERM_STR holen
						errTermStr = &b->errTermStr[l];

						//nur bei Pass 1
						if( !pass )
						{
							//negiertes Terminal?
							if( errTermStr->neg )
							{
								//Namen des Terminals
								name = hash_tab->getName( errTermStr->terminal );

								//Ja, alle ausser dieses
								for( m = 0; m < termArrCount; m++ )
								{
									//Ist es das nicht-negierte Terminal?
									if( hash_tab->getLRTabIndex( errTermStr->terminal ) != m )
									{
										//schon gesetzt?
										if( b->tArr[m] != -1 )
											//Nein, setzen
											b->tArr[m] = 1;
									}

									else
										//Ist das negierte Terminal, deselektieren
										b->tArr[m] = -1;
								}
							}
						}

						//nur bei Pass 2
						else if( pass == 1 )
						{
							//Nun all die Terminale prüfen, die nicht negiert sind

							//negiertes Terminal?
							if( !errTermStr->neg )
							{
								//Nein
								termIndex = hash_tab->getLRTabIndex( errTermStr->terminal );

								//Namen des Terminals
								name = hash_tab->getName( errTermStr->terminal );

								//schon besetzt?
								if( b->tArr[termIndex] )
								{
									//Ja, Warnung ausgeben
									cerr << "sslr: ERROR: line " << b->line << ": Terminal " << hash_tab->getName( errTermStr->terminal ) << " already used in used-defined error-action!" << endl;

									//Fehler
									err++;
								}

								//setzen
								b->tArr[termIndex] = 1;
							}
						}
					}
				}

				//alle durch im ersten Pass?
				if( k == ( errArr1Cnt - 1 ) )
				{
					//Ja
					pass++;
					k = -1;
				}
			}


			/*
				Hier werden Fehlerangaben gefunden, die nie ausgeführt werden. Beim folgenden Beispiel wird
				die letzte Fehlerangabe nicht ausgeführt.
				1:!ADD:			"Fehlermeldung1"
				1:ADD			"Fehlermeldung2"
				1:SHIFT(ADD)	"Fehlermeldung3"
			*/

			//Array für die Prüfung der Doppeldeutigkeit bei den Terminalen
			memset( tArr, 0, sizeof( int ) * termArrCount );

			//Alle ERROR_STR durchgehen
			for( k = 0; k < errArr1Cnt; k++ )
			{
				//Zeiger auf ERROR_STR
				b = &error_str[errArr1[k]];

				//benutzte Terminale übertragen
				for( m = 0; m < termArrCount; m++ )
				{
					//gesetzt?
					if( b->tArr[m] > 0 )
						//Ja, übertragen
						tArr[m] = 1;
				}
			}

			//Nun stehen in tArr alle benutzten Terminale der ERROR_STR, die alle daselbe Item behandeln

			//Alle ERROR_STR durchgehen
			for( k = 0; k < errArr1Cnt; k++ )
			{
				//Zeiger auf ERROR_STR
				b = &error_str[errArr1[k]];

				//Ist es eine Fehlerangabe ohne terminal-gebundene Aktion?
				if( !b->errTermStrAnz )
				{
					//Ja, prüfen, ob sie jemals ausgeführt werden kann
					for( m = 0, l = 0; m < termArrCount; m++ )
					{
						//noch frei?
						if( !tArr[m] )
							//Ja
							l++;
					}

					//Waren noch Terminale frei?
					if( !l )
					{
						//Nein, Fehlermeldung
						cerr << "sslr: ERROR: line " << b->line << ": Error-action will never be used!" << endl;

						//Fehler
						err++;
					}
				}
			}





			//Hier wird geprüft, ob zwischen den ERROR_STR sich Terminale überschneiden.
			//Alle ERROR_STR durchgehen
			for( k = 0; k < errArr1Cnt; k++ )
			{
				//Zeiger auf ERROR_STR
				a = &error_str[errArr1[k]];

				//hat a überhaupt terminal-gebundene Fehlerangaben?
				if( !a->errTermStrAnz )
				//Nein, nächste ERROR_STR
					continue;

				//Alle anderen ERROR_STR prüfen
				for( l = k + 1; l < errArr1Cnt; l++ )
				{
					//Zeiger auf ERROR_STR
					b = &error_str[errArr1[l]];

					//sich überschneidende Terminale finden
					for( m = 0; m < termArrCount; m++ )
					{
						//In beiden ERROR_STR genutzt?
						if( ( a->tArr[m] > 0 ) && ( b->tArr[m] > 0 ) )
						{
							//Den Namen des Terminals holen
							name = hash_tab->getName( termArr[m] );

							//Meldung ausgeben
							cerr << "sslr: ERROR: line " << a->line << ": Collision in Terminal " << name << " in error-action in line " << b->line << "!" << endl;

							//Fehler
							err++;
						}
					}
				}
			}





			/*
				Hier wird geprüft, ob Fehlerangaben der folgenden Form auftauchen:

				1:SHIFT(ADD)	"Fehlermeldung 1"
				1:OVERREAD(SUB)	"Fehlermeldung 2"

				Dies geht nicht, da nicht beide Fehlermeldungen gleichzeitig ausgegeben werden, besser:
				1:SHIFT(ADD):OVERREAD(SUB)	"Fehlermeldung 1 und 2"
			*/

			//Alle ERROR_STR durchgehen
			for( k = 0; k < errArr1Cnt; k++ )
			{
				//Zeiger auf ERROR_STR
				a = &error_str[errArr1[k]];

				//hat a überhaupt terminal-gebundene Fehlerangaben?
				if( a->errTermStrAnz )
					//Ja, nächste ERROR_STR
					continue;

				//Alle anderen ERROR_STR prüfen
				for( l = k + 1; l < errArr1Cnt; l++ )
				{
					//Zeiger auf ERROR_STR
					b = &error_str[errArr1[l]];

					//hat b überhaupt terminal-gebundene Fehlerangaben?
					if( b->errTermStrAnz )
						//Ja, nächste ERROR_STR
						continue;

					//Aktionen?
					if( ( a->del || a->exit || a->overread || a->sem || a->shift ) && ( b->del || b->exit || b->overread || b->sem || b->shift  ) )
					{
						//Bei beiden eine Fehlermeldung?
						if( a->msg && b->msg )
						{
							//nicht gut
							cerr << "sslr: ERROR: line " << a->line << ": Both error-actions with an error message in line " << b->line << "!" << endl;

							//Fehler
							err++;
						}
					}
				}
			}

			//zurücksetzen
			errArr1Cnt = 0;
		}







		//Nun prüfen, ob EXIT mit etwas anderem zusammen steht
		for( k = 0, pass = 0; ( k < error_anz ) && ( pass < 2 ); k++ )
		{
			//Zeiger auf ERROR_STR
			a = &error_str[k];

			//Ist EXIT aktiviert?
			if( a->exit )
			{
				//mit SHIFT?
				if( a->shift || a->del || a->overread || a->sem )
					//unsinnig
					cerr << "sslr: Warning: line " << a->line << ": It makes no sense to use EXIT together with other user-defined error-actions!" << endl;
			}
		}






		//Nun prüfen, ob eine Fehlerangabe jemals ausgeführt wird
		for( k = 0, pass = 0; ( k < error_anz ) && ( pass < 2 ); k++ )
		{
			//Zeiger auf ERROR_STR
			a = &error_str[k];

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[a->prod2_index];

			//Ist die Position des Punktes zu groß?
			if( a->dot > p2->riAnz )
			{
				//wird niemals ausgeführt
				cerr << "sslr: ERROR: line " << a->line << ": Position of dot " << a->dot << " to big!" << endl;

				//Fehler
				err++;
			}
		}



		//Speicher freigeben
		delete[] ( errArr1 );
		delete[] ( errArr2 );
		delete[] ( tArr );
	}

	//Anzahl der Fehler zurückgeben
	return( err );
}


void SSLRParser::sortProd2Str( void )
{
	//Die PROD2_STR sortieren
	PROD2_STR	*a, *b, *source, *dest, tmp;
	PROD_STR	*p1;
	char		*name1, *name2;
	int			i, j, k, anz;

	//Initialisieren
	i = 0;

	//alle Alternativen
	while( i < ( prod2_anz - 1 ) )
	{
		//Zeiger auf PROD2_STR
		a = &prod2_str[i];

		//Den Namen holen
		name1 = hash_tab->getName( prod_str[a->prod_index].hash_index );

		//Index
		j = i++;

		do
		{
			//nächsten
			j++;

			//Zeiger auf PROD2_STR
			b = &prod2_str[j];

			//Zeiger auf PROD_STR
			p1 = &prod_str[b->prod_index];

			//Den Namen holen
			name2 = hash_tab->getName( p1->hash_index );

		}while( ( a->prod_index == b->prod_index ) && ( j < ( prod2_anz - 1 ) ) );

		//Alle Alternativen
		for( k = j++; j < prod2_anz; j++ )
		{
			//Zeiger auf PROD2_STR
			b = &prod2_str[j];

			//Den Namen holen
			name2 = hash_tab->getName( prod_str[b->prod_index].hash_index );

			//gleiche Produktionen, d.h. prod_index gleich?
			if( a->prod_index == b->prod_index )
			{
				//Ja

				//Zeiger auf PROD2_STR
				source = &prod2_str[j];

				//Zeiger auf PROD2_STR
				dest = &prod2_str[k];

				//j sichern
				tmp.prod_index = source->prod_index;
				tmp.riAnz = source->riAnz;
				tmp.right = source->right;
				tmp.priority = source->priority;
				tmp.semAct = source->semAct;
				tmp.semActLine = source->semActLine;

				//verschieben
				memmove( &prod2_str[k+1], &prod2_str[k], sizeof( PROD2_STR ) * ( j - k ) );

				//eintragen
				dest->prod_index = tmp.prod_index;
				dest->riAnz = tmp.riAnz;
				dest->right = tmp.right;
				dest->priority = tmp.priority;
				dest->semAct = tmp.semAct;
				dest->semActLine = tmp.semActLine;

				//nächste Position
				k++;
			}
		}

		//ab k + 1
		i = k;
	}

	//Indices anpassen
	for( i = 0, k = 0; i < prod_anz; i++ )
	{
		//Anzahl der Alternativen
		anz = prod_str[i].altAnz;

		//prod2_index anpassen
		prod_str[i].prod2_index = k;

		//Alle zugehörigen Alternativen
		for( j = k; j < ( k + anz ); j++ )
			//PROD_STR-Index eintragen
			prod2_str[j].prod_index = i;

		//überspringen
		k += anz;
	}
}


void SSLRParser::outputGrammar( void )
{
	//Grammatik in Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name;
	int			i, j, k, r;

	//Grammatik in Datei ausgeben?
	if( argv_str->outputGrammar )
	{
		//Stream öffnen
		ofstream	out( argv_str->name );

		//Header ausgeben
		out << "/*\n";
		out << "Grammatik in BNF-Form. Generiert vom SSLR-Parser-Generator V" << VERSION << ".\n";
		out << "(c) 2002-2005 by Sven Schmidt\n";
		out << "s.schmidt@lboro.ac.uk\n";
		out << "*/\n\n";

		//Alle Produktionen
		for( i = 1; i < prod_anz; i++ )
		{
			//Zeiger auf die PROD_STR holen
			p1 = &prod_str[i];

			//Den Namen der Produktion holen
			name = hash_tab->getName( p1->hash_index );

			//Produktion ausgeben
			out << name << "\n";

			//Seperator ausgeben
			out << "\t->\t";

			//alle Alternativen ausgeben
			for( j = p1->prod2_index, k = 0; j < ( p1->prod2_index + p1->altAnz ); j++, k++ )
			{
				//Zeiger auf die PROD2_STR holen
				p2 = &prod2_str[j];

				//neue Alternative?
				if( k )
					//Ja
					out << "\t|\t";

				//rechte Seite ausgeben
				for( r = 0; r < p2->riAnz; r++ )
				{
					//Namen holen
					name = hash_tab->getName( p2->right[r] );

					//Terminal?
					if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
						//Ja
						out << " '" << name << "' ";

					else
						//Nichtterminal
						out << " " << name << " ";
				}

				//Priorität ausgeben
				out << "\t/* Priority: " << p2->priority << " */\n";
			}

			//Produktion abschliessen
			out << "\t;\n\n";
		}
	}
}


void SSLRParser::outputAlt( ostream &s, long prod2_index )
{
	//Alle Alternativen der Produktion ausgeben, zu der die Alternative prod2_index gehört
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	s << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//Ja
			s << " '" << name << "' ";

		else
			//Nichtterminal
			s << " " << name << " ";
	}

	//nächste Zeile
	s << "\n";
}


void SSLRParser::outputItem( long prod2_index, int dot, ofstream &file )
{
	//Ein Item ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	file << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Position des Punktes?
		if( dot == r )
			//Ja
			file << ".";

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//Ja
			file << " '" << name << "' ";

		else
			//Nichtterminal
			file << " " << name << " ";
	}

	//Position des Punktes?
	if( dot == r )
		//Ja
		file << ".";
}


void SSLRParser::outputAllAlt( void )
{
	//Alle Alternativen ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	ofstream	out( argv_str->name );
	char		*name;
	int			j, r;

	//alle Alternativen ausgeben
	for( j = 0; j < prod2_anz; j++ )
	{
		//Zeiger auf die PROD2_STR holen
		p2 = &prod2_str[j];

		//Zeiger auf die PROD_STR holen
		p1 = &prod_str[p2->prod_index];

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//ausgeben
		out << " " << name << " -> ";

		//rechte Seite ausgeben
		for( r = 0; r < p2->riAnz; r++ )
		{
			//Namen holen
			name = hash_tab->getName( p2->right[r] );

			//Terminal?
			if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
				//Ja
				out << " '" << name << "' ";

			else
				//Nichtterminal
				out << " " << name << " ";
		}

		//nächste Zeile
		out << "\n";
	}
}


void SSLRParser::genAllFirst( void )
{
	//Alle FIRST-Mengen bilden
	PROD2_STR	*p2;
	PROD_STR	*p1;
	Terminal	*f1;
	long		anzFirst;
	char		*name;
	int			i, j, changed;
	int			pass = 0;
	int			*pArr;

	//keine doppelten Ausgaben
	pArr = new( int[prod_anz] );

	//Initialisieren
	memset( pArr, 0, sizeof( int ) * prod_anz );

	do
	{
		//prüft, ob weitere Terminale zur FIRST-Menge hinzugefügt wurden
		changed = 0;

		//ein weiterer Pass
		pass++;

		//alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//ausführliche Ausgaben?
			if( ( argv_str->verbose ) && !( pArr[i] ) )
			{
				//ja
				cout << "sslr: Generate FIRST(" << name << ")..." << endl;

				//Meldung nicht nocheinmal ausgeben
				pArr[i]++;
			}

			//Anzahl der FIRST-Elemente holen
			anzFirst = hash_tab->getFirstAnz( p1->hash_index );

			//Zeiger auf FIRST-Mengen holen
			f1 = hash_tab->getFirst( p1->hash_index );

			//Alle Alternativen
			for( j = p1->prod2_index; j < ( p1->prod2_index + p1->altAnz ); j++ )
			{
				//Zeiger auf PROD2_STR
				p2 = &prod2_str[j];

				//FIRST-Menge berechnen
				genFirst( f1, p2->riAnz, p2->right );
			}

			//geändert?
			if( anzFirst != hash_tab->getFirstAnz( p1->hash_index ) )
				//Ja
				changed++;
		}

	}while( changed );

	//Speicher wieder freigeben
	delete[] ( pArr );

	//ausführliche Ausgaben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate FIRST-Sets!" << endl;

	//FIRST-Mengen ausgeben?
	if( argv_str->showFirst )
	{
		//Alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//Ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//Meldung
			cout << "\nFIRST(" << name << ")=" << endl;

			//FIRST-Menge ausgeben
			hash_tab->printFirst( p1->hash_index );
		}
	}
}


void SSLRParser::genFirst( Terminal *f, int anzElem, long *arr )
{
	//Hier werden die FIRST-Mengen eines Terminals/Nichtterminals erzeugt
	Terminal	*f2, *f3;
	char		*name;
	int			i, eps = 0;

	//für jeden Durchgang eine eigene FIRST-Menge
	f3 = new Terminal( epsHashIndex );

	//Gibt es überhaupt noch Elemente
	if( anzElem > 0 )
	{
		//Alle Elemente
		for( i = 0; i < anzElem; i++ )
		{
			//Namen holen
			name = hash_tab->getName( arr[i] );

			//Zeiger auf die FIRST-Menge holen
			f2 = hash_tab->getFirst( arr[i] );

			//hinzufügen
			f3->add( f2 );

			//beinhaltet die FIRST-Menge EPSILON?
			if( f2->isEpsilon() )
				//Ja, hochzählen
				eps++;

			else
				//Nein, for-Schleife verlassen
				break;
		}

		//Epsilon zu dieser Menge hinzufügen?
		if( eps && ( eps < anzElem ) )
		{
			//Nein, aus der FIRST-Menge löschen

			//EPSILON aus FIRST-Menge löschen
			f3->del( epsHashIndex );
		}
	}

	else
		//leere Menge, EPSILON hinzufügen
		f3->ins( epsHashIndex );

	//FIRST-Menge hinzufügen
	f->add( f3 );

	//Speicher freigeben
	delete( f3 );
}


void SSLRParser::genAllFollow( void )
{
	//Alle FOLLOW-Mengen bilden
	PROD2_STR	*p2;
	PROD_STR	*p1, *p3;
	Terminal	*f1, *f2, *first;
	long		anzFollow;
	char		*name, *tmpName;
	int			i, j, r, changed;
	int			pass = 0;
	int			*pArr;

	//keine doppelten Ausgaben
	pArr = new( int[prod_anz] );

	//Initialisieren
	memset( pArr, 0, sizeof( int ) * prod_anz );

	//ACCEPT in die Start-Produktion aufnehmen
	f1 = hash_tab->getFollow( prod_str[0].hash_index );

	//ACCEPT eintragen
	f1->ins( acceptHashIndex );

	do
	{
		//prüft, ob weitere Terminale zur FOLLOW-Menge hinzugefügt wurden
		changed = 0;

		//ein weiterer Pass
		pass++;

		//alle Produktionen
		for( i = 1; i < prod_anz; i++ )
		{
			//nein, Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//ausführliche Ausgaben?
			if( ( argv_str->verbose ) && !( pArr[i] ) )
			{
				//ja
				cout << "sslr: Generate FOLLOW(" << name << ")..." << endl;

				//Meldung nicht nocheinmal ausgeben
				pArr[i]++;
			}

			//Anzahl der FOLLOW-Elemente holen
			anzFollow = hash_tab->getFollowAnz( p1->hash_index );

			//Zeiger auf FOLLOW-Mengen holen
			f1 = hash_tab->getFollow( p1->hash_index );

			//Alle Alternativen
			for( j = 0; j < prod2_anz; j++ )
			{
				//Zeiger auf PROD2_STR
				p2 = &prod2_str[j];

//Debug-Modus?
#ifdef SSLR_DEBUG
				//Alternative ausgeben
				outputAlt( j );
#endif

				//Nichtterminal check[i] auf rechter Seite suchen
				for( r = 0; r < p2->riAnz; r++ )
				{
					//Name holen
					tmpName = hash_tab->getName( p2->right[r] );

					//Gefunden?
					if( p2->right[r] == p1->hash_index )
					{
						//FIRST-Mengen bilden
						first = new Terminal( epsHashIndex );

						//FIRST-Mengen bilden
						genFirst( first, p2->riAnz - r - 1, &p2->right[r+1] );

						//EPSILON in FIRST-Menge?
						if( first->isEpsilon() )
						{
							//Ja, Zeiger auf PROD_STR
							p3 = &prod_str[p2->prod_index];

							//Namen holen
							tmpName = hash_tab->getName( p3->hash_index );

//							cerr << "FOLLOW(" << name << ") += FOLLOW(" << tmpName << ")" << endl;

							//Ja, FOLLOW(p2->prodindex) = FOLLOW(check[i])
							f2 = hash_tab->getFollow( p3->hash_index );

							//hinzufügen
							f1->add( f2 );

							//EPSILON aus FIRST-Menge löschen
							first->del( epsHashIndex );
						}

						//hinzufügen
						f1->add( first );

						//FIRST-Mengen löschen
						delete( first );
					}
				}
			}

			//geändert?
			if( anzFollow != hash_tab->getFollowAnz( p1->hash_index ) )
				//Ja
				changed++;
		}

	}while( changed );

	//Speicher wieder freigeben
	delete[] ( pArr );

	//ausführliche Ausgaben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate FOLLOW-Sets!" << endl;

	//FOLLOW-Mengen ausgeben?
	if( argv_str->showFollow )
	{
		//Alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//Ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//Meldung
			cout << "\nFOLLOW(" << name << ")=" << endl;

			//FOLLOW-Menge ausgeben
			hash_tab->printFollow( p1->hash_index );
		}
	}
}


void SSLRParser::genLR0Hulle( void )
{
	//Generiere alle Hüllen der LR(0)-Elemente für SLR und LALR
	HULLE_STR	*h;
	int			changed = 0, pass = 0, i;

	//1. Hülle generieren
	h = createHulle();

	//ersten Kern eintragen
	insertItem( h, 0, 0, CORE );

	//Hülle eintragen
	insertHulle( h );

	//Wurde nicht durch Sprung-Funktion erzeugt
	h->from = 0;
	h->elem = 0;

	//bei Hülle 0 anfangen
	i = 0;

	do
	{
		//Passe zählen
		pass++;

		//Keine Änderungen
//		changed = 0;

		//Anzahl der Hüllen merken
//		anzH = hulle_anz;

		//Alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf Hülle
			h = hulle_str[i];

			//Alle Elemente dieser Hülle erzeugen
			genLR0Items( h );

			//Ausgeben
//			outputHulle( h );

			//Anhand der Items die Hüllen erzeugen, die sich durch Spring( h, X ) ergeben
			makeLR0Jump( h );
/*
			//Anzahl der Hüllen geändert?
			if( hulle_anz != anzH )
				//Ja
				changed++;
*/
		}

	}while( changed );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate " << hulle_anz << " LR(0)-Items!" << endl;
}


void SSLRParser::genLR1Hulle( void )
{
	//Generiere alle Hüllen der LR(1)-Elemente für LR
	HULLE_STR	*h;
	Terminal	*la;
	int			changed = 0, pass = 0, i;

	//1. Hülle generieren
	h = createHulle();

	//Speicher für die Lookaheads
	la = new Terminal( epsHashIndex );

	//Accept eintragen
	la->ins( acceptHashIndex );

	//ersten Kern eintragen
	insertItem( h, 0, 0, CORE, la );

	//Hülle eintragen
	insertHulle( h );

	//Wurde nicht durch Sprung-Funktion erzeugt
	h->from = 0;
	h->elem = 0;

	//bei Hülle 0 anfangen
	i = 0;

	do
	{
		//Passe zählen
		pass++;

		//Keine Änderungen
//		changed = 0;

		//Anzahl der Hüllen merken
//		anzH = hulle_anz;

		//Alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf Hülle
			h = hulle_str[i];

			//Alle Elemente dieser Hülle erzeugen
			genLR1Items( h );

			//Ausgeben
//			outputHulle( h );

			//Anhand der Items die Hüllen erzeugen, die sich durch Spring( h, X ) ergeben
			makeLR1Jump( h );
/*
			//Anzahl der Hüllen geändert?
			if( hulle_anz != anzH )
				//Ja
				changed++;
*/
		}

	}while( changed );

	//Speicher freigeben
	delete( la );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//Ja
		cout << "sslr: " << pass << " pass(es) to generate " << hulle_anz << " LR(1)-Items!" << endl;
}


void SSLRParser::makeLR0Jump( HULLE_STR *h )
{
	//Hier werden die Hüllen erzeugt, die sich durch Sprung( h, X ) ergeben
	HULLE_STR	*tmp;
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	long		elem, hInd;
	int			i;

	//Alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Punkt eine Position weiter und Element eintragen

			//Das (Nicht)Terminal holen, das nach dem Punkt kommt
			/*
				Bsp: expr
							->	.expr ADD expr
							|	.expr SUB expr
							|	term
							;

				Hier also ist expr vor dem Punkt.
			*/
			elem = p2->right[lr->dot];

			/*
				Die hier erzeugte Hülle ergibt sich also aus:

				tmp = Sprung( h, elem )
			*/

			//darf nicht .EPSILON sein
			if( elem != epsHashIndex )
			{
				//Den Namen holen
				name = hash_tab->getName( elem );

				//Hülle anfordern
				tmp = createHulle();

				//Hülle erzeugen
				genLR0Jump( h, tmp, elem );

				//Hülle schon in hulle_str?
				if( ( hInd = cmpLR0Hulle( tmp ) ) < 0 )
				{
					//Nein

					// this = Sprung( h, elem ) merken
					tmp->from = h->hulleIndex;
					tmp->elem = elem;

					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hulle_anz );

					//Meldung ausgeben?
					if( argv_str->verbose )
						//Ja
						cout << "sslr: Generate Jump(" << name << ")..." << endl;

					//Hülle eintragen
					insertHulle( tmp );

					//Ausgeben
//					outputHulle( tmp );
				}

				else
				{
					//Die Hülle existiert schon
					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hInd );

					//Hülle löschen
					deleteHulle( tmp );
				}
			}
		}
	}
}


void SSLRParser::makeLR1Jump( HULLE_STR *h )
{
	//Hier werden die Hüllen erzeugt, die sich durch Sprung( h, X ) ergeben
	HULLE_STR	*tmp;
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	long		elem, hInd;
	int			i;

	//Alle LR(1)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Punkt eine Position weiter und Element eintragen

			//Das (Nicht)Terminal holen, das nach dem Punkt kommt
			/*
				Bsp: expr
							->	.expr ADD expr
							|	.expr SUB expr
							|	.term
							;

				Hier sind expr und term vor dem Punkt.
			*/
			elem = p2->right[lr->dot];

			/*
				Die hier erzeugte Hülle ergibt sich also aus:

				tmp = Sprung( h, elem )
			*/

			//darf nicht .EPSILON sein
			if( elem != epsHashIndex )
			{
				//Den Namen holen
				name = hash_tab->getName( elem );

				//Hülle anfordern
				tmp = createHulle();

				//Hülle erzeugen
				genLR1Jump( h, tmp, elem );

				//Hülle schon in hulle_str?
				if( ( hInd = cmpLR1Hulle( tmp ) ) < 0 )
				{
					//Nein

					// this = Sprung( h, elem ) merken
					tmp->from = h->hulleIndex;
					tmp->elem = elem;

					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hulle_anz );

					//Meldung ausgeben?
					if( argv_str->verbose )
						//Ja
						cout << "sslr: " << hulle_anz << " Generate Jump(" << h->hulleIndex << ", " << name << ")..." << endl;

					//Hülle eintragen
					insertHulle( tmp );

					//Ausgeben
//					outputHulle( tmp );
				}

				else
				{
					//Die Hülle existiert schon
					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hInd );

					//Hülle löschen
					deleteHulle( tmp );
				}
			}
		}
	}
}


void SSLRParser::genLR0Items( HULLE_STR *h )
{
	//Hier werden alle LR(0)-Items einer Hülle erzeugt.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr;
	char		*name, *tmpName;
	long		pi;
	int			j, k;

	//Alle Elemente dieser Hülle
	for( j = 0; j < h->anzElem; j++ )
	{
		/*
			Bsp:	expr	->	.expr ADD expr
							|	.expr SUB expr
							|	.term
		*/
		//Index der ersten Alternative der Produktion nach dem Punkt holen

		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[j];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Namen holen
			name = hash_tab->getName( p2->right[lr->dot] );

			//Ist es ein Nichtterminal?
			if( hash_tab->getType( p2->right[lr->dot] ) == SSLR_NTERM )
			{
				//Ja, diese Produktion als Elemente mit dot = 0 aufnehmen

				//prod_index dieses Nichtterminals
				pi = hash_tab->getProdStr( p2->right[lr->dot] );

				//Zeiger auf PROD_STR
				p1 = &prod_str[pi];

				//Namen holen
				tmpName = hash_tab->getName( p1->hash_index );

				//Index der ersten Alternative in der PROD2_STR
				for( k = p1->prod2_index; k < ( p1->prod2_index + p1->altAnz ); k++ )
					//Als LR(0)-Item hinzufügen
					insertItem( h, k, 0, ITEM );
			}
		}
	}
}


void SSLRParser::genLR1Items( HULLE_STR *h )
{
	//Hier werden alle LR(1)-Items einer Hülle erzeugt.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr, *lr2;
	Terminal	*la;
	char		*name, *tmpName;
	long		pi, cInd;
	int			j, k, changed, anzElem;

	do
	{
		//solange etwas hinzugefügt wurde
		changed = 0;

		//Alle Elemente dieser Hülle
		for( j = 0; j < h->anzElem; j++ )
		{
			/*
				Bsp:	expr	->	.expr ADD expr
								|	.expr SUB expr
								|	.term
			*/
			//Index der ersten Alternative der Produktion nach dem Punkt holen

			//Zeiger auf LR(0)-Element
			lr = &h->lr_str[j];

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[lr->prod2_index];

			//Ist der Punkt am Ende?
			if( lr->dot < p2->riAnz )
			{
				//Namen holen
				name = hash_tab->getName( p2->right[lr->dot] );

				//Ist es ein Nichtterminal?
				if( hash_tab->getType( p2->right[lr->dot] ) == SSLR_NTERM )
				{
					//Ja, diese Produktion als Elemente mit dot = 0 aufnehmen

					//prod_index dieses Nichtterminals
					/*
						Bsp:
							term	->	.term MUL factor

						Also PROD_STR-Index von term
					*/
					pi = hash_tab->getProdStr( p2->right[lr->dot] );

					//Zeiger auf PROD_STR
					p1 = &prod_str[pi];

					//Namen holen
					tmpName = hash_tab->getName( p1->hash_index );

					//Speicher für die Lookaheads holen
					la = new Terminal( epsHashIndex );

					//FIRST-Menge bilden nach dot
					genFirst( la, p2->riAnz - lr->dot - 1, &p2->right[lr->dot + 1] );

					//EPSILON in FIRST-Menge?
					if( la->isEpsilon() )
					{
						//Ja, alle Lookaheads des LR(1)-Items hinzufügen
						la->add( lr->la );

						//EPSILON aus FIRST-Menge löschen
						la->del( epsHashIndex );
					}

					//Index der ersten Alternative in der PROD2_STR
					for( k = p1->prod2_index; k < ( p1->prod2_index + p1->altAnz ); k++ )
					{
						//Ist dieses Item schon in der Hülle, also nur die Lookaheads ergänzen?
						if( ( cInd = findItem( h, k, 0 ) ) < 0 )
							//Nein, noch nicht da, als LR(1)-Item hinzufügen
							insertItem( h, k, 0, ITEM, la );

						else
						{
							//Ja, Item schon da

							//Zeiger auf Item
							lr2 = &h->lr_str[cInd];

							//Anzahl der Lookaheads merken
							anzElem = lr2->la->getAnzElem();

							//Lookaheads ergänzen
							insertItem( h, k, 0, ITEM, la );

							//Wurden Terminale hinzugefügt?
							if( anzElem != lr2->la->getAnzElem() )
								//Ja
								changed++;


							/*

								statement_list
									:	statement
									|	statement_list statement
									;

								Wegen solchen Produktionen muss man mehrmals über die Items hinweggehen,
								da im zweiten Schritt .statement_list statement FIRST(statement)
								als Lookaheads hinzukommt, die im ersten Schritt .statement nicht
								erfasst wurden!
							*/
						}
					}

					//Speicher wieder freigeben
					delete( la );
				}
			}
		}

		//Solange Änderungen vorgenommen wurden

	}while( changed );
}


SSLRParser::HULLE_STR *SSLRParser::createHulle( void )
{
	//Eine HULLE_STR-Struktur erzeugen
	HULLE_STR	*h;

	//Speicher anfordern
	h = new HULLE_STR;

	//Initailisieren
	h->anzCore = 0;
	h->anzElem = 0;
	h->lr_str = 0;

	//Zeiger auf Hülle zurückliefern
	return( h );
}


void SSLRParser::deleteHulle( HULLE_STR *h )
{
	//Eine HULLE_STR-Struktur löschen
	LR_STR	*lr;
	int		i;

	//Alle Elemente einer Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0/1)-Item
		lr = &h->lr_str[i];

		//Lookahead-Terminale freigeben
		if( lr->la )
			delete( lr->la );

		//Lookahead-Terminale freigeben
		if( lr->lalr )
			delete( lr->lalr );
	}

	//LR_STR freigeben
	delete[] ( h->lr_str );

	//HULLE_STR löschen
	delete( h );
}


void SSLRParser::delHulle( HULLE_STR *h )
{
	//Hülle löschen
	int	i;

	//Alle Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Terminale freigeben
		if( h->lr_str[i].la )
		{
			delete( h->lr_str[i].la );
			h->lr_str[i].la = 0L;
		}

		//Lookaheads freigeben
		if( h->lr_str[i].lalr )
		{
			delete( h->lr_str[i].lalr );
			h->lr_str[i].lalr = 0L;
		}
	}

	//Item-Struktur freigeben
	delete[] ( h->lr_str );

	//zurücksetzen
	h->lr_str = 0L;

	//Speicher freigeben
	delete( h );
}


void SSLRParser::insertItem( HULLE_STR *h, long prod2_index, int dot, int type )
{
	//LR(0)-Element in HULLE h eintragen
	LR_STR	*tmp;

	//Item schon enthalten?
	if( findItem( h, prod2_index, dot ) < 0 )
	{
		//Nein, Speicher für das LR(0)-Element
		tmp = new( LR_STR[h->anzElem + 1] );

		//kopieren
		memmove( tmp, h->lr_str, sizeof( LR_STR ) * h->anzElem );

		//Alten Speicher freigeben
		if( h->lr_str )
			delete[] ( h->lr_str );

		//Zeiger
		h->lr_str = tmp;

		//eintragen
		h->lr_str[h->anzElem].dot = dot;
		h->lr_str[h->anzElem].prod2_index = prod2_index;

		//Keine Lookaheads
		h->lr_str[h->anzElem].la = new Terminal( epsHashIndex );

		//Lookaheads eintragen
		h->lr_str[h->anzElem++].lalr = new Terminal( epsHashIndex );

		//ein weiterer Kern hinzugefügt?
		if( type == CORE )
			//Ja
			h->anzCore++;

		//Warnung?
		if( ( type == CORE ) && ( h->anzElem > h->anzCore ) )
			cerr << "sslr: SSLRParser::insertItem: Es wurde ein Kern eingetragen, obwohl schon alle Items berechnet sein sollten!" << endl;
	}
}


void SSLRParser::insertItem( HULLE_STR *h, long prod2_index, int dot, int type, Terminal *la )
{
	//LR(1)-Element in HULLE h eintragen
	LR_STR	*tmp;
	long	hInd;

	//Item schon enthalten?
	if( ( hInd = findItem( h, prod2_index, dot ) ) < 0 )
	{
		//Nein, Speicher für das LR(1)-Element
		tmp = new( LR_STR[h->anzElem + 1] );

		//kopieren
		memmove( tmp, h->lr_str, sizeof( LR_STR ) * h->anzElem );

		//Alten Speicher freigeben
		if( h->lr_str )
			delete[] ( h->lr_str );

		//Zeiger
		h->lr_str = tmp;

		//eintragen
		h->lr_str[h->anzElem].dot = dot;
		h->lr_str[h->anzElem].prod2_index = prod2_index;

		//Lookaheads eintragen
		h->lr_str[h->anzElem].la = new Terminal( epsHashIndex );
		h->lr_str[h->anzElem].la->add( la );

		//keine Lookahead-Terminale
		h->lr_str[h->anzElem++].lalr = 0L;

		//ein weiterer Kern hinzugefügt?
		if( type == CORE )
			//Ja
			h->anzCore++;

		//Warnung?
		if( ( type == CORE ) && ( h->anzElem > h->anzCore ) )
			cerr << "sslr: SSLRParser::insertItem: Es wurde ein Kern eingetragen, obwohl schon alle Items berechnet sein sollten!" << endl;
	}

	else
	{
		//Item schon in der Hülle enthalten, also nur die Lookaheads la hinzufügen
		tmp = &h->lr_str[hInd];

		//Lookaheads hinzufügen
		tmp->la->add( la );
	}
}


int SSLRParser::cmpLR0Hulle( HULLE_STR *h )
{
	//Prüft, ob die Hülle h schon in hulle_str enthalten ist
	HULLE_STR	*tmp;
	LR_STR		*lr;
	int			i, j, elemCnt = 0;
	int			anzCore = h->anzCore, cInd;

	//Alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zähler
		elemCnt = 0;

		//Zeiger auf Hülle
		tmp = hulle_str[i];

		//Anzahl der Items gleich?
		if( ( h->anzElem == tmp->anzElem ) && ( h->anzCore == tmp->anzCore ) )
		{
			//Alle LR(0)-Kerne von tmp
			for( j = 0; j < tmp->anzCore; j++ )
			{
				//Zeiger auf LR(0)-Item
				lr = &tmp->lr_str[j];

				//Item in h enthalten?
				if( ( cInd = findItem( h, lr->prod2_index, lr->dot ) ) < 0 )
					//Nein
					break;

				//Ist es ein Kern-Item von h?
				else if( cInd <= ( anzCore - 1 ) )
					//Ja
					elemCnt++;
			}

			//gefunden?
			if( elemCnt == anzCore )
				//Ja
				break;
		}
	}

	//h noch nicht in hulle_str enthalten
	return( anzCore == elemCnt ? i : -1 );
}


int SSLRParser::cmpLR1Hulle( HULLE_STR *h )
{
	//Prüft, ob die Hülle h schon in hulle_str enthalten ist
	HULLE_STR	*tmp;
	LR_STR		*lr;
	int			i, j, elemCnt = 0;
	int			anzCore = h->anzCore, cInd;

	//Alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zähler
		elemCnt = 0;

		//Zeiger auf Hülle
		tmp = hulle_str[i];

		//Anzahl der Items gleich?
		if( ( h->anzElem == tmp->anzElem ) && ( h->anzCore == tmp->anzCore ) )
		{
			//Alle LR(1)-Kerne
			for( j = 0; j < tmp->anzCore; j++ )
			{
				//Zeiger auf LR(0)-Item
				lr = &tmp->lr_str[j];

				//Item in h enthalten?
				if( ( cInd = findItem( h, lr->prod2_index, lr->dot, lr->la ) ) < 0 )
					//Nein
					break;

				//Ist es ein Kern-Item von h?
				else if( cInd <= ( anzCore - 1 ) )
					//Ja
					elemCnt++;
			}

			//gefunden?
			if( elemCnt == anzCore )
				//Ja
				break;
		}
	}

	//h noch nicht in hulle_str enthalten
	return( anzCore == elemCnt ? i : -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index, int dot )
{
	//Prüft, ob in h der Kern schon enthalten ist
	LR_STR	*lr;
	int		i;

	//Alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Item
		lr = &h->lr_str[i];

		//gleich?
		if( ( prod2_index == lr->prod2_index ) && ( dot == lr->dot ) )
			//Ja
			return( i );
	}

	//Nicht enthalten
	return( -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index, int dot, Terminal *la )
{
	//Prüft, ob in h der LR(1)-Kern schon enthalten ist
	LR_STR	*lr;
	int		i;

	//Alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Item
		lr = &h->lr_str[i];

		//gleich?
		if( ( prod2_index == lr->prod2_index ) && ( dot == lr->dot ) && ( lr->la->cmp( la ) ) )
			//Ja
			return( i );
	}

	//Nicht enthalten
	return( -1 );
}


void SSLRParser::outputHulle ( HULLE_STR *h )
{
	//Eine Hülle ausgeben
	Terminal	*la;
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr;
	char		*name = "";
	long		*tArr, *nArr, elem, LRTabIndex;
	int			i, r, v, anz, typ;
	bool		draw;

	//Namen der Produktion holen
	name = hash_tab->getName( h->elem );

	//erster name ist leer
	if( name )
		//ausgeben
		cout << "\n\nHülle " << h->hulleIndex << " = Sprung( " << h->from << ", " << name << " )" << endl;

	else
		//ohne "Vererbung"
		cout << "\n\nHülle " << h->hulleIndex << endl;

	//Alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Kern?
		if( i < h->anzCore )
			//Ja
			cout << "Kern:\t";

		else
			//Kein Kern-Element
			cout << "     \t";

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//ausgeben
		cout << " " << name << " -> ";

		//rechte Seite ausgeben
		for( r = 0; r < p2->riAnz; r++ )
		{
			//Position des Punktes?
			if( lr->dot == r )
				//Ja
				cout << ".";

			//Namen holen
			name = hash_tab->getName( p2->right[r] );

			//Terminal?
			if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
				//Ja
				cout << " '" << name << "' ";

			else
				//Nichtterminal
				cout << " " << name << " ";
		}

		//Position des Punktes?
		if( lr->dot == r )
			//Ja
			cout << ".";

		//Lookaheads ausgeben?
		if( lr->la )
		{
			//Ja, Lookaheads ausgeben
			la = lr->la;

			//Anzahl der Lookaheads
			anz = lr->la->getAnzElem();

			//Alle Lookaheads ausgeben
			for( v = 0; v < anz; v++ )
				//Terminal ausgeben
				cout << "," << hash_tab->getName( (*la)[v] );
		}

		//nächste Zeile
		cout << endl;
	}

	//Alle Sprung-Übergänge nur einmal zeigen
	tArr = new( long[termArrCount + 1] );
	nArr = new( long[ntermArrCount] );

	//initialisieren
	memset( tArr, 0, sizeof( long ) * ( termArrCount + 1 ) );
	memset( nArr, 0, sizeof( long ) * ( ntermArrCount ) );

	//Alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Position des Punktes?
		if( lr->dot < p2->riAnz )
		{
			//Sprung-Hülle ausgeben
			elem = p2->right[lr->dot];

			//Index des Element in der LR-Tabelle
			LRTabIndex = hash_tab->getLRTabIndex( elem );

			//Namen holen
			name = hash_tab->getName( elem );

			//Typ holen
			typ = hash_tab->getType( elem );

			//Terminal?
			if( typ == SSLR_TERM )
			{
				//hinter dem Punkt folgt ein Terminal
				if( tArr[LRTabIndex] )
					//wurde schon ausgegeben
					draw = false;

				else
				{
					//ausgeben
					draw = true;

					//markieren, damit es nicht mehr ausgegeben wird
					tArr[LRTabIndex]++;
				}
			}

			else
			{
				//hinter dem Punkt folgt ein Nichtterminal
				if( nArr[LRTabIndex] )
					//wurde schon ausgegeben
					draw = false;

				else
				{
					//ausgeben
					draw = true;

					//markieren, damit es nicht mehr ausgegeben wird
					nArr[LRTabIndex]++;
				}
			}

			//Epsilon?
			if( ( draw == true ) && ( p2->right[lr->dot] != epsHashIndex ) )
				//Jump ausgeben
				cout << "Sprung(" << name << ") = " << lr->jumpTo << endl;
		}
	}

	//Speicher freigeben
	delete[] ( tArr );
	delete[] ( nArr );

	//nächste Zeile
	cout << endl << endl;
}


void SSLRParser::insertHulle( HULLE_STR *h )
{
	//Eine Hülle in die Sammlung von Elementen eintragen.
	HULLE_STR	**tmp;

	//Hülle schon eingetragen?
//	if( cmpLR0Hulle( h ) == -1 )
	{
		//Speicher anfordern
		tmp = new( HULLE_STR *[hulle_anz + 1] );

		//kopieren
		memmove( tmp, hulle_str, sizeof( HULLE_STR * ) * hulle_anz );

		//Alten Speicher freigeben
		if( hulle_str )
			delete[] ( hulle_str );

		//Zeiger
		hulle_str = tmp;

		//eintragen
		hulle_str[hulle_anz] = h;
		h->hulleIndex = hulle_anz++;

		//Anzahl der Kerne
		coreAnz += h->anzCore;
	}
}


void SSLRParser::genLALR( void )
{
	//Aus der Sammlung der LR(0)-Elemente die Lookaheads anfügen.
	HULLE_STR	*h, *checkHulle, *hTmp, *hTmp2;
	PROD2_STR	*p2;
	Terminal	*checkTerm, *la;
	LR_STR		*lr, *lr2, *lr3;
	long		elem;
	char		*name;
	int			i, j, k, v, hInd, cInd, laAnz, changed;
	int			pass = 0;

	//Check-Terminal # (s. Drache S. 295)
	checkTerm = new Terminal( epsHashIndex );
	checkTerm->ins( lalrHashIndex );

	/******************************************/
	/* spontan generierte Lookaheads erzeugen */
	/******************************************/


	//Alle Hüllen, I
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//für jeden Kern, B -> gamma .delta in K
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//neue Hülle anfordern, erzeuge J' := Hülle({[B -> gamma .delta, #]});
			checkHulle = createHulle();

			//Diesen Kern mit Check-Terminal # in checkHulle eintragen
			insertItem( checkHulle, lr->prod2_index, lr->dot, CORE, checkTerm );

			//Hülle bilden
			genLR1Items( checkHulle );

			//Hülle ausgeben
//			outputHulle( checkHulle );

			//Alle LR(1)-Elemente dieser Hülle
			for( k = 0; k < checkHulle->anzElem; k++ )
			{
				//Zeiger auf das LR(1)-Item, [A -> alpha .X beta, a]
				lr2 = &checkHulle->lr_str[k];

				//Zeiger auf die Terminale
				la = lr2->la;

				//Alle Terminale
				for( v = 0; v < la->getAnzElem(); v++ )
				{
					//lalrHashIndex?
					if( (*la)[v] == lalrHashIndex )
						//Ja, Lookaheads breiten sich aus; werden später behandelt
						continue;

					//Zeiger auf die Alternative
					p2 = &prod2_str[lr2->prod2_index];

					//Position des Punktes < maximale Position?
					if( lr2->dot < p2->riAnz )
					{
						//.index holen
						elem = p2->right[lr2->dot];

						//darf nicht Epsilon sein
						if( elem != epsHashIndex )
						{
							//Namen holen
							name = hash_tab->getName( elem );

							//Das LR(0)-Item k in h suchen
							cInd = findItem( h, lr2->prod2_index, lr2->dot );

							//Kern nicht gefunden?
							if( cInd < 0 )
							{
								//Kern nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf Item
							lr3 = &h->lr_str[cInd];

							//Index der Sprung-Hülle
							hInd = lr3->jumpTo;

							//Hülle nicht gefunden?
							if( hInd < 0 )
							{
								//Hülle nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf Hülle
							hTmp2 = hulle_str[hInd];

							//Kern k in hTmp2 finden
							cInd = findItem( hTmp2, lr2->prod2_index, lr2->dot + 1 );

							//Kern nicht gefunden?
							if( cInd < 0 )
							{
								//Kern nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf LR(1)-Item, A -> alpha X .beta in Sprung(I,X)
							lr3 = &hTmp2->lr_str[cInd];

							//spontan generierte Lookaheads aufnehmen
							lr3->lalr->add( la );

							//das checkTerminal löschen
							lr3->lalr->del( lalrHashIndex );

							//Speicher freigeben
//							delete( hTmp );
						}
					}
				}
			}

			//Speicher wieder freigeben
			deleteHulle( checkHulle );
		}
	}

/*
	//Alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//Alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Meldung
			cout << "\nKern " << j << ": spontan generierte Lookaheads für " << i << ":" << endl;

			//spontan generierte Lookaheads ausgeben
			outputTerminal( lr->lalr );

			//Absatz
			cout << endl;
		}
	}
*/

	/********************************************/
	/* spontan generierte Lookaheads verbreiten */
	/********************************************/

	//Im ersten Kern ist ACCEPT ein spontan generiertes Lookahead
	hulle_str[0]->lr_str[0].lalr->ins( acceptHashIndex );


	//Ab hier sollten alle spontan generierten Lookaheads verfügbar sein,
	//nun auf die übrigen Kerne verbreiten.

	do
	{
		//keine Änderungen
		changed = 0;

		//Anzahl der Pässe
		pass++;

		//Alle Hüllen, I
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hülle
			h = hulle_str[i];

			//Alle Kerne dieser Hülle, B -> gamma .delta in K
			for( j = 0; j < h->anzCore; j++ )
			{
				//Zeiger auf das LR(0)-Item des Kerns
				lr = &h->lr_str[j];

				//Position des Punktes < maximale Position?
				if( lr->dot < prod2_str[lr->prod2_index].riAnz )
				{
					//Hülle erzeugen, erzeuge J' := Hülle({[B -> gamma .delta, #]});
					hTmp = createHulle();

					//Hülle erzeugen, wo die Terminale hinvererbt werden
					insertItem( hTmp, lr->prod2_index, lr->dot, CORE, checkTerm );

					//alle Items erzeugen
					genLR1Items( hTmp );

					//Hülle ausgeben
//					outputHulle( hTmp );

					/*
						Nun alle Elemente dieser Hülle untersuchen, die # als Lookahead haben.
						Von diesen Elementen die Sprung-Hüllen bilden und an die Kerne
						die Looakheads verbreiten.
					*/
					for( k = 0; k < hTmp->anzElem; k++ )
					{
						//Zeiger auf Item, [A -> alpha .X beta, #]
						lr2 = &hTmp->lr_str[k];

						//Hat dieses Element # als Lookahead?
						if( lr2->la->find( lalrHashIndex ) )
						{
							//Ja, die Sprung-Hülle dieses Elements bilden
							p2 = &prod2_str[lr2->prod2_index];

							//Punkt am Ende?
							if( lr2->dot < p2->riAnz )
							{
								//.index holen
								elem = p2->right[lr2->dot];

								//darf nicht Epsilon sein
								if( elem != epsHashIndex )
								{
									//Namen holen
									name = hash_tab->getName( elem );

									//Das LR(0)-Item k in h suchen
									cInd = findItem( h, lr2->prod2_index, lr2->dot );

									//Kern nicht gefunden?
									if( cInd < 0 )
									{
										//Kern nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf Item
									lr3 = &h->lr_str[cInd];

									//Index der Spring-Hülle
									hInd = lr3->jumpTo;

									//Hülle nicht gefunden?
									if( hInd < 0 )
									{
										//Hülle nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf die Hülle
									hTmp2 = hulle_str[hInd];

									//Kern k in hTmp2 finden
									cInd = findItem( hTmp2, lr2->prod2_index, lr2->dot + 1 );

									//Kern nicht gefunden?
									if( cInd < 0 )
									{
										//Kern nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf Item, A -> alpha X .beta in Sprung(I,X)
									lr3 = &hTmp2->lr_str[cInd];

									//Anzahl der Terminale
									laAnz = lr3->lalr->getAnzElem();

									//Lookaheads hinzufügen
									lr3->lalr->add( lr->lalr );

									//# löschen
									lr3->lalr->del( lalrHashIndex );

									//Wurde etwas hinzugefügt?
									if( laAnz != lr3->lalr->getAnzElem() )
										//Ja
										changed++;
								}
							}
						}
					}

					//Speicher freigeben
					deleteHulle( hTmp );
				}
			}
		}

/*
		//Alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hülle
			h = hulle_str[i];

			//Alle Kerne
			for( j = 0; j < h->anzCore; j++ )
			{
				//Zeiger auf das LR(0)-Item
				lr = &h->lr_str[j];

				//Meldung
				cout << "\nspontan generierte Lookaheads für " << i << ":" << endl;

				//spontan generierte Lookaheads ausgeben
				outputTerminal( lr->lalr );

				//Absatz
				cout << endl;
			}
		}
*/


	}while( changed );

	//Meldung?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate LALR-Items!" << endl;

	//Speicher für Check-Terminal # freigeben (s. Drache S. 295)
	delete( checkTerm );


	//Überall die Hüllen neu generieren
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//Hülle ausgeben
//		outputHulle( h );

		//Alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Alten Speicher freigeben
			delete( lr->la );

			//Lookaheads eintragen
			lr->la = lr->lalr;

			//zurücksetzen
			lr->lalr = 0L;
		}

		//Hüllen erzeugen
		genLR1Items( h );
	}

/*
	//Alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//Alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Meldung
			cout << "\nspontan generierte Lookaheads für " << i << ":" << endl;

			//spontan generierte Lookaheads ausgeben
			outputTerminal( lr->lalr );

			//Absatz
			cout << endl;
		}
	}
*/
}


void SSLRParser::genLR0Jump( HULLE_STR *I0, HULLE_STR *I1, long index )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name, *tmpName;
	int			i;

	//Name von index
	name = hash_tab->getName( index );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt em Ende?
		if( lr->dot < p2->riAnz )
		{
			//Name von Element nach Punkt
			tmpName = hash_tab->getName( p2->right[lr->dot] );

			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == index )
				//Ja, als Kern in I1 eintragen
				insertItem( I1, lr->prod2_index, lr->dot + 1, CORE );
		}
	}

	//Alle LR(0)-Elemente dieser Hülle erzeugen
	genLR0Items( I1 );
}


void SSLRParser::genLR1Jump( HULLE_STR *I0, HULLE_STR *I1, long index )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	int			i;

	//Name von index
	name = hash_tab->getName( index );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt em Ende?
		if( lr->dot < p2->riAnz )
		{
			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == index )
				//Ja, als Kern in I1 eintragen
				insertItem( I1, lr->prod2_index, lr->dot + 1, CORE, lr->la );
		}
	}

	//Alle LR(1)-Elemente dieser Hülle erzeugen
	genLR1Items( I1 );
}


void SSLRParser::outputTerminal( Terminal *la )
{
	//Terminale ausgeben
	int	i, anz;

	//Anzahl der Terminale
	anz = la->getAnzElem();

	//Alle Terminale ausgeben
	for( i = 0; i < anz; i++ )
		//ausgaben
		cout << hash_tab->getName( (*la)[i] ) << ", ";
}


void SSLRParser::setJump( HULLE_STR *I0, long elem, long HIindex )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	int			i;

	//Name von index
	name = hash_tab->getName( elem );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == elem )
				//Ja, den Index der Hülle eintragen, die durch Sprung( I0, elem ) erzeugt wird
				lr->jumpTo = HIindex;
		}
	}
}


bool SSLRParser::cmp2LR0Hulle( HULLE_STR *a, HULLE_STR *b )
{
	//Hier werden die LR(0)-Kerne beider Hüllen verglichen
	LR_STR	*lr;
	int		i, cInd;

	//Kerne gleich?
	if( ( a->anzElem == b->anzElem ) && ( a->anzCore == b->anzCore ) )
	{
		//Ja, gleich
		for( i = 0; i < a->anzCore; i++ )
		{
			//Zeiger auf Kern von a
			lr = &a->lr_str[i];

			//Ist dieses Item in b?
			if( ( cInd = findItem( b, lr->prod2_index, lr->dot ) ) < 0 )
				//Nein
				return( false );

			//Ist es ein Kern?
			else if( cInd > ( a->anzCore - 1 ) )
				//Ist kein Kern
				return( false );
		}

		//gleich
		return( true );
	}

	//nicht gleich
	return( false );
}


void SSLRParser::LR2LALR( void )
{
	//Wandelt die LR(1)-Hüllen in LR(0)-Hüllen
	HULLE_STR	*a, *b, **tmp;
	LR_STR		*lr;
	int			i, j, k;

	//Meldung?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Making LR to LALR..." << endl;

	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf Hülle
		a = hulle_str[i];

		//Alle anderen Hüllen mit dieser vergleichen
		for( j = i + 1; j < hulle_anz; j++ )
		{
			//Zeiger auf Hülle
			b = hulle_str[j];

			//beiden Hüllen vergleichen
			if( cmp2LR0Hulle( a, b ) == true )
			{
				//Meldung?
				if( argv_str->verbose )
					//ja
					cout << "Closure " << i << " and " << j << " equal..." << endl;

				//Die Terminale der Kerne von b in a eintragen, dann b löschen
				for( k = 0; k < b->anzCore; k++ )
				{
					//Zeiger auf Kern
					lr = &b->lr_str[k];

					//Kern in a eintragen
					insertItem( a, lr->prod2_index, lr->dot, CORE, lr->la );
				}

				//Hülle nochmal bilden, da Lookaheads möglicherweise anders
				genLR1Items( a );

				//Den Speicher der Hülle freigeben
				delHulle( b );

				//Speicher für alle Hüllen
				tmp = new( HULLE_STR *[hulle_anz - 1] );

				//Hüllen kopieren
				memmove( tmp, hulle_str, sizeof( HULLE_STR * ) * j );
				memmove( &tmp[j], &hulle_str[j + 1], sizeof( HULLE_STR * ) * ( hulle_anz - j - 1 ) );

				//Hülle b löschen

				//eine Hülle weniger
				hulle_anz--;

				//Alten Speicher freigeben
				delete[] ( hulle_str );

				//Zeiger
				hulle_str = tmp;

				//Index erniedrigen
				j--;
			}
		}

		//Hüllennummerierung
		a->hulleIndex = i;
	}
}


void SSLRParser::LRTab( void )
{
	//LR-Tabelle erzeugen
	PROD2_STR	*p2;
	HULLE_STR	*h;
	PROD_STR	*p1;
	Terminal	*la;
	LR_STR		*lr;
	char		*name;
	long		elem;
	int			i, j, type, lrTabIndex;

	//Meldugn ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Generate LR-Table..." << endl;

	//Speicher für die LR-Tabelle
	lrTab = new( LR_TAB *[hulle_anz] );

	//Speicher für die Sprung-Tabelle
	jumpTab = new( int *[hulle_anz] );

	//Für jeden Zustand die Spalten anfordern
	for( i = 0; i < hulle_anz; i++ )
	{
		//Speicher für Spalte
		lrTab[i] = new( LR_TAB[termArrCount + 1] );

		//Speicher für Spalte
		jumpTab[i] = new( int[ntermArrCount] );

		//Initialisieren
		memset( lrTab[i], 0, sizeof( LR_TAB ) * termArrCount );
		memset( jumpTab[i], 0, sizeof( int ) * ntermArrCount );
	}


	//Alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//Alle LR(0)/LR(1)-Elemente der Hülle
		for( j = 0; j < h->anzElem; j++ )
		{
			//Zeiger auf das LR(0)/LR(1)-Item
			lr = &h->lr_str[j];

			//Zeiger auf die Alternative
			p2 = &prod2_str[lr->prod2_index];

			//Zeiger auf die Alternative
			p1 = &prod_str[p2->prod_index];

			//Ist es ein Element der Art .expr?
			if( lr->dot < p2->riAnz )
			{
				//Element nach Punkt, hier z.B. expr
				elem = p2->right[lr->dot];

				//Index des Elements in der LR-Tabelle
				lrTabIndex = hash_tab->getLRTabIndex( elem );

				//Typ holen
				type = hash_tab->getType( elem );

				//Name holen
				name = hash_tab->getName( elem );

				//Nichtterminal vor Punkt?
				if( type == SSLR_NTERM )
				{
					//Ja, Eintrag in Sprung-Hülle
					jumpTab[i][lrTabIndex] = lr->jumpTo;

					//Meldung?
					if( argv_str->verbose )
						//ja
						cout << "sslr: LRTab: jump[" << i << "][" << name << "] = " << lr->jumpTo << "..." << endl;
				}

				else if( elem == epsHashIndex )
				{
					//Spezial-Fall, reduzieren

					//SLR-Parser?
					if( argv_str->type == SLR )
						//Follow-Menge
						la = hash_tab->getFollow( p1->hash_index );

					else
						//bei LALR und LR sind es die Lookaheads
						la = lr->la;

					//Reduzieren eintragen
					setReduce( i, lr->prod2_index, la );
				}

				else
					//Terminal schieben
					setShift( i, elem, lr->jumpTo );

			}

			else
			{
				//Reduce-Zustand

				//SLR-Parser?
				if( argv_str->type == SLR )
					//Follow-Menge
					la = hash_tab->getFollow( p1->hash_index );

				else
					//bei LALR und LR sind es die Lookaheads
					la = lr->la;

				//Reduzieren eintragen
				setReduce( i, lr->prod2_index, la );
			}
		}
	}

	//ltTab[1][ACCEPT] = Akzeptiere
	lrTab[1][termArrCount].state = LR_ACCEPT;

	//Shift-Reduce-Fehler aufgetreten?
	if( srError )
		//Meldung
		cerr << "sslr: " << srError << " shift-reduce error(s) occured!" << endl;

	//Reduce-Reduce-Fehler aufgetreten?
	if( rrError )
		//Meldung
		cerr << "sslr: " << rrError << " reduce-reduce error(s) occured!" << endl;
}


void SSLRParser::setReduce( int hInd, long prod2_index, Terminal *la )
{
	//Einen Reduce-Eintrag erzeugen und dabei Reduce-Reduce- und Shift-Reduce-Fehler behandeln.
	PROD2_STR	*p2, *p3, *p4;
	PROD_STR	*p1;
	long		elem;
	char		*name;
	int			i, laAnz, lrTabIndex;
	int			tAssoc, pPriority, tPriority, state;

	//Hier mit der Produktion prod2_index reduzieren
//	h = hulle_str[hInd];

	//Zeiger auf die Alternative
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die Alternative
	p1 = &prod_str[p2->prod_index];

	//Anzahl der Lookaheads
	laAnz = la->getAnzElem();

	//Für jedes Lookahead
	for( i = 0; i < laAnz; i++ )
	{
		//nächstes Lookahead holen
		elem = (*la)[i];

		//Namen
		name = hash_tab->getName( elem );

		//Spalten-Index in LR-Tabelle holen
		lrTabIndex = hash_tab->getLRTabIndex( elem );

		//Ist dieser Eintrag in der Hash-Tabelle schon belegt?
		if( lrTab[hInd][lrTabIndex].state == LR_REDUCE )
		{
			//Reduce-Reduce-Konflikt

			//Zeiger auf die PROD2_STR
			p3 = &prod2_str[lrTab[hInd][lrTabIndex].value];
			p4 = &prod2_str[prod2_index];

			//ist ein "echter" Reduce-Reduce-Konflikt
			cout << "sslr: Reduce-Reduce conflict in closure " << hInd << " between" << endl;

			//eingetragene Produktion ausgeben
			outputAlt( cout, lrTab[hInd][lrTabIndex].value );

			cout << "and" << endl;

			//eingetragene Produktion ausgeben
			outputAlt( cout, prod2_index );

			//neue Zeile
			cout << endl;

			//Fehler
			rrError++;
		}

		else if( lrTab[hInd][lrTabIndex].state == LR_SHIFT )
		{
			//Shift-Reduce-Fehler

			//Fehler ausgeben
			cout << "sslr: Shift-Reduce conflict in closure " << hInd << " between reducing" << endl;

			//Alternative ausgeben, mit der reduziert werden soll
			outputAlt( cout, prod2_index ),

			//Schieben mit Terminal
			name = hash_tab->getName( lrTab[hInd][lrTabIndex].termHashIndex );
			cout << "and shifting " << name << "!" << endl << endl;

			//Priorität des geschobenen Terminals
			tPriority = hash_tab->getPriority( lrTab[hInd][lrTabIndex].termHashIndex );

			//Priorität der Produktion holen
			pPriority = p2->priority;

			//Assoziation des Terminals holen
			tAssoc = hash_tab->getAssociation( lrTab[hInd][lrTabIndex].termHashIndex );

			//Wurde die Priorität überhaupt angegeben?
			if( ( tPriority > 0 ) && ( pPriority > 0 ) )
			{
				//Ja, Priorität der Produktion > Priorität des Terminals?
				if( pPriority > tPriority )
					//Ja, reduzieren
					state = LR_REDUCE;

				else if( ( tPriority == pPriority ) && ( tAssoc == isLeftAssoc ) )
					//beide Prioritäten gleich, zu schiebendes Terminal ist links-assoziativ
					state = LR_REDUCE;

				//nicht-assoziatives Terminal?
				else if( ( tPriority == pPriority ) && ( tAssoc == isNonAssoc ) )
				{
					//Ja, Fehlereintrag
					lrTab[hInd][lrTabIndex].state = 0;
					lrTab[hInd][lrTabIndex].value = 0;

					//ausgeben
					state = LR_ERROR;
				}

				else
					//nichts von alledem
					state = LR_SHIFT;
			}

			else
				//Schieben
				state = LR_SHIFT;

			//Schieben oder reduzieren?
			if( state == LR_REDUCE )
			{
				//Reduzieren
				lrTab[hInd][lrTabIndex].state = LR_REDUCE;
				lrTab[hInd][lrTabIndex].value = prod2_index;

				//Meldung
				cout << "reduce..." << endl;

				//merken, dass reduziert wird
				prod2_str[prod2_index].reduce--;

				//Meldung ausgeben?
				if( argv_str->verbose )
				{
					//Ja
//					cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce " << hash_tab->getName( p1->hash_index ) << "..." << endl;
					cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce with ";

					//rechte Seite ausgeben
					outputAlt( cout, prod2_index );
				}
			}

			else if( state == LR_SHIFT )
				//geschobenen beibehalten
				cout << "shift..." << endl << endl;

			else if( state == LR_ERROR )
				//Terminal ist nicht-assoziativ
				cout << "Terminal is non-associative!" << endl;

			//Fehler
			srError++;
		}

		else
		{
			//kein Fehler aufgetreten
			lrTab[hInd][lrTabIndex].state = LR_REDUCE;
			lrTab[hInd][lrTabIndex].value = prod2_index;

			//merken, dass reduziert wird
			prod2_str[prod2_index].reduce++;

			//Meldung ausgeben?
			if( argv_str->verbose )
			{
				//Ja
//				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce " << hash_tab->getName( p1->hash_index ) << "..." << endl;
				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce with ";

				//rechte Seite ausgeben
				outputAlt( cout, prod2_index );
			}
		}
	}
}


void SSLRParser::setShift( int hInd, long termHashIndex, int jumpTo )
{
	//Einen Shift-Eintrag erzeugen und dabei Shift-Reduce-Fehler behandeln.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	long		prod2_index;
	char		*name;
	int			lrTabIndex;
	int			tAssoc, pPriority, tPriority, state;

	//Spalten-Index in LR-Tabelle holen
	lrTabIndex = hash_tab->getLRTabIndex( termHashIndex );

	//Name holen
	name = hash_tab->getName( termHashIndex );

	//Ist dieser Eintrag in der Hash-Tabelle schon belegt?
	if( lrTab[hInd][lrTabIndex].state == LR_REDUCE )
	{
		//Shift-Reduce-Fehler

		//Index der Alternative in PROD2_STR
		prod2_index = lrTab[hInd][lrTabIndex].value;

		//Zeiger auf die Alternative
		p2 = &prod2_str[prod2_index];

		//Zeiger auf die Alternative
		p1 = &prod_str[p2->prod_index];

		//Fehler ausgeben
		cout << "sslr: Shift-Reduce conflict in closure " << hInd << " between reducing" << endl;

		//Alternative ausgeben, mit der reduziert werden soll
		outputAlt( cout, prod2_index ),

		//Schieben mit Terminal
		cout << "and shifting " << name << "!" << endl;

		//Priorität des geschobenen Terminals
		tPriority = hash_tab->getPriority( termHashIndex );

		//Priorität der Produktion holen
		pPriority = p2->priority;

		//Assoziation des Terminals holen
		tAssoc = hash_tab->getAssociation( termHashIndex );

		//Wurde die Priorität überhaupt angegeben?
		if( ( tPriority > 0 ) && ( pPriority > 0 ) )
		{
			//Ja, Priorität der Produktion > Priorität des Terminals?
			if( pPriority > tPriority )
				//Ja, reduzieren
				state = LR_REDUCE;

			else if( ( tPriority == pPriority ) && ( tAssoc == isLeftAssoc ) )
				//beide Prioritäten gleich, Terminal ist links-assoziativ
				state = LR_REDUCE;

			//nicht-assoziatives Terminal?
			else if( ( tPriority == pPriority ) && ( tAssoc == isNonAssoc ) )
			{
				//Ja, Fehlereintrag
				lrTab[hInd][lrTabIndex].state = 0;
				lrTab[hInd][lrTabIndex].value = 0;

				//ausgeben
				state = LR_ERROR;
			}

			else
				//nichts von alledem
				state = LR_SHIFT;
		}

		else
			//Schieben
			state = LR_SHIFT;

		//Schieben oder reduzieren?
		if( state == LR_SHIFT )
		{
			//Schieben
			lrTab[hInd][lrTabIndex].state = LR_SHIFT;
			lrTab[hInd][lrTabIndex].value = jumpTo;
			lrTab[hInd][lrTabIndex].termHashIndex = termHashIndex;

			//merken, dass nicht reduziert, sondern geschoben wird
			prod2_str[prod2_index].reduce--;

			//Meldung
			cout << "shift..." << endl << endl;

			//Meldung ausgeben?
			if( argv_str->verbose )
				//ja
				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = shift " << jumpTo << "..." << endl;
		}

		else if( state == LR_REDUCE )
			//Reduktion mit Alternative beibehalten
			cout << "reduce..." << endl << endl;

		else if( state == LR_ERROR )
			//Terminal ist nicht-assoziativ
			cout << "Terminal is non-associative!" << endl;

		//Fehler
		srError++;
	}

	else
	{
		//Kein Fehler aufgetreten
		lrTab[hInd][lrTabIndex].state = LR_SHIFT;
		lrTab[hInd][lrTabIndex].value = jumpTo;
		lrTab[hInd][lrTabIndex].termHashIndex = termHashIndex;

		//Meldung ausgeben?
		if( argv_str->verbose )
			//ja
			cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = shift " << jumpTo << "..." << endl;
	}
}


void SSLRParser::generateFiles( void )
{
	//hier werden die Source-Files des Parsers erzeugt
	ofstream	cppFile( "sslrparser.cpp" );
	ofstream	hFile( "sslrparser.h" );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Generate parser file..." << endl;

	//das Header-File generieren
	outputHFile( hFile );

	//den Header des cpp-Files ausgeben
	outputCPPHeader( cppFile );

	//Terminal-Defines als enum ausgeben
	outputCPPTerminal( cppFile );

	//etwaige Include-Anweisungen einfügen
	outputIncl( cppFile );

	//LR-Tabelle ausgeben
	outputLRTab( cppFile );

	//Sprung-Tabelle ausgeben
	outputJumpTab( cppFile );

	//die Follow-Sets ausgeben
	outputFollow( cppFile );

	//die rechten Seiten ausgeben
	outputAlternatives( cppFile );

	//alle NTERM_STR ausgeben
	outputNtermStr( cppFile );

	//Debug-Mode?
	if( argv_str->debug == true )
		//ja
		outputTermName( cppFile );

	//Fehlerbehandlung ausgeben
	outputErrorRecovery( cppFile );

	//alle übrigen Routinen ausgeben
	outputCPPEnd( cppFile );

	//semantische Aktionen ausgeben
	outputSemAct( cppFile );

	//etwaige eigene Erweiterungen einfügen
	outputExt( cppFile );
}


void SSLRParser::outputCPPHeader( ofstream &file )
{
	//Den Header des cpp-Files ausgeben

	//Header des cpp-Files
file << "/***************************************************************************\n";
file << "                          sslrparser.cpp  -  description\n";
file << "                             -------------------\n";
file << "    copyright            : (C) 2002 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#include \"sslrparser.h\"\n";
file << "#include <iostream>\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug version *\n";
		file << "****************************/\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug version *\n";
		file << "********************************/\n\n\n";
	}
}


void SSLRParser::outputCPPEnd( ofstream &file )
{
	//alle übrigen Routinen des cpp-Files ausgeben

file << "\n";
file << "\n";
file << "SSLRParser::SSLRParser( SSLEXScanner *scan )\n";
file << "{\n";
file << "	//call reset to initialize the parser\n";
file << "	reset();\n";
file << "\n";
file << "	//scanner class\n";
file << "	SSLR_scanner = scan;\n";
file << "\n";
file << "#ifdef SSLR_INIT\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "SSLRParser::~SSLRParser()\n";
file << "{\n";
file << "#ifdef SSLR_INIT\n";
file << "	//uninizialize user defined variables\n";
file << "	deinit();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::reset( void )\n";
file << "{\n";
file << "	//resets the whole parser\n";
file << "\n";
file << "	//parse stack pointer\n";
file << "	SSLR_sp = 0;\n";
file << "\n";
file << "	//start with state 0\n";
file << "	SSLR_push( 0 );\n";
file << "	SSLR_state = 0;\n";
file << "\n";
file << "	//no errors yet\n";
file << "	SSLR_anzError = 0;\n";
file << "\n";
file << "	//defualt values for error recovery\n";
file << "	SSLR_errorStr.alt = start_0;\n";
file << "	SSLR_errorStr.sp = SSLR_sp;\n";
file << "	SSLR_errorStr.state = 0;\n";
file << "\n";


	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//Ja
		file << "	//semantic actions\n";
		file << "	SSLR_semAct = 0;\n";
		file << "\n";
		file << "	//stack counter for semantic action stack\n";
		file << "	SSLR_semStackCnt = 0;\n";
	}

file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::SSLR_getTerminal( void )\n";
file << "{\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//Ja, Attribut des Scanners auf den Stack schieben
		file << "	//semantic actions allowed?\n";
		file << "	if( !SSLR_semAct )\n";
		file << "		//push attribute on stack for semantic actions\n";
		file << "		SSLR_semStack[SSLR_semStackCnt++] = SSLR_attributeStr;\n";
		file << "\n";
	}

file << "	//get next terminal\n";
file << "	SSLR_terminal = SSLR_scanner->yyLex( &SSLR_attributeStr );\n";
file << "\n";
file << "	//get line\n";
file << "	SSLR_line = SSLR_scanner->getYYLineno();\n";
file << "\n";
file << "	//return terminal\n";
file << "	return( SSLR_terminal );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::yyParse( void )\n";
file << "{\n";
file << "	//start parsing\n";
file << "\n";
file << "	//get first terminal\n";
file << "	SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "	//start parsing\n";
file << "	return( SSLR_parse() );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_push( long ast )\n";
file << "{\n";
file << "	//push a new state on the parse stack\n";
file << "	SSLR_stack[SSLR_sp++] = ast;\n";
file << "\n";
file << "	//stack overflow?\n";
file << "	if( SSLR_sp > SSLR_maxStackSize )\n";
file << "	{\n";
file << "		//stack-overflow\n";
file << "		cerr << \"SSLRParser::SSLR_push: stack overflow!\\nExiting...\" << endl;\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//set new state\n";
file << "	SSLR_state = ast;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "long SSLRParser::SSLR_pop( int anz )\n";
file << "{\n";
file << "	//pop anz elements from the parse stack\n";
file << "	SSLR_sp -= anz;\n";
file << "\n";
file << "	//stack underflow?\n";
file << "	if( SSLR_sp < 0 )\n";
file << "	{\n";
file << "		//stack underflow\n";
file << "		cerr << \"SSLRParser::SSLR_pop: stack underflow!\\nExiting...\" << endl;\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//return new state\n";
file << "	return( SSLR_stack[SSLR_sp - 1] );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::SSLR_parse( void )\n";
file << "{\n";
file << "	//begin parsing\n";
file << "\n";
file << "	while( 1 )\n";
file << "	{\n";
file << "		//end of parsing?\n";
file << "		if( SSLR_state == 1 )\n";
file << "		{\n";
file << "			//yes, is terminal ACCEPT\n";
file << "			if( SSLR_terminal == ACCEPT )\n";
file << "				//return number of errors\n";
file << "				return( SSLR_anzError );\n";
file << "\n";
file << "			else\n";
file << "			{\n";
file << "				//error\n";
file << "				cerr << \"SSLRParser::SSLR_parse: bailing out...\" << endl;\n";
file << "				return( SSLR_anzError );\n";
file << "			}\n";
file << "		}\n";
file << "\n";
file << "		//shift terminal SSLR_terminal?\n";
file << "		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_SHIFT )\n";
file << "		{\n";
file << "			//yes\n";
file << "			SSLR_shift( &SSLR_lrTab[SSLR_state][SSLR_terminal] );\n";
file << "\n";
file << "			//get new terminal\n";
file << "			SSLR_terminal = SSLR_getTerminal();\n";
file << "		}\n";
file << "\n";
file << "		//reduce with production?\n";
file << "		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_REDUCE )\n";
file << "			//reduce\n";
file << "			SSLR_reduce( &SSLR_lrTab[SSLR_state][SSLR_terminal] );\n";
file << "\n";
file << "		//otherwise an error occured\n";
file << "		else\n";
file << "			//call error recovery\n";
file << "			SSLR_error();\n";
file << "	}\n";
file << "}\n";
	file << "\n";
	file << "\n";

	//Debug-Version
	if( argv_str->debug == true )
	{
		//Ja
		file << "void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//shift a terminal onto the parse stack\n";

		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "	//output\n";
		file << "	cout << \"Shift\" << endl;\n";
		file << "	cout << \"current state: \" << SSLR_state << endl;\n";
		file << "	cout << \"current terminal: \" << SSLR_termName[SSLR_terminal] << endl;\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//shift a new state onto the stack\n";
		file << "	SSLR_push( tab->value );\n";
		file << "\n";

		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "	//output\n";
		file << "	cout << \"shift new state \" << SSLR_state << endl << endl;\n";

		//Debug-Makro ausgeben
		file << "#endif\n";

		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//reduce with production\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "\n";

		//semantische Aktionen?
		if( semActCnt )
		{
			//Ja
			file << "	//perform a semantic action accociated with the reduced production\n";
			file << "	SSLR_doSemAct( tab );\n";
			file << "\n";
		}

		file << "	//get a pointer to the alternative\n";
		file << "	n = &SSLR_ntermStr[tab->value];\n";

		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "	//output\n";
		file << "	cout << \"Reduce\\n\";\n";
		file << "	cout << \"current state: \" << SSLR_state << \"\\n\";\n";
		file << "	cout << \"current terminal: \" << SSLR_termName[SSLR_terminal] << \"\\n\";\n";
		file << "	cout << \"reduce with \";\n";
		file << "\n";
		file << "	//output alternative\n";
		file << "	SSLR_outputAlt( n );\n";
		file << "\n";
		file << "	//output\n";
		file << "	cout << \"\\n\";\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//remove states form stack\n";
		file << "	SSLR_state = SSLR_pop( n->elem );\n";
		file << "\n";
		file << "	//get new state\n";
		file << "	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];\n";
		file << "\n";
		file << "	//push new state on stack\n";
		file << "	SSLR_push( SSLR_state );\n";


		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "	//output\n";
		file << "	cout << \"new state \" << SSLR_state << \"\\n\\n\";\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//for error recovery\n";
		file << "	SSLR_errorStr.alt = tab->value;\n";
		file << "	SSLR_errorStr.sp = SSLR_sp;\n";
		file << "	SSLR_errorStr.state = SSLR_state;\n";
		file << "}\n";
		file << "\n";

		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "void SSLRParser::SSLR_outputAlt( SSLR_NTERM_STR *n )\n";
		file << "{\n";
		file << "	//output an alternative\n";
		file << "	int	i;\n";
		file << "\n";
		file << "	//name of alternative\n";
		file << "	cout << n->name << \" -> \";\n";
		file << "\n";
		file << "	//output right side\n";
		file << "	for( i = 0; i < n->elem; i++ )\n";
		file << "		cout << n->ri[i] << \" \";\n";
		file << "\n";
		file << "\t//EPSILON alternative?\n";
		file << "\tif( !n->elem )\n";
		file << "\t\t//yes\n";
		file << "\t\tcout << \"'EPSILON'\";\n";
		file << "}\n";

		//Debug-Makro ausgeben
		file << "#endif\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//shift a new state onto the stack\n";
		file << "	SSLR_push( tab->value );\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//reduce with production\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "\n";

		//semantische Aktionen?
		if( semActCnt )
		{
			//Ja
			file << "	//perform a semantic action accociated with the reduced production\n";
			file << "	SSLR_doSemAct( tab );\n";
			file << "\n";
		}

		file << "	//get a pointer to the alternative\n";
		file << "	n = &SSLR_ntermStr[tab->value];\n";
		file << "\n";
		file << "	//remove states form stack\n";
		file << "	SSLR_state = SSLR_pop( n->elem );\n";
		file << "\n";
		file << "	//get new state\n";
		file << "	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];\n";
		file << "\n";
		file << "	//push new state on stack\n";
		file << "	SSLR_push( SSLR_state );\n";
		file << "\n";
		file << "	//for error recovery\n";
		file << "	SSLR_errorStr.alt = tab->value;\n";
		file << "	SSLR_errorStr.sp = SSLR_sp;\n";
		file << "	SSLR_errorStr.state = SSLR_state;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
	}
}


void SSLRParser::outputCPPTerminal( ofstream &file )
{
	//Terminal-Defines als enum ausgeben
	char	*name;
	int		i;

	//Header ausgeben
	file << "//Terminals for debugging\n";
	file << "char *SSLR_scannerToken[] =\n{\n";

	for( i = 0; i < termArrCount; i++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//Define-Anweisung ausgeben
		file << "\t/*" << i << "*/ \"" << name << "\",\n";
	}

	//Abschluss
	file << "\t0L\n};\n\n\n";
}


void SSLRParser::outputLRTab( ofstream &file )
{
	//LR-Tabelle in Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_TAB		*lrtab;
	char		puf1[256+1], puf2[256+1], *name;
	int			i, j, k, id;


	//Überschrift
	file << "//syntax analyze table\n";

	//Definition der LR-Tabelle
	file << "SSLRParser::SSLR_LR_TAB SSLRParser::SSLR_lrTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzTerm] = {\n";

	//Alle Zustände
	for( i = 0; i < hulle_anz; i++ )
	{
		//Öffnen
		file << "/* State " << i << " */\n{ ";

		//Alle Terminale
		for( j = 0, k = 0; j < termArrCount; j++, k++ )
		{
			//Zeiger auf LR_TAB-Struktur
			lrtab = &lrTab[i][j];

			//Zustand ausgeben
			switch( lrtab->state )
			{
				//Fehler?
				case LR_ERROR:
				{
					//Ja, Fehlerbehandlung
					sprintf( puf1, "%s", "LR_ERROR" );
					break;
				}

				//Shift?
				case LR_SHIFT:
				{
					//Ja, Zustand schieben
					sprintf( puf1, "%s", "LR_SHIFT" );
					break;
				}

				//Reduce?
				case LR_REDUCE:
				{
					//Ja, mit Produktion reduzieren
					sprintf( puf1, "%s", "LR_REDUCE" );

					//Produktion ausschreiben
					p2 = &prod2_str[lrtab->value];

					//Zeiger auf PROD_STR
					p1 = &prod_str[p2->prod_index];

					//Name der Produktion
					name = hash_tab->getName( p1->hash_index );

					//Nummer der Alternative
					id = lrtab->value - p1->prod2_index;

					//Namen generieren
					sprintf( puf2, "%s_%d", name, id );

					break;
				}

				//Akzeptieren?
				case LR_ACCEPT:
				{
					//Ja, akzeptieren
					sprintf( puf1, "%s", "LR_ACCEPT" );
					break;
				}

				default:
				{
					//anderer Wert
					sprintf( puf1, "%d", lrTab[i][j].state );
					break;
				}
			}

			//Werte-Paar ausgeben
			file << "{ " << puf1 << ", ";

			//Reduce?
			if( lrtab->state == LR_REDUCE )
				//Ja
				file << puf2 << " }";

			else
				//ausgeben
				file << lrtab->value << " }";

			//Kommt noch etwas?
			if( j < ( termArrCount - 1 ) )
				//Ja
				file << ",";

			//neue Zeile?
			if( k == 8 )
			{
				//Ja
				file << "\n";
				k = 0;
			}
		}

		//Nächster Zustand?
		if( i < ( hulle_anz - 1 ) )
			//Ja
			file << " },\n";

		else
			//Nein
			file << " }\n";
	}

	//abschliessen
	file << "};\n";
}


void SSLRParser::outputJumpTab( ofstream &file )
{
	//Sprung-Tabelle ausgeben
	PROD_STR	*p1;
	long		index, prod_index;
	char		*name, widthChar[128];
	int			i, j, k, width;

	//Breite des größten Zustands
	sprintf( widthChar, "%d", hulle_anz );
	width = strlen( widthChar );

	//Definition der Sprung-Tabelle
	file << "\n\n//jump table\n";
	file << "long SSLRParser::SSLR_jumpTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzNTerm] = {\n";

	//zuerst alle Produktionen ausgeben, dient der Orientierung
	file << "//";
	for( i = 0, k = 0; i < ntermArrCount; i++, k++ )
	{
		//neue Zeile?
		if( k == 10 )
			//Ja
			file << "\n//";

		//Produktion ausgeben
		file << hash_tab->getName( ntermArr[i] ) << ", ";
	}

	//neue Zeile
	file << "\n\n";

	//Alle Zustände
	for( i = 0; i < hulle_anz; i++ )
	{
		//Öffnen
		file << "/* State " << i << " */\n{ ";

		//Alle Produktionen
		for( j = 0, k = 0; j < ntermArrCount; j++, k++ )
		{
			//Name der Produktion
			name = hash_tab->getName( ntermArr[j] );

			//prod_index holen
			prod_index = hash_tab->getProdStr( ntermArr[j] );

			//Zeiger auf PROD_STR
			p1 = &prod_str[prod_index];

			//Index in Jump-Tabelle
			index = hash_tab->getLRTabIndex( p1->hash_index );

			//Wert ausgeben
			file.width( width );
			file << jumpTab[i][index];

			//Folgt noch etwas?
			if( j < ( prod_anz - 1 ) )
				//Ja
				file << ", ";

			//neue Zeile?
			if( k == 15 )
			{
				//Ja
				file << "\n";
				k = 0;
			}
		}

		//Nächster Zustand?
		if( i < ( hulle_anz - 1 ) )
			//Ja
			file << " },\n";

		else
			//Nein
			file << " }\n";
	}

	//abschliessen
	file << "};\n\n";
}


void SSLRParser::outputAlternatives( ofstream &file )
{
	//Die Alternativen in die cpp-Datei ausgeben.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, puf1[256+1];
	int			i, j, id, type;

	//Nur bei Debug-Version
	if( argv_str->debug == true )
	{
		//Header
		file << "\n//all alternatives\n";

		//Alle Alternativen
		for( i = 0; i < prod2_anz; i++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//Den Namen der Alternative holen
			name = hash_tab->getName( p1->hash_index );

			//Nummer der Alternative
			id = i - p1->prod2_index;

			//Namen generieren
			sprintf( puf1, "%s%d", name, id );

			//Initialisieren
			file << "char *SSLRParser::SSLR_" << puf1 << "Ri[" << p2->riAnz << "] = { ";

			//Alle Elemente auf der rechten Seite ausgeben
			for( j = 0; j < p2->riAnz; j++ )
			{
				//Namen holen
				name = hash_tab->getName( p2->right[j] );

				//Typ holen
				type = hash_tab->getType( p2->right[j] );

				//Terminal?
				if( type == SSLR_TERM )
					//Ja
					file << "\"\\\'" << name << "\\\'\"";

				else
					//Nichtterminal
					file << "\"" << name << "\"";

				//folgt noch ein Eintrag?
				if( j < ( p2->riAnz - 1 ) )
					//Ja
					file << ", ";
			}

			//abschließen
			file << " };\n";
		}
	}
}


void SSLRParser::outputNtermStr( ofstream &file )
{
	//die NTERM_STR ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, puf1[256+1];
	long		followAnz;
	int			i, id, riAnz;

	//Header
	file << "\n\n//all alternatives\n";
	file << "SSLRParser::SSLR_NTERM_STR SSLRParser::SSLR_ntermStr[SSLRParser::SSLR_anzProd] = {\n";

	//Alle Alternativen
	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf PROD2_STR
		p2 = &prod2_str[i];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Den Namen der Alternative holen
		name = hash_tab->getName( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Nummer der Alternative
		id = i - p1->prod2_index;

		//Namen generieren
		sprintf( puf1, "%s%d", name, id );

		//ist es eine EPSILON-Produktion?
		if( p2->right[0] == epsHashIndex )
			//Ja
			riAnz = 0;

		else
			//Nein, ganz normal
			riAnz = p2->riAnz;

		//Debug-Version?
		if( argv_str->debug == true )
			//Nein, entsprechende SSLR_NTERM_STR ausgeben
			file << "{ \"" << name << "\", SSLRParser::SSLR_" << puf1 << "Ri, " << name << ", " << riAnz << ", SSLRParser::SSLR_" << name << "Follow, " << followAnz << " }";

		else
			//Ja, entsprechende SSLR_NTERM_STR ausgeben
			file << "{ " << name << ", " << riAnz << ", SSLRParser::SSLR_" << name << "Follow, " << followAnz << " }";

		//folgt noch ein Eintrag?
		if( i < ( prod2_anz - 1 ) )
			//Ja
			file << ",\n";
	}

	//abschließen
	file << "};\n\n";
}


void SSLRParser::outputFollow( ofstream &file )
{
	//Die Alternativen in die cpp-Datei ausgeben.
	PROD_STR	*p1;
	Terminal	*followSet;
	char		*name;
	long		followAnz, *followTerm;
	int			i, j;

	//Header
	file << "\n//follow sets for the error recovery\n";

	//Alle Produktionen
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Den Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//Zeiger auf die Follow-Elemente
		followSet = hash_tab->getFollow( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Initialisieren
		file << "long SSLRParser::SSLR_" << name << "Follow[" << followAnz << "] = { ";

		//Alle Follow-Elemente ausgeben
		for( j = 0; j < followAnz; j++ )
		{
			//Namen holen
			name = hash_tab->getName( (*followSet)[j] );

			//Terminal ausgeben
			file << name;

			//folgt noch ein Eintrag?
			if( j < ( followAnz - 1 ) )
				//Ja
				file << ", ";
		}

		//abschließen
		file << " };\n";
	}
}


void SSLRParser::outputTermName( ofstream &file )
{
	//Die Namen der Terminale ausgeben, nur im debug-mode
	char	*name;
	int		i, k;

	//Debug-Makro ausgeben
	file << "\n#ifdef SSLR_DEBUG\n";

	//Header
	file << "\n//names of the terminals\n";
	file << "char *SSLRParser::SSLR_termName[SSLRParser::SSLR_anzTerm] =\n{ ";

	//Alle Terminale
	for( i = k = 0; i < termArrCount; i++, k++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//neue Zeile?
		if( k == 16 )
		{
			//Ja
			file << "\n";
			k = 0;
		}

		//Define-Anweisung ausgeben
		file << "\"" << name << "\"";

		//Folgt noch ein Terminal?
		if( i < ( termArrCount - 1 ) )
			//Ja
			file << ", ";
	}

	//abschliessen
	file << " };\n\n";
	file << "#endif\n\n";
}


void SSLRParser::outputSemAct( ofstream &file )
{
	//semantische Aktionen ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, *pos, *tmp, *semTypeName;
	long		_line, LRTabIndex;
	bool		semTypeOK = false;
	int			i, state, depth, semIndex, semTypeIndex, id;
	int			*nArr, *tArr, type, sign, err;

	//Gibt es überhaupt welche?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//dient der Vermeidung von Fehlerlawinen
		nArr = new( int[ntermArrCount] );
		tArr = new( int[termArrCount] );

		//Initialisieren
		memset( nArr, 0, sizeof( int ) * ntermArrCount );
		memset( tArr, 0, sizeof( int ) * termArrCount );

		//Funktions-Header ausgeben
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_doSemAct( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//do semantic actions before reduction\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "	SSLR_TYPE		tmp;\n";
		file << "\n";
		file << "	//semantic actions allowed?\n";
		file << "	if( !SSLR_semAct )\n";
		file << "	{\n";
		file << "		//get a pointer to the alternative\n";
		file << "		n = &SSLR_ntermStr[tab->value];\n";
		file << "\n";
		file << "		//Alternative to reduce with\n";
		file << "		switch( tab->value )\n";
		file << "		{\n";

		//Alle Alternativen
		for( i = 0; i < prod2_anz; i++ )
		{
			//Fehlerflag zurücksetzen
			err = 0;

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//Gibt es semantische Aktionen?
			if( p2->semAct )
			{
				//Ja, ausgeben
				name = hash_tab->getName( p1->hash_index );

				//das entsprechende Item ausgeben
				file << "\t\t\t//";
				outputItem( i, p2->riAnz, file );
				file << "\n";

				//case ausgeben
				file << "\t\t\tcase " << name << "_" << i - p1->prod2_index << ":\n";
				file << "\t\t\t{\n\t\t\t\t";

				//Zustand setzen
				state = 0;
				_line = p2->semActLine;

				//Verschachtelung von Kommentaren
				depth = 0;

				//Zeiger auf den text
				pos = p2->semAct;

				//den Text analysieren
				while( *pos && !err )
				{
					//Blancs löschen
					switch( state )
					{
						case 0:
						{
							//Leerzeichen löschen
							while( isspace( *pos ) && ( *pos != '\n' ) )
								//nächstes Zeichen
								file << *pos++;

							break;
						}
					}

					//Neue Zeile?
					if( *pos == '\n' )
					{
						//Neue Zeile
						_line++;

						//Status: 2?
						if( state != 2 )
						{
							//Status 2 ist Kommentar //
							file << *pos++;
							continue;
						}
					}

					//semantischer Typ?
					if( !state && ( *pos == '$' ) )
					{
						//Ja
						state = 10;
						pos++;
					}

					switch( state )
					{
						//Default-Zustand
						case 10:
						{
							//semantischer Typ?
							if( *pos == '$' )
							{
								//den semantischen Typ der Produktion holen
								semIndex = hash_tab->getUnionType( p1->hash_index );

								//gibt es einen semantischen Typ?
								if( semIndex )
								{
									//Ja, mit semantischem Typ ausgeben
									file << "tmp." << unionStr->id[semIndex];

									//ist überflüssigerweise ein semantischer Typ in Form von <typ>
									//angegeben worden?
									if( semTypeOK )
									{
										//sind die Typen gleich?
										if( semIndex == semTypeIndex )
											//Ja, Angabe ist überflüssig
											cerr << "sslr: line " << _line << ": Explicit semantic type statement not necessary!" << endl;

										else
											//Nein, sind verschieden!
											cerr << "sslr: line " << _line << ": Explicit semantic type statement does not coincide with %union statement!" << endl;

										//Speicher für Namen freigeben
										delete( semTypeName );

										//Flag zurücksetzen
										semTypeOK = false;
									}
								}

								else
								{
									//nein, ohne semantischen Typ ausgeben
									file << "tmp";

									//ist ein semantischer Typ in Form von <typ> angegeben worden?
									if( semTypeOK )
									{
										//Typ ausgeben
										file << "." << unionStr->id[semTypeIndex];

										//Speicher für Namen freigeben
										delete( semTypeName );

										//Flag zurücksetzen
										semTypeOK = false;
									}

									else
									{
										//nein, Fehler

										//den Namen der Produktion
										name = hash_tab->getName( p1->hash_index );

										//den Index in der LR-Tabelle holen
										LRTabIndex = hash_tab->getLRTabIndex( p1->hash_index );

										//Warnung ausgeben?
										if( !nArr[LRTabIndex] )
											//Ja, Warnung ausgeben
											cerr << "sslr: line " << _line << ": No semantic type defined for production " << name << "!" << endl;

										//Vermeidung von Fehlerlawinen
										nArr[LRTabIndex]++;
									}
								}

								//überspringen
								pos++;

								//Zustand zurücksetzen
								state = 0;
							}

							else if( *pos == '<' )
							{
								//ist vom Typ $<...>
								pos++;

								//Position merken
								tmp = pos;

								//solange kein >
								while( ( *pos != '>' ) && *pos )
									//übertragen
									pos++;

								//genügend Speicher anfordern
								semTypeName = new( char[pos - tmp + 1] );

								//kopieren
								strncpy( semTypeName, tmp, pos - tmp );
								semTypeName[pos - tmp] = 0;

								//den Index in unionStr finden
								if( ( semTypeIndex = getSemIndex( semTypeName ) ) < 0 )
								{
									//Typ nicht in %union definiert
									cerr << "sslr: ERROR: line " << _line << ": Type " << semTypeName << " for semantic action not defined in %union!" << endl;

									//Speicher gleich wieder freigeben
									delete( semTypeName );

									//Fehler
									semTypeOK = false;
								}

								else
									//Flag setzen
									semTypeOK = true;

								//> löschen
								pos++;
							}

							else if( isdigit( *pos ) || ( *pos == '-' ) )
							{
								//bezieht sich auf ein Element auf der rechten Seite
								//semStack[semStackCnt-1] ist das letzte Element

								//negativer Index?
								if( *pos == '-' )
								{
									//Ja, negativ
									sign = -1;
									pos++;
								}

								else
									//ist positiv
									sign = 1;

								//Zahl einlesen
								id = strtol( pos, 0L, 10 );

								//Vorzeichen
								id *= sign;

								//Ziffern löschen
								while( isdigit( *pos ) )
									pos++;

								//gibt es überhaupt so viele Elemente auf der rechten Seite wie angegeben?
								if( ( id - 1 ) < p2->riAnz )
								{
									//Ist es der Form prod -> 'EPSILON'`?
									if( ( p2->riAnz == 1 ) && ( p2->right[0] == epsHashIndex ) )
									{
										//Warnung ausgeben
										cerr << "sslr: line " <<  _line << ": $" << id << " not allowed inside 'EPSILON'-alternative!" << endl;

										//nächste semantische Aktion behandelt
										err++;
										break;
									}

									else
									{
										//den semantischen Typ des Elements holen
										semIndex = hash_tab->getUnionType( p2->right[id - 1] );

										//gibt es einen semantischen Typ?
										if( semIndex )
										{
											//Ja, Stack-Zugriff
											file << "SSLR_semStack[SSLR_semStackCnt - 1 - " << p2->riAnz << " + (" << id << ")]." << unionStr->id[semIndex];

											//ist überflüssigerweise ein semantischer Typ in Form von <typ>
											//angegeben worden?
											if( semTypeOK )
											{
												//sind die Typen gleich?
												if( semIndex == semTypeIndex )
													//Ja, Angabe ist überflüssig
													cerr << "sslr: line " << _line << ": Explicit semantic type statement not necessary!" << endl;

												else
													//Nein, sind verschieden!
													cerr << "sslr: line " << _line << ": Explicit semantic type statement does not coincide with %union-Statement!" << endl;

												//Speicher für Namen freigeben
												delete( semTypeName );

												//Flag zurücksetzen
												semTypeOK = false;
											}
										}

										else
										{
											//Nein, Stack-Zugriff
											file << "SSLR_semStack[SSLR_semStackCnt - 1 - " << p2->riAnz << " + (" << id << ")]";

											//ist ein semantischer Typ in Form von <typ> angegeben worden?
											if( semTypeOK )
											{
												//Typ ausgeben
												file << "." << unionStr->id[semTypeIndex];

												//Speicher für Namen freigeben
												delete( semTypeName );

												//Flag zurücksetzen
												semTypeOK = false;

												//überspringen
												pos++;
											}

											else
											{
												//den Namen des Elements
												name = hash_tab->getName( p2->right[id - 1] );

												//den Index in der LR-Tabelle holen
												LRTabIndex = hash_tab->getLRTabIndex( p2->right[id - 1] );

												//Typ holen
												type = hash_tab->getType( p2->right[id - 1] );

												//Terminal?
												if( type == SSLR_TERM )
												{
													//Ja

													//Warnung ausgeben?
													if( !tArr[LRTabIndex] )
														//Warnung ausgeben
														cerr << "sslr: line " << _line << ": No semantic type defined for terminal " << name << "!" << endl;

													//Vermeidung von Fehlerlawinen
													tArr[LRTabIndex]++;
												}

												else
												{
													//Ist ein Nicht-Terminal

													//Warnung ausgeben?
													if( !nArr[LRTabIndex] )
														//Warnung ausgeben
														cerr << "sslr: line " << _line << ": No semantic type defined for nonterminal " << name << "!" << endl;

													//Vermeidung von Fehlerlawinen
													nArr[LRTabIndex]++;
												}
											}
										}
									}
								}

								else
								{
									//Indiziertes Element zu groß!
									cerr << "sslr: line " << _line << ": Number in semantic type statement too big!" << endl;

									//abbrechen
									err++;
									break;
								}

								//Zustand zurücksetzen
								state = 0;
							}

							break;
						}

						case 0:
						{
							//Kommentar?
							if( ( pos[0] == '/' ) && ( pos[1] == '*' ) )
							{
								//Ja, Kommentar
								state = 1;

								//Verschachtelung
								depth++;
								pos += 2;

								//ausgeben
								file << "/*";
							}

							else if( ( pos[0] == '/' ) && ( pos[1] == '/' ) )
							{
								//Kommentar
								pos += 2;
								file << "//";
								state = 2;
							}

							else
								//einfach übertragen
								file << *pos++;

							break;
						}

						case 1:
						{
							//Kommentar /*
							if( ( pos[0] == '*' ) && ( pos[1] == '/' ) )
							{
								//Kommentar schliessen
								file << "*/";
								pos += 2;

								//Verschachtelungstiefe
								depth--;

								//Default-Zustand?
								if( !depth )
									//Ja
									state = 0;
							}

							else if( ( pos[0] == '/' ) && ( pos[1] == '*' ) )
							{
								//Ja, Kommentar

								//Verschachtelung
								depth++;
								pos += 2;

								//ausgeben
								file << "/*";
							}

							else
								//einfach übertragen
								file << *pos++;

							break;
						}

						case 2:
						{
							//Kommentar //
							file << *pos;

							//Newline?
							if( *pos++ == '\n' )
								//Ja
								state = 0;

							break;
						}

						default:
							//einfach kopieren
							file << *pos++;
					}
				}

				//case abschliessen
				file << "\t\t\t\tbreak;\n";
				file << "\t\t\t}\n";
				file << "\n";
			}
		}

		file << "\t\t\tdefault:\n";
		file << "\t\t\t\t//error\n";
		file << "\t\t\t\tcerr << \"SSLRParser::SSLR_doSemAct: Unknown alternative \" << tab->value << \"!\" << endl;\n";
		file << "\t\t}\n";
		file << "\n\t\t//correct stack pointer\n";
		file << "\t\tSSLR_semStackCnt -= n->elem;\n";
		file << "\n";
		file << "\t\t//push last value on stack\n";
		file << "\t\tSSLR_semStack[SSLR_semStackCnt++] = tmp;\n";
		file << "\t}\n";
		file << "}\n";
		file << "\n";

		//Speicher freigeben
		delete[] ( nArr );
		delete[] ( tArr );
	}
}


void SSLRParser::outputErrorRecovery( ofstream &file )
{
	//Hier wird die komplette Fehlerbehandlung ausgegeben
	ERRTERM_STR		*errTermStr;
	ERROR_STR		*a, *b;
	HULLE_STR		*h;
	LR_STR			*lr;
	LR_TAB			*lrtab;
	long			LRTabIndex;
	char			*name;
	int				i, j, k, m;
	int				*errArr1, errArr1Cnt = 0, *errArr2, errArr2Cnt = 0;
	int				anzTerm, anznTerm, pass;
	int				*hulleArr, hulleArrCnt, autoErr;

	//Gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_errShift( long termi )\n";
file << "{\n";
file << "	//shift a new state\n";
file << "	if( SSLR_lrTab[SSLR_state][termi].state == LR_SHIFT )\n";
file << "		//push new state\n";
file << "		SSLR_push( SSLR_lrTab[SSLR_state][termi].value );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errDelete( void )\n";
file << "{\n";
file << "	//delete current terminal\n";
file << "	terminal = SSLR_getTerminal();\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errOverRead( long termi )\n";
file << "{\n";
file << "	//delete all terminals untill term is found\n";
file << "	do\n";
file << "	{\n";
file << "		//get next terminal\n";
file << "		terminal = SSLR_getTerminal();\n";
file << "\n";
file << "		//equal?\n";
file << "		if( terminal == termi )\n";
file << "			//yes, return\n";
file << "			return;\n";
file << "\n";
file << "		else if( terminal == ACCEPT )\n";
file << "		{\n";
file << "			//abort parsing\n";
file << "			state = 1;\n";
file << "			return;\n";
file << "		}\n";
file << "\n";
file << "	}while( 1 );\n";
file << "}\n";
	}

	//Fehler-Routine ausgeben
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_error( void )\n";
file << "{\n";
file << "	//error handling\n";
file << "	SSLR_NTERM_STR	*n;\n";
file << "	long			*f, tmpState;\n";
file << "	int				fCnt = 0, i, rec = 0;\n";
file << "\n";
file << "	//delete all terminals untill one that follows the last nonterminal\n";
file << "	//the reduction was done with\n";
file << "	SSLR_anzError++;\n";
file << "\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//Ja, semantische Aktionen des Parsers stoppen
		file << "	//no semantic actions are allowed after errors\n";
		file << "	SSLR_semAct++;";
		file << "\n";
		file << "\n";
	}

file << "	//state after reduction\n";
file << "	tmpState = SSLR_errorStr.state;\n";
file << "\n";
file << "	//get a pointer to the SSLR_NTERM_STR of the nonterminal\n";
file << "	n = &SSLR_ntermStr[SSLR_errorStr.alt];\n";
file << "\n";

	//Debug-mode?
	if( argv_str->debug == true )
	{
		//Ja
		file << "	//debugging message\n";
		file << "	cout << \"SSLRParser::SSLR_error: Looking for terminal that may follow \" << n->name << \"..\\n\";\n";
		file << "\n";
	}

file << "	//get the follow terminals\n";
file << "	f = n->follow;\n";
file << "\n";
file << "	//number of follow terminals\n";
file << "	fCnt = n->followCnt;\n";
file << "\n";
file << "\n";



	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		//ja, Header ausgeben
		file << "	switch( SSLR_state )\n";
		file << "	{\n";

		//es gibt ERROR_STR, die dieselbe Alternative abdecken. Diese dürfen daher nicht doppelt auftreten.
		errArr1 = new( int[error_anz] );
		errArr2 = new( int[error_anz] );

		//initialisieren
		memset( errArr2, 0, error_anz * sizeof( int ) );

		//alle Hüllen, die auf ein Satz ERROR_STR passen, merken
		hulleArr = new( int[hulle_anz] );

		//Alle Fehler-Strukturen durchgehen
		for( i = 0; i < error_anz; i++ )
		{
			//schon bearbeitet?
			if( ( errArr2Cnt ) && ( errArr2[i] ) )
				//Ja
				continue;

			//Zeiger auf ERROR_STR
			a = &error_str[i];

			//aufnehmen
			errArr1[errArr1Cnt++] = i;

			//verhindert ein doppeltes Prüfen dieser ERROR_STR
			errArr2[i] = 1;
			errArr2Cnt++;

			//alle anderen ERROR_STR aufnehmen, die daselbe Item behandeln
			for( j = i + 1; j < error_anz; j++ )
			{
				//Zeiger auf ERROR_STR
				b = &error_str[j];

				//gleiche Items?
				if( ( a->prod2_index == b->prod2_index ) && ( a->dot == b->dot ) )
				{
					//ja, aufnehmen
					errArr1[errArr1Cnt++] = j;

					//verhindert ein doppeltes Prüfen dieser ERROR_STR
					errArr2[j] = 1;
					errArr2Cnt++;
				}
			}


			//das entsprechende Item ausgeben
			file << "		//";

			//entsprechende Alternative ausgeben
			outputItem( a->prod2_index, a->dot, file );
			file << "\n";

			//nun die Hüllen suchen, in denen dieses Item auftaucht
			for( j = 0, hulleArrCnt = 0; j < hulle_anz; j++ )
			{
				//Zeiger auf Hülle
				h = hulle_str[j];

				//alle Items
				for( k = 0; k < h->anzElem; k++ )
				{
					//Zeiger auf LR_STR
					lr = &h->lr_str[k];

					//sind die Items gleich?
					if( ( a->prod2_index == lr->prod2_index ) && ( a->dot == lr->dot ) )
					{
						//ja, Fehlerbehandlung für diese Hülle installieren
						file << "		case " << j << ":\n";

						//den Index der Hülle merken
						hulleArr[hulleArrCnt++] = j;
					}
				}
			}

			//alle Aktionen in errStr->act_str abarbeiten
			file << "\t\t{\n";

			//1. Pass starten
			pass = 0;

			//Anzahl der terminal-gebundenen Fehleraktionen
			anzTerm = 0;

			//Anzahl der nicht-terminal-gebundenen Fehleraktionen
			anznTerm = 0;

			//nun alle ERROR_STR durchlaufen,
			for( j = 0; ( j < errArr1Cnt ) && ( pass < 2 ); j++ )
			{
				//Zeiger auf die entsprechende ERROR_ANZ
				b = &error_str[errArr1[j]];

				//festhalten, ob die automatische Fehlerbehandlung gestartet werden soll
				autoErr = 0;

				//1. Pass?
				if( !pass )
				{
					//zuerst werden alle terminal-gebundenen Fehleraktionen ausgegeben
					if( b->errTermStr )
					{
						//if oder else if?
						if( !anzTerm )
							//das erste Auftreten
							file << "\t\t\tif( ";

						else
							//bei allen übrigen else if
							file << "\t\t\telse if( ";

						//alle Terminal durchgehen
						for( m = 0; m < b->errTermStrAnz; m++ )
						{
							//Zeiger auf ERRTERM_STR
							errTermStr = &b->errTermStr[m];

							//den Namen des Terminals holen
							name = hash_tab->getName( errTermStr->terminal );

							//negiert?
							if( errTermStr->neg )
							{
								//ja, alle ausser dieses

								//&& anfügen?
								if( m )
									//Ja
									file << " && ";

								//Bedingung ausgeben
								file << "( terminal != " << name << " )";
							}

							else
							{
								//nein, nur bei diesem

								//&& anfügen?
								if( m )
									//Ja
									file << " || ";

								//Bedingung ausgeben
								file << "( terminal == " << name << " )";
							}
						}

						//neue Zeile
						file << " )\n";
						file << "\t\t\t{\n";

						//Fehlermeldung ausgeben?
						if( strcmp( b->msg, "" ) )
						{
							/*
								Ja, wenn die Fehlermeldung aus "" besteht, dann gar keine ausgeben.
								Die Fehlermeldung MUSS vor den Fehler-Aktionen ausgegeben werden, da,
								wenn z.B. EXIT verwendet wird, die Fehlermeldung nicht gezeigt
								würde!
							*/
							file << "\t\t\t\t//show user-defined error message\n";
							file << "\t\t\t\tcerr << \"line: \" << line << \": " << b->msg << "\";\n\n";
						}

						//Fehleraktionen ausgeben
						if( b->shift )
						{
							//den Namen des Terminals holen
							name = hash_tab->getName( b->shift );

							//neuen Zustand schieben
							file << "\t\t\t\t//shift Terminal " << name << "\n";
							file << "\t\t\t\tSHIFT( " << name << " );\n\n";

							//Index des Terminals in der LR-Tabelle holen
							LRTabIndex = hash_tab->getLRTabIndex( b->shift );

							//prüfen, ob das Terminal tatsächlich bei jeder Hülle, für die ein case
							//installiert wurde, geschoben werden kann
							for( m = 0; m < hulleArrCnt; m++ )
							{
								//Zeiger auf LR_TAB-Struktur
								lrtab = &lrTab[hulleArr[m]][LRTabIndex];

								//Kann das Terminal geschoben werden?
								if( lrtab->state != LR_SHIFT )
									//Nein, Warnung ausgeben
									cerr << "sslr: line " << b->line << ": Terminal " << name << " cannot be shifted in state " << hulleArr[m] << "!" << endl;
							}

							//automatische Fehlerbehandlung einschalten
							autoErr++;
						}

						if( b->overread )
						{
							//den Namen des Terminals holen
							name = hash_tab->getName( b->overread );

							//Terminale überlesen
							file << "\t\t\t\t//delete terminals untill " << name << " ist the current Terminal\n";
							file << "\t\t\t\tOVERREAD( " << name << " );\n\n";

							//automatische Fehlerbehandlung einschalten
							autoErr++;
						}

						if( b->del )
						{
							//ein Terminal löschen
							file << "\t\t\t\t//delete current terminal\n";

							//mehrfaches Auftreten von DELETE ist erlaubt
							for( m = 0; m < b->del; m++ )
								file << "\t\t\t\tDELETE();\n";

							//neue Zeile
							file << "\n";

							//automatische Fehlerbehandlung einschalten
							autoErr++;
						}

						if( b->exit )
						{
							//Parsen abbrechen
							file << "\t\t\t\t//stop parsing\n";
							file << "\t\t\t\tEXIT;\n";
						}

						if( b->sem )
						{
							//semantische Aktionen trotz Fehler zulassen

							//gibt es überhaupt semantische Aktionen?
							if( semActCnt && ( unionStr->anz > 1 ) )
							{
								//Ja
								file << "\t\t\t\t//allow semantic actions despite the error\n";
								file << "\t\t\t\tSEM;\n\n";
							}

							else
								//nein
								cerr << "sslr: line " << b->line << ": There are no semantic actions not to allow!" << endl;
						}

						//automatische Fehlerbehandlung überspringen, wenn keine Aktion gewält wurde oder nur SEM
						if( autoErr )
						{
							//nein, automatische Fehlerbehandlung trotz eigener Fehler-Angaben ausführen
							file << "\t\t\t\t//skip automatic error recovery\n";
							file << "\t\t\t\trec++;\n\n";
						}

						//abschließen
						file << "\t\t\t}\n\n";

						//zählen
						anzTerm++;
					}
				}

				else
				{
					//hier werden alle nicht-terminal-gebundenen Fehleraktionen ausgeführt

					//nur nicht-terminal-gebundenen Fehleraktionen ausgegeben
					if( !b->errTermStr )
					{
						//gab es terminal-gebundene Fehleraktionen?
						if( anzTerm && !anznTerm )
							//Ja, else ausgeben
							file << "\t\t\telse\n\t\t\t{\n";

						//Fehlermeldung ausgeben?
						if( strcmp( b->msg, "" ) )
						{
							/*
								Ja, wenn die Fehlermeldung aus "" besteht, dann gar keine ausgeben.
								Die Fehlermeldung MUSS vor den Fehler-Aktionen ausgegeben werden, da,
								wenn z.B. EXIT verwendet wird, die Fehlermeldung nicht gezeigt
								würde!
							*/
							file << "\t\t\t\t//show user-defined error message\n";
							file << "\t\t\t\tcerr << \"line: \" << line << \": " << b->msg << "\";\n\n";
						}

						//Fehleraktionen ausgeben
						if( b->shift )
						{
							//den Namen des Terminals holen
							name = hash_tab->getName( b->shift );

							//Neuen Zustand schieben
							file << "\t\t\t\t//shift terminal " << name << "\n";
							file << "\t\t\t\tSHIFT( " << name << " );\n\n";

							//Index des Terminals in der LR-Tabelle holen
							LRTabIndex = hash_tab->getLRTabIndex( b->shift );

							//prüfen, ob das Terminal tatsächlich bei jeder Hülle, für die ein case
							//installiert wurde, geschoben werden kann
							for( m = 0; m < hulleArrCnt; m++ )
							{
								//Zeiger auf LR_TAB-Struktur
								lrtab = &lrTab[hulleArr[m]][LRTabIndex];

								//kann das Terminal geschoben werden?
								if( lrtab->state != LR_SHIFT )
									//Nein, Warnung ausgeben
									cerr << "sslr: line " << b->line << ": Terminal " << name << " cannot be shifted in state " << hulleArr[m] << "!" << endl;
							}

							//automatische Fehlerbehandlung einschalten
							autoErr++;
						}

						if( b->overread )
						{
							//den Namen des Terminals holen
							name = hash_tab->getName( b->overread );

							//Terminale überlesen
							file << "\t\t\t\t//delete terminals untill " << name << " is the current terminal\n";
							file << "\t\t\t\tOVERREAD( " << name << " );\n\n";

							//automatische Fehlerbehandlung einschalten
							autoErr++;
						}

						if( b->del )
						{
							//ein Terminal löschen
							file << "\t\t\t\t//delete current terminal\n";

							//mehrfaches Auftreten von DELETE ist erlaubt
							for( m = 0; m < b->del; m++ )
								file << "\t\t\t\tDELETE();\n";

							//neue Zeile
							file << "\n";

							//automatische Fehlerbehandlung einschalten
							autoErr++;
						}

						if( b->exit )
						{
							//Parsen abbrechen
							file << "\t\t\t\t//stop parsing\n";
							file << "\t\t\t\tEXIT;\n";
						}

						if( b->sem )
						{
							//semantische Aktionen trotz Fehler zulassen

							//gibt es überhaupt semantische Aktionen?
							if( semActCnt && ( unionStr->anz > 1 ) )
							{
								//ja
								file << "\t\t\t\t//allow semantic actions despite the error\n";
								file << "\t\t\t\tSEM;\n\n";
							}

							else
								//nein
								cerr << "sslr: line " << b->line << ": There are no semantic actions not to allow!" << endl;
						}

						//automatische Fehlerbehandlung überspringen, wenn keine Aktion gewält wurde oder nur SEM
						if( autoErr )
						{
							//Nein, automatische Fehlerbehandlung trotz eigener Fehler-Angaben ausführen
							file << "\t\t\t\t//skip automatic error recovery\n";
							file << "\t\t\t\trec++;\n\n";
						}

						//zählen
						anznTerm++;

						//abschliessen
						if( anzTerm && ( anzTerm + anznTerm == errArr1Cnt ) )
							//Ja
							file << "\t\t\t}\n\n";
					}
				}

				//neuen Pass starten?
				if( j == ( errArr1Cnt - 1 ) )
				{
					//Ja
					pass++;
					j = -1;
				}
			}

			//nächste ERROR_STR
			errArr1Cnt = 0;

			//case abschliessen
			file << "\t\t\tbreak;\n";
			file << "		}\n\n";
		}

		//default ausgeben
		file << "		default:\n";
		file << "		{\n";
		file << "			//default error message\n";
		file << "			cerr << \"line: \" << line << \": Syntax error!\" << endl;\n";
		file << "			break;\n";
		file << "		}\n";

		//switch-Statement abschliessen
		file << "\t}\n\n";

		//Speicher wieder freigeben
		delete[] ( errArr1 );
		delete[] ( errArr2 );
		delete[] ( hulleArr );
	}

	else
	{
		//es gibt keine benutzter-definierten Fehleranweisungen, nun default-Fehlermeldung ausgeben
		file << "	//default error message\n";
		file << "	cerr << \"line: \" << SSLR_line << \": Syntax error!\" << endl;\n";
	}


	//noch gewöhnliche Fehlerbehandlung
file << "\n";
file << "	//do SSLRs intern error recovery?\n";
file << "	if( !rec )\n";
file << "	{\n";
file << "		//yes, no user defined error routines given\n";
file << "\n";
file << "		do\n";
file << "		{\n";
file << "			//is the current terminal ACCEPT?\n";
file << "			if( SSLR_terminal == ACCEPT )\n";
file << "			{\n";
file << "				//abort parsing\n";
file << "				SSLR_state = 1;\n";
file << "				return;\n";
file << "			}\n";
file << "\n";
file << "			//may the terminal SSLR_terminal follow?\n";
file << "			for( i = 0; i < SSLR_anzTerm; i++ )\n";
file << "			{\n";
file << "				//shift OK?\n";
file << "				if( SSLR_lrTab[tmpState][SSLR_terminal].state == LR_SHIFT )\n";
file << "				{\n";

	//Debug-mode?
	if( argv_str->debug == true )
	{
		//Ja

		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "					//inform the user\n";
		file << "					cout << SSLR_termName[SSLR_terminal] << \" may follow \" << n->name << \"\\n\\n\";\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}

file << "					//set new state\n";
file << "					SSLR_state = SSLR_errorStr.state;\n";
file << "\n";
file << "					//get stack position\n";
file << "					SSLR_sp = SSLR_errorStr.sp;\n";
file << "					return;\n";
file << "				}\n";
file << "			}\n";
file << "\n";
file << "			//get next terminal\n";
file << "			SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "		}while( 1 );\n";
file << "	}\n";
file << "\n";
file << "\treturn;\n";
file << "}\n";
}


void SSLRParser::outputIncl( ofstream &file )
{
	//Include-Anweisungen in das cpp-File ausgeben
	char	*incl = SSLR_scanner->getInclude(), *beg;
	ulong	len;

	//gibt es include-Anweisungen?
	if( incl )
	{
		//am Anfang das \{ löschen
		while( !( ( incl[0] == '\\' ) && ( incl[1] == '{' ) ) )
			incl++;

		//löschen
		incl = &incl[2];

		//die Länge der Include-Anweisungen
		len = strlen( incl );

		//merken
		beg = &incl[len - 2];

		//am Ende das \{ löschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << incl;
	}
}


void SSLRParser::outputExt( ofstream &file )
{
	//eigene Erweiterungen in das cpp-File ausgeben
	char	*ext = SSLR_scanner->getExtension(), *beg;
	ulong	len;

	//gibt es Extensionen?
	if( ext )
	{
		//am Anfang das \{ löschen
		while( !( ( ext[0] == '\\' ) && ( ext[1] == '{' ) ) )
			ext++;

		//löschen
		ext = &ext[2];

		//die Länge der eigenen Erweiterungen
		len = strlen( ext );

		//merken
		beg = &ext[len - 2];

		//am Ende das \{ löschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << ext;
	}
}


void SSLRParser::outputTermDefHFile( ofstream &file )
{
	/*
		Der Scanner liefert ja Tokens zum Parser zurück, die im Prinzip
		für die Auswahl der nächsten Aktion (schieben/reduzieren) benötigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	char *name;
	int	i;

	//Kopf ausgeben
file << "/***************************************************************************\n";
file << "                          sslrtermdef.h  -  description\n";
file << "                             -------------------\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLRPARSER_H\n";
file << "#define SSLRPARSER_H\n";
file << "\n";
file << "\n";
file << "/**\n";
file << "\t@author SSLR V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";

	//Terminale, die der Scanner zurückliefert
	file << "//Terminals returned by the scanner\n";

	for( i = 0; i < termArrCount; i++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//Define-Anweisung ausgeben
		file << "#define " << name << "\t" << i << "\n";
	}


	//wurde eine %union-Angabe vorgenommen?
	if( unionStr->anz > 1 )
	{
		//ja, ausgeben
		file << "\n\n\n//Type for semantic actions\n";
		file << "typedef union\n{\n";

		//Text ausgeben
		file << unionStr->text;

		//abschliessen
		file << "\n}SSLR_TYPE;\n\n\n";
	}

	//Ende des Header-Files
	file << "#endif\n\n";
}


void SSLRParser::outputHFile( ofstream &file )
{
	//Header-File ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char 		*name, puf1[256+1];
	char 		**userDefHeader;
	long		followAnz;
	int			i, j, id, userDefHeaderCnt;

	//Kopf ausgeben
file << "/***************************************************************************\n";
file << "                          sslrparser.h  -  description\n";
file << "                             -------------------\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLRTERMDEF_H\n";
file << "#define SSLRTERMDEF_H\n";
file << "\n";
file << "\n";
file << "/**\n";
file << "\t@author SSLR V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";


	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug version *\n";
		file << "****************************/\n\n\n";

		//Debug-Makro
		file << "//define debug macro\n";
		file << "#define SSLR_DEBUG\n";
		file << "//#undef SSLR_DEBUG\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug version *\n";
		file << "********************************/\n\n\n";
	}

	//Include-Files
	file << "//Include-Files\n";
	file << "#include <iostream>\n";
	file << "#include \"sslexscanner.h\"\n\n";

	//Allgemeine Definitionen

	//Gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		//ja, die Fehlerroutinen als Defines ausgeben
		file << "//error routines\n";
		file << "#define POP\t\tSSLR_errPop\n";
		file << "#define DELETE\t\tSSLR_errDelete\n";
		file << "#define SHIFT\t\tSSLR_errShift\n";
		file << "#define OVERREAD\tSSLR_errOverRead\n";
		file << "#define SEM\t\tSSLR_semAct = 0\n";
		file << "#define EXIT\t\texit( 1 )\n";
		file << "\n\n\n";
	}



	//Nicht-Terminal-Defines für Sprung-Tabelle
	file << "\n//Nonterminal defines for the jump table\n";

	for( i = 0; i < ntermArrCount; i++ )
	{
		//Name des Nicht-Terminals
		name = hash_tab->getName( ntermArr[i] );

		//Define-Anweisung ausgeben
		file << "#define " << name << "\t" << i << "\n";
	}



	//Nicht-Terminale für die LR-Tabelle
	file << "\n\n//Nontermials for the LR table\n";

	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf PROD2_STR
		p2 = &prod2_str[i];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Name der Produktion
		name = hash_tab->getName( p1->hash_index );

		//Nummer der Alternative
		id = i - p1->prod2_index;

		//Namen generieren
		sprintf( puf1, "%s_%d", name, id );

		//Define-Anweisung ausgeben
		file << "#define " << puf1 << "\t" << i << "\n";
	}



	//Klassen-Deklaration
	file << "\n\nclass SSLRParser\n";
	file << "{\n";
	file << "private:\n";


	//Struktur für die LR-Tabelle
	file << "\n\t//LR table\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";
	file << "\t\tint\t\t\tstate;\n";
	file << "\t\tlong\t\tvalue;\n";
	file << "\n\t}SSLR_LR_TAB;\n\n";


	//Struktur für alle Alternativen
	file << "\n";
	file << "\t//all productions\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		file << "\t\t//name of alternative\n";
		file << "\t\tchar\t*name;\n";
		file << "\n";
		file << "\t\t//pointer to right side of alternative\n";
		file << "\t\tchar\t**ri;\n";
		file << "\n";
	}

	//Zeiger auf die Follow-Terminale
	file << "\t\t//index in jumpTab\n";
	file << "\t\tint\t\tjump_index;\n";
	file << "\n";
	file << "\t\t//number of elements on the right side\n";
	file << "\t\tint\t\telem;\n";
	file << "\n";
	file << "\t\t//pointer to follow sets\n";
	file << "\t\tlong\t*follow;\n";
	file << "\n";
	file << "\t\t//number of follow terminals\n";
	file << "\t\tlong\tfollowCnt;\n";
	file << "\n";
	file << "\t}SSLR_NTERM_STR;\n";
	file << "\n";


	//Struktur für die Standard-Fehlerbehandlung
	file << "\n";
	file << "\t//this structure saves important values for the error recovery\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";
	file << "\t\t//stack pointer position\n";
	file << "\t\tint\t\tsp;\n";
	file << "\n";
	file << "\t\t//state after reduction\n";
	file << "\t\tint\t\tstate;\n";
	file << "\n";
	file << "\t\t//number of alternative the reduction was done\n";
	file << "\t\tint\t\talt;\n";
	file << "\n";
	file << "\t}SSLR_ERROR_STR;\n";
	file << "\n";
	file << "\n";


	file << "\t//private class variables\n\n";

	//Anzahl der Zustände
	file << "\t//Number of lr states\n";
	file << "\tstatic const unsigned long\tSSLR_anzLRStates = " << hulle_anz << ";\n\n";

	//Anzahl der Terminale
	file << "\t//Number of terminals = number of columns in lrTab\n";
	file << "\tstatic const unsigned long\tSSLR_anzTerm = " << termArrCount << ";\n\n";

	//Anzahl der Produktionen
	file << "\t//Number of productions = number of rows in jumpTab\n";
	file << "\tstatic const unsigned long\tSSLR_anzNTerm = " << prod_anz << ";\n\n";

	//Anzahl der Alternativen
	file << "\t//Number of alternatives\n";
	file << "\tstatic const unsigned long\tSSLR_anzProd = " << prod2_anz << ";\n\n";

	//Zustände in der LR-Tabelle
	file << "\n\t//Actions in lrTab\n";
	file << "\tstatic const int\t\t\tLA_ERROR = 1;\n";
	file << "\tstatic const int\t\t\tLR_SHIFT = 2;\n";
	file << "\tstatic const int\t\t\tLR_REDUCE = 3;\n";
	file << "\tstatic const int\t\t\tLR_ACCEPT = 4;\n\n";

	//Stack-Größe
	file << "\n\t//maximum stack size\n";
	file << "\tstatic const int\t\t\tSSLR_maxStackSize = 100;\n\n";

	//Stack für Zustände
	file << "\n";
	file << "	//parse stack\n";
	file << "	long\t\t\t\t\t\tSSLR_stack[SSLR_maxStackSize];\n";
	file << "\n";
	file << "	//stack counter\n";
	file << "	long\t\t\t\t\t\tSSLR_sp;\n";
	file << "\n";
	file << "\n";

	//LR-Tabelle
	file << "\t//LR table\n";
	file << "\tstatic SSLR_LR_TAB\t\t\tSSLR_lrTab[SSLR_anzLRStates][SSLR_anzTerm];\n\n";

	//Sprung-Tabelle
	file << "\t//jump table\n";
	file << "\tstatic long\t\t\t\t\tSSLR_jumpTab[SSLR_anzLRStates][SSLR_anzNTerm];\n\n";

	//scanner-class
	file << "\t//scanner class\n";
	file << "\tSSLEXScanner *\t\t\t\tSSLR_scanner;\n\n";

	//Array with all alternatives, for debug mode only
	file << "\t//Array with all alternatives, for debug-mode only\n";
	file << "\tstatic SSLR_NTERM_STR\t\tSSLR_ntermStr[SSLR_anzProd];\n\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Array mit den Namen der Terminale
		file << "\t//array with the names of the terminals\n";
		file << "\tstatic char *\t\t\t\tSSLR_termName[SSLR_anzTerm];\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	//Typ des Terminals, dass der Scanner zurückliefert
	file << "	//current terminal\n";
	file << "	int\t\t\t\t\t\t\tSSLR_terminal;\n";
	file << "\n";

	//Atrribut des Terminals wie z.B. Zahlenwert
	file << "	//attributes returned form scanner\n";
	file << "	SSLR_TYPE\t\t\t\t\tSSLR_attributeStr;\n";
	file << "\n";

	//Zeile, in der ein Fehler auftrat
	file << "	//line number\n";
	file << "	unsigned long\t\t\t\tSSLR_line;\n";
	file << "\n";

	//Aktueller Zustand des Parsers
	file << "	//current state\n";
	file << "	int\t\t\t\t\t\t\tSSLR_state;\n";
	file << "\n";

	//Anzahl der aufgetretenen Fehler
	file << "	//number of errors\n";
	file << "	int\t\t\t\t\t\t\tSSLR_anzError;\n";
	file << "\n";

	//Struktur für Fehlerbehandlung in der Standard-Fehlerbehandlung
	file << "	//structure for error-recovery\n";
	file << "	SSLR_ERROR_STR\t\t\t\tSSLR_errorStr;\n";
	file << "\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//semantische Aktionen, für Fehlerbehandlung
		file << "	//allow/deny semantic actions\n";
		file << "	int\t\t\t\t\t\t\tSSLR_semAct;\n";
		file << "\n";
		file << "	//stack for semantic actions\n";
		file << "	SSLR_TYPE\t\t\t\t\tSSLR_semStack[SSLR_maxStackSize];\n";
		file << "\n";
		file << "	//stack counter for semantic action stack\n";
		file << "	int\t\t\t\t\t\t\tSSLR_semStackCnt;\n";
		file << "\n";
	}

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//die rechten Seiten
		file << "\t//Alternatives\n";

		//Alle rechten Seiten (nur Debug)
		for( i = 0; i < prod2_anz; i++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//Den Namen der Alternative holen
			name = hash_tab->getName( p1->hash_index );

			//Nummer der Alternative
			id = i - p1->prod2_index;

			//Namen generieren
			sprintf( puf1, "%s%d", name, id );

			//Initialisieren
			file << "\tstatic char *\t\t\t\tSSLR_" << puf1 << "Ri[" << p2->riAnz << "];\n";
		}
	}

	//Alle Follow-Mengen ausgeben
	file << "\n	//all follow sets for the error recovery\n";

	//Alle Follow-Mengen ausgeben
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Den Namen der Alternative holen
		name = hash_tab->getName( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Initialisieren
		file << "\tstatic long\t\t\t\t\tSSLR_" << name << "Follow[" << followAnz << "];\n";
	}

	//Private Methoden
	file << "\n\n\t//private methods\n\n";


	//Methoden der Klasse
file << "\n";
file << "	//push a new state on parse stack\n";
file << "	void SSLR_push( long );\n";
file << "\n";
file << "	//pop elements from parse stack\n";
file << "	long SSLR_pop( int );\n";
file << "\n";
file << "	//begin parsing\n";
file << "	int SSLR_parse( void );\n";
file << "\n";
file << "	//shift a new state onto the parse stack\n";
file << "	void SSLR_shift( SSLR_LR_TAB * );\n";
file << "\n";
file << "	//reduce with a production\n";
file << "	void SSLR_reduce( SSLR_LR_TAB * );\n";
file << "\n";
file << "	//error handling\n";
file << "	void SSLR_error( void );\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Ausgaberoutine für Alternativen
		file << "	//output an alternative\n";
		file << "	void SSLR_outputAlt( SSLR_NTERM_STR * );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}

	//Gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		//Ja, Hilfsroutinen ausgeben
		file << "	//shift a new state onto the parse stack\n";
		file << "	void SSLR_errShift( long );\n";
		file << "\n";
		file << "	//pop elements from the parse stack untill term may be shifted\n";
		file << "	void SSLR_errPop( long );\n";
		file << "\n";
		file << "	//delete next terminal\n";
		file << "	void SSLR_errDelete( void );\n";
		file << "\n";
		file << "	//delete all terminals untill term is found\n";
		file << "	void SSLR_errOverRead( long );\n";
		file << "\n";
	}

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//Ja, Prototypen ausgeben
		file << "\t//perform semantic actions associated with the production\n";
		file << "\t//to be reduced\n";
		file << "\tvoid SSLR_doSemAct( SSLR_LR_TAB * );\n";
		file << "\n";
	}

file << "	//get next terminal\n";
file << "	int SSLR_getTerminal( void );\n";
file << "\n";
file << "public:\n";
file << "\n";
file << "	//public methods \n";
file << "	SSLRParser( SSLEXScanner * );\n";
file << "	~SSLRParser();\n";
file << "\n";
file << "	//resets the whole parser\n";
file << "	void reset( void );\n";
file << "\n";
file << "	//start parsing\n";
file << "	int yyParse( void );\n";
file << "\n";
file << "\n";

	//benutzerdefinierte Daten holen
	userDefHeader = SSLR_scanner->getUserDefHeader( userDefHeaderCnt );

	//alle Zeilen
	for( j = 0; j < userDefHeaderCnt; j++ )
		//ausgeben
		file << userDefHeader[j];

file << "};\n";
file << "\n";
file << "\n";

	//Ende des Header-Files
	file << "#endif\n\n";
}

\}


