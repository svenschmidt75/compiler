/***************************************************************************
                          sslrparser.cpp  -  description
                             -------------------
    copyright            : (C) 2002 by Sven Schmidt
    email                : s.schmidt@lboro.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "_sslrparser.h"
#include <iostream>


/****************************
* This is the debug version *
****************************/


//Terminals for debugging
char *SSLR_scannerToken[] =
{
	/*0*/ "AST",
	/*1*/ "UNION",
	/*2*/ "SEMIKOLON",
	/*3*/ "SHIFT",
	/*4*/ "EXIT",
	/*5*/ "STRING",
	/*6*/ "TERMINAL",
	/*7*/ "DB",
	/*8*/ "EOPEN",
	/*9*/ "LEFT_ASSOC",
	/*10*/ "KLCLOSE",
	/*11*/ "COMMA",
	/*12*/ "PREC",
	/*13*/ "END_OF_PRODUCTION",
	/*14*/ "NON_TERMINAL",
	/*15*/ "ERROR",
	/*16*/ "TYPE",
	/*17*/ "BOPEN",
	/*18*/ "NUMBER",
	/*19*/ "SEMACT",
	/*20*/ "NOT",
	/*21*/ "NEW_ALTERNATIVE",
	/*22*/ "DELETE",
	/*23*/ "RIGHT_ASSOC",
	/*24*/ "POP",
	/*25*/ "BCLOSE",
	/*26*/ "semTypeOpen",
	/*27*/ "OVERREAD",
	/*28*/ "SEM",
	/*29*/ "SEP",
	/*30*/ "NON_ASSOC",
	/*31*/ "NTERM_TYPE",
	/*32*/ "DEFINITION",
	/*33*/ "KLOPEN",
	/*34*/ "semTypeClose",
	/*35*/ "TERM_TYPE",
	/*36*/ "EPSILON",
	/*37*/ "ECLOSE",
	/*38*/ "IDENT",
	/*39*/ "GRAMMAR",
	/*40*/ "ACCEPT",
	0L
};



	//SSLR initialisieren
	#define SSLR_INIT

//syntax analyze table
SSLRParser::SSLR_LR_TAB SSLRParser::SSLR_lrTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzTerm] = {
/* State 0 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initSSLR_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 1 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, start_0 }
 },
/* State 2 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 4 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 3 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 6 },{ LR_REDUCE, sect2_1 }
 },
/* State 4 */
{ { 0, 0 },{ LR_SHIFT, 9 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, union_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_1 },{ LR_REDUCE, union_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_1 },{ LR_REDUCE, union_1 }
 },
/* State 5 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, goal_0 }
 },
/* State 6 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 13 },{ 0, 0 },{ 0, 0 }
 },
/* State 7 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 20 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 21 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 22 },{ LR_SHIFT, 18 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 19 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_2 },{ LR_REDUCE, definition1_2 }
 },
/* State 8 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 23 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 9 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, startUnion_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 10 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 13 },{ 0, 0 },{ LR_REDUCE, sect2_0 }
 },
/* State 11 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 25 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 12 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 26 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 13 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, newProduction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 14 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 20 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 21 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 22 },{ LR_SHIFT, 18 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 19 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_0 },{ LR_REDUCE, sect1_0 }
 },
/* State 15 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, definition1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_1 },{ LR_REDUCE, definition1_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_1 },{ LR_REDUCE, definition1_1 }
 },
/* State 16 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 29 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, semType_1 },{ 0, 0 },{ 0, 0 }
 },
/* State 17 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 31 },{ 0, 0 },{ 0, 0 }
 },
/* State 18 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ntermDef_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ntermDef_0 },{ 0, 0 },{ 0, 0 }
 },
/* State 19 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ntermDef_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ntermDef_1 },{ 0, 0 },{ 0, 0 }
 },
/* State 20 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, associativity_0 },{ 0, 0 },{ 0, 0 }
 },
/* State 21 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, associativity_1 },{ 0, 0 },{ 0, 0 }
 },
/* State 22 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, associativity_2 },{ 0, 0 },{ 0, 0 }
 },
/* State 23 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 24 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 25 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ LR_REDUCE, sc2_1 }
 },
/* State 26 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 27 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, definition1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_0 },{ LR_REDUCE, definition1_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_0 },{ LR_REDUCE, definition1_0 }
 },
/* State 28 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 52 },{ 0, 0 },{ 0, 0 }
 },
/* State 29 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 53 },{ 0, 0 },{ 0, 0 }
 },
/* State 30 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, definition2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_1 },{ LR_REDUCE, definition2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_1 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 54 },{ LR_REDUCE, definition2_1 },{ LR_REDUCE, definition2_1 }
 },
/* State 31 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ LR_REDUCE, namelist2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ LR_REDUCE, namelist2_1 },{ LR_REDUCE, namelist2_1 }
 },
/* State 32 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 55 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 33 */
{ { 0, 0 },{ 0, 0 },{ LR_SHIFT, 57 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 34 */
{ { LR_SHIFT, 59 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 58 },{ 0, 0 },{ 0, 0 }
 },
/* State 35 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ LR_REDUCE, sc2_0 }
 },
/* State 36 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sslrRule_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 61 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 37 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ LR_SHIFT, 64 },{ LR_REDUCE, precedence_1 },{ LR_SHIFT, 48 },{ LR_REDUCE, precedence_1 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 38 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ LR_REDUCE, item1_1 },
{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ LR_REDUCE, item1_1 },{ LR_REDUCE, item1_1 },{ LR_REDUCE, item1_1 },{ 0, 0 },
{ LR_REDUCE, item1_1 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 39 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 40 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 41 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 42 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_REDUCE, rhs_3 },
{ 0, 0 },{ LR_REDUCE, rhs_3 },{ 0, 0 },{ LR_REDUCE, rhs_3 },{ LR_REDUCE, rhs_3 },{ LR_SHIFT, 48 },{ LR_REDUCE, rhs_3 },{ 0, 0 },
{ LR_REDUCE, rhs_3 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, rhs_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 43 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLOpen_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 44 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfBOpen_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 45 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfEOpen_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 46 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ LR_REDUCE, item2_1 },
{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ LR_REDUCE, item2_1 },{ LR_REDUCE, item2_1 },{ LR_REDUCE, item2_1 },{ 0, 0 },
{ LR_REDUCE, item2_1 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 47 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ LR_REDUCE, item3_0 },
{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ LR_REDUCE, item3_0 },{ LR_REDUCE, item3_0 },{ LR_REDUCE, item3_0 },{ 0, 0 },
{ LR_REDUCE, item3_0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 48 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ LR_REDUCE, item3_1 },
{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ LR_REDUCE, item3_1 },{ LR_REDUCE, item3_1 },{ LR_REDUCE, item3_1 },{ 0, 0 },
{ LR_REDUCE, item3_1 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 49 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ LR_REDUCE, item3_2 },
{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ LR_REDUCE, item3_2 },{ LR_REDUCE, item3_2 },{ LR_REDUCE, item3_2 },{ 0, 0 },
{ LR_REDUCE, item3_2 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 50 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },
{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ LR_REDUCE, semanticAction_0 },{ LR_REDUCE, semanticAction_0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },
{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 51 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, definition2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_0 },{ LR_REDUCE, definition2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 69 },{ LR_REDUCE, definition2_0 },{ LR_REDUCE, definition2_0 }
 },
/* State 52 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ LR_REDUCE, namelist1_1 },{ LR_REDUCE, namelist1_1 }
 },
/* State 53 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 70 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 54 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ LR_REDUCE, namelist2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ LR_REDUCE, namelist2_0 },{ LR_REDUCE, namelist2_0 }
 },
/* State 55 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, union_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_0 },{ LR_REDUCE, union_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_0 },{ LR_REDUCE, union_0 }
 },
/* State 56 */
{ { 0, 0 },{ 0, 0 },{ LR_SHIFT, 71 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 57 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, unionBody_1 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, unionBody_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 58 */
{ { 0, 0 },{ 0, 0 },{ LR_REDUCE, unionBody2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 59 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 72 },{ 0, 0 },{ 0, 0 }
 },
/* State 60 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 61 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ LR_REDUCE, newAlternative_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 62 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ LR_SHIFT, 75 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 63 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ LR_REDUCE, item1_0 },
{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ LR_REDUCE, item1_0 },{ LR_REDUCE, item1_0 },{ LR_REDUCE, item1_0 },{ 0, 0 },
{ LR_REDUCE, item1_0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 64 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 76 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 65 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 78 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 61 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 66 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 61 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 80 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 67 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 61 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 82 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 68 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ LR_REDUCE, item2_0 },
{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ LR_REDUCE, item2_0 },{ LR_REDUCE, item2_0 },{ LR_REDUCE, item2_0 },{ 0, 0 },
{ LR_REDUCE, item2_0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 69 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ LR_REDUCE, namelist1_0 },{ LR_REDUCE, namelist1_0 }
 },
/* State 70 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, semType_0 },{ 0, 0 },{ 0, 0 }
 },
/* State 71 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, unionBody_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, unionBody_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 72 */
{ { 0, 0 },{ 0, 0 },{ LR_REDUCE, unionBody2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 73 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ LR_SHIFT, 64 },{ LR_REDUCE, precedence_1 },{ LR_SHIFT, 48 },{ LR_REDUCE, precedence_1 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 74 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 75 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 84 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 76 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, precedence_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 77 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },
{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ LR_REDUCE, rhs_0 },{ LR_REDUCE, rhs_0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },
{ LR_REDUCE, rhs_0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 78 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },
{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ LR_REDUCE, ebnfKLClose_0 },{ LR_REDUCE, ebnfKLClose_0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 79 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ LR_REDUCE, rhs_1 },
{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ LR_REDUCE, rhs_1 },{ LR_REDUCE, rhs_1 },{ LR_REDUCE, rhs_1 },{ 0, 0 },
{ LR_REDUCE, rhs_1 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 80 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },
{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ LR_REDUCE, ebnfBClose_0 },{ LR_REDUCE, ebnfBClose_0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },
{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 81 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ LR_REDUCE, rhs_2 },
{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ LR_REDUCE, rhs_2 },{ LR_REDUCE, rhs_2 },{ LR_REDUCE, rhs_2 },{ 0, 0 },
{ LR_REDUCE, rhs_2 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 82 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },
{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ LR_REDUCE, ebnfEClose_0 },{ LR_REDUCE, ebnfEClose_0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },
{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 83 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ LR_SHIFT, 75 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 84 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 89 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 85 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 86 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 89 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 90 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 87 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 88 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 92 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 89 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initBeforeNumber_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 90 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 91 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 92 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ LR_SHIFT, 97 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 98 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 93 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 107 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 108 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 94 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 109 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 95 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 110 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 96 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 97 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, termList_1 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, termList_1 },{ LR_REDUCE, termList_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 98 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, negTerm_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 99 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 100 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorMsg_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 101 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 111 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 102 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 112 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 103 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 113 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 104 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 105 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 106 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 107 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 108 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 116 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 109 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 97 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 110 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 111 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 120 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 112 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 121 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 113 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 122 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 114 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 115 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 123 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 116 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, termList_0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, termList_0 },{ LR_REDUCE, termList_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 117 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 124 },{ LR_SHIFT, 108 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 118 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 119 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 120 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 125 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 121 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 126 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 122 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 127 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 123 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 124 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 129 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 125 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 126 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 127 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 128 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 129 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 130 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 131 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 132 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 132 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 133 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 }
};


//jump table
long SSLRParser::SSLR_jumpTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzNTerm] = {
//start, semType, errorMsg, newProduction, ebnfEClose, rhs, sc2, error, associativity, ebnfEOpen,
//ebnfKLOpen, rightSide, unionBody2, goal, definition1, definition2, ebnfBOpen, termList, sslrRule, semanticAction, errorAction2, startUnion, errorBody, sect1, sect2, precedence, ebnfKLClose, negTerm, item1, item2, item3, initBeforeNumber, ntermDef, unionBody, initSSLR, union, newAlternative, ebnfBClose, errorAction, errorBody2, namelist1, namelist2,

/* State 0 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   2,   0,   0,   0,   0,   0,   0,   0 },
/* State 1 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 2 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   3,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 3 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 4 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0 },
/* State 5 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 6 */
{   0,   0,   0,  12,   0,   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 7 */
{   0,   0,   0,   0,   0,   0,   0,   0,  17,   0,   0,   0,   0,   0,  14,  15,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 8 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 9 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 10 */
{   0,   0,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 11 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 12 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 13 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 14 */
{   0,   0,   0,   0,   0,   0,   0,   0,  17,   0,   0,   0,   0,   0,   0,  27,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 15 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 16 */
{   0,  28,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 17 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  30 },
/* State 18 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 19 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 20 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 21 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 22 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 23 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  33,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,  32,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 24 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 25 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 26 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,  36,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  37,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 27 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 28 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,  51,   0 },
/* State 29 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 30 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 31 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 32 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  56,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 33 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 34 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 35 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 36 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,  60,   0,   0,   0,   0,   0 },
/* State 37 */
{   0,   0,   0,   0,   0,  63,   0,   0,   0,  41,  39,   0,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,  62,   0,   0,   0,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 38 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 39 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,  65,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  37,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 40 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,  66,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  37,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 41 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,  67,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  37,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 42 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  68,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 43 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 44 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 45 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 46 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 47 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 48 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 49 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 50 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 51 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 52 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 53 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 54 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 55 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 56 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 57 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 58 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 59 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 60 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,   0,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  73,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 61 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 62 */
{   0,   0,   0,   0,   0,   0,   0,  74,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 63 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 64 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 65 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  77,   0,   0,   0,   0,
  0,   0,   0,   0,   0,  60,   0,   0,   0,   0,   0 },
/* State 66 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,  60,  79,   0,   0,   0,   0 },
/* State 67 */
{   0,   0,   0,   0,  81,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,  60,   0,   0,   0,   0,   0 },
/* State 68 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 69 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 70 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 71 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 72 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 73 */
{   0,   0,   0,   0,   0,  63,   0,   0,   0,  41,  39,   0,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,  83,   0,   0,   0,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 74 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 75 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 76 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 77 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 78 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 79 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 80 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 81 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 82 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 83 */
{   0,   0,   0,   0,   0,   0,   0,  85,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 84 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,  86,   0,   0,   0,   0,   0,   0,   0,   0,
 88,   0,   0,   0,   0,   0,   0,   0,  87,   0,   0 },
/* State 85 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 86 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 88,   0,   0,   0,   0,   0,   0,   0,  91,   0,   0 },
/* State 87 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 88 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 89 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 90 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 91 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 92 */
{   0,   0,  96,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,  93,   0,   0,  99,   0,   0,   0,   0,   0,   0,  94,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,  95,   0,   0,   0 },
/* State 93 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 94 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 95 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 96 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 97 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 98 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 99 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 100 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 101 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 102 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 103 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 104 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 105 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 106 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 107 */
{   0,   0, 114,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,  99,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0, 115,   0,   0,   0 },
/* State 108 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 109 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0, 117,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 110 */
{   0,   0, 118,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0, 119,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 111 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 112 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 113 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 114 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 115 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 116 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 117 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 118 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 119 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 120 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 121 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 122 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 123 */
{   0,   0, 128,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0, 119,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 124 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 125 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 126 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 127 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 128 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 129 */
{   0,   0, 130,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,  99,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0, 131,   0,   0,   0 },
/* State 130 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 131 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 132 */
{   0,   0, 133,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0, 119,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 133 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }
};


//follow sets for the error recovery
long SSLRParser::SSLR_startFollow[1] = { ACCEPT };
long SSLRParser::SSLR_goalFollow[1] = { ACCEPT };
long SSLRParser::SSLR_initSSLRFollow[1] = { DEFINITION };
long SSLRParser::SSLR_sect1Follow[2] = { ACCEPT, GRAMMAR };
long SSLRParser::SSLR_definition1Follow[7] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, GRAMMAR };
long SSLRParser::SSLR_unionFollow[7] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, GRAMMAR };
long SSLRParser::SSLR_startUnionFollow[1] = { BOPEN };
long SSLRParser::SSLR_unionBodyFollow[2] = { TYPE, BCLOSE };
long SSLRParser::SSLR_unionBody2Follow[1] = { SEMIKOLON };
long SSLRParser::SSLR_definition2Follow[7] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, GRAMMAR };
long SSLRParser::SSLR_ntermDefFollow[2] = { semTypeOpen, IDENT };
long SSLRParser::SSLR_semTypeFollow[1] = { IDENT };
long SSLRParser::SSLR_associativityFollow[1] = { IDENT };
long SSLRParser::SSLR_namelist1Follow[8] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, IDENT, GRAMMAR };
long SSLRParser::SSLR_namelist2Follow[8] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, IDENT, GRAMMAR };
long SSLRParser::SSLR_sect2Follow[1] = { ACCEPT };
long SSLRParser::SSLR_sc2Follow[2] = { ACCEPT, IDENT };
long SSLRParser::SSLR_sslrRuleFollow[1] = { END_OF_PRODUCTION };
long SSLRParser::SSLR_newProductionFollow[1] = { SEP };
long SSLRParser::SSLR_rightSideFollow[5] = { KLCLOSE, END_OF_PRODUCTION, NEW_ALTERNATIVE, BCLOSE, ECLOSE };
long SSLRParser::SSLR_newAlternativeFollow[6] = { TERMINAL, EOPEN, NON_TERMINAL, BOPEN, SEMACT, KLOPEN };
long SSLRParser::SSLR_item1Follow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_rhsFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_item2Follow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_item3Follow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_semanticActionFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_ebnfKLOpenFollow[6] = { TERMINAL, EOPEN, NON_TERMINAL, BOPEN, SEMACT, KLOPEN };
long SSLRParser::SSLR_ebnfBOpenFollow[6] = { TERMINAL, EOPEN, NON_TERMINAL, BOPEN, SEMACT, KLOPEN };
long SSLRParser::SSLR_ebnfEOpenFollow[6] = { TERMINAL, EOPEN, NON_TERMINAL, BOPEN, SEMACT, KLOPEN };
long SSLRParser::SSLR_ebnfKLCloseFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_ebnfBCloseFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_ebnfECloseFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_precedenceFollow[6] = { KLCLOSE, END_OF_PRODUCTION, ERROR, NEW_ALTERNATIVE, BCLOSE, ECLOSE };
long SSLRParser::SSLR_errorFollow[5] = { KLCLOSE, END_OF_PRODUCTION, NEW_ALTERNATIVE, BCLOSE, ECLOSE };
long SSLRParser::SSLR_errorBodyFollow[2] = { NUMBER, BCLOSE };
long SSLRParser::SSLR_errorBody2Follow[2] = { NUMBER, BCLOSE };
long SSLRParser::SSLR_initBeforeNumberFollow[1] = { DB };
long SSLRParser::SSLR_negTermFollow[1] = { KLOPEN };
long SSLRParser::SSLR_termListFollow[3] = { DB, KLCLOSE, COMMA };
long SSLRParser::SSLR_errorActionFollow[1] = { DB };
long SSLRParser::SSLR_errorAction2Follow[1] = { DB };
long SSLRParser::SSLR_errorMsgFollow[2] = { NUMBER, BCLOSE };

//all alternatives
char *SSLRParser::SSLR_start0Ri[1] = { "goal" };
char *SSLRParser::SSLR_goal0Ri[3] = { "initSSLR", "sect1", "sect2" };
char *SSLRParser::SSLR_initSSLR0Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_sect10Ri[3] = { "\'DEFINITION\'", "union", "definition1" };
char *SSLRParser::SSLR_definition10Ri[2] = { "definition1", "definition2" };
char *SSLRParser::SSLR_definition11Ri[1] = { "definition2" };
char *SSLRParser::SSLR_definition12Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_union0Ri[4] = { "startUnion", "\'BOPEN\'", "unionBody", "\'BCLOSE\'" };
char *SSLRParser::SSLR_union1Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_startUnion0Ri[1] = { "\'UNION\'" };
char *SSLRParser::SSLR_unionBody0Ri[3] = { "unionBody", "unionBody2", "\'SEMIKOLON\'" };
char *SSLRParser::SSLR_unionBody1Ri[2] = { "unionBody2", "\'SEMIKOLON\'" };
char *SSLRParser::SSLR_unionBody20Ri[2] = { "\'TYPE\'", "\'IDENT\'" };
char *SSLRParser::SSLR_unionBody21Ri[3] = { "\'TYPE\'", "\'AST\'", "\'IDENT\'" };
char *SSLRParser::SSLR_definition20Ri[3] = { "ntermDef", "semType", "namelist1" };
char *SSLRParser::SSLR_definition21Ri[2] = { "associativity", "namelist2" };
char *SSLRParser::SSLR_ntermDef0Ri[1] = { "\'NTERM_TYPE\'" };
char *SSLRParser::SSLR_ntermDef1Ri[1] = { "\'TERM_TYPE\'" };
char *SSLRParser::SSLR_semType0Ri[3] = { "\'semTypeOpen\'", "\'IDENT\'", "\'semTypeClose\'" };
char *SSLRParser::SSLR_semType1Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_associativity0Ri[1] = { "\'LEFT_ASSOC\'" };
char *SSLRParser::SSLR_associativity1Ri[1] = { "\'RIGHT_ASSOC\'" };
char *SSLRParser::SSLR_associativity2Ri[1] = { "\'NON_ASSOC\'" };
char *SSLRParser::SSLR_namelist10Ri[2] = { "namelist1", "\'IDENT\'" };
char *SSLRParser::SSLR_namelist11Ri[1] = { "\'IDENT\'" };
char *SSLRParser::SSLR_namelist20Ri[2] = { "namelist2", "\'IDENT\'" };
char *SSLRParser::SSLR_namelist21Ri[1] = { "\'IDENT\'" };
char *SSLRParser::SSLR_sect20Ri[2] = { "\'GRAMMAR\'", "sc2" };
char *SSLRParser::SSLR_sect21Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_sc20Ri[3] = { "sc2", "sslrRule", "\'END_OF_PRODUCTION\'" };
char *SSLRParser::SSLR_sc21Ri[2] = { "sslrRule", "\'END_OF_PRODUCTION\'" };
char *SSLRParser::SSLR_sslrRule0Ri[3] = { "newProduction", "\'SEP\'", "rightSide" };
char *SSLRParser::SSLR_newProduction0Ri[1] = { "\'IDENT\'" };
char *SSLRParser::SSLR_rightSide0Ri[3] = { "item1", "precedence", "error" };
char *SSLRParser::SSLR_rightSide1Ri[5] = { "rightSide", "newAlternative", "item1", "precedence", "error" };
char *SSLRParser::SSLR_newAlternative0Ri[1] = { "\'NEW_ALTERNATIVE\'" };
char *SSLRParser::SSLR_item10Ri[2] = { "item1", "rhs" };
char *SSLRParser::SSLR_item11Ri[1] = { "rhs" };
char *SSLRParser::SSLR_rhs0Ri[3] = { "ebnfKLOpen", "rightSide", "ebnfKLClose" };
char *SSLRParser::SSLR_rhs1Ri[3] = { "ebnfBOpen", "rightSide", "ebnfBClose" };
char *SSLRParser::SSLR_rhs2Ri[3] = { "ebnfEOpen", "rightSide", "ebnfEClose" };
char *SSLRParser::SSLR_rhs3Ri[1] = { "item2" };
char *SSLRParser::SSLR_item20Ri[2] = { "item2", "item3" };
char *SSLRParser::SSLR_item21Ri[1] = { "item3" };
char *SSLRParser::SSLR_item30Ri[1] = { "\'TERMINAL\'" };
char *SSLRParser::SSLR_item31Ri[1] = { "\'NON_TERMINAL\'" };
char *SSLRParser::SSLR_item32Ri[1] = { "semanticAction" };
char *SSLRParser::SSLR_semanticAction0Ri[1] = { "\'SEMACT\'" };
char *SSLRParser::SSLR_ebnfKLOpen0Ri[1] = { "\'KLOPEN\'" };
char *SSLRParser::SSLR_ebnfBOpen0Ri[1] = { "\'BOPEN\'" };
char *SSLRParser::SSLR_ebnfEOpen0Ri[1] = { "\'EOPEN\'" };
char *SSLRParser::SSLR_ebnfKLClose0Ri[1] = { "\'KLCLOSE\'" };
char *SSLRParser::SSLR_ebnfBClose0Ri[1] = { "\'BCLOSE\'" };
char *SSLRParser::SSLR_ebnfEClose0Ri[1] = { "\'ECLOSE\'" };
char *SSLRParser::SSLR_precedence0Ri[2] = { "\'PREC\'", "\'TERMINAL\'" };
char *SSLRParser::SSLR_precedence1Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_error0Ri[4] = { "\'ERROR\'", "\'BOPEN\'", "errorBody", "\'BCLOSE\'" };
char *SSLRParser::SSLR_error1Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_errorBody0Ri[2] = { "errorBody", "errorBody2" };
char *SSLRParser::SSLR_errorBody1Ri[1] = { "errorBody2" };
char *SSLRParser::SSLR_errorBody20Ri[5] = { "initBeforeNumber", "\'DB\'", "termList", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody21Ri[7] = { "initBeforeNumber", "\'DB\'", "termList", "\'DB\'", "errorAction", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody22Ri[8] = { "initBeforeNumber", "\'DB\'", "negTerm", "\'KLOPEN\'", "termList", "\'KLCLOSE\'", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody23Ri[10] = { "initBeforeNumber", "\'DB\'", "negTerm", "\'KLOPEN\'", "termList", "\'KLCLOSE\'", "\'DB\'", "errorAction", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody24Ri[5] = { "initBeforeNumber", "\'DB\'", "errorAction", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody25Ri[3] = { "initBeforeNumber", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_initBeforeNumber0Ri[1] = { "\'NUMBER\'" };
char *SSLRParser::SSLR_negTerm0Ri[1] = { "\'NOT\'" };
char *SSLRParser::SSLR_termList0Ri[3] = { "termList", "\'COMMA\'", "\'TERMINAL\'" };
char *SSLRParser::SSLR_termList1Ri[1] = { "\'TERMINAL\'" };
char *SSLRParser::SSLR_errorAction0Ri[3] = { "errorAction", "\'DB\'", "errorAction2" };
char *SSLRParser::SSLR_errorAction1Ri[1] = { "errorAction2" };
char *SSLRParser::SSLR_errorAction20Ri[4] = { "\'OVERREAD\'", "\'KLOPEN\'", "\'TERMINAL\'", "\'KLCLOSE\'" };
char *SSLRParser::SSLR_errorAction21Ri[4] = { "\'SHIFT\'", "\'KLOPEN\'", "\'TERMINAL\'", "\'KLCLOSE\'" };
char *SSLRParser::SSLR_errorAction22Ri[4] = { "\'POP\'", "\'KLOPEN\'", "\'TERMINAL\'", "\'KLCLOSE\'" };
char *SSLRParser::SSLR_errorAction23Ri[1] = { "\'EXIT\'" };
char *SSLRParser::SSLR_errorAction24Ri[1] = { "\'DELETE\'" };
char *SSLRParser::SSLR_errorAction25Ri[1] = { "\'SEM\'" };
char *SSLRParser::SSLR_errorMsg0Ri[1] = { "\'STRING\'" };
char *SSLRParser::SSLR_errorMsg1Ri[1] = { "\'EPSILON\'" };


//all alternatives
SSLRParser::SSLR_NTERM_STR SSLRParser::SSLR_ntermStr[SSLRParser::SSLR_anzProd] = {
{ "start", SSLRParser::SSLR_start0Ri, start, 1, SSLRParser::SSLR_startFollow, 1 },
{ "goal", SSLRParser::SSLR_goal0Ri, goal, 3, SSLRParser::SSLR_goalFollow, 1 },
{ "initSSLR", SSLRParser::SSLR_initSSLR0Ri, initSSLR, 0, SSLRParser::SSLR_initSSLRFollow, 1 },
{ "sect1", SSLRParser::SSLR_sect10Ri, sect1, 3, SSLRParser::SSLR_sect1Follow, 2 },
{ "definition1", SSLRParser::SSLR_definition10Ri, definition1, 2, SSLRParser::SSLR_definition1Follow, 7 },
{ "definition1", SSLRParser::SSLR_definition11Ri, definition1, 1, SSLRParser::SSLR_definition1Follow, 7 },
{ "definition1", SSLRParser::SSLR_definition12Ri, definition1, 0, SSLRParser::SSLR_definition1Follow, 7 },
{ "union", SSLRParser::SSLR_union0Ri, union, 4, SSLRParser::SSLR_unionFollow, 7 },
{ "union", SSLRParser::SSLR_union1Ri, union, 0, SSLRParser::SSLR_unionFollow, 7 },
{ "startUnion", SSLRParser::SSLR_startUnion0Ri, startUnion, 1, SSLRParser::SSLR_startUnionFollow, 1 },
{ "unionBody", SSLRParser::SSLR_unionBody0Ri, unionBody, 3, SSLRParser::SSLR_unionBodyFollow, 2 },
{ "unionBody", SSLRParser::SSLR_unionBody1Ri, unionBody, 2, SSLRParser::SSLR_unionBodyFollow, 2 },
{ "unionBody2", SSLRParser::SSLR_unionBody20Ri, unionBody2, 2, SSLRParser::SSLR_unionBody2Follow, 1 },
{ "unionBody2", SSLRParser::SSLR_unionBody21Ri, unionBody2, 3, SSLRParser::SSLR_unionBody2Follow, 1 },
{ "definition2", SSLRParser::SSLR_definition20Ri, definition2, 3, SSLRParser::SSLR_definition2Follow, 7 },
{ "definition2", SSLRParser::SSLR_definition21Ri, definition2, 2, SSLRParser::SSLR_definition2Follow, 7 },
{ "ntermDef", SSLRParser::SSLR_ntermDef0Ri, ntermDef, 1, SSLRParser::SSLR_ntermDefFollow, 2 },
{ "ntermDef", SSLRParser::SSLR_ntermDef1Ri, ntermDef, 1, SSLRParser::SSLR_ntermDefFollow, 2 },
{ "semType", SSLRParser::SSLR_semType0Ri, semType, 3, SSLRParser::SSLR_semTypeFollow, 1 },
{ "semType", SSLRParser::SSLR_semType1Ri, semType, 0, SSLRParser::SSLR_semTypeFollow, 1 },
{ "associativity", SSLRParser::SSLR_associativity0Ri, associativity, 1, SSLRParser::SSLR_associativityFollow, 1 },
{ "associativity", SSLRParser::SSLR_associativity1Ri, associativity, 1, SSLRParser::SSLR_associativityFollow, 1 },
{ "associativity", SSLRParser::SSLR_associativity2Ri, associativity, 1, SSLRParser::SSLR_associativityFollow, 1 },
{ "namelist1", SSLRParser::SSLR_namelist10Ri, namelist1, 2, SSLRParser::SSLR_namelist1Follow, 8 },
{ "namelist1", SSLRParser::SSLR_namelist11Ri, namelist1, 1, SSLRParser::SSLR_namelist1Follow, 8 },
{ "namelist2", SSLRParser::SSLR_namelist20Ri, namelist2, 2, SSLRParser::SSLR_namelist2Follow, 8 },
{ "namelist2", SSLRParser::SSLR_namelist21Ri, namelist2, 1, SSLRParser::SSLR_namelist2Follow, 8 },
{ "sect2", SSLRParser::SSLR_sect20Ri, sect2, 2, SSLRParser::SSLR_sect2Follow, 1 },
{ "sect2", SSLRParser::SSLR_sect21Ri, sect2, 0, SSLRParser::SSLR_sect2Follow, 1 },
{ "sc2", SSLRParser::SSLR_sc20Ri, sc2, 3, SSLRParser::SSLR_sc2Follow, 2 },
{ "sc2", SSLRParser::SSLR_sc21Ri, sc2, 2, SSLRParser::SSLR_sc2Follow, 2 },
{ "sslrRule", SSLRParser::SSLR_sslrRule0Ri, sslrRule, 3, SSLRParser::SSLR_sslrRuleFollow, 1 },
{ "newProduction", SSLRParser::SSLR_newProduction0Ri, newProduction, 1, SSLRParser::SSLR_newProductionFollow, 1 },
{ "rightSide", SSLRParser::SSLR_rightSide0Ri, rightSide, 3, SSLRParser::SSLR_rightSideFollow, 5 },
{ "rightSide", SSLRParser::SSLR_rightSide1Ri, rightSide, 5, SSLRParser::SSLR_rightSideFollow, 5 },
{ "newAlternative", SSLRParser::SSLR_newAlternative0Ri, newAlternative, 1, SSLRParser::SSLR_newAlternativeFollow, 6 },
{ "item1", SSLRParser::SSLR_item10Ri, item1, 2, SSLRParser::SSLR_item1Follow, 13 },
{ "item1", SSLRParser::SSLR_item11Ri, item1, 1, SSLRParser::SSLR_item1Follow, 13 },
{ "rhs", SSLRParser::SSLR_rhs0Ri, rhs, 3, SSLRParser::SSLR_rhsFollow, 13 },
{ "rhs", SSLRParser::SSLR_rhs1Ri, rhs, 3, SSLRParser::SSLR_rhsFollow, 13 },
{ "rhs", SSLRParser::SSLR_rhs2Ri, rhs, 3, SSLRParser::SSLR_rhsFollow, 13 },
{ "rhs", SSLRParser::SSLR_rhs3Ri, rhs, 1, SSLRParser::SSLR_rhsFollow, 13 },
{ "item2", SSLRParser::SSLR_item20Ri, item2, 2, SSLRParser::SSLR_item2Follow, 13 },
{ "item2", SSLRParser::SSLR_item21Ri, item2, 1, SSLRParser::SSLR_item2Follow, 13 },
{ "item3", SSLRParser::SSLR_item30Ri, item3, 1, SSLRParser::SSLR_item3Follow, 13 },
{ "item3", SSLRParser::SSLR_item31Ri, item3, 1, SSLRParser::SSLR_item3Follow, 13 },
{ "item3", SSLRParser::SSLR_item32Ri, item3, 1, SSLRParser::SSLR_item3Follow, 13 },
{ "semanticAction", SSLRParser::SSLR_semanticAction0Ri, semanticAction, 1, SSLRParser::SSLR_semanticActionFollow, 13 },
{ "ebnfKLOpen", SSLRParser::SSLR_ebnfKLOpen0Ri, ebnfKLOpen, 1, SSLRParser::SSLR_ebnfKLOpenFollow, 6 },
{ "ebnfBOpen", SSLRParser::SSLR_ebnfBOpen0Ri, ebnfBOpen, 1, SSLRParser::SSLR_ebnfBOpenFollow, 6 },
{ "ebnfEOpen", SSLRParser::SSLR_ebnfEOpen0Ri, ebnfEOpen, 1, SSLRParser::SSLR_ebnfEOpenFollow, 6 },
{ "ebnfKLClose", SSLRParser::SSLR_ebnfKLClose0Ri, ebnfKLClose, 1, SSLRParser::SSLR_ebnfKLCloseFollow, 13 },
{ "ebnfBClose", SSLRParser::SSLR_ebnfBClose0Ri, ebnfBClose, 1, SSLRParser::SSLR_ebnfBCloseFollow, 13 },
{ "ebnfEClose", SSLRParser::SSLR_ebnfEClose0Ri, ebnfEClose, 1, SSLRParser::SSLR_ebnfECloseFollow, 13 },
{ "precedence", SSLRParser::SSLR_precedence0Ri, precedence, 2, SSLRParser::SSLR_precedenceFollow, 6 },
{ "precedence", SSLRParser::SSLR_precedence1Ri, precedence, 0, SSLRParser::SSLR_precedenceFollow, 6 },
{ "error", SSLRParser::SSLR_error0Ri, error, 4, SSLRParser::SSLR_errorFollow, 5 },
{ "error", SSLRParser::SSLR_error1Ri, error, 0, SSLRParser::SSLR_errorFollow, 5 },
{ "errorBody", SSLRParser::SSLR_errorBody0Ri, errorBody, 2, SSLRParser::SSLR_errorBodyFollow, 2 },
{ "errorBody", SSLRParser::SSLR_errorBody1Ri, errorBody, 1, SSLRParser::SSLR_errorBodyFollow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody20Ri, errorBody2, 5, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody21Ri, errorBody2, 7, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody22Ri, errorBody2, 8, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody23Ri, errorBody2, 10, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody24Ri, errorBody2, 5, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody25Ri, errorBody2, 3, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "initBeforeNumber", SSLRParser::SSLR_initBeforeNumber0Ri, initBeforeNumber, 1, SSLRParser::SSLR_initBeforeNumberFollow, 1 },
{ "negTerm", SSLRParser::SSLR_negTerm0Ri, negTerm, 1, SSLRParser::SSLR_negTermFollow, 1 },
{ "termList", SSLRParser::SSLR_termList0Ri, termList, 3, SSLRParser::SSLR_termListFollow, 3 },
{ "termList", SSLRParser::SSLR_termList1Ri, termList, 1, SSLRParser::SSLR_termListFollow, 3 },
{ "errorAction", SSLRParser::SSLR_errorAction0Ri, errorAction, 3, SSLRParser::SSLR_errorActionFollow, 1 },
{ "errorAction", SSLRParser::SSLR_errorAction1Ri, errorAction, 1, SSLRParser::SSLR_errorActionFollow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction20Ri, errorAction2, 4, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction21Ri, errorAction2, 4, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction22Ri, errorAction2, 4, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction23Ri, errorAction2, 1, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction24Ri, errorAction2, 1, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction25Ri, errorAction2, 1, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorMsg", SSLRParser::SSLR_errorMsg0Ri, errorMsg, 1, SSLRParser::SSLR_errorMsgFollow, 2 },
{ "errorMsg", SSLRParser::SSLR_errorMsg1Ri, errorMsg, 0, SSLRParser::SSLR_errorMsgFollow, 2 }};


#ifdef SSLR_DEBUG

//names of the terminals
char *SSLRParser::SSLR_termName[SSLRParser::SSLR_anzTerm] =
{ "AST", "UNION", "SEMIKOLON", "SHIFT", "EXIT", "STRING", "TERMINAL", "DB", "EOPEN", "LEFT_ASSOC", "KLCLOSE", "COMMA", "PREC", "END_OF_PRODUCTION", "NON_TERMINAL", "ERROR",
"TYPE", "BOPEN", "NUMBER", "SEMACT", "NOT", "NEW_ALTERNATIVE", "DELETE", "RIGHT_ASSOC", "POP", "BCLOSE", "semTypeOpen", "OVERREAD", "SEM", "SEP", "NON_ASSOC", "NTERM_TYPE",
"DEFINITION", "KLOPEN", "semTypeClose", "TERM_TYPE", "EPSILON", "ECLOSE", "IDENT", "GRAMMAR", "ACCEPT" };

#endif



void SSLRParser::SSLR_printErrorMsg( bool print, char *errMsg  )
{
	//print an error message, but only when it is allowed
	if( ( print == true ) && !SSLR_anzSuppressError )
		//allowed
		cerr << "sslr: ERROR: line " << SSLR_line << ": " << errMsg << endl;
}


void SSLRParser::SSLR_errPop( long termi )
{
	//get current state
	long state = SSLR_state;

	//pop states from the parse stack untill termi may be shifted
	while( SSLR_lrTab[state][termi].state != LR_SHIFT )
	{
		//pop one element
		state = SSLR_pop( 1 );

		//are we in state 1, that is could'n termi be shifted?
		if( state == 1 )
		{
			//all states poped from parse stack, exit
			SSLR_state = state;

			//set current terminal to ACCEPT to simulate successful parsing
			SSLR_terminal = ACCEPT;
			return;
		}
	}

	//set new state
	SSLR_state = state;
}


void SSLRParser::SSLR_errShift( long termi )
{
	//can we reduce here?
	while( SSLR_lrTab[SSLR_state][termi].state == LR_REDUCE )
		//yes, that might allow recovery
		SSLR_reduce( &SSLR_lrTab[SSLR_state][termi] );

	//shift a new state
	if( SSLR_lrTab[SSLR_state][termi].state == LR_SHIFT )
		//push new state onto the parse stack
		SSLR_push( SSLR_lrTab[SSLR_state][termi].value );
}


void SSLRParser::SSLR_errDelete( void )
{
	//delete current terminal
	SSLR_terminal = SSLR_getTerminal();
}


void SSLRParser::SSLR_errOverRead( long termi )
{
	//delete all terminals untill termi is found
	do
	{
		//get next terminal
		SSLR_terminal = SSLR_getTerminal();

		//equal?
		if( SSLR_terminal == termi )
			//yes, return
			return;

		else if( SSLR_terminal == ACCEPT )
		{
			//abort parsing
			SSLR_state = 1;
			return;
		}

	}while( 1 );
}


void SSLRParser::SSLR_error( void )
{
	//error handling
	long	tmpState, tmpSp;
	int		rec = 0;

	//no more semantic actions allowed
	SSLR_semAct = false;

	//count error
	SSLR_anzError++;


	switch( SSLR_state )
	{
		case 8:
		{
			switch( SSLR_terminal )
			{
				//line 1048,  union ->  startUnion . 'BOPEN'  unionBody  'BCLOSE'
				default:
				{
					//show user defined error message
					SSLR_printErrorMsg( true, "Missing { in %union!" );

					//shift terminal BOPEN
					SSLR_ERROR_SHIFT( BOPEN );

					//skip automatic error recovery
					rec++;

					//leave
					break;
				}
			}

			//leave
			break;
		}

		case 9:
		{
			switch( SSLR_terminal )
			{
				//line 1048,  union ->  startUnion . 'BOPEN'  unionBody  'BCLOSE'
				default:
				{
					//show user defined error message
					SSLR_printErrorMsg( true, "Missing { in %union!" );

					//shift terminal BOPEN
					SSLR_ERROR_SHIFT( BOPEN );

					//skip automatic error recovery
					rec++;

					//leave
					break;
				}
			}

			//leave
			break;
		}

		default:
		{
			//default error message
			SSLR_printErrorMsg( true, "Syntax error!" );
			break;
		}
	}


	//supress further error messages
	SSLR_anzSuppressError = SSLR_anzSuppressErrorMsg;

	//skip intern error recovery?
	if( rec )
		//yes, return
		return;

	//save current stack position
	tmpSp = SSLR_sp;

	//pop states from the parse stack until a valid transition is found
	do
	{
		//pop one state from the parse stack
		tmpState = SSLR_pop( 1 );

		//is there a transition?
		if( ( SSLR_sp > 0 ) && ( SSLR_lrTab[tmpState][SSLR_terminal].state == LR_SHIFT ) )
		{
			//we found a valid transition, consider recovered
			SSLR_state = tmpState;
			return;
		}

		//did we check the whole stack?
		else if( SSLR_sp < 1 )
		{
			//the whole stack has been visited without success
			SSLR_terminal = SSLR_getTerminal();

			//end of input, that is ACCEPT?
			if( SSLR_terminal == ACCEPT )
			{
				//yes, stop parsing
				SSLR_state = 1;
				return;
			}

			//set stack pointer
			SSLR_sp = tmpSp;
		}

	}while( 1 );
}


SSLRParser::SSLRParser( SSLEXScanner *scan )
{
	//call reset to initialize the parser
	reset();

	//scanner class
	SSLR_scanner = scan;

#ifdef SSLR_INIT
	//inizialize user defined variables
	init();
#endif
}


SSLRParser::~SSLRParser()
{
#ifdef SSLR_INIT
	//uninizialize user defined variables
	deinit();
#endif
}


void SSLRParser::reset( void )
{
	//resets the whole parser

#ifdef SSLR_DEBUG
	//output
	cout << setw( SSLR_maxStateWidth ) << " state |"
	<< setw( SSLR_maxElemWidth ) << " stack |" << setw( SSLR_maxAltRightSideWidth )
	<< " action |" << setw( SSLR_maxElemWidth ) << " next |" << endl;

	//separator
	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << "|"
	<< setw( SSLR_maxElemWidth ) << "|" << setw( SSLR_maxAltRightSideWidth )
	<< "|" << setw( SSLR_maxElemWidth ) << "|" << endl;

	//initialize
	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' ) << " 0 |"
	<< setw( SSLR_maxElemWidth ) << "|" << setw( SSLR_maxAltRightSideWidth )
	<< "|" << setw( SSLR_maxElemWidth ) << "|" << endl;

	//set debug stack pointer
	SSLR_dbgSp = 0;
#endif

	//parse stack pointer
	SSLR_sp = 0;

	//start with state 0
	SSLR_push( 0 );
	SSLR_state = 0;

	//no errors yet
	SSLR_anzError = 0;
	SSLR_anzSuppressError = 0;

	//semantic actions
	SSLR_semAct = true;

	//stack counter for semantic action stack
	SSLR_semStackCnt = 0;
}


int SSLRParser::SSLR_getTerminal( void )
{
	//semantic actions allowed?
	if( SSLR_semAct == true )
	{
		//semantic stack overflow?
		if( SSLR_semStackCnt >= SSLR_maxStackSize )
		{
			//yes, print an error message
			cerr << "SSLRParser::SSLR_getTerminal: Semantic stack overflow!" << endl;

			//no more semantic actions allowed
			SSLR_semAct = false;
		}

		else
			//push attribute on stack for semantic actions
			SSLR_semStack[SSLR_semStackCnt++] = SSLR_attributeStr;
	}

	//get line
	SSLR_line = SSLR_scanner->getYYLineno();

	//get next terminal
	SSLR_terminal = SSLR_scanner->yyLex( &SSLR_attributeStr );

	//return terminal
	return( SSLR_terminal );
}


int SSLRParser::yyParse( void )
{
	//start parsing

	//get first terminal
	SSLR_terminal = SSLR_getTerminal();

	//start parsing
	return( SSLR_parse() );
}


void SSLRParser::SSLR_push( long ast )
{
	//push a new state on the parse stack
	SSLR_stack[SSLR_sp++] = ast;

	//stack overflow?
	if( SSLR_sp > SSLR_maxStackSize )
	{
		//stack-overflow
		cerr << "SSLRParser::SSLR_push: stack overflow!\nExiting..." << endl;
		exit( 1 );
	}

	//set new state
	SSLR_state = ast;
}


long SSLRParser::SSLR_pop( int anz )
{
	//pop anz elements from the parse stack
	SSLR_sp -= anz;

	//stack underflow?
	if( SSLR_sp < 0 )
	{
		//stack underflow
		cerr << "SSLRParser::SSLR_pop: stack underflow!\nExiting..." << endl;
		exit( 1 );
	}

	//return new state
	return( SSLR_stack[SSLR_sp - 1] );
}


int SSLRParser::SSLR_parse( void )
{
	//begin parsing
	while( 1 )
	{
		//end of parsing?
		if( ( SSLR_state == 1 ) && ( SSLR_terminal == ACCEPT ) )
			//return number of errors
			return( SSLR_anzError );

		//shift terminal SSLR_terminal?
		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_SHIFT )
		{
			//yes
			SSLR_shift( &SSLR_lrTab[SSLR_state][SSLR_terminal] );

			//get new terminal
			SSLR_terminal = SSLR_getTerminal();
		}

		//reduce with production?
		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_REDUCE )
			//reduce
			SSLR_reduce( &SSLR_lrTab[SSLR_state][SSLR_terminal] );

		//otherwise an error occured
		else
			//call error recovery
			SSLR_error();
	}
}


void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )
{
	//shift a terminal onto the parse stack

	//reduce number of error messages to supress?
	if( SSLR_anzSuppressError )
		//yes, until it is zero
		SSLR_anzSuppressError--;

#ifdef SSLR_DEBUG
	//debug stack overflow?
	if( SSLR_dbgSp >= SSLR_maxStackSize )
	{
		//debug stack overflow
		cerr << "SSLRParser::SSLR_shift: Debug stack overflow!" << endl;

		//exit
		exit( 1 );
	}

	//set debug stack
	SSLR_dbgStack[SSLR_dbgSp].elem = true;
	SSLR_dbgStack[SSLR_dbgSp++].index = SSLR_terminal;

	//output
	SSLR_outputDbgStack( SSLR_state, LR_SHIFT, SSLR_terminal, SSLR_terminal );
#endif

	//shift a new state onto the stack
	SSLR_push( tab->value );
}


void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )
{
	//reduce with production
	SSLR_NTERM_STR	*n;

	//perform a semantic action accociated with the reduced production
	SSLR_doSemAct( tab );

	//get a pointer to the alternative
	n = &SSLR_ntermStr[tab->value];

#ifdef SSLR_DEBUG
	//pop elements from debug stack
	SSLR_dbgSp -= n->elem;

	//debug stack overflow?
	if( SSLR_dbgSp >= SSLR_maxStackSize )
	{
		//debug stack overflow
		cerr << "SSLRParser::SSLR_reduce: Debug stack overflow!" << endl;

		//exit
		exit( 1 );
	}

	//set debug stack
	SSLR_dbgStack[SSLR_dbgSp].elem = false;
	SSLR_dbgStack[SSLR_dbgSp++].index = tab->value;

	//output
	SSLR_outputDbgStack( SSLR_state, LR_REDUCE, tab->value, SSLR_terminal );
#endif

	//remove states form stack
	SSLR_state = SSLR_pop( n->elem );

	//get new state
	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];

	//push new state on stack
	SSLR_push( SSLR_state );
}


#ifdef SSLR_DEBUG
void SSLRParser::SSLR_outputDbgStack( int state, int action, int index, int next )
{
	//print the debugging stack
	char	statePuf[SSLR_maxStateWidth + 1];
	char	stackPuf[SSLR_maxElemWidth + 1];
	char	actionPuf[SSLR_maxAltRightSideWidth + 1];
	char	nextPuf[SSLR_maxElemWidth + 1];
	int		stackIndex, i;

	//curent state in string
	sprintf( statePuf, "%d", SSLR_state );

	//print first element
	stackIndex = SSLR_dbgStack[0].index;

	//terminal?
	if( SSLR_dbgStack[0].elem == true )
		//terminal
		sprintf( stackPuf, "%s", SSLR_termName[stackIndex] );

	else
		//is nonterminal
		sprintf( stackPuf, "%s", SSLR_ntermStr[stackIndex].name );

	//action
	if( action == LR_SHIFT )
	{
		//shift state
		sprintf( actionPuf, "push %s", SSLR_termName[index] );


		//next is empty
		sprintf( nextPuf, "%s", " " );
	}

	else
	{
		SSLR_NTERM_STR	*str = &SSLR_ntermStr[index];
		int				i;

		//reduce with alternative
		sprintf( actionPuf, "reduce with " );

		//print name of alternative
		strcat( actionPuf, str->name );
		strcat( actionPuf, " -> " );

		//print all elements on the right side
		for( i = 0; i < str->elem; i++ )
		{
			//print element
			strcat( actionPuf, str->ri[i] );

			//more elements?
			if( i < ( str->elem - 1 ) )
				//yes
				strcat( actionPuf, " " );
		}

		//alternatives with zero elements have EPSILON on the right side
		if( !str->elem )
			//print EPSILON
			strcat( actionPuf, str->ri[0] );

		//next is the current terminal
		sprintf( nextPuf, "%s", SSLR_termName[next] );
	}

	//separator
	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << "|"
	<< setw( SSLR_maxElemWidth ) << "|" << setw( SSLR_maxAltRightSideWidth )
	<< "|" << setw( SSLR_maxElemWidth ) << "|" << endl;

	//initialize
	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )
	<< ( string( statePuf ) + " |" )
	<< setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + " |" )
	<< setw( SSLR_maxAltRightSideWidth ) << ( string( actionPuf ) + " |" )
	<< setw( SSLR_maxElemWidth ) << ( string( nextPuf ) + " |" ) << endl;



	//print all other debug stack entries
	for( i = 1; i < SSLR_dbgSp; i++ )
	{
		//print element
		stackIndex = SSLR_dbgStack[i].index;

		//terminal?
		if( SSLR_dbgStack[i].elem == true )
			//terminal
			sprintf( stackPuf, "%s", SSLR_termName[stackIndex] );

		else
			//is nonterminal
			sprintf( stackPuf, "%s", SSLR_ntermStr[stackIndex].name );

		cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )
		<< "|" << setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + " |" )
		<< setw( SSLR_maxAltRightSideWidth ) << "|"
		<< setw( SSLR_maxElemWidth ) << "|" << endl;
	}
}
#endif


void SSLRParser::SSLR_doSemAct( SSLR_LR_TAB *tab )
{
	//do semantic actions before reduction
	SSLR_NTERM_STR	*n;
	SSLR_TYPE		tmp;

	//semantic actions allowed?
	if( SSLR_semAct == true )
	{
		//get a pointer to the alternative
		n = &SSLR_ntermStr[tab->value];

		//Alternative to reduce with
		switch( tab->value )
		{
			// goal ->  initSSLR  sect1  sect2 .
			case goal_0:
			{

	//die komplette Eingabe wurde erfolgreich geparst, nun die LR-Tabellen erzeugen

	//Meldung?
	if( argv_str->verbose )
		//ja, start-Produktion nicht mitzhlen
		cout << "sslr: " << prod_anz - 1 << " productions analyzed!" << endl;

	//(Nicht)Terminale checken
	err += checkAll();

	//die PROD2_STR sortieren
	sortProd2Str();

	//finde doppelte Alternativen innerhalb einer Produktion
	err += findDoubleAlt();

	//alles OK?
	if( !err && !SSLR_anzError )
	{
		//Grammatik ausgeben
		outputGrammar();

		//FIRST-Mengen berechnen
		genAllFirst();

		//FOLLOW-Mengen berechnen
		genAllFollow();

		//welchen Parser-Typ erzeugen?
		if( argv_str->type == SSLR_SLR )
			//SLR-Parser erzeugen
			genLR0Hulle();

		else if( argv_str->type == SSLR_LALR )
		{
#ifndef LR2LALR
			//LALR-Parser erzeugen
			genLR0Hulle();

			//Die Lookaheads erzeugen
			genLALR();
#else
			/*
				Es gibt zu Debuggingzwecken auch die Mglichkeit, erst die LR(1)-Items zu erzeugen,
				und dann diese zu den LALR-Items zusammenzufassen.
			*/

			//LR(1)-Hllen erzeugen
			genLR1Hulle();

			//LR(1)-Hllen in LR(0)-Hllen mit Lookaheads
			LR2LALR();
#endif
		}

		else if( argv_str->type == SSLR_LR )
			//LR-Parser erzeugen
			genLR1Hulle();

		//LR-Tabelle erzeugen
		LRTab();


		//die Fehleranweisungen verarbeiten
		processErrorStr();

		//die ERROR_STR prfen
		checkErrorStr();


		//Hllen ausgeben?
		if( argv_str->showHulle )
		{
			//Zeiger auf HULLE_STR
			HULLE_STR	*h;

			//Hllen ausgeben
			for( unsigned long i = 0; i < hulle_anz; i++ )
			{
				//Zeiger auf Hlle
				h = hulle_str[i];

				//ausgeben
				outputHulle( h );
			}
		}

		//Quell-Files des Parsers erzeugen
		generateFiles();

		//prfen, ob mit allen Alternativen reduziert wurde
		checkAllReduce();
	}

	else
		//Abbruch-Meldung ausgeben
		cerr << "\n\nsslr: Aborting..." << endl;

	//das war's
//	return( err );
				break;
			}

			// initSSLR ->  'EPSILON' .
			case initSSLR_0:
			{

	//hier wird SSLR initialisiert

	/*
		Terminalen wird per %left, %right, %nonassoc eine Assoziativitt sowie eine
		Prioritt zugewiesen. Je spter ein Terminal erscheint, deste hher ist seine
		Prioritt, z.b.

		%left ADD SUB
		%right MUL DIV

		ADD und SUB haben gleiche Prioritt und sind links-assoziativ, wohingegen MUL und DIV
		rechts-assoziativ sind und hhere Prioritt haben.
	*/
	priority = 0;

	/*
		Die Prioritt eines Terminals wird indirekt durch %left/%right angegeben: Je tiefer die
		Angabe steht, desto grer ist die Prioritt des Terminals.
	*/
	priLine = 0;


	/*
		Wenn eingebettete semantische Aktionen auftreten, oder EBNF-Symbole benutzt werden,
		so wird dafr auf der rechten Seite ein dummy-Nicht-Terminal auxsym eingetragen.
	*/
	auxsym_count = 1;


	//noch keine Fehler
	err = 0;

	//es wurde noch keine %union-Struktur angegeben
	unionDef = false;

	/*
		Bei der Verwendung von EBNF-Symbolen treten Hierachien auf,
		fr die diverse Informationen gesichert werden mssen.
	*/
	ebnfStack = new( EBNF_STACK[100] );

	//Stack-Pointer fr den EBNF-Stack
	ebnfSP = 0;


	/*
		Bei der Verwendung von eingebetteten semantischen Aktionen
		sowie bei der verwendung von EBNF-Symbolen mssen
		dummy-Nichtterminale eingeschoben werden, die hier
		auxsym heissen.
	*/
	auxsym = new( char[11] );

	//Zhler fr die Anzahl der auxsym-Nichtterminale
	auxsym_count = 1;



	//Speicher fr die %union-Angabe
	unionStr = new( UNION_STR );
	memset( unionStr, 0, sizeof( UNION_STR ) );


	//falls kein semantischer Typ angegeben wird
	insertUnion( "", "" );

	//keine semantische Aktion
	semAct = false;

	//Start-Produktion eintragen
	insertStartProd( prod_index, prod2_index );
				break;
			}

			// union ->  startUnion  'BOPEN'  unionBody  'BCLOSE' .
			case union_0:
			{

	/*
		Den Inhalt der %union-Angabe merken, denn dieser wird spter unverndert ins Header-File
		des generierten Parsers aufgenommen. Das dieser hier geparst wird liegt daran, dass die Typen
		ja in %ntermDef/%termDef benutzt werden, und dies wird geprft.
	*/
	unionStr->text = SSLR_semStack[SSLR_semStackCnt - 1 - 4 + (1)].name;
				break;
			}

			// startUnion ->  'UNION' .
			case startUnion_0:
			{

	//es wurde eine %union-Struktur angegeben
	unionDef = true;

	//den Inhalt der %union-Angabe weitergeben
	tmp.name = SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name;
				break;
			}

			// unionBody2 ->  'TYPE'  'IDENT' .
			case unionBody2_0:
			{

	//einen neuen Eintrag in der unionStr eintragen
	insertUnion( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (1)].name, SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name );

				break;
			}

			// unionBody2 ->  'TYPE'  'AST'  'IDENT' .
			case unionBody2_1:
			{

	//einen neuen Eintrag in der unionStr eintragen
	insertUnion( SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (1)].name, SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (3)].name );
				break;
			}

			// ntermDef ->  'NTERM_TYPE' .
			case ntermDef_0:
			{

		//Nicht-Terminal
		typeDef = SSLR_NTERM;
				break;
			}

			// ntermDef ->  'TERM_TYPE' .
			case ntermDef_1:
			{

		//Terminal
		typeDef = SSLR_TERM;
				break;
			}

			// semType ->  'semTypeOpen'  'IDENT'  'semTypeClose' .
			case semType_0:
			{

	/*
		In $2 steht eine Zeichenkette (<name>), die den semantischen Typ
		gem. der %union-Angabe enthlt.
	*/

	//Typ fr semantische Aktion, sollte in %union definiert sein.

	//%union schon angegeben?
	if( !unionDef )
	{
		//nein
		cerr << "sslr: ERROR: line " << SSLR_line << ": %union missing!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//den Eintrag in unionStr finden
		if( ( semIndex = getSemIndex( SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (2)].name ) ) < 0 )
		{
			//Typ nicht in %union definiert
			cerr << "sslr: ERROR: line " << SSLR_line << ": Type for semantic action " << SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (2)].name << " not defined in %union!" << endl;

			//Fehler
			err++;
		}
	}
				break;
			}

			// semType ->  'EPSILON' .
			case semType_1:
			{

	//ohne Angabe von semantischen Typen, Warnung ausgeben
	cerr << "sslr: line " << SSLR_line << ": No semantic type given!" << endl;
				break;
			}

			// associativity ->  'LEFT_ASSOC' .
			case associativity_0:
			{

	//links-assoziativ
	assocDef = LEFT_ASSOC;
				break;
			}

			// associativity ->  'RIGHT_ASSOC' .
			case associativity_1:
			{

	//rechts-assoziativ
	assocDef = RIGHT_ASSOC;
				break;
			}

			// associativity ->  'NON_ASSOC' .
			case associativity_2:
			{

	//nicht-assoziativ
	assocDef = NON_ASSOC;
				break;
			}

			// namelist1 ->  namelist1  'IDENT' .
			case namelist1_0:
			{

	int	type;

	//ist es ein reserviertes Terminal?
	if( ( typeDef == SSLR_TERM ) && !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name, "LALR" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	else if( ( typeDef == SSLR_NTERM ) && !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Element in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name );

		//fr Fehlerbehandlung merken
		setCheck( hash_index );

		//%termType: Terminal wird definiert
		//%ntermType: Nicht-Terminal wird definiert
		hash_tab->setDefined( hash_index, SSLR_line );

		//Index des Eintrags in unionStr in die Hash-Tabelle eintragen
		hash_tab->setUnionType( hash_index, semIndex );

		//ist es ein Terminal oder ein Nicht-Terminal?
		if( typeDef == SSLR_TERM )
		{
			//ist ein Terminal
			type = hash_tab->setType( hash_index, SSLR_TERM );

			//etwa schon als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nichtterminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}

		else
		{
			//ist ein Nicht-Terminal
			type = hash_tab->setType( hash_index, SSLR_NTERM );

			//etwa schon als Terminal definiert?
			if( type != SSLR_NTERM )
			{
				//Fehler, Nicht-Terminal wurde schon als Terminal definiert

				//Name des Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}
	}
				break;
			}

			// namelist1 ->  'IDENT' .
			case namelist1_1:
			{

	int	type;

	//ist es ein reserviertes Terminal?
	if( ( typeDef == SSLR_TERM ) && !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name, "LALR" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	else if( ( typeDef == SSLR_NTERM ) && !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Element in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

		//fr Fehlerbehandlung merken
		setCheck( hash_index );

		//%termType: Terminal wird definiert
		//%ntermType: Nicht-Terminal wird definiert
		hash_tab->setDefined( hash_index, SSLR_line );

		//Index des Eintrags in unionStr in die Hash-Tabelle eintragen
		hash_tab->setUnionType( hash_index, semIndex );

		//ist es ein Terminal oder ein Nicht-Terminal?
		if( typeDef == SSLR_TERM )
		{
			//ist ein Terminal
			type = hash_tab->setType( hash_index, SSLR_TERM );

			//etwa schon als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nichtterminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}

		else
		{
			//ist ein Nicht-Terminal
			type = hash_tab->setType( hash_index, SSLR_NTERM );

			//etwa schon als Terminal definiert?
			if( type != SSLR_NTERM )
			{
				//Fehler, Nicht-Terminal wurde schon als Terminal definiert

				//Name des Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}
	}
				break;
			}

			// namelist2 ->  namelist2  'IDENT' .
			case namelist2_0:
			{

	//in assocDef steht die Assoziativitt dieses Terminals
	long	tmpPriority;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name );

	//Terminal wird definiert
//	hash_tab->setDefined( hash_index, SSLR_line );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Assoziativitt eintragen
	hash_tab->setAssociation( hash_index, assocDef );

	//Prioritt erhhen
	if( SSLR_line > priLine )
	{
		//ja, erhhen
		priority++;
		priLine = SSLR_line;
	}

	//Prioritt eintragen
	tmpPriority = hash_tab->setPriority( hash_index, priority );

	//wurde die Prioritt des Terminals bereits festgesetzt?
	if( tmpPriority != priority )
	{
		//ja, doppeltes Auftreten

		//Name des Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Priority for terminal " << name << " already set!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// namelist2 ->  'IDENT' .
			case namelist2_1:
			{

	//in assocDef steht die Assoziativitt dieses Terminals
	long	tmpPriority;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

	//Terminal wird definiert
//	hash_tab->setDefined( hash_index, SSLR_line );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Assoziativitt eintragen
	hash_tab->setAssociation( hash_index, assocDef );

	//Prioritt erhhen
	if( SSLR_line > priLine )
	{
		//ja, erhhen
		priority++;
		priLine = SSLR_line;
	}

	//Prioritt eintragen
	tmpPriority = hash_tab->setPriority( hash_index, priority );

	//wurde die Prioritt des Terminals bereits festgesetzt?
	if( tmpPriority != priority )
	{
		//ja, doppeltes Auftreten

		//Name des Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Priority for terminal " << name << " already set!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// sc2 ->  sc2  sslrRule  'END_OF_PRODUCTION' .
			case sc2_0:
			{

	/*
		Es folgt eine neue Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfgen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen bertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurcksetzen
		semAct = false;
	}

	//Anzahl der Alternativen dieser Produktion eintragen
	prod_str[prod_index].altAnz = altCount;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// sc2 ->  sslrRule  'END_OF_PRODUCTION' .
			case sc2_1:
			{

	/*
		Es folgt eine neue Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfgen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen bertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurcksetzen
		semAct = false;
	}

	//Anzahl der Alternativen dieser Produktion eintragen
	prod_str[prod_index].altAnz = altCount;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// newProduction ->  'IDENT' .
			case newProduction_0:
			{

	//es folgt eine Produktion

	//Produktion in die Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//Produktion wurde definiert
	if( hash_tab->setProdDef( hash_index ) < 0 )
	{
		//die Produktion wurde bereits definiert
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung ausgeben
		cerr << "sslr: ERROR: line " << SSLR_line << ": Production " << name << " already defined!" << endl;

		//Fehler
		err++;
	}

	/*
		Wenn dies die erste Produktion ist, dann diese in die rechte Seite der
		Start-Produktion "start" eintragen.
	*/
	if( !prod_index )
	{
		//ja, eintragen
		insertElement( prod_index, prod2_index, hash_index );

		//eine Alternative
		prod_str[prod_index].altAnz = 1;

		//Produktion wurde benutzt
		hash_tab->setUsed( hash_index );
	}


	//Start-Produktion "start" nicht erlaubt
	if( !strcmp( hash_tab->getName( hash_index ), "start" ) )
	{
		//Fehler
		err++;

		//Meldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Production start reserved!" << endl;
	}



	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index der Produktion eintragen
	prod_str[prod_index].hash_index = hash_index;

	//ist ein Nichtterminal
	int type = hash_tab->setType( hash_index, SSLR_NTERM );

	//vorher schon mal als Terminal definiert?
	if( type != SSLR_NTERM )
	{
		//Fehler, Produktion wurde schon als Terminal definiert

		//Name des Nicht-Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Nonterminal " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

		//Fehler
		err++;
	}

	//PROD2_STR anfordern, fr die nchste Alternative
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;

	//Meldung ausgeben
	if( argv_str->verbose )
		cout << "sslr: line " << SSLR_line << ": Analyze " << SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name << "..." << endl;
				break;
			}

			// newAlternative ->  'NEW_ALTERNATIVE' .
			case newAlternative_0:
			{

	/*
		Es folgt eine neue Alternative zu einer bestehenden Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfgen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen bertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurcksetzen
		semAct = false;
	}

	//nchste Produktion
	altCount++;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}

	//PROD2_STR fr eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;
				break;
			}

			// item3 ->  'TERMINAL' .
			case item3_0:
			{

	//Terminal auf rechte Seite der aktuellen Alternative prod2_index eintragen

	//ist es ein reserviertes Terminal?
	if( !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name, "LALR" ) )
	{
		//nein, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Terminal in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

		//ist es ein EPSILON, dass nicht als erstes Element auf der rechten Seite steht?
		if( ( prod2_str[prod2_index].riAnz ) && ( hash_index == epsHashIndex ) )
		{
			//Fehler
			cerr << "sslr: ERROR: line " << SSLR_line << ": EPSILON must always be the only element on the right side!" << endl;

			//Fehler
			err++;
		}

		else
		{
			//semantische Aktion vorher eintragen?
			if( semAct == true )
			{
				//ja
				insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

				//zurcksetzen
				semAct = false;
			}

			//fr Fehlerbehandlung merken
			setCheck( hash_index );

			//Terminal benutzt
			hash_tab->setUsed( hash_index );

			//Terminal in rechte Seite der aktuellen Alternative eintragen
			insertElement( prod_index, prod2_index, hash_index );

			//ist ein Terminal
			int type = hash_tab->setType( hash_index, SSLR_TERM );

			//wurde das Terminal frher bereits als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nicht-Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}

			//Prioritt der Alternative ist die des am weitesten rechts stehenden Terminals
			prod2_str[prod2_index].priority = hash_tab->getPriority( hash_index );
		}
	}
				break;
			}

			// item3 ->  'NON_TERMINAL' .
			case item3_1:
			{

	//Nicht-Terminal auf rechte Seite der Alternative eintragen

	//gibt es eine semantische Aktion, die einzutragen ist, bevor das Nicht-Terminal eingetragen wird?
	if( semAct == true )
	{
		//ja, es gibt eine eingebettete semantische Aktion
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurcksetzen
		semAct = false;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	if( !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Nicht-Terminal in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

		//fr Fehlerbehandlung merken
		setCheck( hash_index );

		//Nicht-Terminal benutzt
		hash_tab->setUsed( hash_index );

		//ist ein Nicht-Terminal
		int type = hash_tab->setType( hash_index, SSLR_NTERM );

		//wurde das Nicht-Terminal vorher als Terminal definiert?
		if( type != SSLR_NTERM )
		{
			//Fehler, Nicht-Terminal wurde schon als Terminal definiert

			//Name des Nichtterminals
			char *name = hash_tab->getName( hash_index );

			//Fehlermeldung
			cerr << "sslr: ERROR: line " << SSLR_line << ": Nonterminal " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

			//Fehler
			err++;
		}

		//Nicht-Terminal in rechte Seite der Alternative prod2_index eintragen
		insertElement( prod_index, prod2_index, hash_index );
	}
				break;
			}

			// semanticAction ->  'SEMACT' .
			case semanticAction_0:
			{

	//eine Alternative ist mit einer semantischen Aktion verbunden

	//%union schon angegeben?
	if( !unionDef )
	{
		//Nein
		cerr << "sslr: ERROR: line " << SSLR_line << ": Semantic action useless without %union!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//schon eine semantische Aktion in der Struktur, d.h. doppeltes Auftreten?
		if( semAct == true )
		{
			//doppelte semantische Aktion
			cerr << "sslr: ERROR: line " << SSLR_line << ": Double semantic action!" << endl;

			//Fehler
			err++;
		}

		else
		{
			//semantische Aktionen bertragen
			semActStr.semAct = SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name;

			//Zeile merken
			semActStr.line = SSLR_line;

			//semantische Aktion wurde definiert
			semAct = true;

			//Zhler
			semActCnt++;
		}
	}
				break;
			}

			// ebnfKLOpen ->  'KLOPEN' .
			case ebnfKLOpen_0:
			{

	/*
		Hier wird das EBNF-Symbol ( benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 ( 'TERM1' | 'TERM2' ) prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym1 prod3
				;

		auxsym1
				:	'TERM1'
				|	'TERM2'
				;
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist eine eingebettete semantische Aktion
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurcksetzen
		semAct = false;
	}

	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
				break;
			}

			// ebnfBOpen ->  'BOPEN' .
			case ebnfBOpen_0:
			{

	/*
		Hier wird das EBNF-Symbol { benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 { 'TERM1' | 'TERM2' } prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym_1 prod3
				;

		auxsym_1
				:	'TERM1' auxsym_1
				|	'TERM2' auxsym_1
				|	'EPSILON'
				;

		{} bedeutet also beliebig oft.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurcksetzen
		semAct = false;
	}


	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );


	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
				break;
			}

			// ebnfEOpen ->  'EOPEN' .
			case ebnfEOpen_0:
			{

	/*
		Hier wird das EBNF-Symbol [ benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 [ 'TERM1' | 'TERM2' ] prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym1 prod3
				;

		auxsym1
				:	'TERM1'
				|	'TERM2'
				|	'EPSILON'
				;

		[] bedeutet also optional, also einmal oder keinmal.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurcksetzen
		semAct = false;
	}

	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
				break;
			}

			// ebnfKLClose ->  'KLCLOSE' .
			case ebnfKLClose_0:
			{

	//schliessendes EBNF-Symbol )

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen bertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurcksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols )!" << endl;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;

	//alte Daten vom EBNF-Stack zurckholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
				break;
			}

			// ebnfBClose ->  'BCLOSE' .
			case ebnfBClose_0:
			{

	//schliessendes EBNF-Symbol }
	long	baseProd2Index, count;

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen bertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurcksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols }!" << endl;


	//prod2_index der ersten Alternative der Produktion
	baseProd2Index = prod_str[prod_index].prod2_index;

	//nun das auxsym selbst als letztes Element auf rechter Seite eintragen,
	//damit beliebiges Ausfhren mglich ist
	for( count = baseProd2Index; count < ( baseProd2Index + altCount ); count ++ )
		//auxsym auf rechter Seite eintragen
		insertElement( prod_index, count, prod_str[prod_index].hash_index );


	/*
		Nun EPSILON als Alternative in die aktuelle Produktion eintragen, da {} ja
		belibieg oft bedeutet.
	*/
	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//EPSILON in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//EPSILON ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen
	altCount++;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;


	//alte Daten vom EBNF-Stack zurckholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
				break;
			}

			// ebnfEClose ->  'ECLOSE' .
			case ebnfEClose_0:
			{

	//schliessendes EBNF-Symbol ]

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen bertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurcksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols ]!" << endl;


	/*
		Nun EPSILON als Alternative in die aktuelle Produktion eintragen, da [] ja
		optional bedeutet.
	*/
	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//EPSILON in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//EPSILON ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen
	altCount++;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;


	//alte Daten vom EBNF-Stack zurckholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
				break;
			}

			// precedence ->  'PREC'  'TERMINAL' .
			case precedence_0:
			{

	/*
		Man kann durch Angabe von %prec die Priorit des Terminals auf die
		Prioritt der aktuellen Alternative bertragen.
	*/

	//Zeiger auf PROD_STR
	PROD_STR *p1 = &prod_str[prod_index];

	//Hash-Index des Terminals holen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name );

	//wurde dem Terminal berhaupt mittels %left/%right/%nonassoc eine Prioritt zugewiesen?
	if( hash_tab->getPriority( hash_index ) != -1 )
	{
		//ja, Terminal wird benutzt
		hash_tab->setUsed( hash_index );

		//Prioritt der aktuellen Alternative holen
		int pri = prod2_str[prod2_index].priority;

		//Prioritt der Alternative > Prioritt des Terminals?
		if( pri <=  hash_tab->getPriority( hash_index ) )
		{
			//nein, bernehmen
			int	pPriority = hash_tab->getPriority( hash_index );

			//Prioritt der aktuellen Alternative setzen
			prod2_str[prod2_index].priority = pPriority;
		}

		else
			//Meldung
			cerr << "sslr: Warning: line " << SSLR_line << ": Priority of " << hash_tab->getName( p1->hash_index ) << " > than priority of " << hash_tab->getName( hash_index ) << "!" << endl;
	}

	else
	{
		//dem Terminal wurde keine Prioritt zugewiesen
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": %prec used but terminal " << name << " was not assigned a priority!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  termList  'DB'  errorMsg .
			case errorBody2_0:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 5 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 5 + (5)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  termList  'DB'  errorAction  'DB'  errorMsg .
			case errorBody2_1:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 7 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 7 + (7)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  negTerm  'KLOPEN'  termList  'KLCLOSE'  'DB'  errorMsg .
			case errorBody2_2:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 8 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 8 + (8)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  negTerm  'KLOPEN'  termList  'KLCLOSE'  'DB'  errorAction  'DB'  errorMsg .
			case errorBody2_3:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 10 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 10 + (10)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  errorAction  'DB'  errorMsg .
			case errorBody2_4:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 5 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 5 + (5)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  errorMsg .
			case errorBody2_5:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (3)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// initBeforeNumber ->  'NUMBER' .
			case initBeforeNumber_0:
			{

	//es folgt eine Fehleranweisung

	//eine ERROR_STR anfordern
	errorIndex = getErrorStr();

	//Zeiger auf die ERROR_STR
	errorStr = &error_str[errorIndex];

	//Index der Produktion eintragen
	errorStr->prod_index = prod_index;

	//Index der Alternative in PROD2_STR eintragen
	errorStr->prod2_index = prod2_index;

	//die Zeile merken
	errorStr->line = SSLR_line;

	//Terminal-Angaben nicht negieren
	errorNeg = false;

	//Position des Punktes
	tmp.integer = SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].integer;
				break;
			}

			// negTerm ->  'NOT' .
			case negTerm_0:
			{

	//Terminal-Angaben negieren
	errorNeg = true;
				break;
			}

			// termList ->  termList  'COMMA'  'TERMINAL' .
			case termList_0:
			{

	//Index des Terminals holen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (3)].name );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//negieren?
	if( errorNeg == true )
		//ERRTERM_STR in errorStr eintragen
		insertErrTermStr( errorStr, hash_index, 1 );

	else
		//nicht negieren
		insertErrTermStr( errorStr, hash_index, 0 );
				break;
			}

			// termList ->  'TERMINAL' .
			case termList_1:
			{

	//Index des Terminals holen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//negieren?
	if( errorNeg == true )
		//ERRTERM_STR in errorStr eintragen
		insertErrTermStr( errorStr, hash_index, 1 );

	else
		//nicht negieren
		insertErrTermStr( errorStr, hash_index, 0 );
				break;
			}

			// errorAction2 ->  'OVERREAD'  'KLOPEN'  'TERMINAL'  'KLCLOSE' .
			case errorAction2_0:
			{

	//Terminale in der Eingabe lschen, nis das Terminal geschoben werden darf

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 4 + (3)].name );

	//schon in der ERROR_STR enthalten?
	if( errorStr->overread )
		//es war schon eine OVERREAD(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used overread(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->overread = hash_index;
				break;
			}

			// errorAction2 ->  'SHIFT'  'KLOPEN'  'TERMINAL'  'KLCLOSE' .
			case errorAction2_1:
			{

	//ein Terminal auf den Parse-Stack schieben

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 4 + (3)].name );

	//schon in der ERROR_STR enthalten?
	if( errorStr->shift )
		//es war schon eine SHIFT(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used shift(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->shift = hash_index;
				break;
			}

			// errorAction2 ->  'POP'  'KLOPEN'  'TERMINAL'  'KLCLOSE' .
			case errorAction2_2:
			{

	//Zustnde vom Parse-Stack lschen, bis Terminal geschoben werden darf

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 4 + (3)].name );

	//schon in der ERROR_STR enthalten?
	if( errorStr->pop )
		//es war schon eine POP(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used pop(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->pop = hash_index;
				break;
			}

			// errorAction2 ->  'EXIT' .
			case errorAction2_3:
			{

	//das Parsen abbrechen
	if( errorStr->exit++ )
		//wurde schon einmal verwendet
		cerr << "sslr: Warning: line " << SSLR_line << ": EXIT already used!" << endl;

				break;
			}

			// errorAction2 ->  'DELETE' .
			case errorAction2_4:
			{

	//es soll der nchste Eingebesymbol aus der Eingabe entfernt werden
	errorStr->del++;
				break;
			}

			// errorAction2 ->  'SEM' .
			case errorAction2_5:
			{

	//semantische Aktionen trotz Fehlers weiterfhren
	if( errorStr->sem++ )
		//schon eingetragen
		cerr << "sslr: Warning: line " << SSLR_line << ": SEM already used!" << endl;
				break;
			}

			// errorMsg ->  'STRING' .
			case errorMsg_0:
			{

		//Fehlermeldung zurckliefern
		tmp.name = SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name;
				break;
			}

			// errorMsg ->  'EPSILON' .
			case errorMsg_1:
			{

		//es wurde keine Fehlermeldung angegeben
		tmp.name = 0L;
				break;
			}

//			default:
				//error
//				cerr << "SSLRParser::SSLR_doSemAct: Unknown alternative " << tab->value << "!" << endl;
		}

		//correct stack pointer
		SSLR_semStackCnt -= n->elem;

		//semantic stack overflow?
		if( SSLR_semStackCnt >= SSLR_maxStackSize )
		{
			//yes, print an error message
			cerr << "SSLRParser::SSLR_doSemAct: Semantic stack overflow!" << endl;

			//no more semantic actions allowed
			SSLR_semAct = false;
		}

		else
			//push last value on stack
			SSLR_semStack[SSLR_semStackCnt++] = tmp;
	}
}




	//Hilfsroutinen fr SSLR


void SSLRParser::giveArgs( ARGV_STR *argv )
{
	/*
		Diese Funktion dient der bergabe der Kommandozeilen-Argumente, die
		SSLR steuern.
	*/

	//Argumente
	argv_str = argv;
}


void SSLRParser::init( void )
{
	/*
		Diese Routine wird vom Konstruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	anzCheck = 0;
	check = 0L;
	prod_anz = 0;
	prod_str = 0L;
	prod2_anz = 0;
	prod2_str = 0L;
	error_anz = 0;
	error_str = 0L;
	hulle_str = 0L;
	hulle_anz =  0;
	coreAnz = 0;
	srError = 0;
	rrError = 0;
	semActCnt = 0;
	termArr = 0L;
	ntermArr = 0L;
	unionStr = 0L;
	lrTab = 0L;
	jumpTab = 0L;
	hash_tab = 0L;
	auxsym = 0L;
	ebnfStack = 0L;

	//Speicher fr die Hash-Tabelle anfordern
	hash_tab = new( hashClass );
}


void SSLRParser::deinit( void )
{
	/*
		Diese Routine wird vom Destruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	int	i;

	//Speicher freigeben
	delete( hash_tab );

	//Speicher fr die %union-Angabe freigeben?
	if( unionStr )
	{
		//alle Eintrge
		for( i = 1; i < unionStr->anz; i++ )
		{
			//Typ und Name der deklarierten Variable freigeben
			delete[] ( unionStr->type[i] );
			delete[] ( unionStr->id[i] );
		}

		//Speicher fr die Struktur freigeben
		delete[] ( unionStr->type );
		delete[] ( unionStr->id );
		delete( unionStr );
	}

	if( auxsym )
		delete[] ( auxsym );


	//gab es Fehlerangaben?
	if( error_anz )
	{
		ERROR_STR	*errorStr;

		//Speicher freigeben
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr = &error_str[i];

			//hat die ERROR_STR Terminal-genbundene Fehleranweisungen?
			if( errorStr->errTermStrAnz )
				//ja, Speicher freigeben
				delete[] ( errorStr->errTermStr );

			//Speicher fr die Terminale freigeben?
			if( errorStr->errTermArr )
				//ja, freigeben
				delete[] ( errorStr->errTermArr );

			//die Hllen, die mit dieser Fehleranweisung verbunden ist, freigeben
			if( errorStr->hInd.anzArr )
				//ja, freigeben
				delete[] ( errorStr->hInd.arr );
		}

		//Speicher fr die ERROR_STR selbst freigeben
		delete[] ( error_str );
	}


	//Speicher fr Nicht-Terminale freigeben
	if( ntermArr )
		delete[] ( ntermArr );

	//Speicher fr Terminale freigeben
	if( termArr )
		delete[] ( termArr );

	//Speicher freigeben
	if( check )
		delete[] ( check );


	//Speicher fr die Produktionen freigeben
	if( prod_anz )
		//freigeben
		delete[]( prod_str );

	//Speicher fr die Alternativen freigeben
	if( prod2_anz )
	{
		//alle PROD2_STR
		for( i = 0; i < prod2_anz; i++ )
		{
			//rechte Seite freigeben
			if( prod2_str[i].riAnz )
				delete[] ( prod2_str[i].right );
		}

		//PROD2_STR freigeben
		delete[]( prod2_str );
	}

	//Speicher fr die Hllen freigeben
	if( hulle_str )
	{
		HULLE_STR	*hStr;
		LR_STR		*lrStr;
		int			i, j;

		//alle Hllen durchgehen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hlle
			hStr = hulle_str[i];

			//alle LR-Items der Hlle
			for( j = 0; j < hStr->anzElem; j++ )
			{
				//Zeiger auf LR_STR-Struktur
				lrStr = &hStr->lr_str[j];

				//Lookaheads?
				if( lrStr->la )
					//ja, freigeben
					delete( lrStr->la );

				//LALR-Lookaheads?
				if( lrStr->lalr )
					//ja, freigeben
					delete( lrStr->lalr );
			}

			//LR_STR freigeben
			delete[] ( hStr->lr_str );

			//Hlle freigeben
			delete( hStr );
		}

		//Speicher aller Hllen-Strukturen freigeben
		delete[] ( hulle_str );
	}

	//Speicher fr die Sprung-Tabelle freigeben?
	if( jumpTab )
	{
		//die jumpTab hat hulle_anz Spalten
		for( i = 0; i < hulle_anz; i++ )
			//Spalte freigeben
			delete[] ( jumpTab[i] );

		//Struktur freigeben
		delete[] ( jumpTab );
	}

	//Speicher fr die LR-Tabelle freigeben?
	if( lrTab )
	{
		//die lrTab hat hulle_anz Spalten
		for( i = 0; i < hulle_anz; i++ )
			//Spalte freigeben
			delete[] ( lrTab[i] );

		//Struktur freigeben
		delete[] ( lrTab );
	}

	//Stack fr die Verarbeitung von EBNF freigeben
	if( ebnfStack )
		//ja, freigeben
		delete[] ( ebnfStack );
}


void SSLRParser::insertEmbeddedSemanticAction( long prod_index, long prod2_index, long line, int &auxsymCount )
{
	//fgt ein auxsym-Nichtterminal auf rechter Seite von prod2_index ein fr eine embedded semantic
	//action.
	PROD2_STR	*p2;
	long		hash_index;
	char		auxsym[11];

	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsymCount++ );

	//in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//Produktion wurde definiert
	hash_tab->setProdDef( hash_index );

	//fr Fehlerbehandlung merken
	setCheck( hash_index );

	//Nichtterminal wird benutzt
	hash_tab->setUsed( hash_index );

	//Nichtterminal wird definiert
	hash_tab->setDefined( hash_index, line );

	//ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );


	//auxsym-Produktion auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );


	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index des Nichtterminals eintragen
	prod_str[prod_index].hash_index = hash_index;

	//PROD2_STR anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//Zeiger auf PROD2_STR
	p2 = &prod2_str[prod2_index];

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Prioritt der Produktion eintragen
	p2->priority = 0;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = 1;



	//semantische Aktion eintragen
	p2->semAct = semActStr.semAct;

	//Zeile merken
	p2->semActLine = semActStr.line;

	//ist eine embedded semantic action
	p2->isEmbeddedSemAct = true;
}


int SSLRParser::findDoubleAlt( void )
{
	//doppelte Alternativen finden
	PROD_STR	*p1;
	PROD2_STR	*p2, *p3;
	char		*name;
	int			i, j, k, l, err = 0, ri;

	//alle Produktionen
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//alle rechten Seiten
		ri = p1->altAnz;

		//alle Alternativen
		for( j = p1->prod2_index; j < ( p1->prod2_index + ri ); j++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[j];

			//alle anderen Alternativen
			for( k = j + 1; k < ( p1->prod2_index + ri ); k++ )
			{
				//Zeiger auf PROD2_STR
				p3 = &prod2_str[k];

				//Anzahl der Elemente gleich?
				if( p2->riAnz == p3->riAnz )
				{
					//die rechten Seiten von p2 und p3 vergleichen
					for( l = 0; l < p2->riAnz; l++ )
					{
						//Elemente gleich?
						if( p2->right[l] != p3->right[l] )
							//nein
							break;
					}

					//gleich, wenn l = p2->riAnz
					if( l == p2->riAnz )
					{
						//die Zeilen der Laternativen holen
						long	l1 = p2->line, l2 = p3->line;

						//Alternativen sind gleich
						cerr << "sslr: ERROR: Alternativen in Zeile " << l1 << " und " << l2 << " gleich in Produktion " << name << "!" << endl;

						//Alternative ausgeben
//						outputAlt( cerr, k );

						//Fehler
						err++;
					}
				}
			}
		}
	}

	//zurck
	return( err );
}


int SSLRParser::getErrorStr( void )
{
	//erzeuge eine neue ERROR_STR und liefere den Index zurck
	ERROR_STR	*tmp;

	//eine neue ERROR_STR anfordern
	tmp = new( ERROR_STR[error_anz + 1] );

	//Inhalt kopieren
	memmove( tmp, error_str, sizeof( ERROR_STR ) * error_anz );

	//initalisieren
	memset( &tmp[error_anz], 0, sizeof( ERROR_STR ) );

	//alten Speicher freigeben?
	if( error_anz )
		//ja
		delete[]( error_str );

	//Adressen kopieren
	error_str = tmp;

	//Index zurckliefern
	return( error_anz++ );
}


int SSLRParser::insertErrTermStr( ERROR_STR *errStr, long terminal, int neg )
{
	//fgt eine ERRTERM_STR zu einer ERROR_STR hinzu
	ERRTERM_STR		*tmp, *tmp2;
	int				i;

	//alle ERRTERM_STR prfen, ob das Terminal schon da ist
	for( i = 0; i < errStr->errTermStrAnz; i++ )
	{
		//Zeiger auf die ERRTERM_STR holen
		tmp = &errStr->errTermStr[i];

		//Terminle gleich?
		if( tmp->terminal == terminal )
		{
			//gleich
			cerr << "sslr: Warning: line " << errStr->line << ": Terminal " << hash_tab->getName( terminal ) << " already used in user-defined error-action!" << endl;

			//zurck
			return( -1 );
		}
	}

	//ERRTERM_STR erzeugen und zu errStr hinzufgen

	//eine neue ERRTERM_STR anfordern
	tmp = new( ERRTERM_STR[errStr->errTermStrAnz + 1] );

	//eintragen
	tmp2 = &tmp[errStr->errTermStrAnz];
	tmp2->terminal = terminal;
	tmp2->neg = neg;

	//Inhalt kopieren
	memmove( tmp, errStr->errTermStr, sizeof( ERRTERM_STR ) * errStr->errTermStrAnz );

	//Adressen
	errStr->errTermStr = tmp;

	//Index zurckliefern
	return( errStr->errTermStrAnz++ );
}


void SSLRParser::insertStartProd( long &prod_index, long &prod2_index )
{
	//Start-Produktion eintragen
	long	hash_index;

	//EPSILON eintragen
	epsHashIndex = hash_tab->insert( "EPSILON" );

	//EPSILON ist ein Terminal
	hash_tab->setType( epsHashIndex, SSLR_TERM );

	//ACCEPT eintragen
	acceptHashIndex = hash_tab->insert( "ACCEPT" );

	//ACCEPT ist ein Terminal
	hash_tab->setType( acceptHashIndex, SSLR_TERM );

	//Check-Index fr LALR-Parser
	lalrHashIndex = hash_tab->insert( "LALR" );

	//das reservierte Terminal LALR ist ein Terminal
	hash_tab->setType( lalrHashIndex, SSLR_TERM );



	//Startproduktion in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "start" );

	//die Start-Produktion "start" ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//Nichtterminal wird definiert
	hash_tab->setDefined( hash_index, 0 );

	//fr Fehlerbehandlung merken
//	setCheck( hash_index );

	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//Hash-Index des Nichtterminals eintragen
	prod_str[prod_index].hash_index = hash_index;

	//PROD2_STR anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;
}


void SSLRParser::setCheck( long hash_index )
{
	//Hash-Index in Liste eintragen zur allgemeinen berprfung
	long	i, *tmp;

	//alle durchgehen
	for( i = 0; i < anzCheck; i++ )
	{
		//gleich?
		if( check[i] == hash_index )
			//Ja
			return;

		else if( check[i] > hash_index )
		{
			//mehr Speicher
			tmp = new( long[anzCheck + 1] );

			//umkopieren
			memcpy( tmp, check, sizeof( long ) * i );
			tmp[i] = hash_index;
			memcpy( &tmp[i+1], &check[i], sizeof( long ) * ( anzCheck - i ) );

			//ein Eintrag mehr
			anzCheck++;

			//Speicher freigeben
			if( check )
				delete[] ( check );

			//Zeiger
			check = tmp;

			//Schleife verlassen
			break;
		}
	}

	//leer?
	if( i == anzCheck )
	{
		//ja, anhngen

		//mehr Speicher
		tmp = new( long[anzCheck + 1] );

		//umkopieren
		memcpy( tmp, check, sizeof( long ) * anzCheck );
		tmp[anzCheck] = hash_index;

		//ein Eintrag mehr
		anzCheck++;

		//Speicher freigeben
		if( check )
			delete[] ( check );

		//Zeiger
		check = tmp;
	}
}


int SSLRParser::checkAllReduce( void )
{
	//prfen, ob mit allen Alternativen reduziert wurde
	/*
		Hier wird geprft, ob
		- jemals mit einer Alternative reduziert wird
	*/
	PROD2_STR	*pStr;
	int			i, err = 0;

	//prfen, ob mit allen Alternativen auch reduziert wurde
	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf Struktur
		pStr = &prod2_str[i];

		//wurde reduziert?
		if( pStr->reduce <= 0 )
		{
			//Nein, Warnung ausgeben
			cerr << "sslr: ERROR: Never reduced with ";

			//rechte Seite ausgeben
			outputAlt( cerr, i );

			//Fehler
			err++;
		}
	}

	//Wenn Fehler, zurckgeben
	return( err );
}


int SSLRParser::checkAll( void )
{
	/*
		Hier wird geprft, ob
		- (Nicht)Terminale definiert wurden
		- (Nicht)Terminale benutzt wurden
		- (Nicht)Terminale schon als Terminale benutzt wurden
		- Mehrfachdefinitionen
	*/
	char	*id[3] = { "", "Terminal", "Nonterminal" }, *name;
	int		type, i, err = 0;
	int		tc = 0, nc = 0;

	//Alle eingetragenen Elemente
	for( i = 0; i < anzCheck; i++ )
	{
		//Typ holen
		type = hash_tab->getType( check[i] );

		//Terminal?
		if( type == SSLR_TERM )
			//Ja
			tc++;

		//Nichtterminal?
		else if( type == SSLR_NTERM )
			//Ja
			nc++;

		//Name holen
		name = hash_tab->getName( check[i] );

		//Definiert?
		if( !hash_tab->getDefined( check[i] ) )
		{
			//Element wurde nicht definiert
			cerr << "sslr: Warning: " << id[type] << " " << name << " not defined!" << endl;

			//Fehler
//			err++;
		}

		//benutzt?
		if( hash_tab->getUsed( check[i] ) == false )
		{
			//Element wurde nicht benutzt
			cerr << "sslr: ERROR: " << id[type] << " " << name << " not used!" << endl;

			//Fehler
			err++;
		}

		//mehrfach benutzt?
		if( hash_tab->getDefined( check[i] ) > 1 )
		{
			//Element wurde nicht benutzt
			cerr << "sslr: ERROR: " << id[type] << " " << name << " more than once defined!" << endl;

			//Fehler
			err++;
		}

		//Produktion definiert?
		if( ( type == SSLR_NTERM ) && ( hash_tab->getProdDef( check[i] ) == false ) )
		{
			//Produktion wurde nicht definiert
			cerr << "sslr: ERROR: Production " << name << " not defined!" << endl;

			//Fehler
			err++;
		}
	}

	//Speicher fr das Array fr die Terminale
	termArr = new( long[tc + 1] );

	//Speicher fr das Array fr die Nichtterminale
	ntermArr = new( long[nc + 1] );

	//Anazhl der Eintrge merken
	termArrCount = tc + 1;
	ntermArrCount = nc + 1;

	//start-Produktion als erste Produktion eintragen
	ntermArr[0] = prod_str[0].hash_index;

	//Index in der LR-Tabelle eintragen
	hash_tab->setLRTabIndex( ntermArr[0], 0 );

	//Hash-Indices aus checkArr
	for( i = 0, tc = 0, nc = 1; i < anzCheck; i++ )
	{
		//Name holen
		name = hash_tab->getName( check[i] );

		//Typ holen
		type = hash_tab->getType( check[i] );

		//Terminal?
		if( type == SSLR_TERM )
		{
			//Ja, eintragen
			termArr[tc] = check[i];

			//Index in der LR-Tabelle eintragen
			hash_tab->setLRTabIndex( check[i], tc++ );
		}

		//Nichtterminal?
		else if( type == SSLR_NTERM )
		{
			//Ja
			ntermArr[nc] = check[i];

			//Index in der LR-Tabelle eintragen
			hash_tab->setLRTabIndex( check[i], nc++ );
		}
	}

	//ACCEPT als letztes Terminal eintragen
	termArr[tc] = acceptHashIndex;

	//Index in der LR-Tabelle eintragen
	hash_tab->setLRTabIndex( acceptHashIndex, tc );

	//Wenn Fehler, zurckgeben
	return( err );
}


void SSLRParser::insertUnion( char *type, char *id )
{
	/*
		Neuen Eintrag aus der %union-Angabe erzeugen.
		ACHTUNG: Der Scanner liefert schon eine Kopie von type und id, hier muss
		also kein zustzlicher Speicher angefordert werden!
	*/
	char	**t1, **t2;
	int		i;

	//Speicher fr die Typen
	t1 = new( char *[unionStr->anz + 1] );

	//Speicher fr die Bezeichner
	t2 = new( char *[unionStr->anz + 1] );

	//kopieren
	for( i = 0; i < unionStr->anz; i++ )
	{
		//nur die Adressen kopieren
		t1[i] = unionStr->type[i];
		t2[i] = unionStr->id[i];
	}

	//den alten Speicher freigeben
	if( unionStr->type )
		delete[] ( unionStr->type );

	if( unionStr->id )
		delete[] ( unionStr->id );

	//die neuen Eintrge merken
	t1[unionStr->anz] = type;
	t2[unionStr->anz] = id;

	//ein weiterer Eintrag
	unionStr->anz++;

	//Adressen kopieren
	unionStr->type = t1;
	unionStr->id = t2;
}


int SSLRParser::getSemIndex( char *name )
{
	//In name steht der Typ zur semantischen Aktion. Den Index in unionStr suchen.
	/*
		Beispiel:
			%union
			{
				int		a;
			}

		In name steht nun a, den Index in unionStr zurckliefern.
	*/
	UNION_STR	*h = unionStr;
	int			i;

	//Alle Eintrge durchgehen
	for( i = 0; i < h->anz; i++ )
	{
		//Vergleichen
		if( !strcmp( h->id[i], name ) )
			//gefunden
			return( i );
	}

	//nicht gefunden
	return( -1 );
}


long SSLRParser::getNewProd( void )
{
	//PROD_STR anfordern
	PROD_STR	*tmp;

	//Speicher fr PROD_STR anfordern
	tmp = new( PROD_STR[prod_anz + 1] );

	//kopieren
	memmove( tmp, prod_str, sizeof( PROD_STR ) * prod_anz );

	//alten Speicher freigeben
	if( prod_str )
		delete[] ( prod_str );

	//Adressen
	prod_str = tmp;

	//initialisieren
	memset( &prod_str[prod_anz], 0, sizeof( PROD_STR ) );

	//Index der ersten Alternative in PROD2_STR eintragen
	prod_str[prod_anz].prod2_index = prod2_anz;

	//Index zurckliefern
	return( prod_anz++ );
}


long SSLRParser::getNewProd2( long prod_index )
{
	//PROD2_STR anfordern
	PROD2_STR	*tmp;

	//Speicher fr PROD2_STR anfordern
	tmp = new( PROD2_STR[prod2_anz + 1] );

	//kopieren
	memmove( tmp, prod2_str, sizeof( PROD2_STR ) * prod2_anz );

	//alten Speicher freigeben
	if( prod2_str )
		delete[] ( prod2_str );

	//Adressen
	prod2_str = tmp;

	//initialisieren
	memset( &prod2_str[prod2_anz], 0, sizeof( PROD2_STR ) );

	//Index der Produktion in PROD_STR
	prod2_str[prod2_anz].prod_index = prod_index;

	//zurcksetzen
	prod2_str[prod2_anz].reduce = 0;

	//die Alternative hat noch keine Prioritt
	prod2_str[prod2_anz].priority = 0;

	//Index zurckliefern
	return( prod2_anz++ );
}


void SSLRParser::insertElement( long prod_index, long prod2_index, long hash_index )
{
	//Element auf der rechten Seite der Produktion eintragen
//	PROD_STR	*p1 = &prod_str[prod_index];
	PROD2_STR	*p2 = &prod2_str[prod2_index];
	long		*tmp;

	//Index der Produktion eintragen
	p2->prod_index = prod_index;

	//Speicher fr die Elemente anfordern
	tmp = new( long[p2->riAnz + 1] );

	//kopieren
	memmove( tmp, p2->right, sizeof( long ) * p2->riAnz );

	//alten Speicher freigeben
	if( p2->right )
		delete[] ( p2->right );

	//Adressen
	p2->right = tmp;

	//Index des Elemente in der rechten Seite eintragen
	p2->right[p2->riAnz++] = hash_index;
}


int SSLRParser::checkErrorStr( void )
{
	//die ERROR_STR prfen

	//gibt es berhaupt Fehlerangaben?
	if( error_anz )
	{
		PROD2_STR	*p2;
		ERROR_STR	*errorStr1, *errorStr2;
		int			i, j, k, l, m;
		int			errTermCnt1, errTermCnt2, anzColl, coll;
		int			*noTermErrActErrorStrIndex, *noTermErrActHulleIndex, noTermErrActCnt;
		int			*errTerm, anzErrTerm;

		/*
			Hier werden Fehlerangaben gefunden, die nie ausgefhrt werden.
			Beim folgenden Beispiel wird die letzte Fehlerangabe nicht ausgefhrt.
			1:!ADD:			"Fehlermeldung1"
			1:ADD			"Fehlermeldung2"
			1:SHIFT(ADD)	"Fehlermeldung3"
		*/
		noTermErrActErrorStrIndex = new( int[error_anz] );
		noTermErrActHulleIndex = new( int[error_anz] );
		errTerm = new( int[termArrCount] );

		/*
			Hier wird geprft, ob es zu zwei Fehlerangaben berschneidungen
			seitens der Terminale gibt.
			Dazu werden immer die Fehlerangaben verglichen, die den selben
			Hllenindex haben sowie dieselbe Punktposition.
		*/
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//initialisieren
			memset( noTermErrActErrorStrIndex, 0, sizeof( int) * error_anz );
			memset( noTermErrActHulleIndex, 0, sizeof( int) * error_anz );
			memset( errTerm, 0, sizeof( int) * termArrCount );
			noTermErrActCnt = 0;
			anzErrTerm = 0;

			//alle nachfolgenden ERROR_STR
			for( j = i + 1; j < error_anz; j++ )
			{
				//Zeiger auf ERROR_STR
				errorStr2 = &error_str[j];

//Meldung ausgeben
//cerr << "process %error " << errorStr1->line << endl;
//cerr << "process %error " << errorStr2->line << endl << endl;

				//alle Eintrge der ersten ERROR_STR
				for( k = 0; k < errorStr1->hInd.anzArr; k++ )
				{
					//alle Eintrge der zweiten ERROR_STR
					for( l = 0; l < errorStr2->hInd.anzArr; l++ )
					{
						//gleiche Hllen-Indices?
						if( errorStr1->hInd.arr[k] == errorStr2->hInd.arr[l] )
						{
							/*
								hat diese ERROR_STR berhaupt Aktionen, die mit Terminalen
								verbunden sind?
							*/
							if( !errorStr1->errTermStrAnz )
							{
								/*
									nein, eine Fehleraktion ohne Angabe von Terminalen,
									also der Art
									1:AKTION:	"Fehler!"
									Nun den Index j der errorStr2 merken, damit spter
									geprft werden kann, ob diese Fehleraktion jemals
									ausgefhrt werden kann.
								*/
								int	k;

								//da mehrere Hllen-Indices zu einer Fehleraktionen gehren knnen, nur einmal eintragen
								for( k = 0; k < noTermErrActCnt; k++ )
								{
									//den Hllen-Index j schon eingetragen?
									if( noTermErrActErrorStrIndex[k] == i )
										//ja, nicht noch einmal eintragen
										break;
								}

								//schon eingetragen?
								if( k == noTermErrActCnt )
								{
									//nein, eintragen
									noTermErrActErrorStrIndex[noTermErrActCnt] = i;
									noTermErrActHulleIndex[noTermErrActCnt++] = errorStr2->hInd.arr[l];
								}
							}

							/*
								die zweite ERROR_STR kann auch eine Fehleraktion
								ohne Terminal haben
							*/
							if( !errorStr2->errTermStrAnz )
							{
								/*
									nein, eine Fehleraktion ohne Angabe von Terminalen,
									also der Art
									1:AKTION:	"Fehler!"
									Nun den Index j der errorStr2 merken, damit spter
									geprft werden kann, ob diese Fehleraktion jemals
									ausgefhrt werden kann.
								*/
								int	k;

								//da mehrere Hllen-Indices zu einer Fehleraktionen gehren knnen, nur einmal eintragen
								for( k = 0; k < noTermErrActCnt; k++ )
								{
									//den Hllen-Index j schon eingetragen?
									if( noTermErrActErrorStrIndex[k] == j )
										//ja, nicht noch einmal eintragen
										break;
								}

								//schon eingetragen?
								if( k == noTermErrActCnt )
								{
									//nein, eintragen
									noTermErrActErrorStrIndex[noTermErrActCnt] = j;
									noTermErrActHulleIndex[noTermErrActCnt++] = errorStr2->hInd.arr[l];
								}
							}

							/*
								PROBLEM: Es kann durchaus sein, dass zwei
								Fehleranweisungen zu verschiedenen
								LR-Items den gleichen Zustand erhalten.
								Nun auf Kollisionen prfen.
							*/
							errTermCnt1 = errTermCnt2 = 0;
							anzColl = 0;

							//fr alle Terminale prfen
							for( m = 0; m < termArrCount; m++ )
							{
								//and
								coll = ( errorStr1->errTermArr[m] & errorStr2->errTermArr[m] );
								anzColl += coll;

								/*
									Anzahl der Terminale merken, fr die
									eine Aktion ausgefhrt wird.
								*/
								if( !errTerm[m] )
								{
									//noch keine Fehleraktion mit dem Terminal m verbunden
									anzErrTerm += ( errorStr1->errTermArr[m] | errorStr2->errTermArr[m] );
									errTerm[m] = ( errorStr1->errTermArr[m] | errorStr2->errTermArr[m] );
								}

								//zhlen
								errTermCnt1 += errorStr1->errTermArr[m];
								errTermCnt2 += errorStr2->errTermArr[m];

								//gab es eine Kollision?
								if( coll )
								{
									//ja, Name des Terminals
									char *name = hash_tab->getName( termArr[m] );

									//Meldung ausgeben
									cerr << "sslr: ERROR: Collision in terminal " << name << " between error action in line " << errorStr1->line << " and " << errorStr2->line << "!" << endl;

									//Fehler
									err++;
								}
							}
						}
					}
				}
			}

			//Fehleraktion ohne Terminale prfen
			if( noTermErrActCnt )
			{
				//sind alle Terminale mit Fehleraktionen versehen?
				if( anzErrTerm == termArrCount )
				{
					/*
						Fr den Zustand errorStr1->hInd.arr[k] gibt es fr jedes Terminal
						eine Fehleraktion.
						Da es auch Fehleraktionen ohne Terminal gibt, werden diese folglich
						nie ausgefhrt.
					*/
					ERROR_STR	*tmp;
					int			i;

					//alle nicht-terminalgebundenen Fehleraktionen
					for( i = 0; i < noTermErrActCnt; i++ )
					{
						//Zeiger auf die zugehrige ERROR_STR
						tmp = &error_str[noTermErrActErrorStrIndex[i]];

						//Warnung ausgeben
						cerr << "sslr: Warning: line " << tmp->line << ": Error action will never be used!" << endl;
					}
				}

				//es gibt noch "freie" Terminale
				else if( noTermErrActCnt > 1 )
				{
					/*
						Hier wird geprft, ob Fehlerangaben der folgenden Form auftauchen

						1:SHIFT(ADD):		"Fehlermeldung 1"
						1:OVERREAD(SUB):	"Fehlermeldung 2"

						Dies geht nicht, da nicht beide Fehlermeldungen gleichzeitig
						ausgegeben werden knnen, besser:
						1:SHIFT(ADD):OVERREAD(SUB):	"Fehlermeldung 1 und 2"
					*/
					unsigned long	state;
					ERROR_STR		*tmp1, *tmp2;
					int				i, j;

					//alle Fehleraktionen miteinander vergleichen
					for( i = 0; i < noTermErrActCnt; i++ )
					{
						for( j = i + 1; j < noTermErrActCnt; j++ )
						{
							//Zeiger auf beide ERROR_STR
							tmp1 = &error_str[noTermErrActErrorStrIndex[i]];
							tmp2 = &error_str[noTermErrActErrorStrIndex[j]];

							//Zustand der Kollision
							state = noTermErrActHulleIndex[i];

							/*
								nur eine nicht-Terminal-gebundene Fehleraktion
								pro Zustand erlaubt
							*/
							cerr << "sslr: Warning: Two error actions in line " << tmp1->line << " and line " << tmp2->line << " without terminals in the same state " << state << "!" << endl;
						}
					}
				}
			}
		}

		//Speicher wieder freigeben
		delete[] ( noTermErrActErrorStrIndex );
		delete[] ( noTermErrActHulleIndex );
		delete[] ( errTerm );




		//nun prfen, ob EXIT mit etwas anderem zusammen steht
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//ist EXIT aktiviert?
			if( errorStr1->exit )
			{
				//mit anderen Aktionen?
				if( errorStr1->shift || errorStr1->del || errorStr1->overread || errorStr1->sem )
					//unsinnig
					cerr << "sslr: Warning: line " << errorStr1->line << ": It makes no sense to use EXIT together with other user-defined error-actions!" << endl;
			}
		}






		//nun prfen, ob eine Fehlerangabe jemals ausgefhrt wird
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[errorStr1->prod2_index];

			//ist die Position des Punktes zu gro?
			if( errorStr1->dot > p2->riAnz )
			{
				//wird niemals ausgefhrt
				cerr << "sslr: ERROR: line " << errorStr1->line << ": Position of dot " << errorStr1->dot << " to big!" << endl;

				//Fehler
				err++;
			}
		}
	}

	//Anzahl der Fehler zurckgeben
	return( err );
}


void SSLRParser::sortProd2Str( void )
{
	//Die PROD2_STR sortieren
	PROD2_STR	*a, *b, *source, *dest, tmp;
	PROD_STR	*p1;
	char		*name1, *name2;
	int			i, j, k, anz;

	//initialisieren
	i = 0;

	//alle Alternativen
	while( i < ( prod2_anz - 1 ) )
	{
		//Zeiger auf PROD2_STR
		a = &prod2_str[i];

		//den Namen holen
		name1 = hash_tab->getName( prod_str[a->prod_index].hash_index );

		//Index
		j = i++;

		do
		{
			//nchsten
			j++;

			//Zeiger auf PROD2_STR
			b = &prod2_str[j];

			//Zeiger auf PROD_STR
			p1 = &prod_str[b->prod_index];

			//den Namen holen
			name2 = hash_tab->getName( p1->hash_index );

		}while( ( a->prod_index == b->prod_index ) && ( j < ( prod2_anz - 1 ) ) );

		//alle Alternativen
		for( k = j++; j < prod2_anz; j++ )
		{
			//Zeiger auf PROD2_STR
			b = &prod2_str[j];

			//Den Namen holen
			name2 = hash_tab->getName( prod_str[b->prod_index].hash_index );

			//gleiche Produktionen, d.h. prod_index gleich?
			if( a->prod_index == b->prod_index )
			{
				//ja

				//Zeiger auf PROD2_STR
				source = &prod2_str[j];

				//Zeiger auf PROD2_STR
				dest = &prod2_str[k];

				//j sichern
				tmp.prod_index = source->prod_index;
				tmp.riAnz = source->riAnz;
				tmp.right = source->right;
				tmp.priority = source->priority;
				tmp.semAct = source->semAct;
				tmp.semActLine = source->semActLine;

				//verschieben
				memmove( &prod2_str[k+1], &prod2_str[k], sizeof( PROD2_STR ) * ( j - k ) );

				//eintragen
				dest->prod_index = tmp.prod_index;
				dest->riAnz = tmp.riAnz;
				dest->right = tmp.right;
				dest->priority = tmp.priority;
				dest->semAct = tmp.semAct;
				dest->semActLine = tmp.semActLine;

				//nchste Position
				k++;
			}
		}

		//ab k + 1
		i = k;
	}

	//Indices anpassen
	for( i = 0, k = 0; i < prod_anz; i++ )
	{
		//Anzahl der Alternativen
		anz = prod_str[i].altAnz;

		//prod2_index anpassen
		prod_str[i].prod2_index = k;

		//alle zugehrigen Alternativen
		for( j = k; j < ( k + anz ); j++ )
			//PROD_STR-Index eintragen
			prod2_str[j].prod_index = i;

		//berspringen
		k += anz;
	}
}


void SSLRParser::outputGrammar( void )
{
	//Grammatik in Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name;
	int			i, j, k, r;

	//Grammatik in Datei ausgeben?
	if( argv_str->outputGrammar )
	{
		//Stream ffnen
		ofstream	out( argv_str->name );

		//Header ausgeben
		out << "/*\n";
		out << "Grammatik in BNF-Form. Generiert vom SSLR-Parser-Generator V" << VERSION << ".\n";
		out << "(c) 2002-2005 by Sven Schmidt\n";
		out << "s.schmidt@lboro.ac.uk\n";
		out << "*/\n\n";

		//Alle Produktionen
		for( i = 1; i < prod_anz; i++ )
		{
			//Zeiger auf die PROD_STR holen
			p1 = &prod_str[i];

			//Den Namen der Produktion holen
			name = hash_tab->getName( p1->hash_index );

			//Produktion ausgeben
			out << name << "\n";

			//Seperator ausgeben
			out << "\t->\t";

			//alle Alternativen ausgeben
			for( j = p1->prod2_index, k = 0; j < ( p1->prod2_index + p1->altAnz ); j++, k++ )
			{
				//Zeiger auf die PROD2_STR holen
				p2 = &prod2_str[j];

				//neue Alternative?
				if( k )
					//Ja
					out << "\t|\t";

				//rechte Seite ausgeben
				for( r = 0; r < p2->riAnz; r++ )
				{
					//Namen holen
					name = hash_tab->getName( p2->right[r] );

					//Terminal?
					if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
						//Ja
						out << " '" << name << "' ";

					else
						//Nichtterminal
						out << " " << name << " ";
				}

				//Prioritt ausgeben
				out << "\t/* Priority: " << p2->priority << " */\n";
			}

			//Produktion abschliessen
			out << "\t;\n\n";
		}
	}
}


void SSLRParser::outputAlt( ostream &s, long prod2_index )
{
	//alle Alternativen der Produktion ausgeben, zu der die Alternative prod2_index gehrt
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	s << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			s << " '" << name << "' ";

		else
			//Nichtterminal
			s << " " << name << " ";
	}

	//nchste Zeile
	s << "\n";
}


void SSLRParser::outputItem( long prod2_index, int dot, ofstream &file )
{
	//Ein Item ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	file << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Position des Punktes?
		if( dot == r )
			//ja
			file << ".";

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			file << " '" << name << "' ";

		else
			//Nichtterminal
			file << " " << name << " ";
	}

	//Position des Punktes?
	if( dot == r )
		//ja
		file << ".";
}


void SSLRParser::outputItem( long prod2_index, int dot )
{
	//Ein Item ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	cout << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Position des Punktes?
		if( dot == r )
			//ja
			cout << ".";

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			cout << " '" << name << "' ";

		else
			//Nichtterminal
			cout << " " << name << " ";
	}

	//Position des Punktes?
	if( dot == r )
		//ja
		cout << ".";
}


void SSLRParser::outputAllAlt( void )
{
	//Alle Alternativen ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	ofstream	out( argv_str->name );
	char		*name;
	int			j, r;

	//alle Alternativen ausgeben
	for( j = 0; j < prod2_anz; j++ )
	{
		//Zeiger auf die PROD2_STR holen
		p2 = &prod2_str[j];

		//Zeiger auf die PROD_STR holen
		p1 = &prod_str[p2->prod_index];

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//ausgeben
		out << " " << name << " -> ";

		//rechte Seite ausgeben
		for( r = 0; r < p2->riAnz; r++ )
		{
			//Namen holen
			name = hash_tab->getName( p2->right[r] );

			//Terminal?
			if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
				//Ja
				out << " '" << name << "' ";

			else
				//Nichtterminal
				out << " " << name << " ";
		}

		//nchste Zeile
		out << "\n";
	}
}


void SSLRParser::genAllFirst( void )
{
	//Alle FIRST-Mengen bilden
	PROD2_STR	*p2;
	PROD_STR	*p1;
	Terminal	*f1;
	long		anzFirst;
	char		*name;
	int			i, j, changed;
	int			pass = 0;
	int			*pArr;

	//keine doppelten Ausgaben
	pArr = new( int[prod_anz] );

	//Initialisieren
	memset( pArr, 0, sizeof( int ) * prod_anz );

	do
	{
		//prft, ob weitere Terminale zur FIRST-Menge hinzugefgt wurden
		changed = 0;

		//ein weiterer Pass
		pass++;

		//alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//ausfhrliche Ausgaben?
			if( ( argv_str->verbose ) && !( pArr[i] ) )
			{
				//ja
				cout << "sslr: Generate FIRST(" << name << ")..." << endl;

				//Meldung nicht nocheinmal ausgeben
				pArr[i]++;
			}

			//Anzahl der FIRST-Elemente holen
			anzFirst = hash_tab->getFirstAnz( p1->hash_index );

			//Zeiger auf FIRST-Mengen holen
			f1 = hash_tab->getFirst( p1->hash_index );

			//Alle Alternativen
			for( j = p1->prod2_index; j < ( p1->prod2_index + p1->altAnz ); j++ )
			{
				//Zeiger auf PROD2_STR
				p2 = &prod2_str[j];

				//FIRST-Menge berechnen
				genFirst( f1, p2->riAnz, p2->right );
			}

			//gendert?
			if( anzFirst != hash_tab->getFirstAnz( p1->hash_index ) )
				//Ja
				changed++;
		}

	}while( changed );

	//Speicher wieder freigeben
	delete[] ( pArr );

	//ausfhrliche Ausgaben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate FIRST-Sets!" << endl;

	//FIRST-Mengen ausgeben?
	if( argv_str->showFirst )
	{
		//Alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//Ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//Meldung
			cout << "\nFIRST(" << name << ")=" << endl;

			//FIRST-Menge ausgeben
			hash_tab->printFirst( p1->hash_index );
		}
	}
}


void SSLRParser::genFirst( Terminal *f, int anzElem, long *arr )
{
	//Hier werden die FIRST-Mengen eines Terminals/Nichtterminals erzeugt
	Terminal	*f2, *f3;
	char		*name;
	int			i, eps = 0;

	//fr jeden Durchgang eine eigene FIRST-Menge
	f3 = new Terminal( epsHashIndex );

	//Gibt es berhaupt noch Elemente
	if( anzElem > 0 )
	{
		//Alle Elemente
		for( i = 0; i < anzElem; i++ )
		{
			//Namen holen
			name = hash_tab->getName( arr[i] );

			//Zeiger auf die FIRST-Menge holen
			f2 = hash_tab->getFirst( arr[i] );

			//hinzufgen
			f3->add( f2 );

			//beinhaltet die FIRST-Menge EPSILON?
			if( f2->isEpsilon() )
				//Ja, hochzhlen
				eps++;

			else
				//Nein, for-Schleife verlassen
				break;
		}

		//Epsilon zu dieser Menge hinzufgen?
		if( eps && ( eps < anzElem ) )
		{
			//Nein, aus der FIRST-Menge lschen

			//EPSILON aus FIRST-Menge lschen
			f3->del( epsHashIndex );
		}
	}

	else
		//leere Menge, EPSILON hinzufgen
		f3->ins( epsHashIndex );

	//FIRST-Menge hinzufgen
	f->add( f3 );

	//Speicher freigeben
	delete( f3 );
}


void SSLRParser::genAllFollow( void )
{
	//Alle FOLLOW-Mengen bilden
	PROD2_STR	*p2;
	PROD_STR	*p1, *p3;
	Terminal	*f1, *f2, *first;
	long		anzFollow;
	char		*name, *tmpName;
	int			i, j, r, changed;
	int			pass = 0;
	int			*pArr;

	//keine doppelten Ausgaben
	pArr = new( int[prod_anz] );

	//Initialisieren
	memset( pArr, 0, sizeof( int ) * prod_anz );

	//ACCEPT in die Start-Produktion aufnehmen
	f1 = hash_tab->getFollow( prod_str[0].hash_index );

	//ACCEPT eintragen
	f1->ins( acceptHashIndex );

	do
	{
		//prft, ob weitere Terminale zur FOLLOW-Menge hinzugefgt wurden
		changed = 0;

		//ein weiterer Pass
		pass++;

		//alle Produktionen
		for( i = 1; i < prod_anz; i++ )
		{
			//nein, Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//ausfhrliche Ausgaben?
			if( ( argv_str->verbose ) && !( pArr[i] ) )
			{
				//ja
				cout << "sslr: Generate FOLLOW(" << name << ")..." << endl;

				//Meldung nicht nocheinmal ausgeben
				pArr[i]++;
			}

			//Anzahl der FOLLOW-Elemente holen
			anzFollow = hash_tab->getFollowAnz( p1->hash_index );

			//Zeiger auf FOLLOW-Mengen holen
			f1 = hash_tab->getFollow( p1->hash_index );

			//Alle Alternativen
			for( j = 0; j < prod2_anz; j++ )
			{
				//Zeiger auf PROD2_STR
				p2 = &prod2_str[j];

//Debug-Modus?
#ifdef SSLR_INTERN_DEBUG
				//Alternative ausgeben
				outputAlt( j );
#endif

				//Nichtterminal check[i] auf rechter Seite suchen
				for( r = 0; r < p2->riAnz; r++ )
				{
					//Name holen
					tmpName = hash_tab->getName( p2->right[r] );

					//Gefunden?
					if( p2->right[r] == p1->hash_index )
					{
						//FIRST-Mengen bilden
						first = new Terminal( epsHashIndex );

						//FIRST-Mengen bilden
						genFirst( first, p2->riAnz - r - 1, &p2->right[r+1] );

						//EPSILON in FIRST-Menge?
						if( first->isEpsilon() )
						{
							//Ja, Zeiger auf PROD_STR
							p3 = &prod_str[p2->prod_index];

							//Namen holen
							tmpName = hash_tab->getName( p3->hash_index );

//							cerr << "FOLLOW(" << name << ") += FOLLOW(" << tmpName << ")" << endl;

							//Ja, FOLLOW(p2->prodindex) = FOLLOW(check[i])
							f2 = hash_tab->getFollow( p3->hash_index );

							//hinzufgen
							f1->add( f2 );

							//EPSILON aus FIRST-Menge lschen
							first->del( epsHashIndex );
						}

						//hinzufgen
						f1->add( first );

						//FIRST-Mengen lschen
						delete( first );
					}
				}
			}

			//gendert?
			if( anzFollow != hash_tab->getFollowAnz( p1->hash_index ) )
				//Ja
				changed++;
		}

	}while( changed );

	//Speicher wieder freigeben
	delete[] ( pArr );

	//ausfhrliche Ausgaben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate FOLLOW-Sets!" << endl;

	//FOLLOW-Mengen ausgeben?
	if( argv_str->showFollow )
	{
		//Alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//Ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//Meldung
			cout << "\nFOLLOW(" << name << ")=" << endl;

			//FOLLOW-Menge ausgeben
			hash_tab->printFollow( p1->hash_index );
		}
	}
}


void SSLRParser::genLR0Hulle( void )
{
	//Generiere alle Hllen der LR(0)-Elemente fr SLR und LALR
	HULLE_STR	*h;
	int			changed = 0, pass = 0, i;

	//1. Hlle generieren
	h = createHulle();

	//ersten Kern eintragen
	insertItem( h, 0, 0, SSLR_CORE );

	//Hlle eintragen
	insertHulle( h );

	//Wurde nicht durch Sprung-Funktion erzeugt
	h->from = 0;
	h->elem = 0;

	//bei Hlle 0 anfangen
	i = 0;

	do
	{
		//Passe zhlen
		pass++;

		//Keine nderungen
//		changed = 0;

		//Anzahl der Hllen merken
//		anzH = hulle_anz;

		//Alle Hllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf Hlle
			h = hulle_str[i];

			//Alle Elemente dieser Hlle erzeugen
			genLR0Items( h );

			//Ausgeben
//			outputHulle( h );

			//Anhand der Items die Hllen erzeugen, die sich durch Spring( h, X ) ergeben
			makeLR0Jump( h );
/*
			//Anzahl der Hllen gendert?
			if( hulle_anz != anzH )
				//Ja
				changed++;
*/
		}

	}while( changed );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate " << hulle_anz << " LR(0)-Items!" << endl;
}


void SSLRParser::genLR1Hulle( void )
{
	//Generiere alle Hllen der LR(1)-Elemente fr LR
	HULLE_STR	*h;
	Terminal	*la;
	int			changed = 0, pass = 0, i;

	//1. Hlle generieren
	h = createHulle();

	//Speicher fr die Lookaheads
	la = new Terminal( epsHashIndex );

	//Accept eintragen
	la->ins( acceptHashIndex );

	//ersten Kern eintragen
	insertItem( h, 0, 0, SSLR_CORE, la );

	//Hlle eintragen
	insertHulle( h );

	//Wurde nicht durch Sprung-Funktion erzeugt
	h->from = 0;
	h->elem = 0;

	//bei Hlle 0 anfangen
	i = 0;

	do
	{
		//Passe zhlen
		pass++;

		//Keine nderungen
//		changed = 0;

		//Anzahl der Hllen merken
//		anzH = hulle_anz;

		//Alle Hllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf Hlle
			h = hulle_str[i];

			//Alle Elemente dieser Hlle erzeugen
			genLR1Items( h );

			//Ausgeben
//			outputHulle( h );

			//Anhand der Items die Hllen erzeugen, die sich durch Spring( h, X ) ergeben
			makeLR1Jump( h );
/*
			//Anzahl der Hllen gendert?
			if( hulle_anz != anzH )
				//Ja
				changed++;
*/
		}

	}while( changed );

	//Speicher freigeben
	delete( la );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//Ja
		cout << "sslr: " << pass << " pass(es) to generate " << hulle_anz << " LR(1)-Items!" << endl;
}


void SSLRParser::makeLR0Jump( HULLE_STR *h )
{
	//Hier werden die Hllen erzeugt, die sich durch Sprung( h, X ) ergeben
	HULLE_STR	*tmp;
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	long		elem, hInd;
	int			i;

	//Alle LR(0)-Elemente der Hlle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Punkt eine Position weiter und Element eintragen

			//Das (Nicht)Terminal holen, das nach dem Punkt kommt
			/*
				Bsp: expr
							->	.expr ADD expr
							|	.expr SUB expr
							|	term
							;

				Hier also ist expr vor dem Punkt.
			*/
			elem = p2->right[lr->dot];

			/*
				Die hier erzeugte Hlle ergibt sich also aus:

				tmp = Sprung( h, elem )
			*/

			//darf nicht .EPSILON sein
			if( elem != epsHashIndex )
			{
				//Den Namen holen
				name = hash_tab->getName( elem );

				//Hlle anfordern
				tmp = createHulle();

				//Hlle erzeugen
				genLR0Jump( h, tmp, elem );

				//Hlle schon in hulle_str?
				if( ( hInd = cmpLR0Hulle( tmp ) ) < 0 )
				{
					//Nein

					// this = Sprung( h, elem ) merken
					tmp->from = h->hulleIndex;
					tmp->elem = elem;

					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hulle_anz );

					//Meldung ausgeben?
					if( argv_str->verbose )
						//Ja
						cout << "sslr: Generate Jump(" << name << ")..." << endl;

					//Hlle eintragen
					insertHulle( tmp );

					//Ausgeben
//					outputHulle( tmp );
				}

				else
				{
					//Die Hlle existiert schon
					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hInd );

					//Hlle lschen
					deleteHulle( tmp );
				}
			}
		}
	}
}


void SSLRParser::makeLR1Jump( HULLE_STR *h )
{
	//Hier werden die Hllen erzeugt, die sich durch Sprung( h, X ) ergeben
	HULLE_STR	*tmp;
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	long		elem, hInd;
	int			i;

	//Alle LR(1)-Elemente der Hlle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Punkt eine Position weiter und Element eintragen

			//Das (Nicht)Terminal holen, das nach dem Punkt kommt
			/*
				Bsp: expr
							->	.expr ADD expr
							|	.expr SUB expr
							|	.term
							;

				Hier sind expr und term vor dem Punkt.
			*/
			elem = p2->right[lr->dot];

			/*
				Die hier erzeugte Hlle ergibt sich also aus:

				tmp = Sprung( h, elem )
			*/

			//darf nicht .EPSILON sein
			if( elem != epsHashIndex )
			{
				//Den Namen holen
				name = hash_tab->getName( elem );

				//Hlle anfordern
				tmp = createHulle();

				//Hlle erzeugen
				genLR1Jump( h, tmp, elem );

				//Hlle schon in hulle_str?
				if( ( hInd = cmpLR1Hulle( tmp ) ) < 0 )
				{
					//Nein

					// this = Sprung( h, elem ) merken
					tmp->from = h->hulleIndex;
					tmp->elem = elem;

					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hulle_anz );

					//Meldung ausgeben?
					if( argv_str->verbose )
						//Ja
						cout << "sslr: " << hulle_anz << " Generate Jump(" << h->hulleIndex << ", " << name << ")..." << endl;

					//Hlle eintragen
					insertHulle( tmp );

					//Ausgeben
//					outputHulle( tmp );
				}

				else
				{
					//Die Hlle existiert schon
					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hInd );

					//Hlle lschen
					deleteHulle( tmp );
				}
			}
		}
	}
}


void SSLRParser::genLR0Items( HULLE_STR *h )
{
	//Hier werden alle LR(0)-Items einer Hlle erzeugt.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr;
	char		*name, *tmpName;
	long		pi;
	int			j, k;

	//Alle Elemente dieser Hlle
	for( j = 0; j < h->anzElem; j++ )
	{
		/*
			Bsp:	expr	->	.expr ADD expr
							|	.expr SUB expr
							|	.term
		*/
		//Index der ersten Alternative der Produktion nach dem Punkt holen

		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[j];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Namen holen
			name = hash_tab->getName( p2->right[lr->dot] );

			//Ist es ein Nichtterminal?
			if( hash_tab->getType( p2->right[lr->dot] ) == SSLR_NTERM )
			{
				//Ja, diese Produktion als Elemente mit dot = 0 aufnehmen

				//prod_index dieses Nichtterminals
				pi = hash_tab->getProdStr( p2->right[lr->dot] );

				//Zeiger auf PROD_STR
				p1 = &prod_str[pi];

				//Namen holen
				tmpName = hash_tab->getName( p1->hash_index );

				//Index der ersten Alternative in der PROD2_STR
				for( k = p1->prod2_index; k < ( p1->prod2_index + p1->altAnz ); k++ )
					//Als LR(0)-Item hinzufgen
					insertItem( h, k, 0, SSLR_ITEM );
			}
		}
	}
}


void SSLRParser::genLR1Items( HULLE_STR *h )
{
	//Hier werden alle LR(1)-Items einer Hlle erzeugt.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr, *lr2;
	Terminal	*la;
	char		*name, *tmpName;
	long		pi, cInd;
	int			j, k, changed, anzElem;

	do
	{
		//solange etwas hinzugefgt wurde
		changed = 0;

		//Alle Elemente dieser Hlle
		for( j = 0; j < h->anzElem; j++ )
		{
			/*
				Bsp:	expr	->	.expr ADD expr
								|	.expr SUB expr
								|	.term
			*/
			//Index der ersten Alternative der Produktion nach dem Punkt holen

			//Zeiger auf LR(0)-Element
			lr = &h->lr_str[j];

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[lr->prod2_index];

			//Ist der Punkt am Ende?
			if( lr->dot < p2->riAnz )
			{
				//Namen holen
				name = hash_tab->getName( p2->right[lr->dot] );

				//Ist es ein Nichtterminal?
				if( hash_tab->getType( p2->right[lr->dot] ) == SSLR_NTERM )
				{
					//Ja, diese Produktion als Elemente mit dot = 0 aufnehmen

					//prod_index dieses Nichtterminals
					/*
						Bsp:
							term	->	.term MUL factor

						Also PROD_STR-Index von term
					*/
					pi = hash_tab->getProdStr( p2->right[lr->dot] );

					//Zeiger auf PROD_STR
					p1 = &prod_str[pi];

					//Namen holen
					tmpName = hash_tab->getName( p1->hash_index );

					//Speicher fr die Lookaheads holen
					la = new Terminal( epsHashIndex );

					//FIRST-Menge bilden nach dot
					genFirst( la, p2->riAnz - lr->dot - 1, &p2->right[lr->dot + 1] );

					//EPSILON in FIRST-Menge?
					if( la->isEpsilon() )
					{
						//Ja, alle Lookaheads des LR(1)-Items hinzufgen
						la->add( lr->la );

						//EPSILON aus FIRST-Menge lschen
						la->del( epsHashIndex );
					}

					//Index der ersten Alternative in der PROD2_STR
					for( k = p1->prod2_index; k < ( p1->prod2_index + p1->altAnz ); k++ )
					{
						//Ist dieses Item schon in der Hlle, also nur die Lookaheads ergnzen?
						if( ( cInd = findItem( h, k, 0 ) ) < 0 )
							//Nein, noch nicht da, als LR(1)-Item hinzufgen
							insertItem( h, k, 0, SSLR_ITEM, la );

						else
						{
							//Ja, Item schon da

							//Zeiger auf Item
							lr2 = &h->lr_str[cInd];

							//Anzahl der Lookaheads merken
							anzElem = lr2->la->getAnzElem();

							//Lookaheads ergnzen
							insertItem( h, k, 0, SSLR_ITEM, la );

							//Wurden Terminale hinzugefgt?
							if( anzElem != lr2->la->getAnzElem() )
								//Ja
								changed++;


							/*

								statement_list
									:	statement
									|	statement_list statement
									;

								Wegen solchen Produktionen muss man mehrmals ber die Items hinweggehen,
								da im zweiten Schritt .statement_list statement FIRST(statement)
								als Lookaheads hinzukommt, die im ersten Schritt .statement nicht
								erfasst wurden!
							*/
						}
					}

					//Speicher wieder freigeben
					delete( la );
				}
			}
		}

		//Solange nderungen vorgenommen wurden

	}while( changed );
}


SSLRParser::HULLE_STR *SSLRParser::createHulle( void )
{
	//Eine HULLE_STR-Struktur erzeugen
	HULLE_STR	*h;

	//Speicher anfordern
	h = new HULLE_STR;

	//Initailisieren
	h->anzCore = 0;
	h->anzElem = 0;
	h->lr_str = 0;

	//Zeiger auf Hlle zurckliefern
	return( h );
}


void SSLRParser::deleteHulle( HULLE_STR *h )
{
	//Eine HULLE_STR-Struktur lschen
	LR_STR	*lr;
	int		i;

	//Alle Elemente einer Hlle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0/1)-Item
		lr = &h->lr_str[i];

		//Lookahead-Terminale freigeben
		if( lr->la )
			delete( lr->la );

		//Lookahead-Terminale freigeben
		if( lr->lalr )
			delete( lr->lalr );
	}

	//LR_STR freigeben
	delete[] ( h->lr_str );

	//HULLE_STR lschen
	delete( h );
}


void SSLRParser::insertItem( HULLE_STR *h, long prod2_index, int dot, int type )
{
	//LR(0)-Element in HULLE h eintragen
	LR_STR	*tmp;

	//Item schon enthalten?
	if( findItem( h, prod2_index, dot ) < 0 )
	{
		//nein, Speicher fr das LR(0)-Element
		tmp = new( LR_STR[h->anzElem + 1] );

		//kopieren
		memmove( tmp, h->lr_str, sizeof( LR_STR ) * h->anzElem );

		//alten Speicher freigeben
		if( h->lr_str )
			delete[] ( h->lr_str );

		//Zeiger
		h->lr_str = tmp;

		//eintragen
		h->lr_str[h->anzElem].dot = dot;
		h->lr_str[h->anzElem].prod2_index = prod2_index;

		//keine Lookaheads
		h->lr_str[h->anzElem].la = new Terminal( epsHashIndex );

		//Lookaheads eintragen
		h->lr_str[h->anzElem++].lalr = new Terminal( epsHashIndex );

		//ein weiterer Kern hinzugefgt?
		if( type == SSLR_CORE )
			//Ja
			h->anzCore++;

		//Warnung?
		if( ( type == SSLR_CORE ) && ( h->anzElem > h->anzCore ) )
			cerr << "sslr: SSLRParser::insertItem: Es wurde ein Kern eingetragen, obwohl schon alle Items berechnet sein sollten!" << endl;
	}
}


void SSLRParser::insertItem( HULLE_STR *h, long prod2_index, int dot, int type, Terminal *la )
{
	//LR(1)-Element in HULLE h eintragen
	LR_STR	*tmp;
	long	hInd;

	//Item schon enthalten?
	if( ( hInd = findItem( h, prod2_index, dot ) ) < 0 )
	{
		//nein, Speicher fr das LR(1)-Element
		tmp = new( LR_STR[h->anzElem + 1] );

		//kopieren
		memmove( tmp, h->lr_str, sizeof( LR_STR ) * h->anzElem );

		//alten Speicher freigeben
		if( h->lr_str )
			delete[] ( h->lr_str );

		//Zeiger
		h->lr_str = tmp;

		//eintragen
		h->lr_str[h->anzElem].dot = dot;
		h->lr_str[h->anzElem].prod2_index = prod2_index;

		//Lookaheads eintragen
		h->lr_str[h->anzElem].la = new Terminal( epsHashIndex );
		h->lr_str[h->anzElem].la->add( la );

		//keine Lookahead-Terminale
		h->lr_str[h->anzElem++].lalr = 0L;

		//ein weiterer Kern hinzugefgt?
		if( type == SSLR_CORE )
			//Ja
			h->anzCore++;

		//Warnung?
		if( ( type == SSLR_CORE ) && ( h->anzElem > h->anzCore ) )
			cerr << "sslr: SSLRParser::insertItem: Es wurde ein Kern eingetragen, obwohl schon alle Items berechnet sein sollten!" << endl;
	}

	else
	{
		//Item schon in der Hlle enthalten, also nur die Lookaheads la hinzufgen
		tmp = &h->lr_str[hInd];

		//Lookaheads hinzufgen
		tmp->la->add( la );
	}
}


int SSLRParser::cmpLR0Hulle( HULLE_STR *h )
{
	//Prft, ob die Hlle h schon in hulle_str enthalten ist
	HULLE_STR	*tmp;
	LR_STR		*lr;
	int			i, j, elemCnt = 0;
	int			anzCore = h->anzCore, cInd;

	//Alle Hllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zhler
		elemCnt = 0;

		//Zeiger auf Hlle
		tmp = hulle_str[i];

		//Anzahl der Items gleich?
		if( ( h->anzElem == tmp->anzElem ) && ( h->anzCore == tmp->anzCore ) )
		{
			//Alle LR(0)-Kerne von tmp
			for( j = 0; j < tmp->anzCore; j++ )
			{
				//Zeiger auf LR(0)-Item
				lr = &tmp->lr_str[j];

				//Item in h enthalten?
				if( ( cInd = findItem( h, lr->prod2_index, lr->dot ) ) < 0 )
					//nein
					break;

				//Ist es ein Kern-Item von h?
				else if( cInd <= ( anzCore - 1 ) )
					//Ja
					elemCnt++;
			}

			//gefunden?
			if( elemCnt == anzCore )
				//Ja
				break;
		}
	}

	//h noch nicht in hulle_str enthalten
	return( anzCore == elemCnt ? i : -1 );
}


int SSLRParser::cmpLR1Hulle( HULLE_STR *h )
{
	//Prft, ob die Hlle h schon in hulle_str enthalten ist
	HULLE_STR	*tmp;
	LR_STR		*lr;
	int			i, j, elemCnt = 0;
	int			anzCore = h->anzCore, cInd;

	//Alle Hllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zhler
		elemCnt = 0;

		//Zeiger auf Hlle
		tmp = hulle_str[i];

		//Anzahl der Items gleich?
		if( ( h->anzElem == tmp->anzElem ) && ( h->anzCore == tmp->anzCore ) )
		{
			//Alle LR(1)-Kerne
			for( j = 0; j < tmp->anzCore; j++ )
			{
				//Zeiger auf LR(0)-Item
				lr = &tmp->lr_str[j];

				//Item in h enthalten?
				if( ( cInd = findItem( h, lr->prod2_index, lr->dot, lr->la ) ) < 0 )
					//nein
					break;

				//Ist es ein Kern-Item von h?
				else if( cInd <= ( anzCore - 1 ) )
					//Ja
					elemCnt++;
			}

			//gefunden?
			if( elemCnt == anzCore )
				//Ja
				break;
		}
	}

	//h noch nicht in hulle_str enthalten
	return( anzCore == elemCnt ? i : -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index )
{
	//prft, ob in der Hlle h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &h->lr_str[i];

		//gleich?
		if( prod2_index == lr->prod2_index )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index, int dot )
{
	//prft, ob in h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Item
		lr = &h->lr_str[i];

		//gleich?
		if( ( prod2_index == lr->prod2_index ) && ( dot == lr->dot ) )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index, int dot, Terminal *la )
{
	//prft, ob in h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Item
		lr = &h->lr_str[i];

		//gleich?
		if( ( prod2_index == lr->prod2_index ) && ( dot == lr->dot ) && ( lr->la->cmp( la ) ) )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


void SSLRParser::outputHulle ( HULLE_STR *h )
{
	//Eine Hlle ausgeben
	Terminal	*la;
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr;
	char		*name = "";
	long		*tArr, *nArr, elem, LRTabIndex;
	int			i, r, v, anz, typ;
	bool		draw;

	//Namen der Produktion holen
	name = hash_tab->getName( h->elem );

	//erster name ist leer
	if( name )
		//ausgeben
		cout << "\n\nHlle " << h->hulleIndex << " = Sprung( " << h->from << ", " << name << " )" << endl;

	else
		//ohne "Vererbung"
		cout << "\n\nHlle " << h->hulleIndex << endl;

	//Alle LR(0)-Elemente der Hlle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Kern?
		if( i < h->anzCore )
			//Ja
			cout << "Kern:\t";

		else
			//Kein Kern-Element
			cout << "     \t";

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//ausgeben
		cout << " " << name << " -> ";

		//rechte Seite ausgeben
		for( r = 0; r < p2->riAnz; r++ )
		{
			//Position des Punktes?
			if( lr->dot == r )
				//Ja
				cout << ".";

			//Namen holen
			name = hash_tab->getName( p2->right[r] );

			//Terminal?
			if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
				//Ja
				cout << " '" << name << "' ";

			else
				//Nichtterminal
				cout << " " << name << " ";
		}

		//Position des Punktes?
		if( lr->dot == r )
			//Ja
			cout << ".";

		//Lookaheads ausgeben?
		if( lr->la )
		{
			//Ja, Lookaheads ausgeben
			la = lr->la;

			//Anzahl der Lookaheads
			anz = lr->la->getAnzElem();

			//Alle Lookaheads ausgeben
			for( v = 0; v < anz; v++ )
				//Terminal ausgeben
				cout << "," << hash_tab->getName( (*la)[v] );
		}

		//nchste Zeile
		cout << endl;
	}

	//Alle Sprung-bergnge nur einmal zeigen
	tArr = new( long[termArrCount + 1] );
	nArr = new( long[ntermArrCount] );

	//initialisieren
	memset( tArr, 0, sizeof( long ) * ( termArrCount + 1 ) );
	memset( nArr, 0, sizeof( long ) * ( ntermArrCount ) );

	//Alle LR(0)-Elemente der Hlle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Position des Punktes?
		if( lr->dot < p2->riAnz )
		{
			//Sprung-Hlle ausgeben
			elem = p2->right[lr->dot];

			//Index des Element in der LR-Tabelle
			LRTabIndex = hash_tab->getLRTabIndex( elem );

			//Namen holen
			name = hash_tab->getName( elem );

			//Typ holen
			typ = hash_tab->getType( elem );

			//Terminal?
			if( typ == SSLR_TERM )
			{
				//hinter dem Punkt folgt ein Terminal
				if( tArr[LRTabIndex] )
					//wurde schon ausgegeben
					draw = false;

				else
				{
					//ausgeben
					draw = true;

					//markieren, damit es nicht mehr ausgegeben wird
					tArr[LRTabIndex]++;
				}
			}

			else
			{
				//hinter dem Punkt folgt ein Nichtterminal
				if( nArr[LRTabIndex] )
					//wurde schon ausgegeben
					draw = false;

				else
				{
					//ausgeben
					draw = true;

					//markieren, damit es nicht mehr ausgegeben wird
					nArr[LRTabIndex]++;
				}
			}

			//Epsilon?
			if( ( draw == true ) && ( p2->right[lr->dot] != epsHashIndex ) )
				//Jump ausgeben
				cout << "Sprung(" << name << ") = " << lr->jumpTo << endl;
		}
	}

	//Speicher freigeben
	delete[] ( tArr );
	delete[] ( nArr );

	//nchste Zeile
	cout << endl << endl;
}


void SSLRParser::insertHulle( HULLE_STR *h )
{
	//Eine Hlle in die Sammlung von Elementen eintragen.
	HULLE_STR	**tmp;

	//Hlle schon eingetragen?
//	if( cmpLR0Hulle( h ) == -1 )
	{
		//Speicher anfordern
		tmp = new( HULLE_STR *[hulle_anz + 1] );

		//kopieren
		memmove( tmp, hulle_str, sizeof( HULLE_STR * ) * hulle_anz );

		//alten Speicher freigeben
		if( hulle_str )
			delete[] ( hulle_str );

		//Zeiger
		hulle_str = tmp;

		//eintragen
		hulle_str[hulle_anz] = h;
		h->hulleIndex = hulle_anz++;

		//Anzahl der Kerne
		coreAnz += h->anzCore;
	}
}


void SSLRParser::genLALR( void )
{
	//Aus der Sammlung der LR(0)-Elemente die Lookaheads anfgen.
	HULLE_STR	*h, *checkHulle, *hTmp, *hTmp2;
	PROD2_STR	*p2;
	Terminal	*checkTerm, *la;
	LR_STR		*lr, *lr2, *lr3;
	long		elem;
	char		*name;
	int			i, j, k, v, hInd, cInd, laAnz, changed;
	int			pass = 0;

	//Check-Terminal # (s. Drache S. 295)
	checkTerm = new Terminal( epsHashIndex );
	checkTerm->ins( lalrHashIndex );

	/******************************************/
	/* spontan generierte Lookaheads erzeugen */
	/******************************************/


	//Alle Hllen, I
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hlle
		h = hulle_str[i];

		//fr jeden Kern, B -> gamma .delta in K
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//neue Hlle anfordern, erzeuge J' := Hlle({[B -> gamma .delta, #]});
			checkHulle = createHulle();

			//Diesen Kern mit Check-Terminal # in checkHulle eintragen
			insertItem( checkHulle, lr->prod2_index, lr->dot, SSLR_CORE, checkTerm );

			//Hlle bilden
			genLR1Items( checkHulle );

			//Hlle ausgeben
//			outputHulle( checkHulle );

			//Alle LR(1)-Elemente dieser Hlle
			for( k = 0; k < checkHulle->anzElem; k++ )
			{
				//Zeiger auf das LR(1)-Item, [A -> alpha .X beta, a]
				lr2 = &checkHulle->lr_str[k];

				//Zeiger auf die Terminale
				la = lr2->la;

				//Alle Terminale
				for( v = 0; v < la->getAnzElem(); v++ )
				{
					//lalrHashIndex?
					if( (*la)[v] == lalrHashIndex )
						//Ja, Lookaheads breiten sich aus; werden spter behandelt
						continue;

					//Zeiger auf die Alternative
					p2 = &prod2_str[lr2->prod2_index];

					//Position des Punktes < maximale Position?
					if( lr2->dot < p2->riAnz )
					{
						//.index holen
						elem = p2->right[lr2->dot];

						//darf nicht Epsilon sein
						if( elem != epsHashIndex )
						{
							//Namen holen
							name = hash_tab->getName( elem );

							//Das LR(0)-Item k in h suchen
							cInd = findItem( h, lr2->prod2_index, lr2->dot );

							//Kern nicht gefunden?
							if( cInd < 0 )
							{
								//Kern nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf Item
							lr3 = &h->lr_str[cInd];

							//Index der Sprung-Hlle
							hInd = lr3->jumpTo;

							//Hlle nicht gefunden?
							if( hInd < 0 )
							{
								//Hlle nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf Hlle
							hTmp2 = hulle_str[hInd];

							//Kern k in hTmp2 finden
							cInd = findItem( hTmp2, lr2->prod2_index, lr2->dot + 1 );

							//Kern nicht gefunden?
							if( cInd < 0 )
							{
								//Kern nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf LR(1)-Item, A -> alpha X .beta in Sprung(I,X)
							lr3 = &hTmp2->lr_str[cInd];

							//spontan generierte Lookaheads aufnehmen
							lr3->lalr->add( la );

							//das checkTerminal lschen
							lr3->lalr->del( lalrHashIndex );

							//Speicher freigeben
//							delete( hTmp );
						}
					}
				}
			}

			//Speicher wieder freigeben
			deleteHulle( checkHulle );
		}
	}

/*
	//alle Hllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hlle
		h = hulle_str[i];

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Meldung
			cout << "\nKern " << j << ": spontan generierte Lookaheads fr " << i << ":" << endl;

			//spontan generierte Lookaheads ausgeben
			outputTerminal( lr->lalr );

			//Absatz
			cout << endl;
		}
	}
*/

	/********************************************/
	/* spontan generierte Lookaheads verbreiten */
	/********************************************/

	//Im ersten Kern ist ACCEPT ein spontan generiertes Lookahead
	hulle_str[0]->lr_str[0].lalr->ins( acceptHashIndex );


	//Ab hier sollten alle spontan generierten Lookaheads verfgbar sein,
	//nun auf die brigen Kerne verbreiten.

	do
	{
		//keine nderungen
		changed = 0;

		//Anzahl der Psse
		pass++;

		//Alle Hllen, I
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hlle
			h = hulle_str[i];

			//Alle Kerne dieser Hlle, B -> gamma .delta in K
			for( j = 0; j < h->anzCore; j++ )
			{
				//Zeiger auf das LR(0)-Item des Kerns
				lr = &h->lr_str[j];

				//Position des Punktes < maximale Position?
				if( lr->dot < prod2_str[lr->prod2_index].riAnz )
				{
					//Hlle erzeugen, erzeuge J' := Hlle({[B -> gamma .delta, #]});
					hTmp = createHulle();

					//Hlle erzeugen, wo die Terminale hinvererbt werden
					insertItem( hTmp, lr->prod2_index, lr->dot, SSLR_CORE, checkTerm );

					//alle Items erzeugen
					genLR1Items( hTmp );

					//Hlle ausgeben
//					outputHulle( hTmp );

					/*
						Nun alle Elemente dieser Hlle untersuchen, die # als Lookahead haben.
						Von diesen Elementen die Sprung-Hllen bilden und an die Kerne
						die Looakheads verbreiten.
					*/
					for( k = 0; k < hTmp->anzElem; k++ )
					{
						//Zeiger auf Item, [A -> alpha .X beta, #]
						lr2 = &hTmp->lr_str[k];

						//Hat dieses Element # als Lookahead?
						if( lr2->la->find( lalrHashIndex ) )
						{
							//Ja, die Sprung-Hlle dieses Elements bilden
							p2 = &prod2_str[lr2->prod2_index];

							//Punkt am Ende?
							if( lr2->dot < p2->riAnz )
							{
								//.index holen
								elem = p2->right[lr2->dot];

								//darf nicht Epsilon sein
								if( elem != epsHashIndex )
								{
									//Namen holen
									name = hash_tab->getName( elem );

									//Das LR(0)-Item k in h suchen
									cInd = findItem( h, lr2->prod2_index, lr2->dot );

									//Kern nicht gefunden?
									if( cInd < 0 )
									{
										//Kern nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf Item
									lr3 = &h->lr_str[cInd];

									//Index der Spring-Hlle
									hInd = lr3->jumpTo;

									//Hlle nicht gefunden?
									if( hInd < 0 )
									{
										//Hlle nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf die Hlle
									hTmp2 = hulle_str[hInd];

									//Kern k in hTmp2 finden
									cInd = findItem( hTmp2, lr2->prod2_index, lr2->dot + 1 );

									//Kern nicht gefunden?
									if( cInd < 0 )
									{
										//Kern nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf Item, A -> alpha X .beta in Sprung(I,X)
									lr3 = &hTmp2->lr_str[cInd];

									//Anzahl der Terminale
									laAnz = lr3->lalr->getAnzElem();

									//Lookaheads hinzufgen
									lr3->lalr->add( lr->lalr );

									//# lschen
									lr3->lalr->del( lalrHashIndex );

									//Wurde etwas hinzugefgt?
									if( laAnz != lr3->lalr->getAnzElem() )
										//Ja
										changed++;
								}
							}
						}
					}

					//Speicher freigeben
					deleteHulle( hTmp );
				}
			}
		}

/*
		//alle Hllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hlle
			h = hulle_str[i];

			//alle Kerne
			for( j = 0; j < h->anzCore; j++ )
			{
				//Zeiger auf das LR(0)-Item
				lr = &h->lr_str[j];

				//Meldung
				cout << "\nspontan generierte Lookaheads fr " << i << ":" << endl;

				//spontan generierte Lookaheads ausgeben
				outputTerminal( lr->lalr );

				//Absatz
				cout << endl;
			}
		}
*/


	}while( changed );

	//Meldung?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate LALR-Items!" << endl;

	//Speicher fr Check-Terminal # freigeben (s. Drache S. 295)
	delete( checkTerm );


	//berall die Hllen neu generieren
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hlle
		h = hulle_str[i];

		//Hlle ausgeben
//		outputHulle( h );

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//alten Speicher freigeben
			delete( lr->la );

			//Lookaheads eintragen
			lr->la = lr->lalr;

			//zurcksetzen
			lr->lalr = 0L;
		}

		//Hllen erzeugen
		genLR1Items( h );
	}

/*
	//alle Hllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hlle
		h = hulle_str[i];

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Meldung
			cout << "\nspontan generierte Lookaheads fr " << i << ":" << endl;

			//spontan generierte Lookaheads ausgeben
			outputTerminal( lr->lalr );

			//Absatz
			cout << endl;
		}
	}
*/
}


void SSLRParser::genLR0Jump( HULLE_STR *I0, HULLE_STR *I1, long index )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefgt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name, *tmpName;
	int			i;

	//Name von index
	name = hash_tab->getName( index );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt em Ende?
		if( lr->dot < p2->riAnz )
		{
			//Name von Element nach Punkt
			tmpName = hash_tab->getName( p2->right[lr->dot] );

			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == index )
				//Ja, als Kern in I1 eintragen
				insertItem( I1, lr->prod2_index, lr->dot + 1, SSLR_CORE );
		}
	}

	//Alle LR(0)-Elemente dieser Hlle erzeugen
	genLR0Items( I1 );
}


void SSLRParser::genLR1Jump( HULLE_STR *I0, HULLE_STR *I1, long index )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefgt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	int			i;

	//Name von index
	name = hash_tab->getName( index );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt em Ende?
		if( lr->dot < p2->riAnz )
		{
			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == index )
				//Ja, als Kern in I1 eintragen
				insertItem( I1, lr->prod2_index, lr->dot + 1, SSLR_CORE, lr->la );
		}
	}

	//Alle LR(1)-Elemente dieser Hlle erzeugen
	genLR1Items( I1 );
}


void SSLRParser::outputTerminal( Terminal *la )
{
	//Terminale ausgeben
	int	i, anz;

	//Anzahl der Terminale
	anz = la->getAnzElem();

	//alle Terminale ausgeben
	for( i = 0; i < anz; i++ )
		//ausgaben
		cout << hash_tab->getName( (*la)[i] ) << ", ";
}


void SSLRParser::setJump( HULLE_STR *I0, long elem, long HIindex )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefgt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	int			i;

	//Name von index
	name = hash_tab->getName( elem );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == elem )
				//Ja, den Index der Hlle eintragen, die durch Sprung( I0, elem ) erzeugt wird
				lr->jumpTo = HIindex;
		}
	}
}


bool SSLRParser::cmp2LR0Hulle( HULLE_STR *a, HULLE_STR *b )
{
	//Hier werden die LR(0)-Kerne beider Hllen verglichen
	LR_STR	*lr;
	int		i, cInd;

	//Kerne gleich?
	if( ( a->anzElem == b->anzElem ) && ( a->anzCore == b->anzCore ) )
	{
		//Ja, gleich
		for( i = 0; i < a->anzCore; i++ )
		{
			//Zeiger auf Kern von a
			lr = &a->lr_str[i];

			//Ist dieses Item in b?
			if( ( cInd = findItem( b, lr->prod2_index, lr->dot ) ) < 0 )
				//Nein
				return( false );

			//Ist es ein Kern?
			else if( cInd > ( a->anzCore - 1 ) )
				//Ist kein Kern
				return( false );
		}

		//gleich
		return( true );
	}

	//nicht gleich
	return( false );
}


void SSLRParser::LR2LALR( void )
{
	//Wandelt die LR(1)-Hllen in LR(0)-Hllen
	HULLE_STR	*a, *b, **tmp;
	LR_STR		*lr;
	int			i, j, k;

	//Meldung?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Making LR to LALR..." << endl;

	//alle Hllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf Hlle
		a = hulle_str[i];

		//Alle anderen Hllen mit dieser vergleichen
		for( j = i + 1; j < hulle_anz; j++ )
		{
			//Zeiger auf Hlle
			b = hulle_str[j];

			//beiden Hllen vergleichen
			if( cmp2LR0Hulle( a, b ) == true )
			{
				//Meldung?
				if( argv_str->verbose )
					//ja
					cout << "Closure " << i << " and " << j << " equal..." << endl;

				//Die Terminale der Kerne von b in a eintragen, dann b lschen
				for( k = 0; k < b->anzCore; k++ )
				{
					//Zeiger auf Kern
					lr = &b->lr_str[k];

					//Kern in a eintragen
					insertItem( a, lr->prod2_index, lr->dot, SSLR_CORE, lr->la );
				}

				//Hlle nochmal bilden, da Lookaheads mglicherweise anders
				genLR1Items( a );

				//den Speicher der Hlle freigeben
				deleteHulle( b );

				//Speicher fr alle Hllen
				tmp = new( HULLE_STR *[hulle_anz - 1] );

				//Hllen kopieren
				memmove( tmp, hulle_str, sizeof( HULLE_STR * ) * j );
				memmove( &tmp[j], &hulle_str[j + 1], sizeof( HULLE_STR * ) * ( hulle_anz - j - 1 ) );

				//Hlle b lschen

				//eine Hlle weniger
				hulle_anz--;

				//alten Speicher freigeben
				delete[] ( hulle_str );

				//Zeiger
				hulle_str = tmp;

				//Index erniedrigen
				j--;
			}
		}

		//Hllennummerierung
		a->hulleIndex = i;
	}
}


void SSLRParser::LRTab( void )
{
	//LR-Tabelle erzeugen
	PROD2_STR	*p2;
	HULLE_STR	*h;
	PROD_STR	*p1;
	Terminal	*la;
	LR_STR		*lr;
	char		*name;
	long		elem;
	int			i, j, type, lrTabIndex;

	//Meldugn ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Generate LR-Table..." << endl;

	//Speicher fr die LR-Tabelle
	lrTab = new( LR_TAB *[hulle_anz] );

	//Speicher fr die Sprung-Tabelle
	jumpTab = new( int *[hulle_anz] );

	//Fr jeden Zustand die Spalten anfordern
	for( i = 0; i < hulle_anz; i++ )
	{
		//Speicher fr Spalte
		lrTab[i] = new( LR_TAB[termArrCount + 1] );

		//Speicher fr Spalte
		jumpTab[i] = new( int[ntermArrCount] );

		//Initialisieren
		memset( lrTab[i], 0, sizeof( LR_TAB ) * termArrCount );
		memset( jumpTab[i], 0, sizeof( int ) * ntermArrCount );
	}


	//Alle Hllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hlle
		h = hulle_str[i];

		//Alle LR(0)/LR(1)-Elemente der Hlle
		for( j = 0; j < h->anzElem; j++ )
		{
			//Zeiger auf das LR(0)/LR(1)-Item
			lr = &h->lr_str[j];

			//Zeiger auf die Alternative
			p2 = &prod2_str[lr->prod2_index];

			//Zeiger auf die Alternative
			p1 = &prod_str[p2->prod_index];

			//ist es ein Element der Art .expr?
			if( lr->dot < p2->riAnz )
			{
				//Element nach Punkt, hier z.B. expr
				elem = p2->right[lr->dot];

				//Index des Elements in der LR-Tabelle
				lrTabIndex = hash_tab->getLRTabIndex( elem );

				//Typ holen
				type = hash_tab->getType( elem );

				//Name holen
				name = hash_tab->getName( elem );

				//Nichtterminal vor Punkt?
				if( type == SSLR_NTERM )
				{
					//ja, Eintrag in Sprung-Hlle
					jumpTab[i][lrTabIndex] = lr->jumpTo;

					//Meldung?
					if( argv_str->verbose == 2 )
						//ja
						cout << "sslr: LRTab: jump[" << i << "][" << name << "] = " << lr->jumpTo << "..." << endl;
				}

				else if( elem == epsHashIndex )
				{
					//Spezial-Fall, reduzieren

					//SLR-Parser?
					if( argv_str->type == SSLR_SLR )
						//Follow-Menge
						la = hash_tab->getFollow( p1->hash_index );

					else
						//bei LALR und LR sind es die Lookaheads
						la = lr->la;

					//reduzieren eintragen
					setReduce( i, lr->prod2_index, la );
				}

				else
					//Terminal schieben
					setShift( i, elem, lr->jumpTo );

			}

			else
			{
				//Reduce-Zustand

				//SLR-Parser?
				if( argv_str->type == SSLR_SLR )
					//Follow-Menge
					la = hash_tab->getFollow( p1->hash_index );

				else
					//bei LALR und LR sind es die Lookaheads
					la = lr->la;

				//Reduzieren eintragen
				setReduce( i, lr->prod2_index, la );
			}
		}
	}

	//ltTab[1][ACCEPT] = Akzeptiere
	lrTab[1][termArrCount].state = SSLR_ACCEPT;

	//Shift-Reduce-Fehler aufgetreten?
	if( srError )
		//Meldung
		cerr << "sslr: " << srError << " shift-reduce error(s) occured!" << endl;

	//Reduce-Reduce-Fehler aufgetreten?
	if( rrError )
		//Meldung
		cerr << "sslr: " << rrError << " reduce-reduce error(s) occured!" << endl;
}


void SSLRParser::setReduce( int hInd, long prod2_index, Terminal *la )
{
	//Einen Reduce-Eintrag erzeugen und dabei Reduce-Reduce- und Shift-Reduce-Fehler behandeln.
	PROD2_STR	*p2, *p3, *p4;
	PROD_STR	*p1;
	long		elem;
	char		*name;
	int			i, laAnz, lrTabIndex;
	int			tAssoc, pPriority, tPriority, state;

	//hier mit der Produktion prod2_index reduzieren
//	h = hulle_str[hInd];

	//Zeiger auf die Alternative
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die Alternative
	p1 = &prod_str[p2->prod_index];

	//Anzahl der Lookaheads
	laAnz = la->getAnzElem();

	//fr jedes Lookahead
	for( i = 0; i < laAnz; i++ )
	{
		//nchstes Lookahead holen
		elem = (*la)[i];

		//Namen
		name = hash_tab->getName( elem );

		//Spalten-Index in LR-Tabelle holen
		lrTabIndex = hash_tab->getLRTabIndex( elem );

		//ist dieser Eintrag in der Hash-Tabelle schon belegt?
		if( lrTab[hInd][lrTabIndex].state == SSLR_REDUCE )
		{
			//Reduce-Reduce-Konflikt

			//Zeiger auf die PROD2_STR
			p3 = &prod2_str[lrTab[hInd][lrTabIndex].value];
			p4 = &prod2_str[prod2_index];

			//ist ein "echter" Reduce-Reduce-Konflikt
			if( argv_str->verbose == 1 )
			{
				//Meldung ausgeben
				cout << "sslr: Reduce-Reduce conflict in closure " << hInd << " between" << endl;

				//eingetragene Produktion ausgeben
				outputAlt( cout, lrTab[hInd][lrTabIndex].value );

				cout << "and" << endl;

				//eingetragene Produktion ausgeben
				outputAlt( cout, prod2_index );

				//neue Zeile
				cout << endl;
			}

			//Fehler
			rrError++;
		}

		else if( lrTab[hInd][lrTabIndex].state == SSLR_SHIFT )
		{
			//Shift-Reduce-Fehler

			//Fehler ausgeben?
			if( argv_str->verbose == 1 )
			{
				//Meldung ausgeben
				cout << "sslr: Shift-Reduce conflict in closure " << hInd << " between reducing" << endl;

				//Alternative ausgeben, mit der reduziert werden soll
				outputAlt( cout, prod2_index ),

				//Schieben mit Terminal
				name = hash_tab->getName( lrTab[hInd][lrTabIndex].termHashIndex );
				cout << "and shifting " << name << "!" << endl << endl;
			}

			//Prioritt des geschobenen Terminals
			tPriority = hash_tab->getPriority( lrTab[hInd][lrTabIndex].termHashIndex );

			//Prioritt der Produktion holen
			pPriority = p2->priority;

			//Assoziation des Terminals holen
			tAssoc = hash_tab->getAssociation( lrTab[hInd][lrTabIndex].termHashIndex );

			//wurde die Prioritt berhaupt angegeben?
			if( ( tPriority > 0 ) && ( pPriority > 0 ) )
			{
				//ja, Prioritt der Produktion > Prioritt des Terminals?
				if( pPriority > tPriority )
					//ja, reduzieren
					state = SSLR_REDUCE;

				else if( ( tPriority == pPriority ) && ( tAssoc == isLeftAssoc ) )
					//beide Prioritten gleich, zu schiebendes Terminal ist links-assoziativ
					state = SSLR_REDUCE;

				//nicht-assoziatives Terminal?
				else if( ( tPriority == pPriority ) && ( tAssoc == isNonAssoc ) )
				{
					//Ja, Fehlereintrag
					lrTab[hInd][lrTabIndex].state = 0;
					lrTab[hInd][lrTabIndex].value = 0;

					//ausgeben
					state = SSLR_ERROR;
				}

				else
					//nichts von alledem
					state = SSLR_SHIFT;
			}

			else
				//schieben
				state = SSLR_SHIFT;

			//schieben oder reduzieren?
			if( state == SSLR_REDUCE )
			{
				//reduzieren
				lrTab[hInd][lrTabIndex].state = SSLR_REDUCE;
				lrTab[hInd][lrTabIndex].value = prod2_index;

				//Meldung?
				if( argv_str->verbose == 1 )
					//ausgeben
					cout << "reduce..." << endl;

				//merken, dass reduziert wird
				prod2_str[prod2_index].reduce--;

				//Meldung ausgeben?
				if( argv_str->verbose == 2 )
				{
					//ja
//					cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce " << hash_tab->getName( p1->hash_index ) << "..." << endl;
					cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce with ";

					//rechte Seite ausgeben
					outputAlt( cout, prod2_index );
				}
			}

			else if( ( state == SSLR_SHIFT ) && ( argv_str->verbose == 1 ) )
				//geschobenen beibehalten
				cout << "shift..." << endl << endl;

			else if( ( state == SSLR_ERROR ) && ( argv_str->verbose == 1 ) )
				//Terminal ist nicht-assoziativ
				cout << "Terminal is non-associative!" << endl;

			//Fehler
			srError++;
		}

		else
		{
			//kein Fehler aufgetreten
			lrTab[hInd][lrTabIndex].state = SSLR_REDUCE;
			lrTab[hInd][lrTabIndex].value = prod2_index;

			//merken, dass reduziert wird
			prod2_str[prod2_index].reduce++;

			//Meldung ausgeben?
			if( argv_str->verbose == 2 )
			{
				//ja
//				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce " << hash_tab->getName( p1->hash_index ) << "..." << endl;
				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce with ";

				//rechte Seite ausgeben
				outputAlt( cout, prod2_index );
			}
		}
	}
}


void SSLRParser::setShift( int hInd, long termHashIndex, int jumpTo )
{
	//Einen Shift-Eintrag erzeugen und dabei Shift-Reduce-Fehler behandeln.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	long		prod2_index;
	char		*name;
	int			lrTabIndex;
	int			tAssoc, pPriority, tPriority, state;

	//Spalten-Index in LR-Tabelle holen
	lrTabIndex = hash_tab->getLRTabIndex( termHashIndex );

	//Name holen
	name = hash_tab->getName( termHashIndex );

	//Ist dieser Eintrag in der Hash-Tabelle schon belegt?
	if( lrTab[hInd][lrTabIndex].state == SSLR_REDUCE )
	{
		//Shift-Reduce-Fehler

		//Index der Alternative in PROD2_STR
		prod2_index = lrTab[hInd][lrTabIndex].value;

		//Zeiger auf die Alternative
		p2 = &prod2_str[prod2_index];

		//Zeiger auf die Alternative
		p1 = &prod_str[p2->prod_index];

		//Fehler ausgeben?
		if( argv_str->verbose == 1 )
		{
			//Meldung ausgeben
			cout << "sslr: Shift-Reduce conflict in closure " << hInd << " between reducing" << endl;

			//Alternative ausgeben, mit der reduziert werden soll
			outputAlt( cout, prod2_index ),

			//Schieben mit Terminal
			cout << "and shifting " << name << "!" << endl;
		}

		//Prioritt des geschobenen Terminals
		tPriority = hash_tab->getPriority( termHashIndex );

		//Prioritt der Produktion holen
		pPriority = p2->priority;

		//Assoziation des Terminals holen
		tAssoc = hash_tab->getAssociation( termHashIndex );

		//wurde die Prioritt berhaupt angegeben?
		if( ( tPriority > 0 ) && ( pPriority > 0 ) )
		{
			//ja, Prioritt der Produktion > Prioritt des Terminals?
			if( pPriority > tPriority )
				//ja, reduzieren
				state = SSLR_REDUCE;

			else if( ( tPriority == pPriority ) && ( tAssoc == isLeftAssoc ) )
				//beide Prioritten gleich, Terminal ist links-assoziativ
				state = SSLR_REDUCE;

			//nicht-assoziatives Terminal?
			else if( ( tPriority == pPriority ) && ( tAssoc == isNonAssoc ) )
			{
				//ja, Fehlereintrag
				lrTab[hInd][lrTabIndex].state = 0;
				lrTab[hInd][lrTabIndex].value = 0;

				//ausgeben
				state = SSLR_ERROR;
			}

			else
				//nichts von alledem
				state = SSLR_SHIFT;
		}

		else
			//Schieben
			state = SSLR_SHIFT;

		//schieben oder reduzieren?
		if( state == SSLR_SHIFT )
		{
			//schieben
			lrTab[hInd][lrTabIndex].state = SSLR_SHIFT;
			lrTab[hInd][lrTabIndex].value = jumpTo;
			lrTab[hInd][lrTabIndex].termHashIndex = termHashIndex;

			//merken, dass nicht reduziert, sondern geschoben wird
			prod2_str[prod2_index].reduce--;

			//Meldung?
			if( argv_str->verbose == 1 )
				//ausgeben
				cout << "shift..." << endl << endl;

			//Meldung ausgeben?
			if( argv_str->verbose == 2 )
				//ja
				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = shift " << jumpTo << "..." << endl;
		}

		else if( ( state == SSLR_REDUCE ) && ( argv_str->verbose == 1 ) )
			//Reduktion mit Alternative beibehalten
			cout << "reduce..." << endl << endl;

		else if( ( state == SSLR_ERROR ) && ( argv_str->verbose == 1 ) )
			//Terminal ist nicht-assoziativ
			cout << "Terminal is non-associative!" << endl;

		//Fehler
		srError++;
	}

	else
	{
		//kein Fehler aufgetreten
		lrTab[hInd][lrTabIndex].state = SSLR_SHIFT;
		lrTab[hInd][lrTabIndex].value = jumpTo;
		lrTab[hInd][lrTabIndex].termHashIndex = termHashIndex;

		//Meldung ausgeben?
		if( argv_str->verbose == 2 )
			//ja
			cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = shift " << jumpTo << "..." << endl;
	}
}


void SSLRParser::processErrorStr( void )
{
	/*
		Innerhalb der Grammatik kann man mittels %error Fehleranweisungen
		in den erzeugten Parser einbauen.
		Ein LR-Parser kann aber ntige Reduktionen verweigern, wenn das
		darauffolgend zu schiebende Terminal nich als Lookahead vorliegt.
		Also werden hier die Zustnde gefunden, die vor dem Item mit der
		Fehleranweisung stehen und die reduzieren.
	*/

	//falls noch gar keine Hllen erzeugt wurden
	assert( hulle_anz );

	//gibt es berhaupt Fehlerangaben?
	if( error_anz )
	{
		HulleErrorIndexStr	*hInd;
		LRReduceErrorItem	*lrItemArr;
		unsigned long		i, j, k, lrItemArrCnt = 0, anzLRItem = 0;
		unsigned long		*lrStack;
		ERRTERM_STR			*errTermStr;
		PROD2_STR			*p2;
		HULLE_STR			*hStr = 0L;
		ERROR_STR			*errorStr;
		PROD_STR			*p1;
		int					*lrMarked, lrStackSp, *errTermArr;
		int					termIndex;


		//Anzahl aller mglichen LR-Items bestimmen
		for( i = 0; i < hulle_anz; i++ )
			//Anzahl der LR-Items dieser Hlle addieren
			anzLRItem += hulle_str[i]->anzElem;

		//einen Stack einrichten
		lrStack = new( unsigned long[prod2_anz] );

		//zum Markieren von Nichtterminalen
		lrMarked = new( int[prod2_anz] );

		/*
			Fr jede Fehleranweisung der Art
			prod1 -> prod2 .prod3 ...
			werden ja die reduzierenden LR-Items gesucht, bei denen
			LA >= FIRST(prod3) ist.

 			Wenn
			prod1 -> prod2 prod3.
			dann gilt LA >= FOLLOW(prod1).

 			Ist hingegen
			prod1 -> .prod2 prod3, dann suche zuerst die LR-Items, bei denen
			gilt
			prodX -> prodY .prod1
		*/
		lrItemArr = new( LRReduceErrorItem[anzLRItem] );


		/*
			Jede Fehleranweisung der Art
			prod1 -> prod2 .prod3
			steht in einer ERROR_STR.
		*/
		for( j = 0; j < error_anz; j++ )
		{
			//Zeiger auf ERROR_STR holen
			errorStr = &error_str[j];

			/*
				Fr jede ERROR_STR die Zustnde eintragen, fr die die
				Fehlermeldung auch ausgegeben werden soll. Dies entspricht
				den case-Anweisungen in der SSLR_error-Routine des erzeugten
				Parser-Files sslrparser.cpp.
			*/
			hInd = &errorStr->hInd;
			hInd->arr = new( unsigned long[hulle_anz] );
			hInd->anzArr = 0;


			//Zeiger auf die Produktion des Fehler-LR-Items
			p1 = &prod_str[errorStr->prod_index];

			//Zeiger auf die Alternative des Fehler-LR-Items
			p2 = &prod2_str[errorStr->prod2_index];

//Fehler-LR-Item ausgeben
//outputItem( errorStr->prod2_index, errorStr->dot );


			/*
				Sei das Fehler-LR-Item von der Form
				prod1 -> ... prod2 .prod3
				Wenn nun prod2 ein Terminal ist, dann berspringen.
			*/
			if( !( errorStr->dot && ( hash_tab->getType( p2->right[errorStr->dot - 1] ) == SSLR_TERM ) ) )
			{
				Terminal 		*t;
				unsigned long	prod2_index;
				/*
					PROBLEM:

					union
						:	startUnion 'BOPEN' unionBody 'BCLOSE'
							|	'EPSILON'
							;

					startUnion
						:	'UNION'
							%error
							{
								1:OVERREAD(BCLOSE):		"Missing { in %union!"
							}
							;

					unionBody
						:	unionBody unionBody2
						|	unionBody2
						;

					unionBody2
						:	'IDENT' 'IDENT' 'SEMIKOLON'
						|	'IDENT' 'AST' 'IDENT' 'SEMIKOLON'
						;

					Wenn der Parser im Zustand
					startUnion : 'UNION'., BOPEN
					ist, dann reduziert er nur, wenn LA=BOPEN ist, d.h. der
					Fehler fr die Fehleranweisung muss schon in diesem
					Zustand ausgegeben werden.
				*/

				//eine neue Terminal-Struktur fr die FIRST-Elemente
				t = new Terminal( epsHashIndex );

				/*
					Wenn das Fehler-Item der Art
					prod1 -> ... prod2 .prod3 ...
					ist, dann muss die LA-Menge der reduzierenden Items
					FIRST(prod3) enthalten.
				*/
				if( errorStr->dot == p2->riAnz )
					//FOLLOW-Menge der Produktion
					t->add( hash_tab->getFollow( p1->hash_index ) );

				else
				{
					//FIRST-Menge des Elements for dem Punkt
					int	i;

					//alle Elemente auf der rechten Seite, ab errorStr->dot
					for( i = errorStr->dot; i < p2->riAnz; i++ )
					{
						//FIRST-Menge hinzufgen
						t->add( hash_tab->getFirst( p2->right[i] ) );

						//ist EPSILON enthalten?
						if( t->isEpsilon() && ( ( i + 1 ) < p2->riAnz ) )
							//ja, lschen und weiter
							t->del( epsHashIndex );

						else
							//Schleife beenden
							break;
					}

					//ist EPSILON enthalten?
					if( t->isEpsilon() )
					{
						//ja, die FOLLOW-Menge der Produktion hinzunehmen
						t->add( hash_tab->getFollow( p1->hash_index ) );

						//EPSILON lschen
						t->del( epsHashIndex );
					}
				}


				/*
					Nun alle Hllen nach Reduce-LR-Items durchsuchen,
					die fr LA >= t ist.
				*/
				for( i = 0; i < hulle_anz; i++ )
				{
					//in der Hlle i nach Reduce-LR-Items suchen
					if( findReduceItem( i, prod2_index, t ) == true )
					{
						//Reduce-LR-Item eintragen
						lrItemArr[lrItemArrCnt].prod_index = prod2_str[prod2_index].prod_index;
						lrItemArr[lrItemArrCnt].prod2_index = prod2_index;
						lrItemArr[lrItemArrCnt++].hulleIndex = i;
					}
				}

				/*
					Nun stehen in lrItemArr die Hllen-Indices, in denen
					LR-Items gefunden wurden, die reduzieren, wenn die
					Terminal-Menge t in deren Lookahead-Mange steht.
					Damit sollen die LR-Items gefunden werden, die vor
					dem Punkt in der Fehlerangabe stehen drfen.
					Dies heisst aber noch nicht, dass alle LR-Items in
					lrItemArr auch erlaubte Zustnde reprsentieren.
					Dies wird nun herausgefunden.
				*/

				//eine neue Hllen-Struktur erzeugen
				hStr = createHulle();

				//ist der Punkt des Fehler-LR-Items an erster Stelle?
				if( !errorStr->dot && lrItemArrCnt )
				{
					unsigned long	hash_index;
					PROD2_STR		*p2;
					HULLE_STR		*h;
					PROD_STR		*p1;
					LR_STR			*lrStr;
					int				dot, i, j;

					/*
						Der Punkt des Fehler-LR-Items steht an erster Stelle,
						also es ist von der Art
						prod1 -> .prod2 prod3...
						Wir mssen also nun in ALLEN Hllen nach LR-Items
						suche, die prod1 auf der rechten Seite haben, also
						prodX -> prodY prod1, denn fr prod1 in prodX knnen
						wir ja prod1 einsetzen, also
						prodX -> prodY .prod2 prod3 ...
						Dann mssen wir somit
						prodX -> .prodY prod1
						in die Hlle eintragen um zu sehen, welche LR-Items
						vor prod1 stehen drfen.

					*/

					//Stack-Pointer zurcksetzen
					lrStackSp = 0;

					//Array mit den Markierungen initialisieren
					memset( lrMarked, 0, sizeof( int ) * prod2_anz );

					//als erstes wird das Fehler-LR-Item auf den Stack gepushed
					lrStack[lrStackSp++] = errorStr->prod_index;

					//solange Eintrge auf den Stack sind
					while( lrStackSp )
					{
						//Zeiger auf Stack-Struktur
						unsigned long prodIndex = lrStack[--lrStackSp];

						//bereits markiert?
						if( !lrMarked[prodIndex] )
						{
							//Nicht-Terminal markieren
							lrMarked[prodIndex]++;

							//Hash-Index des Nicht-Terminals
							hash_index = prod_str[prodIndex].hash_index;

//char *name = hash_tab->getName( hash_index );
//cout << "\nSuche nach Nicht-Terminal " << name << endl;

							//alle Hllen absuchen
							for( i = 0; i < hulle_anz; i++ )
							{
								//Zeiger auf die Hlle
								h = hulle_str[i];

								//alle Items absuchen
								for( j = 0; j < h->anzElem; j++ )
								{
									//Zeiger auf das LR-Item
									lrStr = &h->lr_str[j];

									//das Nicht-Terminal suchen
									dot = findNTERMRightSide( h, j, hash_index );

									//dieses LR-Item interessiert nur, wenn dot != -1
									if( dot != -1 )
									{
										//Zeiger auf die Alternative des Fehler-LR-Items
										p2 = &prod2_str[lrStr->prod2_index];

										//Zeiger auf die Produktion des Fehler-LR-Items
										p1 = &prod_str[p2->prod_index];

//Fehler-LR-Item ausgeben
//outputItem( lrStr->prod2_index, dot );

										//steht der Punkt auch hier am Anfang?
										if( !dot )
											/*
												ja, Nicht-Terminal der Produktion
												auf den Stack pushen
											*/
											lrStack[lrStackSp++] = p2->prod_index;

										else
										{
											/*
												Der Punkt des Fehler-LR-Items steht an erster Stelle,
												also es ist von der Art
												prod1 -> .prod2 prod3...
												Wir mssen also nun in ALLEN Hllen nach LR-Items
												suche, die prod1 auf der rechten Seite haben, also
												prodX -> prodY prod1, denn fr prod1 in prodX knnen
												wir ja prod1 einsetzen, also
												prodX -> prodY .prod2 prod3 ...

												Hier haben wir ein LR-Item der Art
												prodX -> prodY .prod1 prod3 ...
												gefunden, also
												prodX -> .prodY prod1 prod3 ...
												in die Hlle eintragen.
											*/
											insertItem( hStr, lrStr->prod2_index, dot - 1, SSLR_CORE );
										}
									}
								}
							}
						}
					}
				}

				else if( lrItemArrCnt )
				{
					//der Punkt des Fehler-LR-Items ist nicht an erster Stelle

					/*
						Fehler-LR-Item mit Punkt um eine Position nach links
						verschoben in die Hlle eintragen.
					*/
					insertItem( hStr, errorStr->prod2_index, errorStr->dot - 1, SSLR_CORE );
				}

				//die Hlle generieren
				genLR0Items( hStr );

//Hlle ausgeben
//outputHulle( hStr );


				/*
					In der Hlle hStr stehen nun alle LR-Items, die in Frage kommen.
					Nur diese LR-Items von lrItemArr in hInd->arr eintragen, die
					in der Hlle enthalten sind.
				*/
				for( i = 0; i < lrItemArrCnt; i++ )
				{
					//dieses LR-Item in hStr suchen
					if( findItem( hStr, lrItemArr[i].prod2_index ) != -1 )
						//den Index in der Hlle von lrItemArr in hInd eintragen
						hInd->arr[hInd->anzArr++] = lrItemArr[i].hulleIndex;
				}

				//fr nchste ERROR_STR zurcksetzen
				lrItemArrCnt = 0;

				//Terminale freigeben
				delete( t );
			}

			/*
				Nun in allen Hllen nach dem Fehler-LR-Item suchen, denn
				fr diese Zustnde muss die Fehlermeldung ja auch ausgegeben
				werden.
			*/
			//Anzahl aller mglichen LR-Items bestimmen
			for( i = 0; i < hulle_anz; i++ )
			{
				//ist das Fehler-Item in der Hlle i enthalten?
				if( findItem( hulle_str[i], errorStr->prod2_index, errorStr->dot ) != -1 )
				{
					//ja, nun prfen, ob es schon in errorStr->hInd enthalten ist
//cout << "SSLRParser::processErrorStr: Fehler-LR-Item ist in Hlle " << i << " enthalten!" << endl;

					//alle Eintrge in errorStr->hInd prfen
					for( k = 0; k < hInd->anzArr; k++ )
					{
						//Hllen-Indices gleich?
						if( hInd->arr[k] == i )
							//ja, abbrechen
							break;
					}

					//war es schon enthalten?
					if( k == hInd->anzArr )
						//nein, eintragen
						hInd->arr[hInd->anzArr++] = i;
				}
			}

			//Meldung ausgeben?
			if( argv_str->verbose )
			{
				//ja, informieren
				cout << "sslr: SSLRParser::processErrorStr: Error action in line " << errorStr->line << " is active in ";

				//gibt es nur einen Zustand, in dem die Fehleranweisung aktiv ist?
				if( hInd->anzArr == 1 )
					//ja, ausgeben
					cout << "state " << hInd->arr[0] << "!" << endl;

				else
				{
					int	i;

					//abschliessen
					cout << "states ";

					//alle Zustnde ausgeben
					for( i = 0; i < hInd->anzArr; i++ )
					{
						//Zustand ausgeben
						cout << hInd->arr[i];

						//folgt ein weiterer?
						if( ( i + 1 ) < hInd->anzArr )
							//ja
							cout << ",";
					}

					//abschliessen
					cout << "!" << endl;
				}
			}

			//Hlle freigeben?
			if( hStr )
			{
				//Hlle freigeben
				deleteHulle( hStr );

				//initialisieren
				hStr = 0L;
			}
		}

		//Speicher freigeben
		delete[] ( lrItemArr );
		delete[] ( lrMarked );
		delete[] ( lrStack );




		/*
			An dieser Stelle sind alle Fehleranweisungen komplett eingetragen.
			Die Terminale, die zu einer Fehleranweisung der Art
			1:ADD,SUB:	""
			eingetragen wurden, befinden sich in der ERRTERM_STR der Struktur
			ERROR_STR, denn zur Zeit des Scannens der Grammatik ist die
			Gesamtzahl der Terminale noch nicht bekannt, jetzt aber.
		*/
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR holen
			errorStr = &error_str[i];

			/*
				Die Terminale, fr die die Fehleraktion gelten soll,
				werden nun linear in ein Array eingetragen. Der Index
				ist der in termArr, die Lnge betrgt termArrCount
				Eintrge.
			*/
			errTermArr = new( int[termArrCount] );

			//vorab initialisieren
			memset( errTermArr, 0, sizeof( int ) * termArrCount );

			//alle Terminal-Anweisungen
			for( j = 0; j < errorStr->errTermStrAnz; j++ )
			{
				//Zeiger auf die ERRTERM_STR holen
				errTermStr = &errorStr->errTermStr[j];

				//die erste ERRTERM_STR?
				if( !j && errTermStr->neg )
				{
					/*
						errTermArr muss initialisiert werden.
						Dabei wird es mit 1 initialisiert, wenn die
						Terminal-Angaben negiert sind, sonst
						mit 0.
					*/
					for( int i = 0; i < termArrCount; i++ )
						//auf 1 setzen
						errTermArr[i] = 1;
				}

				//den Index des Terminals in termArr holen
				termIndex = getTermArrIndex( errTermStr->terminal );

				//gefunden?
				if( termIndex != -1 )
				{
					//Fehler, das Terminal wurde nicht gefunden
					char *name = hash_tab->getName( errTermStr->terminal );

					//negieren?
					if( errTermStr->neg )
						//ja, auf Null setzen
						errTermArr[termIndex] = 0;

					else
						//nicht negieren, auf 1 setzen
						errTermArr[termIndex] = 1;
				}

				else
				{
					//Fehler, das Terminal wurde nicht gefunden
					char *name = hash_tab->getName( errTermStr->terminal );

					//Fehlermeldung
					cerr << "sslr: SSLRParser::processErrorStr: ERROR: Terminal " << name << " not found in termArr!" << endl;
				}
			}

			//errTermArr in die ERROR_STR eintragen
			errorStr->errTermArr = errTermArr;
		}
	}
}


int SSLRParser::getTermArrIndex( unsigned long hash_index )
{
	//liefere den Index des Terminals in termArr zurck
	int	i;

	//prfen, ob termArrCount schon angelegt ist
	assert( termArr );

	//alle Eintrge in termArr
	for( i = 0; i < termArrCount; i++ )
	{
		//Hash-Indices gleich?
		if( termArr[i] == hash_index )
			//ja, Index zurckliefern
			return( i );
	}

	//Terminal nicht gefunden!
	return( -1 );
}


int SSLRParser::findNTERMRightSide( HULLE_STR *hStr, int item, unsigned long hash_index )
{
	/*
		Hier wird geprft, ob auf der rechten Seite des LR-Item item
		der Hlle hStr das Nicht-Terminal hash_index auftaucht.
	*/
	PROD2_STR	*p2;
	LR_STR		*lrStr = &hStr->lr_str[item];
	int			i;

	//Zeiger auf die Alternative des LR-Items
	p2 = &prod2_str[lrStr->prod2_index];

	//alle Eintrge auf der rechten Seite des LR-Items prfen
	for( i = 0; i < p2->riAnz; i++ )
	{
		//ist es das gesuchte Nicht-Terminal?
		if( p2->right[i] == hash_index )
			//ja, Position des Punktes wiedergeben
			return( i );
	}

	/*
		Nein, Nicht-Terminal hash_index nicht auf rechter Seite des
		LR-Items gefunden.
	*/
	return( -1 );
}


bool SSLRParser::findReduceItem( unsigned long hulleIndex, unsigned long &prod2_index, Terminal *t )
{
	/*
		Hier wird in der Hlle hulleIndex nach einem LR-Item gesucht,
		das reduziert, wobei seine LA-Symbole mind. t umfassen mssen.
	*/
	unsigned int	i;
	HULLE_STR		*hStr = hulle_str[hulleIndex];
	PROD2_STR		*p2;
	LR_STR			*lr;
	Terminal		*la;

	/*
		Hier mssen wir tatschlich ALLE LR-Elemente der Hlle untersuchen,
		denn die der Art
		prod -> .'EPSILON'
		sind ja auch reduzierende LR-Items, sie sind aber nicht unbedingt
		im Kern der Hlle!
	*/
	for( i = 0; i < hStr->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &hStr->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//gleich?
		if( ( ( lr->dot == 0 ) && ( p2->right[0] == epsHashIndex ) ) || ( lr->dot == p2->riAnz ) )
		{
			//es ist ein Reduce-LR-Item, nun die Lookahead-Menge prfen

			/*
				Bei einem SLR-Parser ist die Lookahead-Menge die FOLLOW-Menge
				der Produktion.
			*/
			if( argv_str->type == SSLR_SLR )
				//Zeiger auf die Follow-Menge der Produktion
				la = hash_tab->getFollow( prod_str[p2->prod_index].hash_index );

			else
				//bei LALR und LR sind es die Lookaheads
				la = lr->la;

			//ist die Menge t in la enthalten?
			if( la->bgt( t ) == true )
			{
//den Namen der Produktion ausgeben
//char *name = hash_tab->getName( prod_str[p2->prod_index].hash_index );
//cout << "Nehme FOLLOW(" << name << ") als Lookahead-Menge..." << endl;

//LR-Item ausgeben
//outputItem( lr->prod2_index, lr->dot );

				//die Alternative (prod2_index) zurckliefern
				prod2_index = lr->prod2_index;

				//die Terminale t sind in la enthalten
				return( true );
			}
		}
	}

	//nein, kein passendes LR-Item gefunden
	return( false );
}


void SSLRParser::generateFiles( void )
{
	//hier werden die Source-Files des Parsers erzeugt
	ofstream	cppFile( "sslrparser.cpp" );
	ofstream	hFile( "sslrparser.h" );
	ofstream	termDefHFile( "sslrtermdef.h" );
	char		puf[256];

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Generate parser file..." << endl;

	/*
		Die lngste rechte Seite bestimmen.
		Diese Information wird in das Header-File bernommen, falls die
		Debug-Version des Parsers erzeugt werden soll. Mit Hilfe dieser
		Information kann eine formatierte Ausgabe der rechten Seiten
		erfolgen.
	*/
	maxAltRightSideWidth = 0;

	//lngstes Terminal/Nichtterminal
	maxElemWidth = 0;

	/*
		Die Breite des lngesten Zustands bestimmen. Dazu in einen
		Pufferschreiben.
	*/
	sprintf( puf, "%ld", hulle_anz );

	//Breite des grtes Zustands
	maxStateWidth = strlen( puf ) + 2;







	/*
		Der Scanner liefert ja Tokens zum Parser zurck, die im Prinzip
		fr die Auswahl der nchsten Aktion (schieben/reduzieren) bentigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	outputTermDefHFile( termDefHFile );

	//den Header des cpp-Files ausgeben
	outputCPPHeader( cppFile );

	//Terminal-Defines als enum ausgeben
	outputCPPTerminal( cppFile );

	//etwaige Include-Anweisungen einfgen
	outputIncl( cppFile );

	//LR-Tabelle ausgeben
	outputLRTab( cppFile );

	//Sprung-Tabelle ausgeben
	outputJumpTab( cppFile );

	//die Follow-Sets ausgeben
	outputFollow( cppFile );

	//die rechten Seiten ausgeben
	outputAlternatives( cppFile );

	//alle NTERM_STR ausgeben
	outputNtermStr( cppFile );

	//Debug-Mode?
	if( argv_str->debug == true )
		//ja
		outputTermName( cppFile );

	//Fehlerbehandlung ausgeben
	outputErrorRecovery( cppFile );

	//alle brigen Routinen ausgeben
	outputCPPEnd( cppFile );

	//semantische Aktionen ausgeben
	outputSemAct( cppFile );

	//etwaige eigene Erweiterungen einfgen
	outputExt( cppFile );






	//Mindestbreite festlegen
	maxAltRightSideWidth = ( ( maxAltRightSideWidth + 18 ) < 21 ) ? 21 : ( maxAltRightSideWidth + 18 );
	maxElemWidth = ( ( maxElemWidth + 2 ) < 7 ) ? 7 : ( maxElemWidth + 2 );
	maxStateWidth = ( ( maxStateWidth + 2 ) < 8 ) ? 8 : ( maxStateWidth + 2 );

	//das Header-File generieren
	outputHFile( hFile );
}


void SSLRParser::outputCPPHeader( ofstream &file )
{
	//Den Header des cpp-Files ausgeben

	//Header des cpp-Files
file << "/***************************************************************************\n";
file << "                          sslrparser.cpp  -  description\n";
file << "                             -------------------\n";
file << "    copyright            : (C) 2002 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#include \"sslrparser.h\"\n";
file << "#include <iostream>\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug version *\n";
		file << "****************************/\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug version *\n";
		file << "********************************/\n\n\n";
	}
}


void SSLRParser::outputCPPEnd( ofstream &file )
{
	//alle brigen Routinen des cpp-Files ausgeben

file << "\n";
file << "\n";
file << "SSLRParser::SSLRParser( SSLEXScanner *scan )\n";
file << "{\n";
file << "	//call reset to initialize the parser\n";
file << "	reset();\n";
file << "\n";
file << "	//scanner class\n";
file << "	SSLR_scanner = scan;\n";
file << "\n";
file << "#ifdef SSLR_INIT\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "SSLRParser::~SSLRParser()\n";
file << "{\n";
file << "#ifdef SSLR_INIT\n";
file << "	//uninizialize user defined variables\n";
file << "	deinit();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::reset( void )\n";
file << "{\n";
file << "	//resets the whole parser\n";
file << "\n";
file << "#ifdef SSLR_DEBUG\n";
file << "	//output\n";
file << "	cout << setw( SSLR_maxStateWidth ) << \" state |\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \" stack |\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \" action |\" << setw( SSLR_maxElemWidth ) << \" next |\" << endl;\n";
file << "\n";
file << "	//separator\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << \"|\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//initialize\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' ) << \" 0 |\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//set debug stack pointer\n";
file << "	SSLR_dbgSp = 0;\n";
file << "#endif\n";
file << "\n";
file << "	//parse stack pointer\n";
file << "	SSLR_sp = 0;\n";
file << "\n";
file << "	//start with state 0\n";
file << "	SSLR_push( 0 );\n";
file << "	SSLR_state = 0;\n";
file << "\n";
file << "	//no errors yet\n";
file << "	SSLR_anzError = 0;\n";
file << "	SSLR_anzSuppressError = 0;\n";
file << "\n";


	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja
		file << "	//semantic actions\n";
		file << "	SSLR_semAct = true;\n";
		file << "\n";
		file << "	//stack counter for semantic action stack\n";
		file << "	SSLR_semStackCnt = 0;\n";
	}

file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::SSLR_getTerminal( void )\n";
file << "{\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Attribut des Scanners auf den Stack schieben
		file << "	//semantic actions allowed?\n";
		file << "	if( SSLR_semAct == true )\n";
		file << "	{\n";
		file << "		//semantic stack overflow?\n";
		file << "		if( SSLR_semStackCnt >= SSLR_maxStackSize )\n";
		file << "		{\n";
		file << "			//yes, print an error message\n";
		file << "			cerr << \"SSLRParser::SSLR_getTerminal: Semantic stack overflow!\" << endl;\n";
		file << "\n";
		file << "			//no more semantic actions allowed\n";
		file << "			SSLR_semAct = false;\n";
		file << "		}\n";
		file << "\n";
		file << "		else\n";
		file << "			//push attribute on stack for semantic actions\n";
		file << "			SSLR_semStack[SSLR_semStackCnt++] = SSLR_attributeStr;\n";
		file << "	}\n";
		file << "\n";
	}

file << "	//get line\n";
file << "	SSLR_line = SSLR_scanner->getYYLineno();\n";
file << "\n";
file << "	//get next terminal\n";
file << "	SSLR_terminal = SSLR_scanner->yyLex( &SSLR_attributeStr );\n";
file << "\n";
file << "	//return terminal\n";
file << "	return( SSLR_terminal );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::yyParse( void )\n";
file << "{\n";
file << "	//start parsing\n";
file << "\n";
file << "	//get first terminal\n";
file << "	SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "	//start parsing\n";
file << "	return( SSLR_parse() );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_push( long ast )\n";
file << "{\n";
file << "	//push a new state on the parse stack\n";
file << "	SSLR_stack[SSLR_sp++] = ast;\n";
file << "\n";
file << "	//stack overflow?\n";
file << "	if( SSLR_sp > SSLR_maxStackSize )\n";
file << "	{\n";
file << "		//stack-overflow\n";
file << "		cerr << \"SSLRParser::SSLR_push: stack overflow!\\nExiting...\" << endl;\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//set new state\n";
file << "	SSLR_state = ast;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "long SSLRParser::SSLR_pop( int anz )\n";
file << "{\n";
file << "	//pop anz elements from the parse stack\n";
file << "	SSLR_sp -= anz;\n";
file << "\n";
file << "	//stack underflow?\n";
file << "	if( SSLR_sp < 0 )\n";
file << "	{\n";
file << "		//stack underflow\n";
file << "		cerr << \"SSLRParser::SSLR_pop: stack underflow!\\nExiting...\" << endl;\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//return new state\n";
file << "	return( SSLR_stack[SSLR_sp - 1] );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::SSLR_parse( void )\n";
file << "{\n";
file << "	//begin parsing\n";
file << "	while( 1 )\n";
file << "	{\n";
file << "		//end of parsing?\n";
file << "		if( ( SSLR_state == 1 ) && ( SSLR_terminal == ACCEPT ) )\n";
file << "			//return number of errors\n";
file << "			return( SSLR_anzError );\n";
file << "\n";
file << "		//shift terminal SSLR_terminal?\n";
file << "		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_SHIFT )\n";
file << "		{\n";
file << "			//yes\n";
file << "			SSLR_shift( &SSLR_lrTab[SSLR_state][SSLR_terminal] );\n";
file << "\n";
file << "			//get new terminal\n";
file << "			SSLR_terminal = SSLR_getTerminal();\n";
file << "		}\n";
file << "\n";
file << "		//reduce with production?\n";
file << "		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_REDUCE )\n";
file << "			//reduce\n";
file << "			SSLR_reduce( &SSLR_lrTab[SSLR_state][SSLR_terminal] );\n";
file << "\n";
file << "		//otherwise an error occured\n";
file << "		else\n";
file << "			//call error recovery\n";
file << "			SSLR_error();\n";
file << "	}\n";
file << "}\n";
	file << "\n";
	file << "\n";

	//Debug-Version
	if( argv_str->debug == true )
	{
		//ja
		file << "void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//shift a terminal onto the parse stack\n";
		file << "\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until it is zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";

		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		file << "	//debug stack overflow?\n";
		file << "	if( SSLR_dbgSp >= SSLR_maxStackSize )\n";
		file << "	{\n";
		file << "		//debug stack overflow\n";
		file << "		cerr << \"SSLRParser::SSLR_shift: Debug stack overflow!\" << endl;\n";
		file << "\n";
		file << "		//exit\n";
		file << "		exit( 1 );\n";
		file << "	}\n";
		file << "\n";
		file << "	//set debug stack\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp].elem = true;\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp++].index = SSLR_terminal;\n";
		file << "\n";
		file << "	//output\n";
		file << "	SSLR_outputDbgStack( SSLR_state, LR_SHIFT, SSLR_terminal, SSLR_terminal );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//shift a new state onto the stack\n";
		file << "	SSLR_push( tab->value );\n";

		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//reduce with production\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "\n";

		//semantische Aktionen?
		if( semActCnt )
		{
			//Ja
			file << "	//perform a semantic action accociated with the reduced production\n";
			file << "	SSLR_doSemAct( tab );\n";
			file << "\n";
		}

		file << "	//get a pointer to the alternative\n";
		file << "	n = &SSLR_ntermStr[tab->value];\n";

		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "	//pop elements from debug stack\n";
		file << "	SSLR_dbgSp -= n->elem;\n";
		file << "\n";
		file << "	//debug stack overflow?\n";
		file << "	if( SSLR_dbgSp >= SSLR_maxStackSize )\n";
		file << "	{\n";
		file << "		//debug stack overflow\n";
		file << "		cerr << \"SSLRParser::SSLR_reduce: Debug stack overflow!\" << endl;\n";
		file << "\n";
		file << "		//exit\n";
		file << "		exit( 1 );\n";
		file << "	}\n";
		file << "\n";
		file << "	//set debug stack\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp].elem = false;\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp++].index = tab->value;\n";
		file << "\n";
		file << "	//output\n";
		file << "	SSLR_outputDbgStack( SSLR_state, LR_REDUCE, tab->value, SSLR_terminal );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//remove states form stack\n";
		file << "	SSLR_state = SSLR_pop( n->elem );\n";
		file << "\n";
		file << "	//get new state\n";
		file << "	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];\n";
		file << "\n";
		file << "	//push new state on stack\n";
		file << "	SSLR_push( SSLR_state );\n";
		file << "}\n";
		file << "\n\n";


		//Routine zur Ausgabe des Debug-Stacks SSLR_dbgStack

		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

file << "void SSLRParser::SSLR_outputDbgStack( int state, int action, int index, int next )\n";
file << "{\n";
file << "	//print the debugging stack\n";
file << "	char	statePuf[SSLR_maxStateWidth + 1];\n";
file << "	char	stackPuf[SSLR_maxElemWidth + 1];\n";
file << "	char	actionPuf[SSLR_maxAltRightSideWidth + 1];\n";
file << "	char	nextPuf[SSLR_maxElemWidth + 1];\n";
file << "	int		stackIndex, i;\n";
file << "\n";
file << "	//curent state in string\n";
file << "	sprintf( statePuf, \"%d\", SSLR_state );\n";
file << "\n";
file << "	//print first element\n";
file << "	stackIndex = SSLR_dbgStack[0].index;\n";
file << "\n";
file << "	//terminal?\n";
file << "	if( SSLR_dbgStack[0].elem == true )\n";
file << "		//terminal\n";
file << "		sprintf( stackPuf, \"%s\", SSLR_termName[stackIndex] );\n";
file << "\n";
file << "	else\n";
file << "		//is nonterminal\n";
file << "		sprintf( stackPuf, \"%s\", SSLR_ntermStr[stackIndex].name );\n";
file << "\n";
file << "	//action\n";
file << "	if( action == LR_SHIFT )\n";
file << "	{\n";
file << "		//shift state\n";
file << "		sprintf( actionPuf, \"push %s\", SSLR_termName[index] );\n";
file << "\n";
file << "\n";
file << "		//next is empty\n";
file << "		sprintf( nextPuf, \"%s\", \" \" );\n";
file << "	}\n";
file << "\n";
file << "	else\n";
file << "	{\n";
file << "		SSLR_NTERM_STR	*str = &SSLR_ntermStr[index];\n";
file << "		int				i;\n";
file << "\n";
file << "		//reduce with alternative\n";
file << "		sprintf( actionPuf, \"reduce with \" );\n";
file << "\n";
file << "		//print name of alternative\n";
file << "		strcat( actionPuf, str->name );\n";
file << "		strcat( actionPuf, \" -> \" );\n";
file << "\n";
file << "		//print all elements on the right side\n";
file << "		for( i = 0; i < str->elem; i++ )\n";
file << "		{\n";
file << "			//print element\n";
file << "			strcat( actionPuf, str->ri[i] );\n";
file << "\n";
file << "			//more elements?\n";
file << "			if( i < ( str->elem - 1 ) )\n";
file << "				//yes\n";
file << "				strcat( actionPuf, \" \" );\n";
file << "		}\n";
file << "\n";
file << "		//alternatives with zero elements have EPSILON on the right side\n";
file << "		if( !str->elem )\n";
file << "			//print EPSILON\n";
file << "			strcat( actionPuf, str->ri[0] );\n";
file << "\n";
file << "		//next is the current terminal\n";
file << "		sprintf( nextPuf, \"%s\", SSLR_termName[next] );\n";
file << "	}\n";
file << "\n";
file << "	//separator\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << \"|\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//initialize\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )\n";
file << "	<< ( string( statePuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxAltRightSideWidth ) << ( string( actionPuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxElemWidth ) << ( string( nextPuf ) + \" |\" ) << endl;\n";
file << "\n";
file << "\n";
file << "\n";
file << "	//print all other debug stack entries\n";
file << "	for( i = 1; i < SSLR_dbgSp; i++ )\n";
file << "	{\n";
file << "		//print element\n";
file << "		stackIndex = SSLR_dbgStack[i].index;\n";
file << "\n";
file << "		//terminal?\n";
file << "		if( SSLR_dbgStack[i].elem == true )\n";
file << "			//terminal\n";
file << "			sprintf( stackPuf, \"%s\", SSLR_termName[stackIndex] );\n";
file << "\n";
file << "		else\n";
file << "			//is nonterminal\n";
file << "			sprintf( stackPuf, \"%s\", SSLR_ntermStr[stackIndex].name );\n";
file << "\n";
file << "		cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )\n";
file << "		<< \"|\" << setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + \" |\" )\n";
file << "		<< setw( SSLR_maxAltRightSideWidth ) << \"|\"\n";
file << "		<< setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "	}\n";
file << "}\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until it is zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";
		file << "	//shift a new state onto the stack\n";
		file << "	SSLR_push( tab->value );\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//reduce with production\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until ists zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";

		//semantische Aktionen?
		if( semActCnt )
		{
			//ja
			file << "	//perform a semantic action accociated with the reduced production\n";
			file << "	SSLR_doSemAct( tab );\n";
			file << "\n";
		}

		file << "	//get a pointer to the alternative\n";
		file << "	n = &SSLR_ntermStr[tab->value];\n";
		file << "\n";
		file << "	//remove states form stack\n";
		file << "	SSLR_state = SSLR_pop( n->elem );\n";
		file << "\n";
		file << "	//get new state\n";
		file << "	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];\n";
		file << "\n";
		file << "	//push new state on stack\n";
		file << "	SSLR_push( SSLR_state );\n";
		file << "}\n";
		file << "\n";
		file << "\n";
	}
}


void SSLRParser::outputCPPTerminal( ofstream &file )
{
	//Terminal-Defines als enum ausgeben
	char	*name;
	int		i, width;

	//Header ausgeben
	file << "//Terminals for debugging\n";
	file << "char *SSLR_scannerToken[] =\n{\n";

	for( i = 0; i < termArrCount; i++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//Define-Anweisung ausgeben
		file << "\t/*" << i << "*/ \"" << name << "\",\n";

		//Breite des Namens
		width = strlen( name );

		//lnger?
		if( width > maxElemWidth )
			//ja, merken
			maxElemWidth = width;
	}

	//Abschluss
	file << "\t0L\n};\n\n\n";
}


void SSLRParser::outputLRTab( ofstream &file )
{
	//LR-Tabelle in Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_TAB		*lrtab;
	char		puf1[256+1], puf2[256+1], *name;
	int			i, j, k, id;


	//berschrift
	file << "//syntax analyze table\n";

	//Definition der LR-Tabelle
	file << "SSLRParser::SSLR_LR_TAB SSLRParser::SSLR_lrTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzTerm] = {\n";

	//Alle Zustnde
	for( i = 0; i < hulle_anz; i++ )
	{
		//ffnen
		file << "/* State " << i << " */\n{ ";

		//Alle Terminale
		for( j = 0, k = 0; j < termArrCount; j++, k++ )
		{
			//Zeiger auf LR_TAB-Struktur
			lrtab = &lrTab[i][j];

			//Zustand ausgeben
			switch( lrtab->state )
			{
				//Fehler?
				case SSLR_ERROR:
				{
					//ja, Fehlerbehandlung
					sprintf( puf1, "%s", "LR_ERROR" );
					break;
				}

				//shift?
				case SSLR_SHIFT:
				{
					//ja, Zustand schieben
					sprintf( puf1, "%s", "LR_SHIFT" );
					break;
				}

				//reduce?
				case SSLR_REDUCE:
				{
					//ja, mit Produktion reduzieren
					sprintf( puf1, "%s", "LR_REDUCE" );

					//Produktion ausschreiben
					p2 = &prod2_str[lrtab->value];

					//Zeiger auf PROD_STR
					p1 = &prod_str[p2->prod_index];

					//Name der Produktion
					name = hash_tab->getName( p1->hash_index );

					//Nummer der Alternative
					id = lrtab->value - p1->prod2_index;

					//Namen generieren
					sprintf( puf2, "%s_%d", name, id );
					break;
				}

				//akzeptieren?
				case SSLR_ACCEPT:
				{
					//ja, akzeptieren
					sprintf( puf1, "%s", "LR_ACCEPT" );
					break;
				}

				default:
				{
					//anderer Wert
					sprintf( puf1, "%d", lrTab[i][j].state );
					break;
				}
			}

			//Werte-Paar ausgeben
			file << "{ " << puf1 << ", ";

			//reduce?
			if( lrtab->state == SSLR_REDUCE )
				//ja
				file << puf2 << " }";

			else
				//ausgeben
				file << lrtab->value << " }";

			//Kommt noch etwas?
			if( j < ( termArrCount - 1 ) )
				//Ja
				file << ",";

			//neue Zeile?
			if( k == 8 )
			{
				//Ja
				file << "\n";
				k = 0;
			}
		}

		//Nchster Zustand?
		if( i < ( hulle_anz - 1 ) )
			//Ja
			file << " },\n";

		else
			//Nein
			file << " }\n";
	}

	//abschliessen
	file << "};\n";
}


void SSLRParser::outputJumpTab( ofstream &file )
{
	//Sprung-Tabelle ausgeben
	PROD_STR	*p1;
	long		index, prod_index;
	char		*name, widthChar[128];
	int			i, j, k, width;

	//Breite des grten Zustands
	sprintf( widthChar, "%ld", hulle_anz );
	width = strlen( widthChar );

	//Definition der Sprung-Tabelle
	file << "\n\n//jump table\n";
	file << "long SSLRParser::SSLR_jumpTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzNTerm] = {\n";

	//zuerst alle Produktionen ausgeben, dient der Orientierung
	file << "//";
	for( i = 0, k = 0; i < ntermArrCount; i++, k++ )
	{
		//neue Zeile?
		if( k == 10 )
			//ja
			file << "\n//";

		//Produktion ausgeben
		file << hash_tab->getName( ntermArr[i] ) << ", ";
	}

	//neue Zeile
	file << "\n\n";

	//Alle Zustnde
	for( i = 0; i < hulle_anz; i++ )
	{
		//ffnen
		file << "/* State " << i << " */\n{ ";

		//Alle Produktionen
		for( j = 0, k = 0; j < ntermArrCount; j++, k++ )
		{
			//Name der Produktion
			name = hash_tab->getName( ntermArr[j] );

			//prod_index holen
			prod_index = hash_tab->getProdStr( ntermArr[j] );

			//Zeiger auf PROD_STR
			p1 = &prod_str[prod_index];

			//Index in Jump-Tabelle
			index = hash_tab->getLRTabIndex( p1->hash_index );

			//Wert ausgeben
			file.width( width );
			file << jumpTab[i][index];

			//Folgt noch etwas?
			if( j < ( prod_anz - 1 ) )
				//Ja
				file << ", ";

			//neue Zeile?
			if( k == 15 )
			{
				//Ja
				file << "\n";
				k = 0;
			}
		}

		//Nchster Zustand?
		if( i < ( hulle_anz - 1 ) )
			//Ja
			file << " },\n";

		else
			//Nein
			file << " }\n";
	}

	//abschliessen
	file << "};\n\n";
}


void SSLRParser::outputAlternatives( ofstream &file )
{
	//die Alternativen in die cpp-Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, puf1[256+1];
	int			i, j, id, type, rs, ns;

	//nur bei Debug-Version
	if( argv_str->debug == true )
	{
		//Header
		file << "\n//all alternatives\n";

		//alle Alternativen
		for( i = 0; i < prod2_anz; i++ )
		{
			//Lnge der rechten Seite dieser Alternative
			rs = ns = 0;

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//den Namen der Alternative holen
			name = hash_tab->getName( p1->hash_index );

			//Nummer der Alternative
			id = i - p1->prod2_index;

			//Namen generieren
			sprintf( puf1, "%s%d", name, id );

			//Lnge des Namens der Alternative
			ns = strlen( puf1 );

			//addieren zur Lnge der rechten Seite dieser Alternative
			rs += ns;

			//lnger?
			if( ns > maxElemWidth )
				//ja, merken
				maxElemWidth = ns;

			//initialisieren
			file << "char *SSLRParser::SSLR_" << puf1 << "Ri[" << p2->riAnz << "] = { ";

			//alle Elemente auf der rechten Seite ausgeben
			for( j = 0; j < p2->riAnz; j++ )
			{
				//Namen holen
				name = hash_tab->getName( p2->right[j] );

				//addieren
				rs += strlen( name );

				//Typ holen
				type = hash_tab->getType( p2->right[j] );

				//Terminal?
				if( type == SSLR_TERM )
				{
					//ja
					file << "\"\\\'" << name << "\\\'\"";

					//Terminale werden in ' ausgegeben
					rs += 2;
				}

				else
					//Nichtterminal
					file << "\"" << name << "\"";

				//folgt noch ein Eintrag?
				if( j < ( p2->riAnz - 1 ) )
				{
					//ja
					file << ", ";

					//Space zwischen zwei Elementen auf der rechten Seite
					rs++;
				}
			}

			//abschlieen
			file << " };\n";

			//rechte Seite grer?
			if( rs > maxAltRightSideWidth )
				//ja, merken
				maxAltRightSideWidth = rs;
		}
	}
}


void SSLRParser::outputNtermStr( ofstream &file )
{
	//die NTERM_STR ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, puf1[256+1];
	long		followAnz;
	int			i, id, riAnz;

	//Header
	file << "\n\n//all alternatives\n";
	file << "SSLRParser::SSLR_NTERM_STR SSLRParser::SSLR_ntermStr[SSLRParser::SSLR_anzProd] = {\n";

	//alle Alternativen
	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf PROD2_STR
		p2 = &prod2_str[i];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//den Namen der Alternative holen
		name = hash_tab->getName( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Nummer der Alternative
		id = i - p1->prod2_index;

		//Namen generieren
		sprintf( puf1, "%s%d", name, id );

		//ist es eine EPSILON-Produktion?
		if( p2->right[0] == epsHashIndex )
			//ja
			riAnz = 0;

		else
			//nein, ganz normal
			riAnz = p2->riAnz;

		//Debug-Version?
		if( argv_str->debug == true )
			//nein, entsprechende SSLR_NTERM_STR ausgeben
			file << "{ \"" << name << "\", SSLRParser::SSLR_" << puf1 << "Ri, " << name << ", " << riAnz << ", SSLRParser::SSLR_" << name << "Follow, " << followAnz << " }";

		else
			//ja, entsprechende SSLR_NTERM_STR ausgeben
			file << "{ " << name << ", " << riAnz << ", SSLRParser::SSLR_" << name << "Follow, " << followAnz << " }";

		//folgt noch ein Eintrag?
		if( i < ( prod2_anz - 1 ) )
			//ja
			file << ",\n";
	}

	//abschlieen
	file << "};\n\n";
}


void SSLRParser::outputFollow( ofstream &file )
{
	//Die Alternativen in die cpp-Datei ausgeben.
	PROD_STR	*p1;
	Terminal	*followSet;
	char		*name;
	long		followAnz, *followTerm;
	int			i, j;

	//Header
	file << "\n//follow sets for the error recovery\n";

	//Alle Produktionen
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Den Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//Zeiger auf die Follow-Elemente
		followSet = hash_tab->getFollow( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Initialisieren
		file << "long SSLRParser::SSLR_" << name << "Follow[" << followAnz << "] = { ";

		//Alle Follow-Elemente ausgeben
		for( j = 0; j < followAnz; j++ )
		{
			//Namen holen
			name = hash_tab->getName( (*followSet)[j] );

			//Terminal ausgeben
			file << name;

			//folgt noch ein Eintrag?
			if( j < ( followAnz - 1 ) )
				//Ja
				file << ", ";
		}

		//abschlieen
		file << " };\n";
	}
}


void SSLRParser::outputTermName( ofstream &file )
{
	//Die Namen der Terminale ausgeben, nur im debug-mode
	char	*name;
	int		i, k;

	//Debug-Makro ausgeben
	file << "\n#ifdef SSLR_DEBUG\n";

	//Header
	file << "\n//names of the terminals\n";
	file << "char *SSLRParser::SSLR_termName[SSLRParser::SSLR_anzTerm] =\n{ ";

	//Alle Terminale
	for( i = k = 0; i < termArrCount; i++, k++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//neue Zeile?
		if( k == 16 )
		{
			//Ja
			file << "\n";
			k = 0;
		}

		//Define-Anweisung ausgeben
		file << "\"" << name << "\"";

		//Folgt noch ein Terminal?
		if( i < ( termArrCount - 1 ) )
			//Ja
			file << ", ";
	}

	//abschliessen
	file << " };\n\n";
	file << "#endif\n\n";
}


void SSLRParser::outputSemAct( ofstream &file )
{
	//semantische Aktionen ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, *pos, *tmp, *semTypeName;
	long		_line, LRTabIndex;
	bool		semTypeOK = false;
	int			i, state, depth, semIndex, semTypeIndex, id;
	int			*nArr, *tArr, type, sign, err;

	//gibt es berhaupt welche?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//dient der Vermeidung von Fehlerlawinen
		nArr = new( int[ntermArrCount] );
		tArr = new( int[termArrCount] );

		//initialisieren
		memset( nArr, 0, sizeof( int ) * ntermArrCount );
		memset( tArr, 0, sizeof( int ) * termArrCount );

		//Funktions-Header ausgeben
		file << "void SSLRParser::SSLR_doSemAct( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//do semantic actions before reduction\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "	SSLR_TYPE		tmp;\n";
		file << "\n";
		file << "	//semantic actions allowed?\n";
		file << "	if( SSLR_semAct == true )\n";
		file << "	{\n";
		file << "		//get a pointer to the alternative\n";
		file << "		n = &SSLR_ntermStr[tab->value];\n";
		file << "\n";
		file << "		//Alternative to reduce with\n";
		file << "		switch( tab->value )\n";
		file << "		{\n";

		//alle Alternativen
		for( i = 0; i < prod2_anz; i++ )
		{
			//Fehlerflag zurcksetzen
			err = 0;

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//gibt es semantische Aktionen?
			if( p2->semAct )
			{
				//ja, ausgeben
				name = hash_tab->getName( p1->hash_index );

				//das entsprechende Item ausgeben
				file << "\t\t\t//";
				outputItem( i, p2->riAnz, file );
				file << "\n";

				//case ausgeben
				file << "\t\t\tcase " << name << "_" << i - p1->prod2_index << ":\n";
				file << "\t\t\t{\n\t\t\t\t";

				//Zustand setzen
				state = 0;
				_line = p2->semActLine;

				//Verschachtelung von Kommentaren
				depth = 0;

				//Zeiger auf den text
				pos = p2->semAct;

				//den Text analysieren
				while( *pos && !err )
				{
					//Blancs lschen
					switch( state )
					{
						case 0:
						{
							//Leerzeichen lschen
							while( isspace( *pos ) && ( *pos != '\n' ) )
								//nchstes Zeichen
								file << *pos++;

							break;
						}
					}

					//neue Zeile?
					if( *pos == '\n' )
					{
						//neue Zeile
						_line++;

						//Status: 2?
						if( state != 2 )
						{
							//Status 2 ist Kommentar //
							file << *pos++;
							continue;
						}
					}

					//semantischer Typ?
					if( !state && ( *pos == '$' ) )
					{
						//Ja
						state = 10;
						pos++;
					}

					switch( state )
					{
						//Default-Zustand
						case 10:
						{
							//semantischer Typ?
							if( *pos == '$' )
							{
								//den semantischen Typ der Produktion holen
								semIndex = hash_tab->getUnionType( p1->hash_index );

								//gibt es einen semantischen Typ?
								if( semIndex )
								{
									//ja, mit semantischem Typ ausgeben
									file << "tmp." << unionStr->id[semIndex];

									//ist berflssigerweise ein semantischer Typ in Form von <typ>
									//angegeben worden?
									if( semTypeOK )
									{
										//sind die Typen gleich?
										if( semIndex == semTypeIndex )
											//Ja, Angabe ist berflssig
											cerr << "sslr: line " << _line << ": Explicit semantic type statement not necessary!" << endl;

										else
											//nein, sind verschieden!
											cerr << "sslr: line " << _line << ": Explicit semantic type statement does not coincide with %union statement!" << endl;

										//Speicher fr Namen freigeben
										delete( semTypeName );

										//Flag zurcksetzen
										semTypeOK = false;
									}
								}

								else
								{
									//nein, ohne semantischen Typ ausgeben
									file << "tmp";

									//ist ein semantischer Typ in Form von <typ> angegeben worden?
									if( semTypeOK )
									{
										//Typ ausgeben
										file << "." << unionStr->id[semTypeIndex];

										//Speicher fr Namen freigeben
										delete( semTypeName );

										//Flag zurcksetzen
										semTypeOK = false;
									}

									else
									{
										//nein, Fehler

										//den Namen der Produktion
										name = hash_tab->getName( p1->hash_index );

										//den Index in der LR-Tabelle holen
										LRTabIndex = hash_tab->getLRTabIndex( p1->hash_index );

										//Warnung ausgeben?
										if( !nArr[LRTabIndex] )
											//ja, Warnung ausgeben
											cerr << "sslr: line " << _line << ": No semantic type defined for production " << name << "!" << endl;

										//Vermeidung von Fehlerlawinen
										nArr[LRTabIndex]++;
									}
								}

								//berspringen
								pos++;

								//Zustand zurcksetzen
								state = 0;
							}

							else if( *pos == '<' )
							{
								//ist vom Typ $<...>
								pos++;

								//Position merken
								tmp = pos;

								//solange kein >
								while( ( *pos != '>' ) && *pos )
									//bertragen
									pos++;

								//gengend Speicher anfordern
								semTypeName = new( char[pos - tmp + 1] );

								//kopieren
								strncpy( semTypeName, tmp, pos - tmp );
								semTypeName[pos - tmp] = 0;

								//den Index in unionStr finden
								if( ( semTypeIndex = getSemIndex( semTypeName ) ) < 0 )
								{
									//Typ nicht in %union definiert
									cerr << "sslr: ERROR: line " << _line << ": Type " << semTypeName << " for semantic action not defined in %union!" << endl;

									//Speicher gleich wieder freigeben
									delete( semTypeName );

									//Fehler
									semTypeOK = false;
								}

								else
									//Flag setzen
									semTypeOK = true;

								//> lschen
								pos++;
							}

							else if( isdigit( *pos ) || ( *pos == '-' ) )
							{
								//bezieht sich auf ein Element auf der rechten Seite
								//semStack[semStackCnt-1] ist das letzte Element

								//negativer Index?
								if( *pos == '-' )
								{
									//ja, negativ
									sign = -1;
									pos++;
								}

								else
									//ist positiv
									sign = 1;

								//Zahl einlesen
								id = strtol( pos, 0L, 10 );

								//Vorzeichen
								id *= sign;

								//Ziffern lschen
								while( isdigit( *pos ) )
									pos++;

								//gibt es berhaupt so viele Elemente auf der rechten Seite wie angegeben?
								if( ( id - 1 ) < p2->riAnz )
								{
									//ist es der Form prod -> 'EPSILON'`?
									if( ( p2->riAnz == 1 ) && ( p2->right[0] == epsHashIndex ) )
									{
										//Warnung ausgeben
										cerr << "sslr: line " <<  _line << ": $" << id << " not allowed inside 'EPSILON'-alternative!" << endl;

										//nchste semantische Aktion behandelt
										err++;
										break;
									}

									else
									{
										//den semantischen Typ des Elements holen
										semIndex = hash_tab->getUnionType( p2->right[id - 1] );

										//gibt es einen semantischen Typ?
										if( semIndex )
										{
											//ja, Stack-Zugriff
											file << "SSLR_semStack[SSLR_semStackCnt - 1 - " << p2->riAnz << " + (" << id << ")]." << unionStr->id[semIndex];

											//ist berflssigerweise ein semantischer Typ in Form von <typ>
											//angegeben worden?
											if( semTypeOK )
											{
												//sind die Typen gleich?
												if( semIndex == semTypeIndex )
													//Ja, Angabe ist berflssig
													cerr << "sslr: line " << _line << ": Explicit semantic type statement not necessary!" << endl;

												else
													//Nein, sind verschieden!
													cerr << "sslr: line " << _line << ": Explicit semantic type statement does not coincide with %union-Statement!" << endl;

												//Speicher fr Namen freigeben
												delete( semTypeName );

												//Flag zurcksetzen
												semTypeOK = false;
											}
										}

										else
										{
											//nein, Stack-Zugriff
											file << "SSLR_semStack[SSLR_semStackCnt - 1 - " << p2->riAnz << " + (" << id << ")]";

											//ist ein semantischer Typ in Form von <typ> angegeben worden?
											if( semTypeOK )
											{
												//Typ ausgeben
												file << "." << unionStr->id[semTypeIndex];

												//Speicher fr Namen freigeben
												delete( semTypeName );

												//Flag zurcksetzen
												semTypeOK = false;

												//berspringen
												pos++;
											}

											else
											{
												//den Namen des Elements
												name = hash_tab->getName( p2->right[id - 1] );

												//den Index in der LR-Tabelle holen
												LRTabIndex = hash_tab->getLRTabIndex( p2->right[id - 1] );

												//Typ holen
												type = hash_tab->getType( p2->right[id - 1] );

												//Terminal?
												if( type == SSLR_TERM )
												{
													//ja

													//Warnung ausgeben?
													if( !tArr[LRTabIndex] )
														//Warnung ausgeben
														cerr << "sslr: line " << _line << ": No semantic type defined for terminal " << name << "!" << endl;

													//Vermeidung von Fehlerlawinen
													tArr[LRTabIndex]++;
												}

												else
												{
													//ist ein Nicht-Terminal

													//Warnung ausgeben?
													if( !nArr[LRTabIndex] )
														//Warnung ausgeben
														cerr << "sslr: line " << _line << ": No semantic type defined for nonterminal " << name << "!" << endl;

													//Vermeidung von Fehlerlawinen
													nArr[LRTabIndex]++;
												}
											}
										}
									}
								}

								else
								{
									//Indiziertes Element zu gro!
									cerr << "sslr: line " << _line << ": Number in semantic type statement too big!" << endl;

									//abbrechen
									err++;
									break;
								}

								//Zustand zurcksetzen
								state = 0;
							}

							break;
						}

						case 0:
						{
							//Kommentar?
							if( ( pos[0] == '/' ) && ( pos[1] == '*' ) )
							{
								//ja, Kommentar
								state = 1;

								//Verschachtelung
								depth++;
								pos += 2;

								//ausgeben
								file << "/*";
							}

							else if( ( pos[0] == '/' ) && ( pos[1] == '/' ) )
							{
								//Kommentar
								pos += 2;
								file << "//";
								state = 2;
							}

							else if( *pos )
								//einfach bertragen
								file << *pos++;

							break;
						}

						case 1:
						{
							//Kommentar /*
							if( ( pos[0] == '*' ) && ( pos[1] == '/' ) )
							{
								//Kommentar schliessen
								file << "*/";
								pos += 2;

								//Verschachtelungstiefe
								depth--;

								//Default-Zustand?
								if( !depth )
									//ja
									state = 0;
							}

							else if( ( pos[0] == '/' ) && ( pos[1] == '*' ) )
							{
								//ja, Kommentar

								//Verschachtelung
								depth++;
								pos += 2;

								//ausgeben
								file << "/*";
							}

							else
								//einfach bertragen
								file << *pos++;

							break;
						}

						case 2:
						{
							//Kommentar //
							file << *pos;

							//Newline?
							if( *pos++ == '\n' )
								//ja
								state = 0;

							break;
						}

						default:
							//einfach kopieren
							file << *pos++;
					}
				}

				//case abschliessen
				file << "\t\t\t\tbreak;\n";
				file << "\t\t\t}\n";
				file << "\n";
			}
		}

		file << "//\t\t\tdefault:\n";
		file << "\t\t\t\t//error\n";
		file << "//\t\t\t\tcerr << \"SSLRParser::SSLR_doSemAct: Unknown alternative \" << tab->value << \"!\" << endl;\n";
		file << "\t\t}\n";
		file << "\n\t\t//correct stack pointer\n";
		file << "\t\tSSLR_semStackCnt -= n->elem;\n";
		file << "\n";
		file << "		//semantic stack overflow?\n";
		file << "		if( SSLR_semStackCnt >= SSLR_maxStackSize )\n";
		file << "		{\n";
		file << "			//yes, print an error message\n";
		file << "			cerr << \"SSLRParser::SSLR_doSemAct: Semantic stack overflow!\" << endl;\n";
		file << "\n";
		file << "			//no more semantic actions allowed\n";
		file << "			SSLR_semAct = false;\n";
		file << "		}\n";
		file << "\n";
		file << "		else\n";
		file << "			//push last value on stack\n";
		file << "			SSLR_semStack[SSLR_semStackCnt++] = tmp;\n";
		file << "\t}\n";
		file << "}\n";
		file << "\n";

		//Speicher freigeben
		delete[] ( nArr );
		delete[] ( tArr );
	}
}


void SSLRParser::outputErrorRecovery( ofstream &file )
{
	//Hier wird die komplette Fehlerbehandlung ausgegeben
	LR_TAB	*lrtab;
	char	*name;

	//gibt es berhaupt Fehlerangaben?
	if( error_anz )
	{
		file << "\n";
		file << "\n";
file << "void SSLRParser::SSLR_printErrorMsg( bool print, char *errMsg  )\n";
file << "{\n";
file << "	//print an error message, but only when it is allowed\n";
file << "	if( ( print == true ) && !SSLR_anzSuppressError )\n";
file << "		//allowed\n";
file << "		cerr << \"sslr: ERROR: line \" << SSLR_line << \": \" << errMsg << endl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errPop( long termi )\n";
file << "{\n";
file << "\t//get current state\n";
file << "\tlong state = SSLR_state;\n";
file << "\n";
file << "\t//pop states from the parse stack untill termi may be shifted\n";
file << "\twhile( SSLR_lrTab[state][termi].state != LR_SHIFT )\n";
file << "\t{\n";
file << "\t\t//pop one element\n";
file << "\t\tstate = SSLR_pop( 1 );\n";
file << "\n";
file << "\t\t//are we in state 1, that is could'n termi be shifted?\n";
file << "\t\tif( state == 1 )\n";
file << "\t\t{\n";
file << "\t\t\t//all states poped from parse stack, exit\n";
file << "\t\t\tSSLR_state = state;\n";
file << "\n";
file << "\t\t\t//set current terminal to ACCEPT to simulate successful parsing\n";
file << "\t\t\tSSLR_terminal = ACCEPT;\n";
file << "\t\t\treturn;\n";
file << "\t\t}\n";
file << "\t}\n";
file << "\n";
file << "\t//set new state\n";
file << "\tSSLR_state = state;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errShift( long termi )\n";
file << "{\n";
file << "\t//can we reduce here?\n";
file << "\twhile( SSLR_lrTab[SSLR_state][termi].state == LR_REDUCE )\n";
file << "\t\t//yes, that might allow recovery\n";
file << "\t\tSSLR_reduce( &SSLR_lrTab[SSLR_state][termi] );\n";
file << "\n";
file << "	//shift a new state\n";
file << "	if( SSLR_lrTab[SSLR_state][termi].state == LR_SHIFT )\n";
file << "		//push new state onto the parse stack\n";
file << "		SSLR_push( SSLR_lrTab[SSLR_state][termi].value );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errDelete( void )\n";
file << "{\n";
file << "	//delete current terminal\n";
file << "	SSLR_terminal = SSLR_getTerminal();\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errOverRead( long termi )\n";
file << "{\n";
file << "	//delete all terminals untill termi is found\n";
file << "	do\n";
file << "	{\n";
file << "		//get next terminal\n";
file << "		SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "		//equal?\n";
file << "		if( SSLR_terminal == termi )\n";
file << "			//yes, return\n";
file << "			return;\n";
file << "\n";
file << "		else if( SSLR_terminal == ACCEPT )\n";
file << "		{\n";
file << "			//abort parsing\n";
file << "			SSLR_state = 1;\n";
file << "			return;\n";
file << "		}\n";
file << "\n";
file << "	}while( 1 );\n";
file << "}\n";
	}

	//Fehler-Routine ausgeben
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_error( void )\n";
file << "{\n";
file << "	//error handling\n";
file << "	long	tmpState, tmpSp;\n";
file << "	int		rec = 0;\n";
file << "\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Flag ausgeben
		file << "	//no more semantic actions allowed\n";
		file << "	SSLR_semAct = false;\n";
		file << "\n";
	}

file << "	//count error\n";
file << "	SSLR_anzError++;\n";
file << "\n";
file << "\n";



	//gibt es berhaupt Fehlerangaben?
	if( error_anz )
	{
		unsigned long	i, j, k, m;
		ERROR_STR		*errorStr;
		bool			outputCase;
		long			LRTabIndex;
		int				pass, autoErr;

		//ja, Header ausgeben
		file << "	switch( SSLR_state )\n";
		file << "	{\n";

		//alle Hllen-Indices prfen
		for( i = 0; i < hulle_anz; i++ )
		{
			/*
				vor Verarbeitung der ersten Hlle muss ein case-Statement
				ausgegeben werden
			*/
			outputCase = true;

			//einen neuen Zustand prfen, dazu zwei Psse
			for( pass = 0; pass < 2; pass++ )
			{
				/*
					Fr alle ERROR_STR prfen, ob sie eine Fehleranweisung
					fr den Zustand i haben.
				*/
				for( j = 0; j < error_anz; j++ )
				{
					//Zeiger auf ERROR_STR
					errorStr = &error_str[j];

					//hat diese Hlle eine Fehleraktion fr Zustand i?
					for( k = 0; k < errorStr->hInd.anzArr; k++ )
					{
						//gesuchter Zustand?
						if( errorStr->hInd.arr[k] == i )
						{
							//Fehleraktion ausgeben

							//case-Statement ausgeben?
							if( outputCase == true )
							{
								//Einleitung
								file << "\t\tcase " << i << ":\n";
								file << "\t\t{\n";
								file << "\t\t\tswitch( SSLR_terminal )\n";
								file << "\t\t\t{\n";

								//nicht noch einmal ausgeben
								outputCase = false;
							}

							/*
								Im ersten Pass werden nur Terminal-gebundene
								Fehleraktionen bearbeitet, also der Art
								1:ADD,SUB:AKTION:		"Fehlermeldung!" oder
								1:!(ADD,SUB):AKTION:	"Fehlermeldung!"
							*/
							if( !pass & errorStr->errTermStrAnz )
							{
								//das Fehler-Item ausgeben
								file << "\t\t\t\t//line " << errorStr->line << ", ";

								//entsprechende Alternative ausgeben
								outputItem( errorStr->prod2_index, errorStr->dot, file );
								file << "\n";

								//hat die ERROR_STR berhaupt Terminal-gebundenen Fehleraktionen?
								if( errorStr->errTermStr )
								{
									//alle Terminale durchgehen
									for( m = 0; m < termArrCount; m++ )
									{
										//Terminal gesetzt?
										if( errorStr->errTermArr[m] )
										{
											//den Namen des Terminals holen
											name = hash_tab->getName( termArr[m] );

											//case-Statement ausgeben
											file << "\t\t\t\tcase " << name << ":\n";
										}
									}
								}

								//neue Zeile
								file << "\t\t\t\t{\n";

								//interne Fehlerbehandlung standardmssig ausgeben
								autoErr = 1;

								//Fehlermeldung ausgeben?
								if( errorStr->msg )
								{
									/*
										Die Fehlermeldung MUSS vor den Fehler-Aktionen ausgegeben werden, da,
										wenn z.B. EXIT verwendet wird, die Fehlermeldung nicht gezeigt
										wrde!
									*/
									file << "\t\t\t\t\t//show user defined error message\n";
									file << "\t\t\t\t\tSSLR_printErrorMsg( true, \"" << errorStr->msg << "\" );\n\n";
								}


								//Zustnde vom Parse-Stack poppen?
								if( errorStr->pop )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->pop );

									//Zustnde vom Parse-Stack poppen
									file << "\t\t\t\t\t//pop states from parse stack\n";
									file << "\t\t\t\t\tSSLR_ERROR_POP( " << name << " );\n\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//Terminal auf den Parse-Stack schieben?
								if( errorStr->shift )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->shift );

									//neuen Zustand schieben
									file << "\t\t\t\t\t//shift terminal " << name << "\n";
									file << "\t\t\t\t\tSSLR_ERROR_SHIFT( " << name << " );\n\n";

									//Index des Terminals in der LR-Tabelle holen
									LRTabIndex = hash_tab->getLRTabIndex( errorStr->shift );
//LRTabIndex = getTermArrIndex( errorStr->shift );

									//prfen, ob das Terminal tatschlich in diesem Zustand i geschoben werden kann

									//Zeiger auf LR_TAB-Struktur
									lrtab = &lrTab[errorStr->hInd.arr[k]][LRTabIndex];

									//kann das Terminal geschoben werden?
									if( lrtab->state != LR_SHIFT )
										//nein, Warnung ausgeben
										cerr << "sslr: line " << errorStr->line << ": Terminal " << name << " cannot be shifted in state " << i << "!" << endl;

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//Terminale berlesen?
								if( errorStr->overread )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->overread );

									//Terminale berlesen
									file << "\t\t\t\t\t//delete terminals until " << name << " ist the current terminal\n";
									file << "\t\t\t\t\tSSLR_ERROR_OVERREAD( " << name << " );\n\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//aktuelles Terminal aus der Eingabe lschen?
								if( errorStr->del )
								{
									//ein Terminal lschen
									file << "\t\t\t\t\t//delete current terminal\n";

									//mehrfaches Auftreten von DELETE ist erlaubt
									for( m = 0; m < errorStr->del; m++ )
										file << "\t\t\t\t\tSSLR_ERROR_DELETE();\n";

									//neue Zeile
									file << "\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//den Parse-Prozess beenden?
								if( errorStr->exit )
								{
									//Parsen abbrechen
									file << "\t\t\t\t\t//stop parsing\n";
									file << "\t\t\t\t\tSSLR_ERROR_EXIT;\n";
								}


								//semantische Aktionen trotz Fehlers weiterfhren?
								if( errorStr->sem )
								{
									//semantische Aktionen trotz Fehler zulassen

									//gibt es berhaupt semantische Aktionen?
									if( semActCnt && ( unionStr->anz > 1 ) )
									{
										//ja
										file << "\t\t\t\t\t//allow semantic actions despite the error\n";
										file << "\t\t\t\t\tSSLR_ERROR_SEM;\n\n";
									}

									else
										//nein
										cerr << "sslr: line " << errorStr->line << ": There are no semantic actions not to allow!" << endl;
								}


								//automatische Fehlerbehandlung berspringen, wenn keine Aktion gewhlt wurde oder nur SEM
								if( autoErr )
								{
									//nein, automatische Fehlerbehandlung trotz eigener Fehler-Angaben ausfhren
									file << "\t\t\t\t\t//skip automatic error recovery\n";
									file << "\t\t\t\t\trec++;\n";
								}

								//case fr diese ERROR_STR abschliessen
								file << "\n";
								file << "\t\t\t\t\t//leave\n";
								file << "\t\t\t\t\tbreak;\n";
								file << "\t\t\t\t}\n";

								//nchste ERROR_STR prfen
								break;
							}

							//zweiter Pass?
							else if( pass )
							{
								/*
									zweiter Pass, hier nun die Fehleraktionen ausgeben, die
									nicht mit einem Terminal verbunden sind, also der Art
									1:AKTION:	"Fehlermeldung!
								*/
								if( !errorStr->errTermStr )
								{
									//das Fehler-Item ausgeben
									file << "\t\t\t\t//line " << errorStr->line << ", ";

									//entsprechende Alternative ausgeben
									outputItem( errorStr->prod2_index, errorStr->dot, file );
									file << "\n";

									//alle nicht-Terminal-gebundenen Fehleranweisung unter default subsummieren
									file << "\t\t\t\tdefault:\n";

									//neue Zeile
									file << "\t\t\t\t{\n";

									//interne Fehlerbehandlung standardmssig ausgeben
									autoErr = 1;

									//Fehlermeldung ausgeben?
									if( errorStr->msg )
									{
										/*
											Die Fehlermeldung MUSS vor den Fehler-Aktionen ausgegeben werden, da,
											wenn z.B. EXIT verwendet wird, die Fehlermeldung nicht gezeigt
											wrde!
										*/
										file << "\t\t\t\t\t//show user defined error message\n";
										file << "\t\t\t\t\tSSLR_printErrorMsg( true, \"" << errorStr->msg << "\" );\n\n";
									}


									//Zustnde vom Parse-Stack poppen?
									if( errorStr->pop )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->pop );

										//Zustnde vom Parse-Stack poppen
										file << "\t\t\t\t\t//pop states from parse stack\n";
										file << "\t\t\t\t\tSSLR_ERROR_POP( " << name << " );\n\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//Terminal auf den Parse-Stack schieben?
									if( errorStr->shift )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->shift );

										//neuen Zustand schieben
										file << "\t\t\t\t\t//shift terminal " << name << "\n";
										file << "\t\t\t\t\tSSLR_ERROR_SHIFT( " << name << " );\n\n";

										//Index des Terminals in der LR-Tabelle holen
										LRTabIndex = hash_tab->getLRTabIndex( errorStr->shift );
//LRTabIndex = getTermArrIndex( errorStr->shift );

										//prfen, ob das Terminal tatschlich in diesem Zustand i geschoben werden kann

										//Zeiger auf LR_TAB-Struktur
										lrtab = &lrTab[errorStr->hInd.arr[k]][LRTabIndex];

										//kann das Terminal geschoben werden?
										if( lrtab->state != LR_SHIFT )
											//nein, Warnung ausgeben
											cerr << "sslr: line " << errorStr->line << ": Terminal " << name << " cannot be shifted in state " << i << "!" << endl;

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//Terminale berlesen?
									if( errorStr->overread )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->overread );

										//Terminale berlesen
										file << "\t\t\t\t\t//delete terminals until " << name << " ist the current terminal\n";
										file << "\t\t\t\t\tSSLR_ERROR_OVERREAD( " << name << " );\n\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//aktuelles Terminal aus der Eingabe lschen?
									if( errorStr->del )
									{
										//ein Terminal lschen
										file << "\t\t\t\t\t//delete current terminal\n";

										//mehrfaches Auftreten von DELETE ist erlaubt
										for( m = 0; m < errorStr->del; m++ )
											file << "\t\t\t\t\tSSLR_ERROR_DELETE();\n";

										//neue Zeile
										file << "\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//den Parse-Prozess beenden?
									if( errorStr->exit )
									{
										//Parsen abbrechen
										file << "\t\t\t\t\t//stop parsing\n";
										file << "\t\t\t\t\tSSLR_ERROR_EXIT;\n";
									}


									//semantische Aktionen trotz Fehlers weiterfhren?
									if( errorStr->sem )
									{
										//semantische Aktionen trotz Fehler zulassen

										//gibt es berhaupt semantische Aktionen?
										if( semActCnt && ( unionStr->anz > 1 ) )
										{
											//ja
											file << "\t\t\t\t\t//allow semantic actions despite the error\n";
											file << "\t\t\t\t\tSSLR_ERROR_SEM;\n\n";
										}

										else
											//nein
											cerr << "sslr: line " << errorStr->line << ": There are no semantic actions not to allow!" << endl;
									}


									//automatische Fehlerbehandlung berspringen, wenn keine Aktion gewhlt wurde oder nur SEM
									if( autoErr )
									{
										//nein, automatische Fehlerbehandlung trotz eigener Fehler-Angaben ausfhren
										file << "\t\t\t\t\t//skip automatic error recovery\n";
										file << "\t\t\t\t\trec++;\n";
									}

									//default fr diese ERROR_STR abschliessen
									file << "\n";
									file << "\t\t\t\t\t//leave\n";
									file << "\t\t\t\t\tbreak;\n";
									file << "\t\t\t\t}\n";

									//pro Zustand ist nur eine nicht-Terminal-gebundene Fehleranweisung zulssig
//									j = error_anz;
//									break;
								}

								//case-Anweisung abschliessen
								file << "\t\t\t}\n";

								//pro Zustand ist nur eine nicht-Terminal-gebundene Fehleranweisung zulssig
								j = error_anz;
								break;
							}
						}
					}
				}
			}

			//Zustand abschliessen?
			if( outputCase == false )
			{
				//ja, es gab fr die Hlle i Fehleranweisungen
				file << "\n";
				file << "\t\t\t//leave\n";
				file << "\t\t\tbreak;\n";
				file << "\t\t}\n\n";
			}
		}


		//default ausgeben
		file << "		default:\n";
		file << "		{\n";
		file << "			//default error message\n";
		file << "			SSLR_printErrorMsg( true, \"Syntax error!\" );\n";
		file << "			break;\n";
		file << "		}\n";

		//switch-Statement abschliessen
		file << "\t}\n\n";
	}

	else
	{
		//es gibt keine benutzter-definierten Fehleranweisungen, nun default-Fehlermeldung ausgeben
		file << "	//default error message\n";
		file << "	cerr << \"line: \" << SSLR_line << \": Syntax error!\" << endl;\n";
	}

	//nun die Standard-Fehlerbehandlung

file << "\n";
file << "	//supress further error messages\n";
file << "	SSLR_anzSuppressError = SSLR_anzSuppressErrorMsg;\n";
file << "\n";
file << "	//skip intern error recovery?\n";
file << "	if( rec )\n";
file << "		//yes, return\n";
file << "		return;\n";
file << "\n";
file << "	//save current stack position\n";
file << "	tmpSp = SSLR_sp;\n";
file << "\n";
file << "	//pop states from the parse stack until a valid transition is found\n";
file << "	do\n";
file << "	{\n";
file << "		//pop one state from the parse stack\n";
file << "		tmpState = SSLR_pop( 1 );\n";
file << "\n";
file << "		//is there a transition?\n";
file << "		if( ( SSLR_sp > 0 ) && ( SSLR_lrTab[tmpState][SSLR_terminal].state == LR_SHIFT ) )\n";
file << "		{\n";
file << "			//we found a valid transition, consider recovered\n";
file << "			SSLR_state = tmpState;\n";
file << "			return;\n";
file << "		}\n";
file << "\n";
file << "		//did we check the whole stack?\n";
file << "		else if( SSLR_sp < 1 )\n";
file << "		{\n";
file << "			//the whole stack has been visited without success\n";
file << "			SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "			//end of input, that is ACCEPT?\n";
file << "			if( SSLR_terminal == ACCEPT )\n";
file << "			{\n";
file << "				//yes, stop parsing\n";
file << "				SSLR_state = 1;\n";
file << "				return;\n";
file << "			}\n";
file << "\n";
file << "			//set stack pointer\n";
file << "			SSLR_sp = tmpSp;\n";
file << "		}\n";
file << "\n";
file << "	}while( 1 );\n";
file << "}\n";
}


void SSLRParser::outputIncl( ofstream &file )
{
	//Include-Anweisungen in das cpp-File ausgeben
	char	*incl = SSLR_scanner->getInclude(), *beg;
	ulong	len;

	//gibt es include-Anweisungen?
	if( incl )
	{
		//am Anfang das \{ lschen
		while( !( ( incl[0] == '\\' ) && ( incl[1] == '{' ) ) )
			incl++;

		//lschen
		incl = &incl[2];

		//die Lnge der Include-Anweisungen
		len = strlen( incl );

		//merken
		beg = &incl[len - 2];

		//am Ende das \{ lschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << incl;
	}
}


void SSLRParser::outputExt( ofstream &file )
{
	//eigene Erweiterungen in das cpp-File ausgeben
	char	*ext = SSLR_scanner->getExtension(), *beg;
	ulong	len;

	//gibt es Extensionen?
	if( ext )
	{
		//am Anfang das \{ lschen
		while( !( ( ext[0] == '\\' ) && ( ext[1] == '{' ) ) )
			ext++;

		//lschen
		ext = &ext[2];

		//die Lnge der eigenen Erweiterungen
		len = strlen( ext );

		//merken
		beg = &ext[len - 2];

		//am Ende das \{ lschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << ext;
	}
}


void SSLRParser::outputTermDefHFile( ofstream &file )
{
	/*
		Der Scanner liefert ja Tokens zum Parser zurck, die im Prinzip
		fr die Auswahl der nchsten Aktion (schieben/reduzieren) bentigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	char *name;
	int	i;

	//Kopf ausgeben
file << "/***************************************************************************\n";
file << "                          sslrtermdef.h  -  description\n";
file << "                             -------------------\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLRTERMDEF_H\n";
file << "#define SSLRTERMDEF_H\n";
file << "\n";
file << "\n";
file << "/**\n";
file << "\t@author SSLR V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";

	//Terminale, die der Scanner zurckliefert
	file << "//Terminals returned by the scanner\n";

	for( i = 0; i < termArrCount; i++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//Define-Anweisung ausgeben
		file << "#define " << name << "\t" << i << "\n";
	}


	//wurde eine %union-Angabe vorgenommen?
	if( unionStr->anz > 1 )
	{
		//ja, ausgeben
		file << "\n\n\n//Type for semantic actions\n";
		file << "typedef union\n{\n";

		//Text ausgeben
		file << unionStr->text;

		//abschliessen
		file << "\n}SSLR_TYPE;\n\n\n";
	}

	//Ende des Header-Files
	file << "#endif\n\n";
}


void SSLRParser::outputHFile( ofstream &file )
{
	//Header-File ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char 		*name, puf1[256+1];
	char 		**userDefHeader;
	long		followAnz;
	int			i, j, id, userDefHeaderCnt;

	//Kopf ausgeben
file << "/***************************************************************************\n";
file << "                          sslrparser.h  -  description\n";
file << "                             -------------------\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLRPARSER_H\n";
file << "#define SSLRPARSER_H\n";
file << "\n";
file << "\n";
file << "/**\n";
file << "\t@author SSLR V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";


	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug version *\n";
		file << "****************************/\n\n\n";

		//Debug-Makro
		file << "//define debug macro\n";
		file << "#define SSLR_DEBUG\n";
		file << "//#undef SSLR_DEBUG\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug version *\n";
		file << "********************************/\n\n\n";
	}

	//Include-Files
	file << "//Include-Files\n";
	file << "#include <iostream>\n";
	file << "#include <iomanip>\n";
	file << "#include \"sslexscanner.h\"\n\n";

	//allgemeine Definitionen

	//gibt es berhaupt Fehlerangaben?
	if( error_anz )
	{
		//ja, die Fehlerroutinen als Defines ausgeben
		file << "\n//error routines\n";
		file << "#define SSLR_ERROR_POP\t\t\tSSLR_errPop\n";
		file << "#define SSLR_ERROR_DELETE\t\tSSLR_errDelete\n";
		file << "#define SSLR_ERROR_SHIFT\t\tSSLR_errShift\n";
		file << "#define SSLR_ERROR_OVERREAD\t\tSSLR_errOverRead\n";
		file << "#define SSLR_ERROR_SEM\t\t\tSSLR_semAct = true\n";
		file << "#define SSLR_ERROR_EXIT\t\t\texit( 1 )\n";
		file << "\n";
	}



	//Nicht-Terminal-Defines fr Sprung-Tabelle
	file << "\n//Nonterminal defines for the jump table\n";

	for( i = 0; i < ntermArrCount; i++ )
	{
		//Name des Nicht-Terminals
		name = hash_tab->getName( ntermArr[i] );

		//Define-Anweisung ausgeben
		file << "#define " << name << "\t" << i << "\n";
	}



	//Nicht-Terminale fr die LR-Tabelle
	file << "\n\n//Nontermials for the LR table\n";

	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf PROD2_STR
		p2 = &prod2_str[i];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Name der Produktion
		name = hash_tab->getName( p1->hash_index );

		//Nummer der Alternative
		id = i - p1->prod2_index;

		//Namen generieren
		sprintf( puf1, "%s_%d", name, id );

		//Define-Anweisung ausgeben
		file << "#define " << puf1 << "\t" << i << "\n";
	}



	//Klassen-Deklaration
	file << "\n\nclass SSLRParser\n";
	file << "{\n";
	file << "private:\n";


	//Struktur fr die LR-Tabelle
	file << "\n\t//LR table\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";
	file << "\t\tint\t\t\tstate;\n";
	file << "\t\tlong\t\tvalue;\n";
	file << "\n\t}SSLR_LR_TAB;\n\n";


	//Struktur fr alle Alternativen
	file << "\n";
	file << "\t//all productions\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		file << "\t\t//name of alternative\n";
		file << "\t\tchar\t*name;\n";
		file << "\n";
		file << "\t\t//pointer to right side of alternative\n";
		file << "\t\tchar\t**ri;\n";
		file << "\n";
	}

	//Zeiger auf die Follow-Terminale
	file << "\t\t//index in jumpTab\n";
	file << "\t\tint\t\tjump_index;\n";
	file << "\n";
	file << "\t\t//number of elements on the right side\n";
	file << "\t\tint\t\telem;\n";
	file << "\n";
	file << "\t\t//pointer to follow sets\n";
	file << "\t\tlong\t*follow;\n";
	file << "\n";
	file << "\t\t//number of follow terminals\n";
	file << "\t\tlong\tfollowCnt;\n";
	file << "\n";
	file << "\t}SSLR_NTERM_STR;\n";
	file << "\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		//Debug-Stack-Struktur ausgeben
		file << "\t//stack for debugging\n";
		file << "\ttypedef struct\n";
		file << "\t{\n";
		file << "\t\t//true: terminal, false: nonterminal\n";
		file << "\t\tbool\telem;\n";
		file << "\n";
		file << "\t\t//terminal: index in SSLR_termName, nonterminal: index in SSLR_NTERM_STR\n";
		file << "\t\tint\t\tindex;\n";
		file << "\n";
		file << "\t}SSLR_debugStack;\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	file << "\n\n\n\t//private class variables\n\n\n\n";

	//Anzahl der Zustnde
	file << "\t//Number of lr states\n";
	file << "\tstatic const unsigned long\tSSLR_anzLRStates = " << hulle_anz << ";\n\n";

	//Anzahl der Terminale
	file << "\t//Number of terminals = number of columns in lrTab\n";
	file << "\tstatic const unsigned long\tSSLR_anzTerm = " << termArrCount << ";\n\n";

	//Anzahl der Produktionen
	file << "\t//Number of productions = number of rows in jumpTab\n";
	file << "\tstatic const unsigned long\tSSLR_anzNTerm = " << prod_anz << ";\n\n";

	//Anzahl der Alternativen
	file << "\t//Number of alternatives\n";
	file << "\tstatic const unsigned long\tSSLR_anzProd = " << prod2_anz << ";\n\n";

	//Zustnde in der LR-Tabelle
	file << "\n\t//Actions in lrTab\n";
	file << "\tstatic const int\t\t\tLR_ERROR = 1;\n";
	file << "\tstatic const int\t\t\tLR_SHIFT = 2;\n";
	file << "\tstatic const int\t\t\tLR_REDUCE = 3;\n";
	file << "\tstatic const int\t\t\tLR_ACCEPT = 4;\n\n";

	//Stack-Gre
	file << "\n\t//maximum stack size\n";
	file << "\tstatic const int\t\t\tSSLR_maxStackSize = 100;\n\n";


	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Breite der lngsten rechten Seite aller Alternativen
		file << "\t//longest right side of all alternatives\n";
		file << "\tstatic const int\t\t\tSSLR_maxAltRightSideWidth = " << maxAltRightSideWidth << ";\n\n";

		//Breite des lngsten Elements (Terminal/Nicht-Terminal)
		file << "\t//longest terminal or nonterminal\n";
		file << "\tstatic const int\t\t\tSSLR_maxElemWidth = " << maxElemWidth << ";\n\n";

		//Breite des grten Zustands
		file << "\t//longest state\n";
		file << "\tstatic const int\t\t\tSSLR_maxStateWidth = " << maxStateWidth << ";\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	/*
		Anzahl der erfolgreichen Reduktionen bzw. Shifts nach einem Fehler,
		um wieder Fehlermeldungen zu zeigen.
	*/
	file << "	//number of seccessful reduce - and shift actions\n";
	file << "	//neccassary after an error occured\n";
	file << "	static const int\t\t\tSSLR_anzSuppressErrorMsg = 3;\n";
	file << "\n";

	//Anzahl der erfolgreichen Reduktionen bzw. Shifts nach einem Fehler
	file << "	//number of seccessful reduce - and shift actions after an error occured\n";
	file << "	int\t\t\t\t\t\t\tSSLR_anzSuppressError;\n";
	file << "\n";


	//Stack fr Zustnde
	file << "\n";
	file << "	//parse stack\n";
	file << "	long\t\t\t\t\t\tSSLR_stack[SSLR_maxStackSize];\n";
	file << "\n";


	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Stack frs Debugging
		file << "\t//debug stack\n";
		file << "\tSSLR_debugStack\t\t\t\tSSLR_dbgStack[SSLR_maxStackSize];\n\n";

		//Stack-Pointer frs Debugging
		file << "\t//debug stack pointer\n";
		file << "\tlong\t\t\t\t\t\tSSLR_dbgSp;\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	file << "	//stack counter\n";
	file << "	long\t\t\t\t\t\tSSLR_sp;\n";
	file << "\n";
	file << "\n";

	//LR-Tabelle
	file << "\t//LR table\n";
	file << "\tstatic SSLR_LR_TAB\t\t\tSSLR_lrTab[SSLR_anzLRStates][SSLR_anzTerm];\n\n";

	//Sprung-Tabelle
	file << "\t//jump table\n";
	file << "\tstatic long\t\t\t\t\tSSLR_jumpTab[SSLR_anzLRStates][SSLR_anzNTerm];\n\n";

	//Scanner-Klasse
	file << "\t//scanner class\n";
	file << "\tSSLEXScanner *\t\t\t\tSSLR_scanner;\n\n";

	//array with all alternatives
	file << "\t//array with all alternatives\n";
	file << "\tstatic SSLR_NTERM_STR\t\tSSLR_ntermStr[SSLR_anzProd];\n\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Array mit den Namen der Terminale
		file << "\t//array with the names of the terminals\n";
		file << "\tstatic char *\t\t\t\tSSLR_termName[SSLR_anzTerm];\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	//Typ des Terminals, dass der Scanner zurckliefert
	file << "	//current terminal\n";
	file << "	int\t\t\t\t\t\t\tSSLR_terminal;\n";
	file << "\n";

	//Atrribut des Terminals wie z.B. Zahlenwert
	file << "	//attributes returned form scanner\n";
	file << "	SSLR_TYPE\t\t\t\t\tSSLR_attributeStr;\n";
	file << "\n";

	//Zeile, in der ein Fehler auftrat
	file << "	//line number\n";
	file << "	unsigned long\t\t\t\tSSLR_line;\n";
	file << "\n";

	//aktueller Zustand des Parsers
	file << "	//current state\n";
	file << "	int\t\t\t\t\t\t\tSSLR_state;\n";
	file << "\n";

	//Anzahl der aufgetretenen Fehler
	file << "	//number of errors\n";
	file << "	int\t\t\t\t\t\t\tSSLR_anzError;\n";
	file << "\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//semantische Aktionen, fr Fehlerbehandlung
		file << "	//allow/deny semantic actions\n";
		file << "	bool\t\t\t\t\t\tSSLR_semAct;\n";
		file << "\n";
		file << "	//stack for semantic actions\n";
		file << "	SSLR_TYPE\t\t\t\t\tSSLR_semStack[SSLR_maxStackSize];\n";
		file << "\n";
		file << "	//stack counter for semantic action stack\n";
		file << "	unsigned int\t\t\t\tSSLR_semStackCnt;\n";
		file << "\n";
	}

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//die rechten Seiten
		file << "\t//Alternatives\n";

		//alle rechten Seiten (nur Debug)
		for( i = 0; i < prod2_anz; i++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//den Namen der Alternative holen
			name = hash_tab->getName( p1->hash_index );

			//Nummer der Alternative
			id = i - p1->prod2_index;

			//Namen generieren
			sprintf( puf1, "%s%d", name, id );

			//initialisieren
			file << "\tstatic char *\t\t\t\tSSLR_" << puf1 << "Ri[" << p2->riAnz << "];\n";
		}
	}

	//alle Follow-Mengen ausgeben
	file << "\n	//all follow sets for the error recovery\n";

	//alle Follow-Mengen ausgeben
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//den Namen der Alternative holen
		name = hash_tab->getName( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//initialisieren
		file << "\tstatic long\t\t\t\t\tSSLR_" << name << "Follow[" << followAnz << "];\n";
	}

	//private Methoden
	file << "\n\n\t//private methods\n\n";


	//Methoden der Klasse
file << "\n";
file << "	//push a new state on parse stack\n";
file << "	void SSLR_push( long );\n";
file << "\n";
file << "	//pop elements from parse stack\n";
file << "	long SSLR_pop( int );\n";
file << "\n";
file << "	//begin parsing\n";
file << "	int SSLR_parse( void );\n";
file << "\n";
file << "	//shift a new state onto the parse stack\n";
file << "	void SSLR_shift( SSLR_LR_TAB * );\n";
file << "\n";
file << "	//reduce with a production\n";
file << "	void SSLR_reduce( SSLR_LR_TAB * );\n";
file << "\n";
file << "	//error handling\n";
file << "	void SSLR_error( void );\n";
file << "\n";
file << "	//print an error message, but only when it is allowed\n";
file << "	void SSLR_printErrorMsg( bool, char * );\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Ausgaberoutine fr den Debug-Stack
		file << "	//print the debug stack SSLR_dbgStack\n";
		file << "	void SSLR_outputDbgStack( int, int, int, int );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}

	//gibt es berhaupt Fehlerangaben?
	if( error_anz )
	{
		//ja, Hilfsroutinen ausgeben
		file << "	//shift a new state onto the parse stack\n";
		file << "	void SSLR_errShift( long );\n";
		file << "\n";
		file << "	//pop elements from the parse stack untill term may be shifted\n";
		file << "	void SSLR_errPop( long );\n";
		file << "\n";
		file << "	//delete next terminal\n";
		file << "	void SSLR_errDelete( void );\n";
		file << "\n";
		file << "	//delete all terminals untill term is found\n";
		file << "	void SSLR_errOverRead( long );\n";
		file << "\n";
	}

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Prototypen ausgeben
		file << "\t//perform semantic actions associated with the production\n";
		file << "\t//to be reduced\n";
		file << "\tvoid SSLR_doSemAct( SSLR_LR_TAB * );\n";
		file << "\n";
	}

file << "	//get next terminal\n";
file << "	int SSLR_getTerminal( void );\n";
file << "\n";
file << "public:\n";
file << "\n";
file << "	//public methods \n";
file << "	SSLRParser( SSLEXScanner * );\n";
file << "	~SSLRParser();\n";
file << "\n";
file << "	//resets the whole parser\n";
file << "	void reset( void );\n";
file << "\n";
file << "	//start parsing\n";
file << "	int yyParse( void );\n";
file << "\n";
file << "\n";

	//benutzerdefinierte Daten holen
	userDefHeader = SSLR_scanner->getUserDefHeader( userDefHeaderCnt );

	//alle Zeilen
	for( j = 0; j < userDefHeaderCnt; j++ )
		//ausgeben
		file << userDefHeader[j];

file << "};\n";
file << "\n";
file << "\n";

	//Ende des Header-Files
	file << "#endif\n\n";
}

