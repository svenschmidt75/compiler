/***************************************************************************
                          sslrparser.cpp  -  description
                             -------------------
    copyright            : (C) 2002 by Sven Schmidt
    email                : s.schmidt@lboro.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "_sslrparser.h"
#include <iostream>


/****************************
* This is the debug version *
****************************/


//Terminals for debugging
char *SSLR_scannerToken[] =
{
	/*0*/ "AST",
	/*1*/ "UNION",
	/*2*/ "SEMIKOLON",
	/*3*/ "SHIFT",
	/*4*/ "EXIT",
	/*5*/ "STRING",
	/*6*/ "TERMINAL",
	/*7*/ "DB",
	/*8*/ "EOPEN",
	/*9*/ "LEFT_ASSOC",
	/*10*/ "KLCLOSE",
	/*11*/ "COMMA",
	/*12*/ "PREC",
	/*13*/ "END_OF_PRODUCTION",
	/*14*/ "NON_TERMINAL",
	/*15*/ "ERROR",
	/*16*/ "TYPE",
	/*17*/ "BOPEN",
	/*18*/ "NUMBER",
	/*19*/ "SEMACT",
	/*20*/ "NOT",
	/*21*/ "NEW_ALTERNATIVE",
	/*22*/ "DELETE",
	/*23*/ "RIGHT_ASSOC",
	/*24*/ "POP",
	/*25*/ "BCLOSE",
	/*26*/ "semTypeOpen",
	/*27*/ "OVERREAD",
	/*28*/ "SEM",
	/*29*/ "SEP",
	/*30*/ "NON_ASSOC",
	/*31*/ "NTERM_TYPE",
	/*32*/ "DEFINITION",
	/*33*/ "KLOPEN",
	/*34*/ "semTypeClose",
	/*35*/ "TERM_TYPE",
	/*36*/ "EPSILON",
	/*37*/ "ECLOSE",
	/*38*/ "IDENT",
	/*39*/ "GRAMMAR",
	/*40*/ "ACCEPT",
	0L
};



	//SSLR initialisieren
	#define SSLR_INIT

//syntax analyze table
SSLRParser::SSLR_LR_TAB SSLRParser::SSLR_lrTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzTerm] = {
/* State 0 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initSSLR_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 1 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, start_0 }
 },
/* State 2 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 4 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 3 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 6 },{ LR_REDUCE, sect2_1 }
 },
/* State 4 */
{ { 0, 0 },{ LR_SHIFT, 9 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, union_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_1 },{ LR_REDUCE, union_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_1 },{ LR_REDUCE, union_1 }
 },
/* State 5 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, goal_0 }
 },
/* State 6 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 13 },{ 0, 0 },{ 0, 0 }
 },
/* State 7 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 20 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 21 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 22 },{ LR_SHIFT, 18 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 19 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_2 },{ LR_REDUCE, definition1_2 }
 },
/* State 8 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 23 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 9 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, startUnion_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 10 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 13 },{ 0, 0 },{ LR_REDUCE, sect2_0 }
 },
/* State 11 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 25 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 12 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 26 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 13 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, newProduction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 14 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 20 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 21 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 22 },{ LR_SHIFT, 18 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 19 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_0 },{ LR_REDUCE, sect1_0 }
 },
/* State 15 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, definition1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_1 },{ LR_REDUCE, definition1_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_1 },{ LR_REDUCE, definition1_1 }
 },
/* State 16 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 29 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, semType_1 },{ 0, 0 },{ 0, 0 }
 },
/* State 17 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 31 },{ 0, 0 },{ 0, 0 }
 },
/* State 18 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ntermDef_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ntermDef_0 },{ 0, 0 },{ 0, 0 }
 },
/* State 19 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ntermDef_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ntermDef_1 },{ 0, 0 },{ 0, 0 }
 },
/* State 20 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, associativity_0 },{ 0, 0 },{ 0, 0 }
 },
/* State 21 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, associativity_1 },{ 0, 0 },{ 0, 0 }
 },
/* State 22 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, associativity_2 },{ 0, 0 },{ 0, 0 }
 },
/* State 23 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 24 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 25 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ LR_REDUCE, sc2_1 }
 },
/* State 26 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 27 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, definition1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_0 },{ LR_REDUCE, definition1_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition1_0 },{ LR_REDUCE, definition1_0 }
 },
/* State 28 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 52 },{ 0, 0 },{ 0, 0 }
 },
/* State 29 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 53 },{ 0, 0 },{ 0, 0 }
 },
/* State 30 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, definition2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_1 },{ LR_REDUCE, definition2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_1 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 54 },{ LR_REDUCE, definition2_1 },{ LR_REDUCE, definition2_1 }
 },
/* State 31 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ LR_REDUCE, namelist2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ LR_REDUCE, namelist2_1 },{ LR_REDUCE, namelist2_1 }
 },
/* State 32 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 55 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 33 */
{ { 0, 0 },{ 0, 0 },{ LR_SHIFT, 57 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 34 */
{ { LR_SHIFT, 59 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 58 },{ 0, 0 },{ 0, 0 }
 },
/* State 35 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ LR_REDUCE, sc2_0 }
 },
/* State 36 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sslrRule_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 61 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 37 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ LR_SHIFT, 64 },{ LR_REDUCE, precedence_1 },{ LR_SHIFT, 48 },{ LR_REDUCE, precedence_1 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 38 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ LR_REDUCE, item1_1 },
{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ LR_REDUCE, item1_1 },{ LR_REDUCE, item1_1 },{ LR_REDUCE, item1_1 },{ 0, 0 },
{ LR_REDUCE, item1_1 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 39 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 40 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 41 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 42 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_REDUCE, rhs_3 },
{ 0, 0 },{ LR_REDUCE, rhs_3 },{ 0, 0 },{ LR_REDUCE, rhs_3 },{ LR_REDUCE, rhs_3 },{ LR_SHIFT, 48 },{ LR_REDUCE, rhs_3 },{ 0, 0 },
{ LR_REDUCE, rhs_3 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, rhs_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 43 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLOpen_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 44 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfBOpen_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfBOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 45 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfEOpen_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfEOpen_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 46 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ LR_REDUCE, item2_1 },
{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ LR_REDUCE, item2_1 },{ LR_REDUCE, item2_1 },{ LR_REDUCE, item2_1 },{ 0, 0 },
{ LR_REDUCE, item2_1 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 47 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ LR_REDUCE, item3_0 },
{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ LR_REDUCE, item3_0 },{ LR_REDUCE, item3_0 },{ LR_REDUCE, item3_0 },{ 0, 0 },
{ LR_REDUCE, item3_0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 48 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ LR_REDUCE, item3_1 },
{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ LR_REDUCE, item3_1 },{ LR_REDUCE, item3_1 },{ LR_REDUCE, item3_1 },{ 0, 0 },
{ LR_REDUCE, item3_1 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 49 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ LR_REDUCE, item3_2 },
{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ LR_REDUCE, item3_2 },{ LR_REDUCE, item3_2 },{ LR_REDUCE, item3_2 },{ 0, 0 },
{ LR_REDUCE, item3_2 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item3_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item3_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 50 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },
{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ LR_REDUCE, semanticAction_0 },{ LR_REDUCE, semanticAction_0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },
{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, semanticAction_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 51 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, definition2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_0 },{ LR_REDUCE, definition2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, definition2_0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 69 },{ LR_REDUCE, definition2_0 },{ LR_REDUCE, definition2_0 }
 },
/* State 52 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ LR_REDUCE, namelist1_1 },{ LR_REDUCE, namelist1_1 }
 },
/* State 53 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 70 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 54 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ LR_REDUCE, namelist2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ LR_REDUCE, namelist2_0 },{ LR_REDUCE, namelist2_0 }
 },
/* State 55 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, union_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_0 },{ LR_REDUCE, union_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, union_0 },{ LR_REDUCE, union_0 }
 },
/* State 56 */
{ { 0, 0 },{ 0, 0 },{ LR_SHIFT, 71 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 57 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, unionBody_1 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, unionBody_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 58 */
{ { 0, 0 },{ 0, 0 },{ LR_REDUCE, unionBody2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 59 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 72 },{ 0, 0 },{ 0, 0 }
 },
/* State 60 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 48 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 61 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ LR_REDUCE, newAlternative_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, newAlternative_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 62 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ LR_SHIFT, 75 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 63 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ LR_REDUCE, item1_0 },
{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ LR_REDUCE, item1_0 },{ LR_REDUCE, item1_0 },{ LR_REDUCE, item1_0 },{ 0, 0 },
{ LR_REDUCE, item1_0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 64 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 76 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 65 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 78 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 61 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 66 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 61 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 80 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 67 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 61 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 82 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 68 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ LR_REDUCE, item2_0 },
{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ LR_REDUCE, item2_0 },{ LR_REDUCE, item2_0 },{ LR_REDUCE, item2_0 },{ 0, 0 },
{ LR_REDUCE, item2_0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, item2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, item2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 69 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ LR_REDUCE, namelist1_0 },{ LR_REDUCE, namelist1_0 }
 },
/* State 70 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, semType_0 },{ 0, 0 },{ 0, 0 }
 },
/* State 71 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, unionBody_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, unionBody_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 72 */
{ { 0, 0 },{ 0, 0 },{ LR_REDUCE, unionBody2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 73 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 45 },
{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ LR_SHIFT, 64 },{ LR_REDUCE, precedence_1 },{ LR_SHIFT, 48 },{ LR_REDUCE, precedence_1 },{ 0, 0 },
{ LR_SHIFT, 44 },{ 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 43 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 74 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 75 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 84 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 76 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, precedence_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, precedence_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 77 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },
{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ LR_REDUCE, rhs_0 },{ LR_REDUCE, rhs_0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },
{ LR_REDUCE, rhs_0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 78 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },
{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ LR_REDUCE, ebnfKLClose_0 },{ LR_REDUCE, ebnfKLClose_0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfKLClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 79 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ LR_REDUCE, rhs_1 },
{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ LR_REDUCE, rhs_1 },{ LR_REDUCE, rhs_1 },{ LR_REDUCE, rhs_1 },{ 0, 0 },
{ LR_REDUCE, rhs_1 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 80 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },
{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ LR_REDUCE, ebnfBClose_0 },{ LR_REDUCE, ebnfBClose_0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },
{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfBClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 81 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ LR_REDUCE, rhs_2 },
{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ LR_REDUCE, rhs_2 },{ LR_REDUCE, rhs_2 },{ LR_REDUCE, rhs_2 },{ 0, 0 },
{ LR_REDUCE, rhs_2 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rhs_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rhs_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 82 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },
{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ LR_REDUCE, ebnfEClose_0 },{ LR_REDUCE, ebnfEClose_0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },
{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ebnfEClose_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 83 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ LR_SHIFT, 75 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 84 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 89 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 85 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rightSide_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 86 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 89 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 90 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 87 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 88 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 92 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 89 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initBeforeNumber_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 90 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, error_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 91 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 92 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ LR_SHIFT, 97 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 98 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 93 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 107 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 108 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 94 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 109 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 95 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 110 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 96 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 97 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, termList_1 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, termList_1 },{ LR_REDUCE, termList_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 98 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, negTerm_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 99 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 100 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorMsg_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 101 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 111 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 102 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 112 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 103 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 113 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 104 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 105 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 106 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 107 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 108 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 116 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 109 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 97 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 110 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 111 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 120 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 112 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 121 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 113 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 122 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 114 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 115 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 123 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 116 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, termList_0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, termList_0 },{ LR_REDUCE, termList_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 117 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 124 },{ LR_SHIFT, 108 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 118 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 119 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 120 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 125 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 121 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 126 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 122 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 127 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 123 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 124 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 129 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 125 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 126 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 127 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, errorAction2_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 128 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 129 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 130 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 131 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 132 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 132 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 102 },{ LR_SHIFT, 104 },{ LR_SHIFT, 100 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 105 },{ 0, 0 },{ LR_SHIFT, 103 },
{ LR_REDUCE, errorMsg_1 },{ 0, 0 },{ LR_SHIFT, 101 },{ LR_SHIFT, 106 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 },
/* State 133 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, errorBody2_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, errorBody2_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 }
 }
};


//jump table
long SSLRParser::SSLR_jumpTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzNTerm] = {
//start, semType, errorMsg, newProduction, ebnfEClose, rhs, sc2, error, associativity, ebnfEOpen,
//ebnfKLOpen, rightSide, unionBody2, goal, definition1, definition2, ebnfBOpen, termList, sslrRule, semanticAction, errorAction2, startUnion, errorBody, sect1, sect2, precedence, ebnfKLClose, negTerm, item1, item2, item3, initBeforeNumber, ntermDef, unionBody, initSSLR, union, newAlternative, ebnfBClose, errorAction, errorBody2, namelist1, namelist2,

/* State 0 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   2,   0,   0,   0,   0,   0,   0,   0 },
/* State 1 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 2 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   3,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 3 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 4 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0 },
/* State 5 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 6 */
{   0,   0,   0,  12,   0,   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 7 */
{   0,   0,   0,   0,   0,   0,   0,   0,  17,   0,   0,   0,   0,   0,  14,  15,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 8 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 9 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 10 */
{   0,   0,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 11 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 12 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 13 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 14 */
{   0,   0,   0,   0,   0,   0,   0,   0,  17,   0,   0,   0,   0,   0,   0,  27,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 15 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 16 */
{   0,  28,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 17 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  30 },
/* State 18 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 19 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 20 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 21 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 22 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 23 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  33,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,  32,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 24 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 25 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 26 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,  36,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  37,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 27 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 28 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,  51,   0 },
/* State 29 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 30 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 31 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 32 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  56,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 33 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 34 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 35 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 36 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,  60,   0,   0,   0,   0,   0 },
/* State 37 */
{   0,   0,   0,   0,   0,  63,   0,   0,   0,  41,  39,   0,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,  62,   0,   0,   0,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 38 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 39 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,  65,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  37,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 40 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,  66,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  37,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 41 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,  67,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  37,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 42 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  68,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 43 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 44 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 45 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 46 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 47 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 48 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 49 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 50 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 51 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 52 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 53 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 54 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 55 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 56 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 57 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 58 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 59 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 60 */
{   0,   0,   0,   0,   0,  38,   0,   0,   0,  41,  39,   0,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,   0,   0,   0,  73,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 61 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 62 */
{   0,   0,   0,   0,   0,   0,   0,  74,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 63 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 64 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 65 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  77,   0,   0,   0,   0,
  0,   0,   0,   0,   0,  60,   0,   0,   0,   0,   0 },
/* State 66 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,  60,  79,   0,   0,   0,   0 },
/* State 67 */
{   0,   0,   0,   0,  81,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,  60,   0,   0,   0,   0,   0 },
/* State 68 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 69 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 70 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 71 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 72 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 73 */
{   0,   0,   0,   0,   0,  63,   0,   0,   0,  41,  39,   0,   0,   0,   0,   0,
 40,   0,   0,  49,   0,   0,   0,   0,   0,  83,   0,   0,   0,  42,  46,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 74 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 75 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 76 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 77 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 78 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 79 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 80 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 81 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 82 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 83 */
{   0,   0,   0,   0,   0,   0,   0,  85,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 84 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,  86,   0,   0,   0,   0,   0,   0,   0,   0,
 88,   0,   0,   0,   0,   0,   0,   0,  87,   0,   0 },
/* State 85 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 86 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 88,   0,   0,   0,   0,   0,   0,   0,  91,   0,   0 },
/* State 87 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 88 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 89 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 90 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 91 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 92 */
{   0,   0,  96,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,  93,   0,   0,  99,   0,   0,   0,   0,   0,   0,  94,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,  95,   0,   0,   0 },
/* State 93 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 94 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 95 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 96 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 97 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 98 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 99 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 100 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 101 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 102 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 103 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 104 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 105 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 106 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 107 */
{   0,   0, 114,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,  99,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0, 115,   0,   0,   0 },
/* State 108 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 109 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0, 117,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 110 */
{   0,   0, 118,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0, 119,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 111 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 112 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 113 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 114 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 115 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 116 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 117 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 118 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 119 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 120 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 121 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 122 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 123 */
{   0,   0, 128,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0, 119,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 124 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 125 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 126 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 127 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 128 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 129 */
{   0,   0, 130,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,  99,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0, 131,   0,   0,   0 },
/* State 130 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 131 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 132 */
{   0,   0, 133,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0, 119,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
/* State 133 */
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }
};


//follow sets for the error recovery
long SSLRParser::SSLR_startFollow[1] = { ACCEPT };
long SSLRParser::SSLR_goalFollow[1] = { ACCEPT };
long SSLRParser::SSLR_initSSLRFollow[1] = { DEFINITION };
long SSLRParser::SSLR_sect1Follow[2] = { ACCEPT, GRAMMAR };
long SSLRParser::SSLR_definition1Follow[7] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, GRAMMAR };
long SSLRParser::SSLR_unionFollow[7] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, GRAMMAR };
long SSLRParser::SSLR_startUnionFollow[1] = { BOPEN };
long SSLRParser::SSLR_unionBodyFollow[2] = { TYPE, BCLOSE };
long SSLRParser::SSLR_unionBody2Follow[1] = { SEMIKOLON };
long SSLRParser::SSLR_definition2Follow[7] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, GRAMMAR };
long SSLRParser::SSLR_ntermDefFollow[2] = { semTypeOpen, IDENT };
long SSLRParser::SSLR_semTypeFollow[1] = { IDENT };
long SSLRParser::SSLR_associativityFollow[1] = { IDENT };
long SSLRParser::SSLR_namelist1Follow[8] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, IDENT, GRAMMAR };
long SSLRParser::SSLR_namelist2Follow[8] = { LEFT_ASSOC, ACCEPT, RIGHT_ASSOC, NON_ASSOC, NTERM_TYPE, TERM_TYPE, IDENT, GRAMMAR };
long SSLRParser::SSLR_sect2Follow[1] = { ACCEPT };
long SSLRParser::SSLR_sc2Follow[2] = { ACCEPT, IDENT };
long SSLRParser::SSLR_sslrRuleFollow[1] = { END_OF_PRODUCTION };
long SSLRParser::SSLR_newProductionFollow[1] = { SEP };
long SSLRParser::SSLR_rightSideFollow[5] = { KLCLOSE, END_OF_PRODUCTION, NEW_ALTERNATIVE, BCLOSE, ECLOSE };
long SSLRParser::SSLR_newAlternativeFollow[6] = { TERMINAL, EOPEN, NON_TERMINAL, BOPEN, SEMACT, KLOPEN };
long SSLRParser::SSLR_item1Follow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_rhsFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_item2Follow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_item3Follow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_semanticActionFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_ebnfKLOpenFollow[6] = { TERMINAL, EOPEN, NON_TERMINAL, BOPEN, SEMACT, KLOPEN };
long SSLRParser::SSLR_ebnfBOpenFollow[6] = { TERMINAL, EOPEN, NON_TERMINAL, BOPEN, SEMACT, KLOPEN };
long SSLRParser::SSLR_ebnfEOpenFollow[6] = { TERMINAL, EOPEN, NON_TERMINAL, BOPEN, SEMACT, KLOPEN };
long SSLRParser::SSLR_ebnfKLCloseFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_ebnfBCloseFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_ebnfECloseFollow[13] = { TERMINAL, EOPEN, KLCLOSE, PREC, END_OF_PRODUCTION, NON_TERMINAL, ERROR, BOPEN, SEMACT, NEW_ALTERNATIVE, BCLOSE, KLOPEN, ECLOSE };
long SSLRParser::SSLR_precedenceFollow[6] = { KLCLOSE, END_OF_PRODUCTION, ERROR, NEW_ALTERNATIVE, BCLOSE, ECLOSE };
long SSLRParser::SSLR_errorFollow[5] = { KLCLOSE, END_OF_PRODUCTION, NEW_ALTERNATIVE, BCLOSE, ECLOSE };
long SSLRParser::SSLR_errorBodyFollow[2] = { NUMBER, BCLOSE };
long SSLRParser::SSLR_errorBody2Follow[2] = { NUMBER, BCLOSE };
long SSLRParser::SSLR_initBeforeNumberFollow[1] = { DB };
long SSLRParser::SSLR_negTermFollow[1] = { KLOPEN };
long SSLRParser::SSLR_termListFollow[3] = { DB, KLCLOSE, COMMA };
long SSLRParser::SSLR_errorActionFollow[1] = { DB };
long SSLRParser::SSLR_errorAction2Follow[1] = { DB };
long SSLRParser::SSLR_errorMsgFollow[2] = { NUMBER, BCLOSE };

//all alternatives
char *SSLRParser::SSLR_start0Ri[1] = { "goal" };
char *SSLRParser::SSLR_goal0Ri[3] = { "initSSLR", "sect1", "sect2" };
char *SSLRParser::SSLR_initSSLR0Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_sect10Ri[3] = { "\'DEFINITION\'", "union", "definition1" };
char *SSLRParser::SSLR_definition10Ri[2] = { "definition1", "definition2" };
char *SSLRParser::SSLR_definition11Ri[1] = { "definition2" };
char *SSLRParser::SSLR_definition12Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_union0Ri[4] = { "startUnion", "\'BOPEN\'", "unionBody", "\'BCLOSE\'" };
char *SSLRParser::SSLR_union1Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_startUnion0Ri[1] = { "\'UNION\'" };
char *SSLRParser::SSLR_unionBody0Ri[3] = { "unionBody", "unionBody2", "\'SEMIKOLON\'" };
char *SSLRParser::SSLR_unionBody1Ri[2] = { "unionBody2", "\'SEMIKOLON\'" };
char *SSLRParser::SSLR_unionBody20Ri[2] = { "\'TYPE\'", "\'IDENT\'" };
char *SSLRParser::SSLR_unionBody21Ri[3] = { "\'TYPE\'", "\'AST\'", "\'IDENT\'" };
char *SSLRParser::SSLR_definition20Ri[3] = { "ntermDef", "semType", "namelist1" };
char *SSLRParser::SSLR_definition21Ri[2] = { "associativity", "namelist2" };
char *SSLRParser::SSLR_ntermDef0Ri[1] = { "\'NTERM_TYPE\'" };
char *SSLRParser::SSLR_ntermDef1Ri[1] = { "\'TERM_TYPE\'" };
char *SSLRParser::SSLR_semType0Ri[3] = { "\'semTypeOpen\'", "\'IDENT\'", "\'semTypeClose\'" };
char *SSLRParser::SSLR_semType1Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_associativity0Ri[1] = { "\'LEFT_ASSOC\'" };
char *SSLRParser::SSLR_associativity1Ri[1] = { "\'RIGHT_ASSOC\'" };
char *SSLRParser::SSLR_associativity2Ri[1] = { "\'NON_ASSOC\'" };
char *SSLRParser::SSLR_namelist10Ri[2] = { "namelist1", "\'IDENT\'" };
char *SSLRParser::SSLR_namelist11Ri[1] = { "\'IDENT\'" };
char *SSLRParser::SSLR_namelist20Ri[2] = { "namelist2", "\'IDENT\'" };
char *SSLRParser::SSLR_namelist21Ri[1] = { "\'IDENT\'" };
char *SSLRParser::SSLR_sect20Ri[2] = { "\'GRAMMAR\'", "sc2" };
char *SSLRParser::SSLR_sect21Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_sc20Ri[3] = { "sc2", "sslrRule", "\'END_OF_PRODUCTION\'" };
char *SSLRParser::SSLR_sc21Ri[2] = { "sslrRule", "\'END_OF_PRODUCTION\'" };
char *SSLRParser::SSLR_sslrRule0Ri[3] = { "newProduction", "\'SEP\'", "rightSide" };
char *SSLRParser::SSLR_newProduction0Ri[1] = { "\'IDENT\'" };
char *SSLRParser::SSLR_rightSide0Ri[3] = { "item1", "precedence", "error" };
char *SSLRParser::SSLR_rightSide1Ri[5] = { "rightSide", "newAlternative", "item1", "precedence", "error" };
char *SSLRParser::SSLR_newAlternative0Ri[1] = { "\'NEW_ALTERNATIVE\'" };
char *SSLRParser::SSLR_item10Ri[2] = { "item1", "rhs" };
char *SSLRParser::SSLR_item11Ri[1] = { "rhs" };
char *SSLRParser::SSLR_rhs0Ri[3] = { "ebnfKLOpen", "rightSide", "ebnfKLClose" };
char *SSLRParser::SSLR_rhs1Ri[3] = { "ebnfBOpen", "rightSide", "ebnfBClose" };
char *SSLRParser::SSLR_rhs2Ri[3] = { "ebnfEOpen", "rightSide", "ebnfEClose" };
char *SSLRParser::SSLR_rhs3Ri[1] = { "item2" };
char *SSLRParser::SSLR_item20Ri[2] = { "item2", "item3" };
char *SSLRParser::SSLR_item21Ri[1] = { "item3" };
char *SSLRParser::SSLR_item30Ri[1] = { "\'TERMINAL\'" };
char *SSLRParser::SSLR_item31Ri[1] = { "\'NON_TERMINAL\'" };
char *SSLRParser::SSLR_item32Ri[1] = { "semanticAction" };
char *SSLRParser::SSLR_semanticAction0Ri[1] = { "\'SEMACT\'" };
char *SSLRParser::SSLR_ebnfKLOpen0Ri[1] = { "\'KLOPEN\'" };
char *SSLRParser::SSLR_ebnfBOpen0Ri[1] = { "\'BOPEN\'" };
char *SSLRParser::SSLR_ebnfEOpen0Ri[1] = { "\'EOPEN\'" };
char *SSLRParser::SSLR_ebnfKLClose0Ri[1] = { "\'KLCLOSE\'" };
char *SSLRParser::SSLR_ebnfBClose0Ri[1] = { "\'BCLOSE\'" };
char *SSLRParser::SSLR_ebnfEClose0Ri[1] = { "\'ECLOSE\'" };
char *SSLRParser::SSLR_precedence0Ri[2] = { "\'PREC\'", "\'TERMINAL\'" };
char *SSLRParser::SSLR_precedence1Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_error0Ri[4] = { "\'ERROR\'", "\'BOPEN\'", "errorBody", "\'BCLOSE\'" };
char *SSLRParser::SSLR_error1Ri[1] = { "\'EPSILON\'" };
char *SSLRParser::SSLR_errorBody0Ri[2] = { "errorBody", "errorBody2" };
char *SSLRParser::SSLR_errorBody1Ri[1] = { "errorBody2" };
char *SSLRParser::SSLR_errorBody20Ri[5] = { "initBeforeNumber", "\'DB\'", "termList", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody21Ri[7] = { "initBeforeNumber", "\'DB\'", "termList", "\'DB\'", "errorAction", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody22Ri[8] = { "initBeforeNumber", "\'DB\'", "negTerm", "\'KLOPEN\'", "termList", "\'KLCLOSE\'", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody23Ri[10] = { "initBeforeNumber", "\'DB\'", "negTerm", "\'KLOPEN\'", "termList", "\'KLCLOSE\'", "\'DB\'", "errorAction", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody24Ri[5] = { "initBeforeNumber", "\'DB\'", "errorAction", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_errorBody25Ri[3] = { "initBeforeNumber", "\'DB\'", "errorMsg" };
char *SSLRParser::SSLR_initBeforeNumber0Ri[1] = { "\'NUMBER\'" };
char *SSLRParser::SSLR_negTerm0Ri[1] = { "\'NOT\'" };
char *SSLRParser::SSLR_termList0Ri[3] = { "termList", "\'COMMA\'", "\'TERMINAL\'" };
char *SSLRParser::SSLR_termList1Ri[1] = { "\'TERMINAL\'" };
char *SSLRParser::SSLR_errorAction0Ri[3] = { "errorAction", "\'DB\'", "errorAction2" };
char *SSLRParser::SSLR_errorAction1Ri[1] = { "errorAction2" };
char *SSLRParser::SSLR_errorAction20Ri[4] = { "\'OVERREAD\'", "\'KLOPEN\'", "\'TERMINAL\'", "\'KLCLOSE\'" };
char *SSLRParser::SSLR_errorAction21Ri[4] = { "\'SHIFT\'", "\'KLOPEN\'", "\'TERMINAL\'", "\'KLCLOSE\'" };
char *SSLRParser::SSLR_errorAction22Ri[4] = { "\'POP\'", "\'KLOPEN\'", "\'TERMINAL\'", "\'KLCLOSE\'" };
char *SSLRParser::SSLR_errorAction23Ri[1] = { "\'EXIT\'" };
char *SSLRParser::SSLR_errorAction24Ri[1] = { "\'DELETE\'" };
char *SSLRParser::SSLR_errorAction25Ri[1] = { "\'SEM\'" };
char *SSLRParser::SSLR_errorMsg0Ri[1] = { "\'STRING\'" };
char *SSLRParser::SSLR_errorMsg1Ri[1] = { "\'EPSILON\'" };


//all alternatives
SSLRParser::SSLR_NTERM_STR SSLRParser::SSLR_ntermStr[SSLRParser::SSLR_anzProd] = {
{ "start", SSLRParser::SSLR_start0Ri, start, 1, SSLRParser::SSLR_startFollow, 1 },
{ "goal", SSLRParser::SSLR_goal0Ri, goal, 3, SSLRParser::SSLR_goalFollow, 1 },
{ "initSSLR", SSLRParser::SSLR_initSSLR0Ri, initSSLR, 0, SSLRParser::SSLR_initSSLRFollow, 1 },
{ "sect1", SSLRParser::SSLR_sect10Ri, sect1, 3, SSLRParser::SSLR_sect1Follow, 2 },
{ "definition1", SSLRParser::SSLR_definition10Ri, definition1, 2, SSLRParser::SSLR_definition1Follow, 7 },
{ "definition1", SSLRParser::SSLR_definition11Ri, definition1, 1, SSLRParser::SSLR_definition1Follow, 7 },
{ "definition1", SSLRParser::SSLR_definition12Ri, definition1, 0, SSLRParser::SSLR_definition1Follow, 7 },
{ "union", SSLRParser::SSLR_union0Ri, union, 4, SSLRParser::SSLR_unionFollow, 7 },
{ "union", SSLRParser::SSLR_union1Ri, union, 0, SSLRParser::SSLR_unionFollow, 7 },
{ "startUnion", SSLRParser::SSLR_startUnion0Ri, startUnion, 1, SSLRParser::SSLR_startUnionFollow, 1 },
{ "unionBody", SSLRParser::SSLR_unionBody0Ri, unionBody, 3, SSLRParser::SSLR_unionBodyFollow, 2 },
{ "unionBody", SSLRParser::SSLR_unionBody1Ri, unionBody, 2, SSLRParser::SSLR_unionBodyFollow, 2 },
{ "unionBody2", SSLRParser::SSLR_unionBody20Ri, unionBody2, 2, SSLRParser::SSLR_unionBody2Follow, 1 },
{ "unionBody2", SSLRParser::SSLR_unionBody21Ri, unionBody2, 3, SSLRParser::SSLR_unionBody2Follow, 1 },
{ "definition2", SSLRParser::SSLR_definition20Ri, definition2, 3, SSLRParser::SSLR_definition2Follow, 7 },
{ "definition2", SSLRParser::SSLR_definition21Ri, definition2, 2, SSLRParser::SSLR_definition2Follow, 7 },
{ "ntermDef", SSLRParser::SSLR_ntermDef0Ri, ntermDef, 1, SSLRParser::SSLR_ntermDefFollow, 2 },
{ "ntermDef", SSLRParser::SSLR_ntermDef1Ri, ntermDef, 1, SSLRParser::SSLR_ntermDefFollow, 2 },
{ "semType", SSLRParser::SSLR_semType0Ri, semType, 3, SSLRParser::SSLR_semTypeFollow, 1 },
{ "semType", SSLRParser::SSLR_semType1Ri, semType, 0, SSLRParser::SSLR_semTypeFollow, 1 },
{ "associativity", SSLRParser::SSLR_associativity0Ri, associativity, 1, SSLRParser::SSLR_associativityFollow, 1 },
{ "associativity", SSLRParser::SSLR_associativity1Ri, associativity, 1, SSLRParser::SSLR_associativityFollow, 1 },
{ "associativity", SSLRParser::SSLR_associativity2Ri, associativity, 1, SSLRParser::SSLR_associativityFollow, 1 },
{ "namelist1", SSLRParser::SSLR_namelist10Ri, namelist1, 2, SSLRParser::SSLR_namelist1Follow, 8 },
{ "namelist1", SSLRParser::SSLR_namelist11Ri, namelist1, 1, SSLRParser::SSLR_namelist1Follow, 8 },
{ "namelist2", SSLRParser::SSLR_namelist20Ri, namelist2, 2, SSLRParser::SSLR_namelist2Follow, 8 },
{ "namelist2", SSLRParser::SSLR_namelist21Ri, namelist2, 1, SSLRParser::SSLR_namelist2Follow, 8 },
{ "sect2", SSLRParser::SSLR_sect20Ri, sect2, 2, SSLRParser::SSLR_sect2Follow, 1 },
{ "sect2", SSLRParser::SSLR_sect21Ri, sect2, 0, SSLRParser::SSLR_sect2Follow, 1 },
{ "sc2", SSLRParser::SSLR_sc20Ri, sc2, 3, SSLRParser::SSLR_sc2Follow, 2 },
{ "sc2", SSLRParser::SSLR_sc21Ri, sc2, 2, SSLRParser::SSLR_sc2Follow, 2 },
{ "sslrRule", SSLRParser::SSLR_sslrRule0Ri, sslrRule, 3, SSLRParser::SSLR_sslrRuleFollow, 1 },
{ "newProduction", SSLRParser::SSLR_newProduction0Ri, newProduction, 1, SSLRParser::SSLR_newProductionFollow, 1 },
{ "rightSide", SSLRParser::SSLR_rightSide0Ri, rightSide, 3, SSLRParser::SSLR_rightSideFollow, 5 },
{ "rightSide", SSLRParser::SSLR_rightSide1Ri, rightSide, 5, SSLRParser::SSLR_rightSideFollow, 5 },
{ "newAlternative", SSLRParser::SSLR_newAlternative0Ri, newAlternative, 1, SSLRParser::SSLR_newAlternativeFollow, 6 },
{ "item1", SSLRParser::SSLR_item10Ri, item1, 2, SSLRParser::SSLR_item1Follow, 13 },
{ "item1", SSLRParser::SSLR_item11Ri, item1, 1, SSLRParser::SSLR_item1Follow, 13 },
{ "rhs", SSLRParser::SSLR_rhs0Ri, rhs, 3, SSLRParser::SSLR_rhsFollow, 13 },
{ "rhs", SSLRParser::SSLR_rhs1Ri, rhs, 3, SSLRParser::SSLR_rhsFollow, 13 },
{ "rhs", SSLRParser::SSLR_rhs2Ri, rhs, 3, SSLRParser::SSLR_rhsFollow, 13 },
{ "rhs", SSLRParser::SSLR_rhs3Ri, rhs, 1, SSLRParser::SSLR_rhsFollow, 13 },
{ "item2", SSLRParser::SSLR_item20Ri, item2, 2, SSLRParser::SSLR_item2Follow, 13 },
{ "item2", SSLRParser::SSLR_item21Ri, item2, 1, SSLRParser::SSLR_item2Follow, 13 },
{ "item3", SSLRParser::SSLR_item30Ri, item3, 1, SSLRParser::SSLR_item3Follow, 13 },
{ "item3", SSLRParser::SSLR_item31Ri, item3, 1, SSLRParser::SSLR_item3Follow, 13 },
{ "item3", SSLRParser::SSLR_item32Ri, item3, 1, SSLRParser::SSLR_item3Follow, 13 },
{ "semanticAction", SSLRParser::SSLR_semanticAction0Ri, semanticAction, 1, SSLRParser::SSLR_semanticActionFollow, 13 },
{ "ebnfKLOpen", SSLRParser::SSLR_ebnfKLOpen0Ri, ebnfKLOpen, 1, SSLRParser::SSLR_ebnfKLOpenFollow, 6 },
{ "ebnfBOpen", SSLRParser::SSLR_ebnfBOpen0Ri, ebnfBOpen, 1, SSLRParser::SSLR_ebnfBOpenFollow, 6 },
{ "ebnfEOpen", SSLRParser::SSLR_ebnfEOpen0Ri, ebnfEOpen, 1, SSLRParser::SSLR_ebnfEOpenFollow, 6 },
{ "ebnfKLClose", SSLRParser::SSLR_ebnfKLClose0Ri, ebnfKLClose, 1, SSLRParser::SSLR_ebnfKLCloseFollow, 13 },
{ "ebnfBClose", SSLRParser::SSLR_ebnfBClose0Ri, ebnfBClose, 1, SSLRParser::SSLR_ebnfBCloseFollow, 13 },
{ "ebnfEClose", SSLRParser::SSLR_ebnfEClose0Ri, ebnfEClose, 1, SSLRParser::SSLR_ebnfECloseFollow, 13 },
{ "precedence", SSLRParser::SSLR_precedence0Ri, precedence, 2, SSLRParser::SSLR_precedenceFollow, 6 },
{ "precedence", SSLRParser::SSLR_precedence1Ri, precedence, 0, SSLRParser::SSLR_precedenceFollow, 6 },
{ "error", SSLRParser::SSLR_error0Ri, error, 4, SSLRParser::SSLR_errorFollow, 5 },
{ "error", SSLRParser::SSLR_error1Ri, error, 0, SSLRParser::SSLR_errorFollow, 5 },
{ "errorBody", SSLRParser::SSLR_errorBody0Ri, errorBody, 2, SSLRParser::SSLR_errorBodyFollow, 2 },
{ "errorBody", SSLRParser::SSLR_errorBody1Ri, errorBody, 1, SSLRParser::SSLR_errorBodyFollow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody20Ri, errorBody2, 5, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody21Ri, errorBody2, 7, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody22Ri, errorBody2, 8, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody23Ri, errorBody2, 10, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody24Ri, errorBody2, 5, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "errorBody2", SSLRParser::SSLR_errorBody25Ri, errorBody2, 3, SSLRParser::SSLR_errorBody2Follow, 2 },
{ "initBeforeNumber", SSLRParser::SSLR_initBeforeNumber0Ri, initBeforeNumber, 1, SSLRParser::SSLR_initBeforeNumberFollow, 1 },
{ "negTerm", SSLRParser::SSLR_negTerm0Ri, negTerm, 1, SSLRParser::SSLR_negTermFollow, 1 },
{ "termList", SSLRParser::SSLR_termList0Ri, termList, 3, SSLRParser::SSLR_termListFollow, 3 },
{ "termList", SSLRParser::SSLR_termList1Ri, termList, 1, SSLRParser::SSLR_termListFollow, 3 },
{ "errorAction", SSLRParser::SSLR_errorAction0Ri, errorAction, 3, SSLRParser::SSLR_errorActionFollow, 1 },
{ "errorAction", SSLRParser::SSLR_errorAction1Ri, errorAction, 1, SSLRParser::SSLR_errorActionFollow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction20Ri, errorAction2, 4, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction21Ri, errorAction2, 4, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction22Ri, errorAction2, 4, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction23Ri, errorAction2, 1, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction24Ri, errorAction2, 1, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorAction2", SSLRParser::SSLR_errorAction25Ri, errorAction2, 1, SSLRParser::SSLR_errorAction2Follow, 1 },
{ "errorMsg", SSLRParser::SSLR_errorMsg0Ri, errorMsg, 1, SSLRParser::SSLR_errorMsgFollow, 2 },
{ "errorMsg", SSLRParser::SSLR_errorMsg1Ri, errorMsg, 0, SSLRParser::SSLR_errorMsgFollow, 2 }};


#ifdef SSLR_DEBUG

//names of the terminals
char *SSLRParser::SSLR_termName[SSLRParser::SSLR_anzTerm] =
{ "AST", "UNION", "SEMIKOLON", "SHIFT", "EXIT", "STRING", "TERMINAL", "DB", "EOPEN", "LEFT_ASSOC", "KLCLOSE", "COMMA", "PREC", "END_OF_PRODUCTION", "NON_TERMINAL", "ERROR",
"TYPE", "BOPEN", "NUMBER", "SEMACT", "NOT", "NEW_ALTERNATIVE", "DELETE", "RIGHT_ASSOC", "POP", "BCLOSE", "semTypeOpen", "OVERREAD", "SEM", "SEP", "NON_ASSOC", "NTERM_TYPE",
"DEFINITION", "KLOPEN", "semTypeClose", "TERM_TYPE", "EPSILON", "ECLOSE", "IDENT", "GRAMMAR", "ACCEPT" };

#endif



void SSLRParser::SSLR_printErrorMsg( bool print, char *errMsg  )
{
	//print an error message, but only when it is allowed
	if( ( print == true ) && !SSLR_anzSuppressError )
		//allowed
		cerr << "sslr: ERROR: line " << SSLR_line << ": " << errMsg << endl;
}


void SSLRParser::SSLR_errPop( long termi )
{
	//get current state
	long state = SSLR_state;

	//pop states from the parse stack untill termi may be shifted
	while( SSLR_lrTab[state][termi].state != LR_SHIFT )
	{
		//pop one element
		state = SSLR_pop( 1 );

		//are we in state 1, that is could'n termi be shifted?
		if( state == 1 )
		{
			//all states poped from parse stack, exit
			SSLR_state = state;

			//set current terminal to ACCEPT to simulate successful parsing
			SSLR_terminal = ACCEPT;
			return;
		}
	}

	//set new state
	SSLR_state = state;
}


void SSLRParser::SSLR_errShift( long termi )
{
	//can we reduce here?
	while( SSLR_lrTab[SSLR_state][termi].state == LR_REDUCE )
		//yes, that might allow recovery
		SSLR_reduce( &SSLR_lrTab[SSLR_state][termi] );

	//shift a new state
	if( SSLR_lrTab[SSLR_state][termi].state == LR_SHIFT )
		//push new state onto the parse stack
		SSLR_push( SSLR_lrTab[SSLR_state][termi].value );
}


void SSLRParser::SSLR_errDelete( void )
{
	//delete current terminal
	SSLR_terminal = SSLR_getTerminal();
}


void SSLRParser::SSLR_errOverRead( long termi )
{
	//delete all terminals untill termi is found
	do
	{
		//get next terminal
		SSLR_terminal = SSLR_getTerminal();

		//equal?
		if( SSLR_terminal == termi )
			//yes, return
			return;

		else if( SSLR_terminal == ACCEPT )
		{
			//abort parsing
			SSLR_state = 1;
			return;
		}

	}while( 1 );
}


void SSLRParser::SSLR_error( void )
{
	//error handling
	long	tmpState, tmpSp;
	int		rec = 0;

	//no more semantic actions allowed
	SSLR_semAct = false;

	//count error
	SSLR_anzError++;


	switch( SSLR_state )
	{
		case 8:
		{
			switch( SSLR_terminal )
			{
				//line 1048,  union ->  startUnion . 'BOPEN'  unionBody  'BCLOSE'
				default:
				{
					//show user defined error message
					SSLR_printErrorMsg( true, "Missing { in %union!" );

					//shift terminal BOPEN
					SSLR_ERROR_SHIFT( BOPEN );

					//skip automatic error recovery
					rec++;

					//leave
					break;
				}
			}

			//leave
			break;
		}

		case 9:
		{
			switch( SSLR_terminal )
			{
				//line 1048,  union ->  startUnion . 'BOPEN'  unionBody  'BCLOSE'
				default:
				{
					//show user defined error message
					SSLR_printErrorMsg( true, "Missing { in %union!" );

					//shift terminal BOPEN
					SSLR_ERROR_SHIFT( BOPEN );

					//skip automatic error recovery
					rec++;

					//leave
					break;
				}
			}

			//leave
			break;
		}

		default:
		{
			//default error message
			SSLR_printErrorMsg( true, "Syntax error!" );
			break;
		}
	}


	//supress further error messages
	SSLR_anzSuppressError = SSLR_anzSuppressErrorMsg;

	//skip intern error recovery?
	if( rec )
		//yes, return
		return;

	//save current stack position
	tmpSp = SSLR_sp;

	//pop states from the parse stack until a valid transition is found
	do
	{
		//pop one state from the parse stack
		tmpState = SSLR_pop( 1 );

		//is there a transition?
		if( ( SSLR_sp > 0 ) && ( SSLR_lrTab[tmpState][SSLR_terminal].state == LR_SHIFT ) )
		{
			//we found a valid transition, consider recovered
			SSLR_state = tmpState;
			return;
		}

		//did we check the whole stack?
		else if( SSLR_sp < 1 )
		{
			//the whole stack has been visited without success
			SSLR_terminal = SSLR_getTerminal();

			//end of input, that is ACCEPT?
			if( SSLR_terminal == ACCEPT )
			{
				//yes, stop parsing
				SSLR_state = 1;
				return;
			}

			//set stack pointer
			SSLR_sp = tmpSp;
		}

	}while( 1 );
}


SSLRParser::SSLRParser( SSLEXScanner *scan )
{
	//call reset to initialize the parser
	reset();

	//scanner class
	SSLR_scanner = scan;

#ifdef SSLR_INIT
	//inizialize user defined variables
	init();
#endif
}


SSLRParser::~SSLRParser()
{
#ifdef SSLR_INIT
	//uninizialize user defined variables
	deinit();
#endif
}


void SSLRParser::reset( void )
{
	//resets the whole parser

#ifdef SSLR_DEBUG
	//output
	cout << setw( SSLR_maxStateWidth ) << " state |"
	<< setw( SSLR_maxElemWidth ) << " stack |" << setw( SSLR_maxAltRightSideWidth )
	<< " action |" << setw( SSLR_maxElemWidth ) << " next |" << endl;

	//separator
	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << "|"
	<< setw( SSLR_maxElemWidth ) << "|" << setw( SSLR_maxAltRightSideWidth )
	<< "|" << setw( SSLR_maxElemWidth ) << "|" << endl;

	//initialize
	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' ) << " 0 |"
	<< setw( SSLR_maxElemWidth ) << "|" << setw( SSLR_maxAltRightSideWidth )
	<< "|" << setw( SSLR_maxElemWidth ) << "|" << endl;

	//set debug stack pointer
	SSLR_dbgSp = 0;
#endif

	//parse stack pointer
	SSLR_sp = 0;

	//start with state 0
	SSLR_push( 0 );
	SSLR_state = 0;

	//no errors yet
	SSLR_anzError = 0;
	SSLR_anzSuppressError = 0;

	//semantic actions
	SSLR_semAct = true;

	//stack counter for semantic action stack
	SSLR_semStackCnt = 0;
}


int SSLRParser::SSLR_getTerminal( void )
{
	//semantic actions allowed?
	if( SSLR_semAct == true )
	{
		//semantic stack overflow?
		if( SSLR_semStackCnt >= SSLR_maxStackSize )
		{
			//yes, print an error message
			cerr << "SSLRParser::SSLR_getTerminal: Semantic stack overflow!" << endl;

			//no more semantic actions allowed
			SSLR_semAct = false;
		}

		else
			//push attribute on stack for semantic actions
			SSLR_semStack[SSLR_semStackCnt++] = SSLR_attributeStr;
	}

	//get line
	SSLR_line = SSLR_scanner->getYYLineno();

	//get next terminal
	SSLR_terminal = SSLR_scanner->yyLex( &SSLR_attributeStr );

	//return terminal
	return( SSLR_terminal );
}


int SSLRParser::yyParse( void )
{
	//start parsing

	//get first terminal
	SSLR_terminal = SSLR_getTerminal();

	//start parsing
	return( SSLR_parse() );
}


void SSLRParser::SSLR_push( long ast )
{
	//push a new state on the parse stack
	SSLR_stack[SSLR_sp++] = ast;

	//stack overflow?
	if( SSLR_sp > SSLR_maxStackSize )
	{
		//stack-overflow
		cerr << "SSLRParser::SSLR_push: stack overflow!\nExiting..." << endl;
		exit( 1 );
	}

	//set new state
	SSLR_state = ast;
}


long SSLRParser::SSLR_pop( int anz )
{
	//pop anz elements from the parse stack
	SSLR_sp -= anz;

	//stack underflow?
	if( SSLR_sp < 0 )
	{
		//stack underflow
		cerr << "SSLRParser::SSLR_pop: stack underflow!\nExiting..." << endl;
		exit( 1 );
	}

	//return new state
	return( SSLR_stack[SSLR_sp - 1] );
}


int SSLRParser::SSLR_parse( void )
{
	//begin parsing
	while( 1 )
	{
		//end of parsing?
		if( ( SSLR_state == 1 ) && ( SSLR_terminal == ACCEPT ) )
			//return number of errors
			return( SSLR_anzError );

		//shift terminal SSLR_terminal?
		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_SHIFT )
		{
			//yes
			SSLR_shift( &SSLR_lrTab[SSLR_state][SSLR_terminal] );

			//get new terminal
			SSLR_terminal = SSLR_getTerminal();
		}

		//reduce with production?
		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_REDUCE )
			//reduce
			SSLR_reduce( &SSLR_lrTab[SSLR_state][SSLR_terminal] );

		//otherwise an error occured
		else
			//call error recovery
			SSLR_error();
	}
}


void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )
{
	//shift a terminal onto the parse stack

	//reduce number of error messages to supress?
	if( SSLR_anzSuppressError )
		//yes, until it is zero
		SSLR_anzSuppressError--;

#ifdef SSLR_DEBUG
	//debug stack overflow?
	if( SSLR_dbgSp >= SSLR_maxStackSize )
	{
		//debug stack overflow
		cerr << "SSLRParser::SSLR_shift: Debug stack overflow!" << endl;

		//exit
		exit( 1 );
	}

	//set debug stack
	SSLR_dbgStack[SSLR_dbgSp].elem = true;
	SSLR_dbgStack[SSLR_dbgSp++].index = SSLR_terminal;

	//output
	SSLR_outputDbgStack( SSLR_state, LR_SHIFT, SSLR_terminal, SSLR_terminal );
#endif

	//shift a new state onto the stack
	SSLR_push( tab->value );
}


void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )
{
	//reduce with production
	SSLR_NTERM_STR	*n;

	//perform a semantic action accociated with the reduced production
	SSLR_doSemAct( tab );

	//get a pointer to the alternative
	n = &SSLR_ntermStr[tab->value];

#ifdef SSLR_DEBUG
	//pop elements from debug stack
	SSLR_dbgSp -= n->elem;

	//debug stack overflow?
	if( SSLR_dbgSp >= SSLR_maxStackSize )
	{
		//debug stack overflow
		cerr << "SSLRParser::SSLR_reduce: Debug stack overflow!" << endl;

		//exit
		exit( 1 );
	}

	//set debug stack
	SSLR_dbgStack[SSLR_dbgSp].elem = false;
	SSLR_dbgStack[SSLR_dbgSp++].index = tab->value;

	//output
	SSLR_outputDbgStack( SSLR_state, LR_REDUCE, tab->value, SSLR_terminal );
#endif

	//remove states form stack
	SSLR_state = SSLR_pop( n->elem );

	//get new state
	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];

	//push new state on stack
	SSLR_push( SSLR_state );
}


#ifdef SSLR_DEBUG
void SSLRParser::SSLR_outputDbgStack( int state, int action, int index, int next )
{
	//print the debugging stack
	char	statePuf[SSLR_maxStateWidth + 1];
	char	stackPuf[SSLR_maxElemWidth + 1];
	char	actionPuf[SSLR_maxAltRightSideWidth + 1];
	char	nextPuf[SSLR_maxElemWidth + 1];
	int		stackIndex, i;

	//curent state in string
	sprintf( statePuf, "%d", SSLR_state );

	//print first element
	stackIndex = SSLR_dbgStack[0].index;

	//terminal?
	if( SSLR_dbgStack[0].elem == true )
		//terminal
		sprintf( stackPuf, "%s", SSLR_termName[stackIndex] );

	else
		//is nonterminal
		sprintf( stackPuf, "%s", SSLR_ntermStr[stackIndex].name );

	//action
	if( action == LR_SHIFT )
	{
		//shift state
		sprintf( actionPuf, "push %s", SSLR_termName[index] );


		//next is empty
		sprintf( nextPuf, "%s", " " );
	}

	else
	{
		SSLR_NTERM_STR	*str = &SSLR_ntermStr[index];
		int				i;

		//reduce with alternative
		sprintf( actionPuf, "reduce with " );

		//print name of alternative
		strcat( actionPuf, str->name );
		strcat( actionPuf, " -> " );

		//print all elements on the right side
		for( i = 0; i < str->elem; i++ )
		{
			//print element
			strcat( actionPuf, str->ri[i] );

			//more elements?
			if( i < ( str->elem - 1 ) )
				//yes
				strcat( actionPuf, " " );
		}

		//alternatives with zero elements have EPSILON on the right side
		if( !str->elem )
			//print EPSILON
			strcat( actionPuf, str->ri[0] );

		//next is the current terminal
		sprintf( nextPuf, "%s", SSLR_termName[next] );
	}

	//separator
	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << "|"
	<< setw( SSLR_maxElemWidth ) << "|" << setw( SSLR_maxAltRightSideWidth )
	<< "|" << setw( SSLR_maxElemWidth ) << "|" << endl;

	//initialize
	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )
	<< ( string( statePuf ) + " |" )
	<< setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + " |" )
	<< setw( SSLR_maxAltRightSideWidth ) << ( string( actionPuf ) + " |" )
	<< setw( SSLR_maxElemWidth ) << ( string( nextPuf ) + " |" ) << endl;



	//print all other debug stack entries
	for( i = 1; i < SSLR_dbgSp; i++ )
	{
		//print element
		stackIndex = SSLR_dbgStack[i].index;

		//terminal?
		if( SSLR_dbgStack[i].elem == true )
			//terminal
			sprintf( stackPuf, "%s", SSLR_termName[stackIndex] );

		else
			//is nonterminal
			sprintf( stackPuf, "%s", SSLR_ntermStr[stackIndex].name );

		cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )
		<< "|" << setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + " |" )
		<< setw( SSLR_maxAltRightSideWidth ) << "|"
		<< setw( SSLR_maxElemWidth ) << "|" << endl;
	}
}
#endif


void SSLRParser::SSLR_doSemAct( SSLR_LR_TAB *tab )
{
	//do semantic actions before reduction
	SSLR_NTERM_STR	*n;
	SSLR_TYPE		tmp;

	//semantic actions allowed?
	if( SSLR_semAct == true )
	{
		//get a pointer to the alternative
		n = &SSLR_ntermStr[tab->value];

		//Alternative to reduce with
		switch( tab->value )
		{
			// goal ->  initSSLR  sect1  sect2 .
			case goal_0:
			{

	//die komplette Eingabe wurde erfolgreich geparst, nun die LR-Tabellen erzeugen

	//Meldung?
	if( argv_str->verbose )
		//ja, start-Produktion nicht mitzählen
		cout << "sslr: " << prod_anz - 1 << " productions analyzed!" << endl;

	//(Nicht)Terminale checken
	err += checkAll();

	//die PROD2_STR sortieren
	sortProd2Str();

	//finde doppelte Alternativen innerhalb einer Produktion
	err += findDoubleAlt();

	//alles OK?
	if( !err && !SSLR_anzError )
	{
		//Grammatik ausgeben
		outputGrammar();

		//FIRST-Mengen berechnen
		genAllFirst();

		//FOLLOW-Mengen berechnen
		genAllFollow();

		//welchen Parser-Typ erzeugen?
		if( argv_str->type == SSLR_SLR )
			//SLR-Parser erzeugen
			genLR0Hulle();

		else if( argv_str->type == SSLR_LALR )
		{
#ifndef LR2LALR
			//LALR-Parser erzeugen
			genLR0Hulle();

			//Die Lookaheads erzeugen
			genLALR();
#else
			/*
				Es gibt zu Debuggingzwecken auch die Möglichkeit, erst die LR(1)-Items zu erzeugen,
				und dann diese zu den LALR-Items zusammenzufassen.
			*/

			//LR(1)-Hüllen erzeugen
			genLR1Hulle();

			//LR(1)-Hüllen in LR(0)-Hüllen mit Lookaheads
			LR2LALR();
#endif
		}

		else if( argv_str->type == SSLR_LR )
			//LR-Parser erzeugen
			genLR1Hulle();

		//LR-Tabelle erzeugen
		LRTab();


		//die Fehleranweisungen verarbeiten
		processErrorStr();

		//die ERROR_STR prüfen
		checkErrorStr();


		//Hüllen ausgeben?
		if( argv_str->showHulle )
		{
			//Zeiger auf HULLE_STR
			HULLE_STR	*h;

			//Hüllen ausgeben
			for( unsigned long i = 0; i < hulle_anz; i++ )
			{
				//Zeiger auf Hülle
				h = hulle_str[i];

				//ausgeben
				outputHulle( h );
			}
		}

		//Quell-Files des Parsers erzeugen
		generateFiles();

		//prüfen, ob mit allen Alternativen reduziert wurde
		checkAllReduce();
	}

	else
		//Abbruch-Meldung ausgeben
		cerr << "\n\nsslr: Aborting..." << endl;

	//das war's
//	return( err );
				break;
			}

			// initSSLR ->  'EPSILON' .
			case initSSLR_0:
			{

	//hier wird SSLR initialisiert

	/*
		Terminalen wird per %left, %right, %nonassoc eine Assoziativität sowie eine
		Priorität zugewiesen. Je später ein Terminal erscheint, deste höher ist seine
		Priorität, z.b.

		%left ADD SUB
		%right MUL DIV

		ADD und SUB haben gleiche Priorität und sind links-assoziativ, wohingegen MUL und DIV
		rechts-assoziativ sind und höhere Priorität haben.
	*/
	priority = 0;

	/*
		Die Priorität eines Terminals wird indirekt durch %left/%right angegeben: Je tiefer die
		Angabe steht, desto größer ist die Priorität des Terminals.
	*/
	priLine = 0;


	/*
		Wenn eingebettete semantische Aktionen auftreten, oder EBNF-Symbole benutzt werden,
		so wird dafür auf der rechten Seite ein dummy-Nicht-Terminal auxsym eingetragen.
	*/
	auxsym_count = 1;


	//noch keine Fehler
	err = 0;

	//es wurde noch keine %union-Struktur angegeben
	unionDef = false;

	/*
		Bei der Verwendung von EBNF-Symbolen treten Hierachien auf,
		für die diverse Informationen gesichert werden müssen.
	*/
	ebnfStack = new( EBNF_STACK[100] );

	//Stack-Pointer für den EBNF-Stack
	ebnfSP = 0;


	/*
		Bei der Verwendung von eingebetteten semantischen Aktionen
		sowie bei der verwendung von EBNF-Symbolen müssen
		dummy-Nichtterminale eingeschoben werden, die hier
		auxsym heissen.
	*/
	auxsym = new( char[11] );

	//Zähler für die Anzahl der auxsym-Nichtterminale
	auxsym_count = 1;



	//Speicher für die %union-Angabe
	unionStr = new( UNION_STR );
	memset( unionStr, 0, sizeof( UNION_STR ) );


	//falls kein semantischer Typ angegeben wird
	insertUnion( "", "" );

	//keine semantische Aktion
	semAct = false;

	//Start-Produktion eintragen
	insertStartProd( prod_index, prod2_index );
				break;
			}

			// union ->  startUnion  'BOPEN'  unionBody  'BCLOSE' .
			case union_0:
			{

	/*
		Den Inhalt der %union-Angabe merken, denn dieser wird später unverändert ins Header-File
		des generierten Parsers aufgenommen. Das dieser hier geparst wird liegt daran, dass die Typen
		ja in %ntermDef/%termDef benutzt werden, und dies wird geprüft.
	*/
	unionStr->text = SSLR_semStack[SSLR_semStackCnt - 1 - 4 + (1)].name;
				break;
			}

			// startUnion ->  'UNION' .
			case startUnion_0:
			{

	//es wurde eine %union-Struktur angegeben
	unionDef = true;

	//den Inhalt der %union-Angabe weitergeben
	tmp.name = SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name;
				break;
			}

			// unionBody2 ->  'TYPE'  'IDENT' .
			case unionBody2_0:
			{

	//einen neuen Eintrag in der unionStr eintragen
	insertUnion( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (1)].name, SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name );

				break;
			}

			// unionBody2 ->  'TYPE'  'AST'  'IDENT' .
			case unionBody2_1:
			{

	//einen neuen Eintrag in der unionStr eintragen
	insertUnion( SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (1)].name, SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (3)].name );
				break;
			}

			// ntermDef ->  'NTERM_TYPE' .
			case ntermDef_0:
			{

		//Nicht-Terminal
		typeDef = SSLR_NTERM;
				break;
			}

			// ntermDef ->  'TERM_TYPE' .
			case ntermDef_1:
			{

		//Terminal
		typeDef = SSLR_TERM;
				break;
			}

			// semType ->  'semTypeOpen'  'IDENT'  'semTypeClose' .
			case semType_0:
			{

	/*
		In $2 steht eine Zeichenkette (<name>), die den semantischen Typ
		gem. der %union-Angabe enthält.
	*/

	//Typ für semantische Aktion, sollte in %union definiert sein.

	//%union schon angegeben?
	if( !unionDef )
	{
		//nein
		cerr << "sslr: ERROR: line " << SSLR_line << ": %union missing!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//den Eintrag in unionStr finden
		if( ( semIndex = getSemIndex( SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (2)].name ) ) < 0 )
		{
			//Typ nicht in %union definiert
			cerr << "sslr: ERROR: line " << SSLR_line << ": Type for semantic action " << SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (2)].name << " not defined in %union!" << endl;

			//Fehler
			err++;
		}
	}
				break;
			}

			// semType ->  'EPSILON' .
			case semType_1:
			{

	//ohne Angabe von semantischen Typen, Warnung ausgeben
	cerr << "sslr: line " << SSLR_line << ": No semantic type given!" << endl;
				break;
			}

			// associativity ->  'LEFT_ASSOC' .
			case associativity_0:
			{

	//links-assoziativ
	assocDef = LEFT_ASSOC;
				break;
			}

			// associativity ->  'RIGHT_ASSOC' .
			case associativity_1:
			{

	//rechts-assoziativ
	assocDef = RIGHT_ASSOC;
				break;
			}

			// associativity ->  'NON_ASSOC' .
			case associativity_2:
			{

	//nicht-assoziativ
	assocDef = NON_ASSOC;
				break;
			}

			// namelist1 ->  namelist1  'IDENT' .
			case namelist1_0:
			{

	int	type;

	//ist es ein reserviertes Terminal?
	if( ( typeDef == SSLR_TERM ) && !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name, "LALR" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	else if( ( typeDef == SSLR_NTERM ) && !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Element in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name );

		//für Fehlerbehandlung merken
		setCheck( hash_index );

		//%termType: Terminal wird definiert
		//%ntermType: Nicht-Terminal wird definiert
		hash_tab->setDefined( hash_index, SSLR_line );

		//Index des Eintrags in unionStr in die Hash-Tabelle eintragen
		hash_tab->setUnionType( hash_index, semIndex );

		//ist es ein Terminal oder ein Nicht-Terminal?
		if( typeDef == SSLR_TERM )
		{
			//ist ein Terminal
			type = hash_tab->setType( hash_index, SSLR_TERM );

			//etwa schon als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nichtterminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}

		else
		{
			//ist ein Nicht-Terminal
			type = hash_tab->setType( hash_index, SSLR_NTERM );

			//etwa schon als Terminal definiert?
			if( type != SSLR_NTERM )
			{
				//Fehler, Nicht-Terminal wurde schon als Terminal definiert

				//Name des Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}
	}
				break;
			}

			// namelist1 ->  'IDENT' .
			case namelist1_1:
			{

	int	type;

	//ist es ein reserviertes Terminal?
	if( ( typeDef == SSLR_TERM ) && !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name, "LALR" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	else if( ( typeDef == SSLR_NTERM ) && !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Element in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

		//für Fehlerbehandlung merken
		setCheck( hash_index );

		//%termType: Terminal wird definiert
		//%ntermType: Nicht-Terminal wird definiert
		hash_tab->setDefined( hash_index, SSLR_line );

		//Index des Eintrags in unionStr in die Hash-Tabelle eintragen
		hash_tab->setUnionType( hash_index, semIndex );

		//ist es ein Terminal oder ein Nicht-Terminal?
		if( typeDef == SSLR_TERM )
		{
			//ist ein Terminal
			type = hash_tab->setType( hash_index, SSLR_TERM );

			//etwa schon als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nichtterminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}

		else
		{
			//ist ein Nicht-Terminal
			type = hash_tab->setType( hash_index, SSLR_NTERM );

			//etwa schon als Terminal definiert?
			if( type != SSLR_NTERM )
			{
				//Fehler, Nicht-Terminal wurde schon als Terminal definiert

				//Name des Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}
	}
				break;
			}

			// namelist2 ->  namelist2  'IDENT' .
			case namelist2_0:
			{

	//in assocDef steht die Assoziativität dieses Terminals
	long	tmpPriority;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name );

	//Terminal wird definiert
//	hash_tab->setDefined( hash_index, SSLR_line );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Assoziativität eintragen
	hash_tab->setAssociation( hash_index, assocDef );

	//Priorität erhöhen
	if( SSLR_line > priLine )
	{
		//ja, erhöhen
		priority++;
		priLine = SSLR_line;
	}

	//Priorität eintragen
	tmpPriority = hash_tab->setPriority( hash_index, priority );

	//wurde die Priorität des Terminals bereits festgesetzt?
	if( tmpPriority != priority )
	{
		//ja, doppeltes Auftreten

		//Name des Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Priority for terminal " << name << " already set!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// namelist2 ->  'IDENT' .
			case namelist2_1:
			{

	//in assocDef steht die Assoziativität dieses Terminals
	long	tmpPriority;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

	//Terminal wird definiert
//	hash_tab->setDefined( hash_index, SSLR_line );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Assoziativität eintragen
	hash_tab->setAssociation( hash_index, assocDef );

	//Priorität erhöhen
	if( SSLR_line > priLine )
	{
		//ja, erhöhen
		priority++;
		priLine = SSLR_line;
	}

	//Priorität eintragen
	tmpPriority = hash_tab->setPriority( hash_index, priority );

	//wurde die Priorität des Terminals bereits festgesetzt?
	if( tmpPriority != priority )
	{
		//ja, doppeltes Auftreten

		//Name des Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Priority for terminal " << name << " already set!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// sc2 ->  sc2  sslrRule  'END_OF_PRODUCTION' .
			case sc2_0:
			{

	/*
		Es folgt eine neue Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Anzahl der Alternativen dieser Produktion eintragen
	prod_str[prod_index].altAnz = altCount;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// sc2 ->  sslrRule  'END_OF_PRODUCTION' .
			case sc2_1:
			{

	/*
		Es folgt eine neue Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Anzahl der Alternativen dieser Produktion eintragen
	prod_str[prod_index].altAnz = altCount;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// newProduction ->  'IDENT' .
			case newProduction_0:
			{

	//es folgt eine Produktion

	//Produktion in die Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//Produktion wurde definiert
	if( hash_tab->setProdDef( hash_index ) < 0 )
	{
		//die Produktion wurde bereits definiert
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung ausgeben
		cerr << "sslr: ERROR: line " << SSLR_line << ": Production " << name << " already defined!" << endl;

		//Fehler
		err++;
	}

	/*
		Wenn dies die erste Produktion ist, dann diese in die rechte Seite der
		Start-Produktion "start" eintragen.
	*/
	if( !prod_index )
	{
		//ja, eintragen
		insertElement( prod_index, prod2_index, hash_index );

		//eine Alternative
		prod_str[prod_index].altAnz = 1;

		//Produktion wurde benutzt
		hash_tab->setUsed( hash_index );
	}


	//Start-Produktion "start" nicht erlaubt
	if( !strcmp( hash_tab->getName( hash_index ), "start" ) )
	{
		//Fehler
		err++;

		//Meldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Production start reserved!" << endl;
	}



	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index der Produktion eintragen
	prod_str[prod_index].hash_index = hash_index;

	//ist ein Nichtterminal
	int type = hash_tab->setType( hash_index, SSLR_NTERM );

	//vorher schon mal als Terminal definiert?
	if( type != SSLR_NTERM )
	{
		//Fehler, Produktion wurde schon als Terminal definiert

		//Name des Nicht-Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Nonterminal " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

		//Fehler
		err++;
	}

	//PROD2_STR anfordern, für die nächste Alternative
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;

	//Meldung ausgeben
	if( argv_str->verbose )
		cout << "sslr: line " << SSLR_line << ": Analyze " << SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name << "..." << endl;
				break;
			}

			// newAlternative ->  'NEW_ALTERNATIVE' .
			case newAlternative_0:
			{

	/*
		Es folgt eine neue Alternative zu einer bestehenden Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//nächste Produktion
	altCount++;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}

	//PROD2_STR für eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;
				break;
			}

			// item3 ->  'TERMINAL' .
			case item3_0:
			{

	//Terminal auf rechte Seite der aktuellen Alternative prod2_index eintragen

	//ist es ein reserviertes Terminal?
	if( !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name, "LALR" ) )
	{
		//nein, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Terminal in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

		//ist es ein EPSILON, dass nicht als erstes Element auf der rechten Seite steht?
		if( ( prod2_str[prod2_index].riAnz ) && ( hash_index == epsHashIndex ) )
		{
			//Fehler
			cerr << "sslr: ERROR: line " << SSLR_line << ": EPSILON must always be the only element on the right side!" << endl;

			//Fehler
			err++;
		}

		else
		{
			//semantische Aktion vorher eintragen?
			if( semAct == true )
			{
				//ja
				insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

				//zurücksetzen
				semAct = false;
			}

			//für Fehlerbehandlung merken
			setCheck( hash_index );

			//Terminal benutzt
			hash_tab->setUsed( hash_index );

			//Terminal in rechte Seite der aktuellen Alternative eintragen
			insertElement( prod_index, prod2_index, hash_index );

			//ist ein Terminal
			int type = hash_tab->setType( hash_index, SSLR_TERM );

			//wurde das Terminal früher bereits als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nicht-Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}

			//Priorität der Alternative ist die des am weitesten rechts stehenden Terminals
			prod2_str[prod2_index].priority = hash_tab->getPriority( hash_index );
		}
	}
				break;
			}

			// item3 ->  'NON_TERMINAL' .
			case item3_1:
			{

	//Nicht-Terminal auf rechte Seite der Alternative eintragen

	//gibt es eine semantische Aktion, die einzutragen ist, bevor das Nicht-Terminal eingetragen wird?
	if( semAct == true )
	{
		//ja, es gibt eine eingebettete semantische Aktion
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	if( !strcmp( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Nicht-Terminal in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

		//für Fehlerbehandlung merken
		setCheck( hash_index );

		//Nicht-Terminal benutzt
		hash_tab->setUsed( hash_index );

		//ist ein Nicht-Terminal
		int type = hash_tab->setType( hash_index, SSLR_NTERM );

		//wurde das Nicht-Terminal vorher als Terminal definiert?
		if( type != SSLR_NTERM )
		{
			//Fehler, Nicht-Terminal wurde schon als Terminal definiert

			//Name des Nichtterminals
			char *name = hash_tab->getName( hash_index );

			//Fehlermeldung
			cerr << "sslr: ERROR: line " << SSLR_line << ": Nonterminal " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

			//Fehler
			err++;
		}

		//Nicht-Terminal in rechte Seite der Alternative prod2_index eintragen
		insertElement( prod_index, prod2_index, hash_index );
	}
				break;
			}

			// semanticAction ->  'SEMACT' .
			case semanticAction_0:
			{

	//eine Alternative ist mit einer semantischen Aktion verbunden

	//%union schon angegeben?
	if( !unionDef )
	{
		//Nein
		cerr << "sslr: ERROR: line " << SSLR_line << ": Semantic action useless without %union!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//schon eine semantische Aktion in der Struktur, d.h. doppeltes Auftreten?
		if( semAct == true )
		{
			//doppelte semantische Aktion
			cerr << "sslr: ERROR: line " << SSLR_line << ": Double semantic action!" << endl;

			//Fehler
			err++;
		}

		else
		{
			//semantische Aktionen übertragen
			semActStr.semAct = SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name;

			//Zeile merken
			semActStr.line = SSLR_line;

			//semantische Aktion wurde definiert
			semAct = true;

			//Zähler
			semActCnt++;
		}
	}
				break;
			}

			// ebnfKLOpen ->  'KLOPEN' .
			case ebnfKLOpen_0:
			{

	/*
		Hier wird das EBNF-Symbol ( benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 ( 'TERM1' | 'TERM2' ) prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym1 prod3
				;

		auxsym1
				:	'TERM1'
				|	'TERM2'
				;
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist eine eingebettete semantische Aktion
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
				break;
			}

			// ebnfBOpen ->  'BOPEN' .
			case ebnfBOpen_0:
			{

	/*
		Hier wird das EBNF-Symbol { benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 { 'TERM1' | 'TERM2' } prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym_1 prod3
				;

		auxsym_1
				:	'TERM1' auxsym_1
				|	'TERM2' auxsym_1
				|	'EPSILON'
				;

		{} bedeutet also beliebig oft.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}


	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );


	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
				break;
			}

			// ebnfEOpen ->  'EOPEN' .
			case ebnfEOpen_0:
			{

	/*
		Hier wird das EBNF-Symbol [ benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 [ 'TERM1' | 'TERM2' ] prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym1 prod3
				;

		auxsym1
				:	'TERM1'
				|	'TERM2'
				|	'EPSILON'
				;

		[] bedeutet also optional, also einmal oder keinmal.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
				break;
			}

			// ebnfKLClose ->  'KLCLOSE' .
			case ebnfKLClose_0:
			{

	//schliessendes EBNF-Symbol )

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols )!" << endl;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;

	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
				break;
			}

			// ebnfBClose ->  'BCLOSE' .
			case ebnfBClose_0:
			{

	//schliessendes EBNF-Symbol }
	long	baseProd2Index, count;

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols }!" << endl;


	//prod2_index der ersten Alternative der Produktion
	baseProd2Index = prod_str[prod_index].prod2_index;

	//nun das auxsym selbst als letztes Element auf rechter Seite eintragen,
	//damit beliebiges Ausführen möglich ist
	for( count = baseProd2Index; count < ( baseProd2Index + altCount ); count ++ )
		//auxsym auf rechter Seite eintragen
		insertElement( prod_index, count, prod_str[prod_index].hash_index );


	/*
		Nun EPSILON als Alternative in die aktuelle Produktion eintragen, da {} ja
		belibieg oft bedeutet.
	*/
	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//EPSILON in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//EPSILON ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen
	altCount++;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;


	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
				break;
			}

			// ebnfEClose ->  'ECLOSE' .
			case ebnfEClose_0:
			{

	//schliessendes EBNF-Symbol ]

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols ]!" << endl;


	/*
		Nun EPSILON als Alternative in die aktuelle Produktion eintragen, da [] ja
		optional bedeutet.
	*/
	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//EPSILON in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//EPSILON ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen
	altCount++;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;


	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
				break;
			}

			// precedence ->  'PREC'  'TERMINAL' .
			case precedence_0:
			{

	/*
		Man kann durch Angabe von %prec die Prioriät des Terminals auf die
		Priorität der aktuellen Alternative übertragen.
	*/

	//Zeiger auf PROD_STR
	PROD_STR *p1 = &prod_str[prod_index];

	//Hash-Index des Terminals holen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 2 + (2)].name );

	//wurde dem Terminal überhaupt mittels %left/%right/%nonassoc eine Priorität zugewiesen?
	if( hash_tab->getPriority( hash_index ) != -1 )
	{
		//ja, Terminal wird benutzt
		hash_tab->setUsed( hash_index );

		//Priorität der aktuellen Alternative holen
		int pri = prod2_str[prod2_index].priority;

		//Priorität der Alternative > Priorität des Terminals?
		if( pri <=  hash_tab->getPriority( hash_index ) )
		{
			//nein, übernehmen
			int	pPriority = hash_tab->getPriority( hash_index );

			//Priorität der aktuellen Alternative setzen
			prod2_str[prod2_index].priority = pPriority;
		}

		else
			//Meldung
			cerr << "sslr: Warning: line " << SSLR_line << ": Priority of " << hash_tab->getName( p1->hash_index ) << " > than priority of " << hash_tab->getName( hash_index ) << "!" << endl;
	}

	else
	{
		//dem Terminal wurde keine Priorität zugewiesen
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": %prec used but terminal " << name << " was not assigned a priority!" << endl;

		//Fehler
		err++;
	}
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  termList  'DB'  errorMsg .
			case errorBody2_0:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 5 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 5 + (5)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  termList  'DB'  errorAction  'DB'  errorMsg .
			case errorBody2_1:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 7 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 7 + (7)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  negTerm  'KLOPEN'  termList  'KLCLOSE'  'DB'  errorMsg .
			case errorBody2_2:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 8 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 8 + (8)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  negTerm  'KLOPEN'  termList  'KLCLOSE'  'DB'  errorAction  'DB'  errorMsg .
			case errorBody2_3:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 10 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 10 + (10)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  errorAction  'DB'  errorMsg .
			case errorBody2_4:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 5 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 5 + (5)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// errorBody2 ->  initBeforeNumber  'DB'  errorMsg .
			case errorBody2_5:
			{

	//Position des Punktes
	errorStr->dot = SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (1)].integer;

	//Fehlermeldung
	errorStr->msg = SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (3)].name;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
				break;
			}

			// initBeforeNumber ->  'NUMBER' .
			case initBeforeNumber_0:
			{

	//es folgt eine Fehleranweisung

	//eine ERROR_STR anfordern
	errorIndex = getErrorStr();

	//Zeiger auf die ERROR_STR
	errorStr = &error_str[errorIndex];

	//Index der Produktion eintragen
	errorStr->prod_index = prod_index;

	//Index der Alternative in PROD2_STR eintragen
	errorStr->prod2_index = prod2_index;

	//die Zeile merken
	errorStr->line = SSLR_line;

	//Terminal-Angaben nicht negieren
	errorNeg = false;

	//Position des Punktes
	tmp.integer = SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].integer;
				break;
			}

			// negTerm ->  'NOT' .
			case negTerm_0:
			{

	//Terminal-Angaben negieren
	errorNeg = true;
				break;
			}

			// termList ->  termList  'COMMA'  'TERMINAL' .
			case termList_0:
			{

	//Index des Terminals holen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 3 + (3)].name );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//negieren?
	if( errorNeg == true )
		//ERRTERM_STR in errorStr eintragen
		insertErrTermStr( errorStr, hash_index, 1 );

	else
		//nicht negieren
		insertErrTermStr( errorStr, hash_index, 0 );
				break;
			}

			// termList ->  'TERMINAL' .
			case termList_1:
			{

	//Index des Terminals holen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//negieren?
	if( errorNeg == true )
		//ERRTERM_STR in errorStr eintragen
		insertErrTermStr( errorStr, hash_index, 1 );

	else
		//nicht negieren
		insertErrTermStr( errorStr, hash_index, 0 );
				break;
			}

			// errorAction2 ->  'OVERREAD'  'KLOPEN'  'TERMINAL'  'KLCLOSE' .
			case errorAction2_0:
			{

	//Terminale in der Eingabe löschen, nis das Terminal geschoben werden darf

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 4 + (3)].name );

	//schon in der ERROR_STR enthalten?
	if( errorStr->overread )
		//es war schon eine OVERREAD(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used overread(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->overread = hash_index;
				break;
			}

			// errorAction2 ->  'SHIFT'  'KLOPEN'  'TERMINAL'  'KLCLOSE' .
			case errorAction2_1:
			{

	//ein Terminal auf den Parse-Stack schieben

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 4 + (3)].name );

	//schon in der ERROR_STR enthalten?
	if( errorStr->shift )
		//es war schon eine SHIFT(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used shift(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->shift = hash_index;
				break;
			}

			// errorAction2 ->  'POP'  'KLOPEN'  'TERMINAL'  'KLCLOSE' .
			case errorAction2_2:
			{

	//Zustände vom Parse-Stack löschen, bis Terminal geschoben werden darf

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( SSLR_semStack[SSLR_semStackCnt - 1 - 4 + (3)].name );

	//schon in der ERROR_STR enthalten?
	if( errorStr->pop )
		//es war schon eine POP(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used pop(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->pop = hash_index;
				break;
			}

			// errorAction2 ->  'EXIT' .
			case errorAction2_3:
			{

	//das Parsen abbrechen
	if( errorStr->exit++ )
		//wurde schon einmal verwendet
		cerr << "sslr: Warning: line " << SSLR_line << ": EXIT already used!" << endl;

				break;
			}

			// errorAction2 ->  'DELETE' .
			case errorAction2_4:
			{

	//es soll der nächste Eingebesymbol aus der Eingabe entfernt werden
	errorStr->del++;
				break;
			}

			// errorAction2 ->  'SEM' .
			case errorAction2_5:
			{

	//semantische Aktionen trotz Fehlers weiterführen
	if( errorStr->sem++ )
		//schon eingetragen
		cerr << "sslr: Warning: line " << SSLR_line << ": SEM already used!" << endl;
				break;
			}

			// errorMsg ->  'STRING' .
			case errorMsg_0:
			{

		//Fehlermeldung zurückliefern
		tmp.name = SSLR_semStack[SSLR_semStackCnt - 1 - 1 + (1)].name;
				break;
			}

			// errorMsg ->  'EPSILON' .
			case errorMsg_1:
			{

		//es wurde keine Fehlermeldung angegeben
		tmp.name = 0L;
				break;
			}

//			default:
				//error
//				cerr << "SSLRParser::SSLR_doSemAct: Unknown alternative " << tab->value << "!" << endl;
		}

		//correct stack pointer
		SSLR_semStackCnt -= n->elem;

		//semantic stack overflow?
		if( SSLR_semStackCnt >= SSLR_maxStackSize )
		{
			//yes, print an error message
			cerr << "SSLRParser::SSLR_doSemAct: Semantic stack overflow!" << endl;

			//no more semantic actions allowed
			SSLR_semAct = false;
		}

		else
			//push last value on stack
			SSLR_semStack[SSLR_semStackCnt++] = tmp;
	}
}




	//Hilfsroutinen für SSLR


void SSLRParser::giveArgs( ARGV_STR *argv )
{
	/*
		Diese Funktion dient der Übergabe der Kommandozeilen-Argumente, die
		SSLR steuern.
	*/

	//Argumente
	argv_str = argv;
}


void SSLRParser::init( void )
{
	/*
		Diese Routine wird vom Konstruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	anzCheck = 0;
	check = 0L;
	prod_anz = 0;
	prod_str = 0L;
	prod2_anz = 0;
	prod2_str = 0L;
	error_anz = 0;
	error_str = 0L;
	hulle_str = 0L;
	hulle_anz =  0;
	coreAnz = 0;
	srError = 0;
	rrError = 0;
	semActCnt = 0;
	termArr = 0L;
	ntermArr = 0L;
	unionStr = 0L;
	lrTab = 0L;
	jumpTab = 0L;
	hash_tab = 0L;
	auxsym = 0L;
	ebnfStack = 0L;

	//Speicher für die Hash-Tabelle anfordern
	hash_tab = new( hashClass );
}


void SSLRParser::deinit( void )
{
	/*
		Diese Routine wird vom Destruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	int	i;

	//Speicher freigeben
	delete( hash_tab );

	//Speicher für die %union-Angabe freigeben?
	if( unionStr )
	{
		//alle Einträge
		for( i = 1; i < unionStr->anz; i++ )
		{
			//Typ und Name der deklarierten Variable freigeben
			delete[] ( unionStr->type[i] );
			delete[] ( unionStr->id[i] );
		}

		//Speicher für die Struktur freigeben
		delete[] ( unionStr->type );
		delete[] ( unionStr->id );
		delete( unionStr );
	}

	if( auxsym )
		delete[] ( auxsym );


	//gab es Fehlerangaben?
	if( error_anz )
	{
		ERROR_STR	*errorStr;

		//Speicher freigeben
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr = &error_str[i];

			//hat die ERROR_STR Terminal-genbundene Fehleranweisungen?
			if( errorStr->errTermStrAnz )
				//ja, Speicher freigeben
				delete[] ( errorStr->errTermStr );

			//Speicher für die Terminale freigeben?
			if( errorStr->errTermArr )
				//ja, freigeben
				delete[] ( errorStr->errTermArr );

			//die Hüllen, die mit dieser Fehleranweisung verbunden ist, freigeben
			if( errorStr->hInd.anzArr )
				//ja, freigeben
				delete[] ( errorStr->hInd.arr );
		}

		//Speicher für die ERROR_STR selbst freigeben
		delete[] ( error_str );
	}


	//Speicher für Nicht-Terminale freigeben
	if( ntermArr )
		delete[] ( ntermArr );

	//Speicher für Terminale freigeben
	if( termArr )
		delete[] ( termArr );

	//Speicher freigeben
	if( check )
		delete[] ( check );


	//Speicher für die Produktionen freigeben
	if( prod_anz )
		//freigeben
		delete[]( prod_str );

	//Speicher für die Alternativen freigeben
	if( prod2_anz )
	{
		//alle PROD2_STR
		for( i = 0; i < prod2_anz; i++ )
		{
			//rechte Seite freigeben
			if( prod2_str[i].riAnz )
				delete[] ( prod2_str[i].right );
		}

		//PROD2_STR freigeben
		delete[]( prod2_str );
	}

	//Speicher für die Hüllen freigeben
	if( hulle_str )
	{
		HULLE_STR	*hStr;
		LR_STR		*lrStr;
		int			i, j;

		//alle Hüllen durchgehen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hülle
			hStr = hulle_str[i];

			//alle LR-Items der Hülle
			for( j = 0; j < hStr->anzElem; j++ )
			{
				//Zeiger auf LR_STR-Struktur
				lrStr = &hStr->lr_str[j];

				//Lookaheads?
				if( lrStr->la )
					//ja, freigeben
					delete( lrStr->la );

				//LALR-Lookaheads?
				if( lrStr->lalr )
					//ja, freigeben
					delete( lrStr->lalr );
			}

			//LR_STR freigeben
			delete[] ( hStr->lr_str );

			//Hülle freigeben
			delete( hStr );
		}

		//Speicher aller Hüllen-Strukturen freigeben
		delete[] ( hulle_str );
	}

	//Speicher für die Sprung-Tabelle freigeben?
	if( jumpTab )
	{
		//die jumpTab hat hulle_anz Spalten
		for( i = 0; i < hulle_anz; i++ )
			//Spalte freigeben
			delete[] ( jumpTab[i] );

		//Struktur freigeben
		delete[] ( jumpTab );
	}

	//Speicher für die LR-Tabelle freigeben?
	if( lrTab )
	{
		//die lrTab hat hulle_anz Spalten
		for( i = 0; i < hulle_anz; i++ )
			//Spalte freigeben
			delete[] ( lrTab[i] );

		//Struktur freigeben
		delete[] ( lrTab );
	}

	//Stack für die Verarbeitung von EBNF freigeben
	if( ebnfStack )
		//ja, freigeben
		delete[] ( ebnfStack );
}


void SSLRParser::insertEmbeddedSemanticAction( long prod_index, long prod2_index, long line, int &auxsymCount )
{
	//fügt ein auxsym-Nichtterminal auf rechter Seite von prod2_index ein für eine embedded semantic
	//action.
	PROD2_STR	*p2;
	long		hash_index;
	char		auxsym[11];

	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsymCount++ );

	//in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//Produktion wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//Nichtterminal wird benutzt
	hash_tab->setUsed( hash_index );

	//Nichtterminal wird definiert
	hash_tab->setDefined( hash_index, line );

	//ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );


	//auxsym-Produktion auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );


	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index des Nichtterminals eintragen
	prod_str[prod_index].hash_index = hash_index;

	//PROD2_STR anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//Zeiger auf PROD2_STR
	p2 = &prod2_str[prod2_index];

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Priorität der Produktion eintragen
	p2->priority = 0;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = 1;



	//semantische Aktion eintragen
	p2->semAct = semActStr.semAct;

	//Zeile merken
	p2->semActLine = semActStr.line;

	//ist eine embedded semantic action
	p2->isEmbeddedSemAct = true;
}


int SSLRParser::findDoubleAlt( void )
{
	//doppelte Alternativen finden
	PROD_STR	*p1;
	PROD2_STR	*p2, *p3;
	char		*name;
	int			i, j, k, l, err = 0, ri;

	//alle Produktionen
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//alle rechten Seiten
		ri = p1->altAnz;

		//alle Alternativen
		for( j = p1->prod2_index; j < ( p1->prod2_index + ri ); j++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[j];

			//alle anderen Alternativen
			for( k = j + 1; k < ( p1->prod2_index + ri ); k++ )
			{
				//Zeiger auf PROD2_STR
				p3 = &prod2_str[k];

				//Anzahl der Elemente gleich?
				if( p2->riAnz == p3->riAnz )
				{
					//die rechten Seiten von p2 und p3 vergleichen
					for( l = 0; l < p2->riAnz; l++ )
					{
						//Elemente gleich?
						if( p2->right[l] != p3->right[l] )
							//nein
							break;
					}

					//gleich, wenn l = p2->riAnz
					if( l == p2->riAnz )
					{
						//die Zeilen der Laternativen holen
						long	l1 = p2->line, l2 = p3->line;

						//Alternativen sind gleich
						cerr << "sslr: ERROR: Alternativen in Zeile " << l1 << " und " << l2 << " gleich in Produktion " << name << "!" << endl;

						//Alternative ausgeben
//						outputAlt( cerr, k );

						//Fehler
						err++;
					}
				}
			}
		}
	}

	//zurück
	return( err );
}


int SSLRParser::getErrorStr( void )
{
	//erzeuge eine neue ERROR_STR und liefere den Index zurück
	ERROR_STR	*tmp;

	//eine neue ERROR_STR anfordern
	tmp = new( ERROR_STR[error_anz + 1] );

	//Inhalt kopieren
	memmove( tmp, error_str, sizeof( ERROR_STR ) * error_anz );

	//initalisieren
	memset( &tmp[error_anz], 0, sizeof( ERROR_STR ) );

	//alten Speicher freigeben?
	if( error_anz )
		//ja
		delete[]( error_str );

	//Adressen kopieren
	error_str = tmp;

	//Index zurückliefern
	return( error_anz++ );
}


int SSLRParser::insertErrTermStr( ERROR_STR *errStr, long terminal, int neg )
{
	//fügt eine ERRTERM_STR zu einer ERROR_STR hinzu
	ERRTERM_STR		*tmp, *tmp2;
	int				i;

	//alle ERRTERM_STR prüfen, ob das Terminal schon da ist
	for( i = 0; i < errStr->errTermStrAnz; i++ )
	{
		//Zeiger auf die ERRTERM_STR holen
		tmp = &errStr->errTermStr[i];

		//Terminle gleich?
		if( tmp->terminal == terminal )
		{
			//gleich
			cerr << "sslr: Warning: line " << errStr->line << ": Terminal " << hash_tab->getName( terminal ) << " already used in user-defined error-action!" << endl;

			//zurück
			return( -1 );
		}
	}

	//ERRTERM_STR erzeugen und zu errStr hinzufügen

	//eine neue ERRTERM_STR anfordern
	tmp = new( ERRTERM_STR[errStr->errTermStrAnz + 1] );

	//eintragen
	tmp2 = &tmp[errStr->errTermStrAnz];
	tmp2->terminal = terminal;
	tmp2->neg = neg;

	//Inhalt kopieren
	memmove( tmp, errStr->errTermStr, sizeof( ERRTERM_STR ) * errStr->errTermStrAnz );

	//Adressen
	errStr->errTermStr = tmp;

	//Index zurückliefern
	return( errStr->errTermStrAnz++ );
}


void SSLRParser::insertStartProd( long &prod_index, long &prod2_index )
{
	//Start-Produktion eintragen
	long	hash_index;

	//EPSILON eintragen
	epsHashIndex = hash_tab->insert( "EPSILON" );

	//EPSILON ist ein Terminal
	hash_tab->setType( epsHashIndex, SSLR_TERM );

	//ACCEPT eintragen
	acceptHashIndex = hash_tab->insert( "ACCEPT" );

	//ACCEPT ist ein Terminal
	hash_tab->setType( acceptHashIndex, SSLR_TERM );

	//Check-Index für LALR-Parser
	lalrHashIndex = hash_tab->insert( "LALR" );

	//das reservierte Terminal LALR ist ein Terminal
	hash_tab->setType( lalrHashIndex, SSLR_TERM );



	//Startproduktion in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "start" );

	//die Start-Produktion "start" ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//Nichtterminal wird definiert
	hash_tab->setDefined( hash_index, 0 );

	//für Fehlerbehandlung merken
//	setCheck( hash_index );

	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//Hash-Index des Nichtterminals eintragen
	prod_str[prod_index].hash_index = hash_index;

	//PROD2_STR anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;
}


void SSLRParser::setCheck( long hash_index )
{
	//Hash-Index in Liste eintragen zur allgemeinen Überprüfung
	long	i, *tmp;

	//alle durchgehen
	for( i = 0; i < anzCheck; i++ )
	{
		//gleich?
		if( check[i] == hash_index )
			//Ja
			return;

		else if( check[i] > hash_index )
		{
			//mehr Speicher
			tmp = new( long[anzCheck + 1] );

			//umkopieren
			memcpy( tmp, check, sizeof( long ) * i );
			tmp[i] = hash_index;
			memcpy( &tmp[i+1], &check[i], sizeof( long ) * ( anzCheck - i ) );

			//ein Eintrag mehr
			anzCheck++;

			//Speicher freigeben
			if( check )
				delete[] ( check );

			//Zeiger
			check = tmp;

			//Schleife verlassen
			break;
		}
	}

	//leer?
	if( i == anzCheck )
	{
		//ja, anhängen

		//mehr Speicher
		tmp = new( long[anzCheck + 1] );

		//umkopieren
		memcpy( tmp, check, sizeof( long ) * anzCheck );
		tmp[anzCheck] = hash_index;

		//ein Eintrag mehr
		anzCheck++;

		//Speicher freigeben
		if( check )
			delete[] ( check );

		//Zeiger
		check = tmp;
	}
}


int SSLRParser::checkAllReduce( void )
{
	//prüfen, ob mit allen Alternativen reduziert wurde
	/*
		Hier wird geprüft, ob
		- jemals mit einer Alternative reduziert wird
	*/
	PROD2_STR	*pStr;
	int			i, err = 0;

	//prüfen, ob mit allen Alternativen auch reduziert wurde
	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf Struktur
		pStr = &prod2_str[i];

		//wurde reduziert?
		if( pStr->reduce <= 0 )
		{
			//Nein, Warnung ausgeben
			cerr << "sslr: ERROR: Never reduced with ";

			//rechte Seite ausgeben
			outputAlt( cerr, i );

			//Fehler
			err++;
		}
	}

	//Wenn Fehler, zurückgeben
	return( err );
}


int SSLRParser::checkAll( void )
{
	/*
		Hier wird geprüft, ob
		- (Nicht)Terminale definiert wurden
		- (Nicht)Terminale benutzt wurden
		- (Nicht)Terminale schon als Terminale benutzt wurden
		- Mehrfachdefinitionen
	*/
	char	*id[3] = { "", "Terminal", "Nonterminal" }, *name;
	int		type, i, err = 0;
	int		tc = 0, nc = 0;

	//Alle eingetragenen Elemente
	for( i = 0; i < anzCheck; i++ )
	{
		//Typ holen
		type = hash_tab->getType( check[i] );

		//Terminal?
		if( type == SSLR_TERM )
			//Ja
			tc++;

		//Nichtterminal?
		else if( type == SSLR_NTERM )
			//Ja
			nc++;

		//Name holen
		name = hash_tab->getName( check[i] );

		//Definiert?
		if( !hash_tab->getDefined( check[i] ) )
		{
			//Element wurde nicht definiert
			cerr << "sslr: Warning: " << id[type] << " " << name << " not defined!" << endl;

			//Fehler
//			err++;
		}

		//benutzt?
		if( hash_tab->getUsed( check[i] ) == false )
		{
			//Element wurde nicht benutzt
			cerr << "sslr: ERROR: " << id[type] << " " << name << " not used!" << endl;

			//Fehler
			err++;
		}

		//mehrfach benutzt?
		if( hash_tab->getDefined( check[i] ) > 1 )
		{
			//Element wurde nicht benutzt
			cerr << "sslr: ERROR: " << id[type] << " " << name << " more than once defined!" << endl;

			//Fehler
			err++;
		}

		//Produktion definiert?
		if( ( type == SSLR_NTERM ) && ( hash_tab->getProdDef( check[i] ) == false ) )
		{
			//Produktion wurde nicht definiert
			cerr << "sslr: ERROR: Production " << name << " not defined!" << endl;

			//Fehler
			err++;
		}
	}

	//Speicher für das Array für die Terminale
	termArr = new( long[tc + 1] );

	//Speicher für das Array für die Nichtterminale
	ntermArr = new( long[nc + 1] );

	//Anazhl der Einträge merken
	termArrCount = tc + 1;
	ntermArrCount = nc + 1;

	//start-Produktion als erste Produktion eintragen
	ntermArr[0] = prod_str[0].hash_index;

	//Index in der LR-Tabelle eintragen
	hash_tab->setLRTabIndex( ntermArr[0], 0 );

	//Hash-Indices aus checkArr
	for( i = 0, tc = 0, nc = 1; i < anzCheck; i++ )
	{
		//Name holen
		name = hash_tab->getName( check[i] );

		//Typ holen
		type = hash_tab->getType( check[i] );

		//Terminal?
		if( type == SSLR_TERM )
		{
			//Ja, eintragen
			termArr[tc] = check[i];

			//Index in der LR-Tabelle eintragen
			hash_tab->setLRTabIndex( check[i], tc++ );
		}

		//Nichtterminal?
		else if( type == SSLR_NTERM )
		{
			//Ja
			ntermArr[nc] = check[i];

			//Index in der LR-Tabelle eintragen
			hash_tab->setLRTabIndex( check[i], nc++ );
		}
	}

	//ACCEPT als letztes Terminal eintragen
	termArr[tc] = acceptHashIndex;

	//Index in der LR-Tabelle eintragen
	hash_tab->setLRTabIndex( acceptHashIndex, tc );

	//Wenn Fehler, zurückgeben
	return( err );
}


void SSLRParser::insertUnion( char *type, char *id )
{
	/*
		Neuen Eintrag aus der %union-Angabe erzeugen.
		ACHTUNG: Der Scanner liefert schon eine Kopie von type und id, hier muss
		also kein zusätzlicher Speicher angefordert werden!
	*/
	char	**t1, **t2;
	int		i;

	//Speicher für die Typen
	t1 = new( char *[unionStr->anz + 1] );

	//Speicher für die Bezeichner
	t2 = new( char *[unionStr->anz + 1] );

	//kopieren
	for( i = 0; i < unionStr->anz; i++ )
	{
		//nur die Adressen kopieren
		t1[i] = unionStr->type[i];
		t2[i] = unionStr->id[i];
	}

	//den alten Speicher freigeben
	if( unionStr->type )
		delete[] ( unionStr->type );

	if( unionStr->id )
		delete[] ( unionStr->id );

	//die neuen Einträge merken
	t1[unionStr->anz] = type;
	t2[unionStr->anz] = id;

	//ein weiterer Eintrag
	unionStr->anz++;

	//Adressen kopieren
	unionStr->type = t1;
	unionStr->id = t2;
}


int SSLRParser::getSemIndex( char *name )
{
	//In name steht der Typ zur semantischen Aktion. Den Index in unionStr suchen.
	/*
		Beispiel:
			%union
			{
				int		a;
			}

		In name steht nun a, den Index in unionStr zurückliefern.
	*/
	UNION_STR	*h = unionStr;
	int			i;

	//Alle Einträge durchgehen
	for( i = 0; i < h->anz; i++ )
	{
		//Vergleichen
		if( !strcmp( h->id[i], name ) )
			//gefunden
			return( i );
	}

	//nicht gefunden
	return( -1 );
}


long SSLRParser::getNewProd( void )
{
	//PROD_STR anfordern
	PROD_STR	*tmp;

	//Speicher für PROD_STR anfordern
	tmp = new( PROD_STR[prod_anz + 1] );

	//kopieren
	memmove( tmp, prod_str, sizeof( PROD_STR ) * prod_anz );

	//alten Speicher freigeben
	if( prod_str )
		delete[] ( prod_str );

	//Adressen
	prod_str = tmp;

	//initialisieren
	memset( &prod_str[prod_anz], 0, sizeof( PROD_STR ) );

	//Index der ersten Alternative in PROD2_STR eintragen
	prod_str[prod_anz].prod2_index = prod2_anz;

	//Index zurückliefern
	return( prod_anz++ );
}


long SSLRParser::getNewProd2( long prod_index )
{
	//PROD2_STR anfordern
	PROD2_STR	*tmp;

	//Speicher für PROD2_STR anfordern
	tmp = new( PROD2_STR[prod2_anz + 1] );

	//kopieren
	memmove( tmp, prod2_str, sizeof( PROD2_STR ) * prod2_anz );

	//alten Speicher freigeben
	if( prod2_str )
		delete[] ( prod2_str );

	//Adressen
	prod2_str = tmp;

	//initialisieren
	memset( &prod2_str[prod2_anz], 0, sizeof( PROD2_STR ) );

	//Index der Produktion in PROD_STR
	prod2_str[prod2_anz].prod_index = prod_index;

	//zurücksetzen
	prod2_str[prod2_anz].reduce = 0;

	//die Alternative hat noch keine Priorität
	prod2_str[prod2_anz].priority = 0;

	//Index zurückliefern
	return( prod2_anz++ );
}


void SSLRParser::insertElement( long prod_index, long prod2_index, long hash_index )
{
	//Element auf der rechten Seite der Produktion eintragen
//	PROD_STR	*p1 = &prod_str[prod_index];
	PROD2_STR	*p2 = &prod2_str[prod2_index];
	long		*tmp;

	//Index der Produktion eintragen
	p2->prod_index = prod_index;

	//Speicher für die Elemente anfordern
	tmp = new( long[p2->riAnz + 1] );

	//kopieren
	memmove( tmp, p2->right, sizeof( long ) * p2->riAnz );

	//alten Speicher freigeben
	if( p2->right )
		delete[] ( p2->right );

	//Adressen
	p2->right = tmp;

	//Index des Elemente in der rechten Seite eintragen
	p2->right[p2->riAnz++] = hash_index;
}


int SSLRParser::checkErrorStr( void )
{
	//die ERROR_STR prüfen

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		PROD2_STR	*p2;
		ERROR_STR	*errorStr1, *errorStr2;
		int			i, j, k, l, m;
		int			errTermCnt1, errTermCnt2, anzColl, coll;
		int			*noTermErrActErrorStrIndex, *noTermErrActHulleIndex, noTermErrActCnt;
		int			*errTerm, anzErrTerm;

		/*
			Hier werden Fehlerangaben gefunden, die nie ausgeführt werden.
			Beim folgenden Beispiel wird die letzte Fehlerangabe nicht ausgeführt.
			1:!ADD:			"Fehlermeldung1"
			1:ADD			"Fehlermeldung2"
			1:SHIFT(ADD)	"Fehlermeldung3"
		*/
		noTermErrActErrorStrIndex = new( int[error_anz] );
		noTermErrActHulleIndex = new( int[error_anz] );
		errTerm = new( int[termArrCount] );

		/*
			Hier wird geprüft, ob es zu zwei Fehlerangaben Überschneidungen
			seitens der Terminale gibt.
			Dazu werden immer die Fehlerangaben verglichen, die den selben
			Hüllenindex haben sowie dieselbe Punktposition.
		*/
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//initialisieren
			memset( noTermErrActErrorStrIndex, 0, sizeof( int) * error_anz );
			memset( noTermErrActHulleIndex, 0, sizeof( int) * error_anz );
			memset( errTerm, 0, sizeof( int) * termArrCount );
			noTermErrActCnt = 0;
			anzErrTerm = 0;

			//alle nachfolgenden ERROR_STR
			for( j = i + 1; j < error_anz; j++ )
			{
				//Zeiger auf ERROR_STR
				errorStr2 = &error_str[j];

//Meldung ausgeben
//cerr << "process %error " << errorStr1->line << endl;
//cerr << "process %error " << errorStr2->line << endl << endl;

				//alle Einträge der ersten ERROR_STR
				for( k = 0; k < errorStr1->hInd.anzArr; k++ )
				{
					//alle Einträge der zweiten ERROR_STR
					for( l = 0; l < errorStr2->hInd.anzArr; l++ )
					{
						//gleiche Hüllen-Indices?
						if( errorStr1->hInd.arr[k] == errorStr2->hInd.arr[l] )
						{
							/*
								hat diese ERROR_STR überhaupt Aktionen, die mit Terminalen
								verbunden sind?
							*/
							if( !errorStr1->errTermStrAnz )
							{
								/*
									nein, eine Fehleraktion ohne Angabe von Terminalen,
									also der Art
									1:AKTION:	"Fehler!"
									Nun den Index j der errorStr2 merken, damit später
									geprüft werden kann, ob diese Fehleraktion jemals
									ausgeführt werden kann.
								*/
								int	k;

								//da mehrere Hüllen-Indices zu einer Fehleraktionen gehören können, nur einmal eintragen
								for( k = 0; k < noTermErrActCnt; k++ )
								{
									//den Hüllen-Index j schon eingetragen?
									if( noTermErrActErrorStrIndex[k] == i )
										//ja, nicht noch einmal eintragen
										break;
								}

								//schon eingetragen?
								if( k == noTermErrActCnt )
								{
									//nein, eintragen
									noTermErrActErrorStrIndex[noTermErrActCnt] = i;
									noTermErrActHulleIndex[noTermErrActCnt++] = errorStr2->hInd.arr[l];
								}
							}

							/*
								die zweite ERROR_STR kann auch eine Fehleraktion
								ohne Terminal haben
							*/
							if( !errorStr2->errTermStrAnz )
							{
								/*
									nein, eine Fehleraktion ohne Angabe von Terminalen,
									also der Art
									1:AKTION:	"Fehler!"
									Nun den Index j der errorStr2 merken, damit später
									geprüft werden kann, ob diese Fehleraktion jemals
									ausgeführt werden kann.
								*/
								int	k;

								//da mehrere Hüllen-Indices zu einer Fehleraktionen gehören können, nur einmal eintragen
								for( k = 0; k < noTermErrActCnt; k++ )
								{
									//den Hüllen-Index j schon eingetragen?
									if( noTermErrActErrorStrIndex[k] == j )
										//ja, nicht noch einmal eintragen
										break;
								}

								//schon eingetragen?
								if( k == noTermErrActCnt )
								{
									//nein, eintragen
									noTermErrActErrorStrIndex[noTermErrActCnt] = j;
									noTermErrActHulleIndex[noTermErrActCnt++] = errorStr2->hInd.arr[l];
								}
							}

							/*
								PROBLEM: Es kann durchaus sein, dass zwei
								Fehleranweisungen zu verschiedenen
								LR-Items den gleichen Zustand erhalten.
								Nun auf Kollisionen prüfen.
							*/
							errTermCnt1 = errTermCnt2 = 0;
							anzColl = 0;

							//für alle Terminale prüfen
							for( m = 0; m < termArrCount; m++ )
							{
								//and
								coll = ( errorStr1->errTermArr[m] & errorStr2->errTermArr[m] );
								anzColl += coll;

								/*
									Anzahl der Terminale merken, für die
									eine Aktion ausgeführt wird.
								*/
								if( !errTerm[m] )
								{
									//noch keine Fehleraktion mit dem Terminal m verbunden
									anzErrTerm += ( errorStr1->errTermArr[m] | errorStr2->errTermArr[m] );
									errTerm[m] = ( errorStr1->errTermArr[m] | errorStr2->errTermArr[m] );
								}

								//zählen
								errTermCnt1 += errorStr1->errTermArr[m];
								errTermCnt2 += errorStr2->errTermArr[m];

								//gab es eine Kollision?
								if( coll )
								{
									//ja, Name des Terminals
									char *name = hash_tab->getName( termArr[m] );

									//Meldung ausgeben
									cerr << "sslr: ERROR: Collision in terminal " << name << " between error action in line " << errorStr1->line << " and " << errorStr2->line << "!" << endl;

									//Fehler
									err++;
								}
							}
						}
					}
				}
			}

			//Fehleraktion ohne Terminale prüfen
			if( noTermErrActCnt )
			{
				//sind alle Terminale mit Fehleraktionen versehen?
				if( anzErrTerm == termArrCount )
				{
					/*
						Für den Zustand errorStr1->hInd.arr[k] gibt es für jedes Terminal
						eine Fehleraktion.
						Da es auch Fehleraktionen ohne Terminal gibt, werden diese folglich
						nie ausgeführt.
					*/
					ERROR_STR	*tmp;
					int			i;

					//alle nicht-terminalgebundenen Fehleraktionen
					for( i = 0; i < noTermErrActCnt; i++ )
					{
						//Zeiger auf die zugehörige ERROR_STR
						tmp = &error_str[noTermErrActErrorStrIndex[i]];

						//Warnung ausgeben
						cerr << "sslr: Warning: line " << tmp->line << ": Error action will never be used!" << endl;
					}
				}

				//es gibt noch "freie" Terminale
				else if( noTermErrActCnt > 1 )
				{
					/*
						Hier wird geprüft, ob Fehlerangaben der folgenden Form auftauchen

						1:SHIFT(ADD):		"Fehlermeldung 1"
						1:OVERREAD(SUB):	"Fehlermeldung 2"

						Dies geht nicht, da nicht beide Fehlermeldungen gleichzeitig
						ausgegeben werden können, besser:
						1:SHIFT(ADD):OVERREAD(SUB):	"Fehlermeldung 1 und 2"
					*/
					unsigned long	state;
					ERROR_STR		*tmp1, *tmp2;
					int				i, j;

					//alle Fehleraktionen miteinander vergleichen
					for( i = 0; i < noTermErrActCnt; i++ )
					{
						for( j = i + 1; j < noTermErrActCnt; j++ )
						{
							//Zeiger auf beide ERROR_STR
							tmp1 = &error_str[noTermErrActErrorStrIndex[i]];
							tmp2 = &error_str[noTermErrActErrorStrIndex[j]];

							//Zustand der Kollision
							state = noTermErrActHulleIndex[i];

							/*
								nur eine nicht-Terminal-gebundene Fehleraktion
								pro Zustand erlaubt
							*/
							cerr << "sslr: Warning: Two error actions in line " << tmp1->line << " and line " << tmp2->line << " without terminals in the same state " << state << "!" << endl;
						}
					}
				}
			}
		}

		//Speicher wieder freigeben
		delete[] ( noTermErrActErrorStrIndex );
		delete[] ( noTermErrActHulleIndex );
		delete[] ( errTerm );




		//nun prüfen, ob EXIT mit etwas anderem zusammen steht
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//ist EXIT aktiviert?
			if( errorStr1->exit )
			{
				//mit anderen Aktionen?
				if( errorStr1->shift || errorStr1->del || errorStr1->overread || errorStr1->sem )
					//unsinnig
					cerr << "sslr: Warning: line " << errorStr1->line << ": It makes no sense to use EXIT together with other user-defined error-actions!" << endl;
			}
		}






		//nun prüfen, ob eine Fehlerangabe jemals ausgeführt wird
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[errorStr1->prod2_index];

			//ist die Position des Punktes zu groß?
			if( errorStr1->dot > p2->riAnz )
			{
				//wird niemals ausgeführt
				cerr << "sslr: ERROR: line " << errorStr1->line << ": Position of dot " << errorStr1->dot << " to big!" << endl;

				//Fehler
				err++;
			}
		}
	}

	//Anzahl der Fehler zurückgeben
	return( err );
}


void SSLRParser::sortProd2Str( void )
{
	//Die PROD2_STR sortieren
	PROD2_STR	*a, *b, *source, *dest, tmp;
	PROD_STR	*p1;
	char		*name1, *name2;
	int			i, j, k, anz;

	//initialisieren
	i = 0;

	//alle Alternativen
	while( i < ( prod2_anz - 1 ) )
	{
		//Zeiger auf PROD2_STR
		a = &prod2_str[i];

		//den Namen holen
		name1 = hash_tab->getName( prod_str[a->prod_index].hash_index );

		//Index
		j = i++;

		do
		{
			//nächsten
			j++;

			//Zeiger auf PROD2_STR
			b = &prod2_str[j];

			//Zeiger auf PROD_STR
			p1 = &prod_str[b->prod_index];

			//den Namen holen
			name2 = hash_tab->getName( p1->hash_index );

		}while( ( a->prod_index == b->prod_index ) && ( j < ( prod2_anz - 1 ) ) );

		//alle Alternativen
		for( k = j++; j < prod2_anz; j++ )
		{
			//Zeiger auf PROD2_STR
			b = &prod2_str[j];

			//Den Namen holen
			name2 = hash_tab->getName( prod_str[b->prod_index].hash_index );

			//gleiche Produktionen, d.h. prod_index gleich?
			if( a->prod_index == b->prod_index )
			{
				//ja

				//Zeiger auf PROD2_STR
				source = &prod2_str[j];

				//Zeiger auf PROD2_STR
				dest = &prod2_str[k];

				//j sichern
				tmp.prod_index = source->prod_index;
				tmp.riAnz = source->riAnz;
				tmp.right = source->right;
				tmp.priority = source->priority;
				tmp.semAct = source->semAct;
				tmp.semActLine = source->semActLine;

				//verschieben
				memmove( &prod2_str[k+1], &prod2_str[k], sizeof( PROD2_STR ) * ( j - k ) );

				//eintragen
				dest->prod_index = tmp.prod_index;
				dest->riAnz = tmp.riAnz;
				dest->right = tmp.right;
				dest->priority = tmp.priority;
				dest->semAct = tmp.semAct;
				dest->semActLine = tmp.semActLine;

				//nächste Position
				k++;
			}
		}

		//ab k + 1
		i = k;
	}

	//Indices anpassen
	for( i = 0, k = 0; i < prod_anz; i++ )
	{
		//Anzahl der Alternativen
		anz = prod_str[i].altAnz;

		//prod2_index anpassen
		prod_str[i].prod2_index = k;

		//alle zugehörigen Alternativen
		for( j = k; j < ( k + anz ); j++ )
			//PROD_STR-Index eintragen
			prod2_str[j].prod_index = i;

		//überspringen
		k += anz;
	}
}


void SSLRParser::outputGrammar( void )
{
	//Grammatik in Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name;
	int			i, j, k, r;

	//Grammatik in Datei ausgeben?
	if( argv_str->outputGrammar )
	{
		//Stream öffnen
		ofstream	out( argv_str->name );

		//Header ausgeben
		out << "/*\n";
		out << "Grammatik in BNF-Form. Generiert vom SSLR-Parser-Generator V" << VERSION << ".\n";
		out << "(c) 2002-2005 by Sven Schmidt\n";
		out << "s.schmidt@lboro.ac.uk\n";
		out << "*/\n\n";

		//Alle Produktionen
		for( i = 1; i < prod_anz; i++ )
		{
			//Zeiger auf die PROD_STR holen
			p1 = &prod_str[i];

			//Den Namen der Produktion holen
			name = hash_tab->getName( p1->hash_index );

			//Produktion ausgeben
			out << name << "\n";

			//Seperator ausgeben
			out << "\t->\t";

			//alle Alternativen ausgeben
			for( j = p1->prod2_index, k = 0; j < ( p1->prod2_index + p1->altAnz ); j++, k++ )
			{
				//Zeiger auf die PROD2_STR holen
				p2 = &prod2_str[j];

				//neue Alternative?
				if( k )
					//Ja
					out << "\t|\t";

				//rechte Seite ausgeben
				for( r = 0; r < p2->riAnz; r++ )
				{
					//Namen holen
					name = hash_tab->getName( p2->right[r] );

					//Terminal?
					if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
						//Ja
						out << " '" << name << "' ";

					else
						//Nichtterminal
						out << " " << name << " ";
				}

				//Priorität ausgeben
				out << "\t/* Priority: " << p2->priority << " */\n";
			}

			//Produktion abschliessen
			out << "\t;\n\n";
		}
	}
}


void SSLRParser::outputAlt( ostream &s, long prod2_index )
{
	//alle Alternativen der Produktion ausgeben, zu der die Alternative prod2_index gehört
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	s << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			s << " '" << name << "' ";

		else
			//Nichtterminal
			s << " " << name << " ";
	}

	//nächste Zeile
	s << "\n";
}


void SSLRParser::outputItem( long prod2_index, int dot, ofstream &file )
{
	//Ein Item ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	file << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Position des Punktes?
		if( dot == r )
			//ja
			file << ".";

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			file << " '" << name << "' ";

		else
			//Nichtterminal
			file << " " << name << " ";
	}

	//Position des Punktes?
	if( dot == r )
		//ja
		file << ".";
}


void SSLRParser::outputItem( long prod2_index, int dot )
{
	//Ein Item ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	cout << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Position des Punktes?
		if( dot == r )
			//ja
			cout << ".";

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			cout << " '" << name << "' ";

		else
			//Nichtterminal
			cout << " " << name << " ";
	}

	//Position des Punktes?
	if( dot == r )
		//ja
		cout << ".";
}


void SSLRParser::outputAllAlt( void )
{
	//Alle Alternativen ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	ofstream	out( argv_str->name );
	char		*name;
	int			j, r;

	//alle Alternativen ausgeben
	for( j = 0; j < prod2_anz; j++ )
	{
		//Zeiger auf die PROD2_STR holen
		p2 = &prod2_str[j];

		//Zeiger auf die PROD_STR holen
		p1 = &prod_str[p2->prod_index];

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//ausgeben
		out << " " << name << " -> ";

		//rechte Seite ausgeben
		for( r = 0; r < p2->riAnz; r++ )
		{
			//Namen holen
			name = hash_tab->getName( p2->right[r] );

			//Terminal?
			if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
				//Ja
				out << " '" << name << "' ";

			else
				//Nichtterminal
				out << " " << name << " ";
		}

		//nächste Zeile
		out << "\n";
	}
}


void SSLRParser::genAllFirst( void )
{
	//Alle FIRST-Mengen bilden
	PROD2_STR	*p2;
	PROD_STR	*p1;
	Terminal	*f1;
	long		anzFirst;
	char		*name;
	int			i, j, changed;
	int			pass = 0;
	int			*pArr;

	//keine doppelten Ausgaben
	pArr = new( int[prod_anz] );

	//Initialisieren
	memset( pArr, 0, sizeof( int ) * prod_anz );

	do
	{
		//prüft, ob weitere Terminale zur FIRST-Menge hinzugefügt wurden
		changed = 0;

		//ein weiterer Pass
		pass++;

		//alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//ausführliche Ausgaben?
			if( ( argv_str->verbose ) && !( pArr[i] ) )
			{
				//ja
				cout << "sslr: Generate FIRST(" << name << ")..." << endl;

				//Meldung nicht nocheinmal ausgeben
				pArr[i]++;
			}

			//Anzahl der FIRST-Elemente holen
			anzFirst = hash_tab->getFirstAnz( p1->hash_index );

			//Zeiger auf FIRST-Mengen holen
			f1 = hash_tab->getFirst( p1->hash_index );

			//Alle Alternativen
			for( j = p1->prod2_index; j < ( p1->prod2_index + p1->altAnz ); j++ )
			{
				//Zeiger auf PROD2_STR
				p2 = &prod2_str[j];

				//FIRST-Menge berechnen
				genFirst( f1, p2->riAnz, p2->right );
			}

			//geändert?
			if( anzFirst != hash_tab->getFirstAnz( p1->hash_index ) )
				//Ja
				changed++;
		}

	}while( changed );

	//Speicher wieder freigeben
	delete[] ( pArr );

	//ausführliche Ausgaben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate FIRST-Sets!" << endl;

	//FIRST-Mengen ausgeben?
	if( argv_str->showFirst )
	{
		//Alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//Ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//Meldung
			cout << "\nFIRST(" << name << ")=" << endl;

			//FIRST-Menge ausgeben
			hash_tab->printFirst( p1->hash_index );
		}
	}
}


void SSLRParser::genFirst( Terminal *f, int anzElem, long *arr )
{
	//Hier werden die FIRST-Mengen eines Terminals/Nichtterminals erzeugt
	Terminal	*f2, *f3;
	char		*name;
	int			i, eps = 0;

	//für jeden Durchgang eine eigene FIRST-Menge
	f3 = new Terminal( epsHashIndex );

	//Gibt es überhaupt noch Elemente
	if( anzElem > 0 )
	{
		//Alle Elemente
		for( i = 0; i < anzElem; i++ )
		{
			//Namen holen
			name = hash_tab->getName( arr[i] );

			//Zeiger auf die FIRST-Menge holen
			f2 = hash_tab->getFirst( arr[i] );

			//hinzufügen
			f3->add( f2 );

			//beinhaltet die FIRST-Menge EPSILON?
			if( f2->isEpsilon() )
				//Ja, hochzählen
				eps++;

			else
				//Nein, for-Schleife verlassen
				break;
		}

		//Epsilon zu dieser Menge hinzufügen?
		if( eps && ( eps < anzElem ) )
		{
			//Nein, aus der FIRST-Menge löschen

			//EPSILON aus FIRST-Menge löschen
			f3->del( epsHashIndex );
		}
	}

	else
		//leere Menge, EPSILON hinzufügen
		f3->ins( epsHashIndex );

	//FIRST-Menge hinzufügen
	f->add( f3 );

	//Speicher freigeben
	delete( f3 );
}


void SSLRParser::genAllFollow( void )
{
	//Alle FOLLOW-Mengen bilden
	PROD2_STR	*p2;
	PROD_STR	*p1, *p3;
	Terminal	*f1, *f2, *first;
	long		anzFollow;
	char		*name, *tmpName;
	int			i, j, r, changed;
	int			pass = 0;
	int			*pArr;

	//keine doppelten Ausgaben
	pArr = new( int[prod_anz] );

	//Initialisieren
	memset( pArr, 0, sizeof( int ) * prod_anz );

	//ACCEPT in die Start-Produktion aufnehmen
	f1 = hash_tab->getFollow( prod_str[0].hash_index );

	//ACCEPT eintragen
	f1->ins( acceptHashIndex );

	do
	{
		//prüft, ob weitere Terminale zur FOLLOW-Menge hinzugefügt wurden
		changed = 0;

		//ein weiterer Pass
		pass++;

		//alle Produktionen
		for( i = 1; i < prod_anz; i++ )
		{
			//nein, Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//ausführliche Ausgaben?
			if( ( argv_str->verbose ) && !( pArr[i] ) )
			{
				//ja
				cout << "sslr: Generate FOLLOW(" << name << ")..." << endl;

				//Meldung nicht nocheinmal ausgeben
				pArr[i]++;
			}

			//Anzahl der FOLLOW-Elemente holen
			anzFollow = hash_tab->getFollowAnz( p1->hash_index );

			//Zeiger auf FOLLOW-Mengen holen
			f1 = hash_tab->getFollow( p1->hash_index );

			//Alle Alternativen
			for( j = 0; j < prod2_anz; j++ )
			{
				//Zeiger auf PROD2_STR
				p2 = &prod2_str[j];

//Debug-Modus?
#ifdef SSLR_INTERN_DEBUG
				//Alternative ausgeben
				outputAlt( j );
#endif

				//Nichtterminal check[i] auf rechter Seite suchen
				for( r = 0; r < p2->riAnz; r++ )
				{
					//Name holen
					tmpName = hash_tab->getName( p2->right[r] );

					//Gefunden?
					if( p2->right[r] == p1->hash_index )
					{
						//FIRST-Mengen bilden
						first = new Terminal( epsHashIndex );

						//FIRST-Mengen bilden
						genFirst( first, p2->riAnz - r - 1, &p2->right[r+1] );

						//EPSILON in FIRST-Menge?
						if( first->isEpsilon() )
						{
							//Ja, Zeiger auf PROD_STR
							p3 = &prod_str[p2->prod_index];

							//Namen holen
							tmpName = hash_tab->getName( p3->hash_index );

//							cerr << "FOLLOW(" << name << ") += FOLLOW(" << tmpName << ")" << endl;

							//Ja, FOLLOW(p2->prodindex) = FOLLOW(check[i])
							f2 = hash_tab->getFollow( p3->hash_index );

							//hinzufügen
							f1->add( f2 );

							//EPSILON aus FIRST-Menge löschen
							first->del( epsHashIndex );
						}

						//hinzufügen
						f1->add( first );

						//FIRST-Mengen löschen
						delete( first );
					}
				}
			}

			//geändert?
			if( anzFollow != hash_tab->getFollowAnz( p1->hash_index ) )
				//Ja
				changed++;
		}

	}while( changed );

	//Speicher wieder freigeben
	delete[] ( pArr );

	//ausführliche Ausgaben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate FOLLOW-Sets!" << endl;

	//FOLLOW-Mengen ausgeben?
	if( argv_str->showFollow )
	{
		//Alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//Ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//Meldung
			cout << "\nFOLLOW(" << name << ")=" << endl;

			//FOLLOW-Menge ausgeben
			hash_tab->printFollow( p1->hash_index );
		}
	}
}


void SSLRParser::genLR0Hulle( void )
{
	//Generiere alle Hüllen der LR(0)-Elemente für SLR und LALR
	HULLE_STR	*h;
	int			changed = 0, pass = 0, i;

	//1. Hülle generieren
	h = createHulle();

	//ersten Kern eintragen
	insertItem( h, 0, 0, SSLR_CORE );

	//Hülle eintragen
	insertHulle( h );

	//Wurde nicht durch Sprung-Funktion erzeugt
	h->from = 0;
	h->elem = 0;

	//bei Hülle 0 anfangen
	i = 0;

	do
	{
		//Passe zählen
		pass++;

		//Keine Änderungen
//		changed = 0;

		//Anzahl der Hüllen merken
//		anzH = hulle_anz;

		//Alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf Hülle
			h = hulle_str[i];

			//Alle Elemente dieser Hülle erzeugen
			genLR0Items( h );

			//Ausgeben
//			outputHulle( h );

			//Anhand der Items die Hüllen erzeugen, die sich durch Spring( h, X ) ergeben
			makeLR0Jump( h );
/*
			//Anzahl der Hüllen geändert?
			if( hulle_anz != anzH )
				//Ja
				changed++;
*/
		}

	}while( changed );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate " << hulle_anz << " LR(0)-Items!" << endl;
}


void SSLRParser::genLR1Hulle( void )
{
	//Generiere alle Hüllen der LR(1)-Elemente für LR
	HULLE_STR	*h;
	Terminal	*la;
	int			changed = 0, pass = 0, i;

	//1. Hülle generieren
	h = createHulle();

	//Speicher für die Lookaheads
	la = new Terminal( epsHashIndex );

	//Accept eintragen
	la->ins( acceptHashIndex );

	//ersten Kern eintragen
	insertItem( h, 0, 0, SSLR_CORE, la );

	//Hülle eintragen
	insertHulle( h );

	//Wurde nicht durch Sprung-Funktion erzeugt
	h->from = 0;
	h->elem = 0;

	//bei Hülle 0 anfangen
	i = 0;

	do
	{
		//Passe zählen
		pass++;

		//Keine Änderungen
//		changed = 0;

		//Anzahl der Hüllen merken
//		anzH = hulle_anz;

		//Alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf Hülle
			h = hulle_str[i];

			//Alle Elemente dieser Hülle erzeugen
			genLR1Items( h );

			//Ausgeben
//			outputHulle( h );

			//Anhand der Items die Hüllen erzeugen, die sich durch Spring( h, X ) ergeben
			makeLR1Jump( h );
/*
			//Anzahl der Hüllen geändert?
			if( hulle_anz != anzH )
				//Ja
				changed++;
*/
		}

	}while( changed );

	//Speicher freigeben
	delete( la );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//Ja
		cout << "sslr: " << pass << " pass(es) to generate " << hulle_anz << " LR(1)-Items!" << endl;
}


void SSLRParser::makeLR0Jump( HULLE_STR *h )
{
	//Hier werden die Hüllen erzeugt, die sich durch Sprung( h, X ) ergeben
	HULLE_STR	*tmp;
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	long		elem, hInd;
	int			i;

	//Alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Punkt eine Position weiter und Element eintragen

			//Das (Nicht)Terminal holen, das nach dem Punkt kommt
			/*
				Bsp: expr
							->	.expr ADD expr
							|	.expr SUB expr
							|	term
							;

				Hier also ist expr vor dem Punkt.
			*/
			elem = p2->right[lr->dot];

			/*
				Die hier erzeugte Hülle ergibt sich also aus:

				tmp = Sprung( h, elem )
			*/

			//darf nicht .EPSILON sein
			if( elem != epsHashIndex )
			{
				//Den Namen holen
				name = hash_tab->getName( elem );

				//Hülle anfordern
				tmp = createHulle();

				//Hülle erzeugen
				genLR0Jump( h, tmp, elem );

				//Hülle schon in hulle_str?
				if( ( hInd = cmpLR0Hulle( tmp ) ) < 0 )
				{
					//Nein

					// this = Sprung( h, elem ) merken
					tmp->from = h->hulleIndex;
					tmp->elem = elem;

					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hulle_anz );

					//Meldung ausgeben?
					if( argv_str->verbose )
						//Ja
						cout << "sslr: Generate Jump(" << name << ")..." << endl;

					//Hülle eintragen
					insertHulle( tmp );

					//Ausgeben
//					outputHulle( tmp );
				}

				else
				{
					//Die Hülle existiert schon
					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hInd );

					//Hülle löschen
					deleteHulle( tmp );
				}
			}
		}
	}
}


void SSLRParser::makeLR1Jump( HULLE_STR *h )
{
	//Hier werden die Hüllen erzeugt, die sich durch Sprung( h, X ) ergeben
	HULLE_STR	*tmp;
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	long		elem, hInd;
	int			i;

	//Alle LR(1)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Punkt eine Position weiter und Element eintragen

			//Das (Nicht)Terminal holen, das nach dem Punkt kommt
			/*
				Bsp: expr
							->	.expr ADD expr
							|	.expr SUB expr
							|	.term
							;

				Hier sind expr und term vor dem Punkt.
			*/
			elem = p2->right[lr->dot];

			/*
				Die hier erzeugte Hülle ergibt sich also aus:

				tmp = Sprung( h, elem )
			*/

			//darf nicht .EPSILON sein
			if( elem != epsHashIndex )
			{
				//Den Namen holen
				name = hash_tab->getName( elem );

				//Hülle anfordern
				tmp = createHulle();

				//Hülle erzeugen
				genLR1Jump( h, tmp, elem );

				//Hülle schon in hulle_str?
				if( ( hInd = cmpLR1Hulle( tmp ) ) < 0 )
				{
					//Nein

					// this = Sprung( h, elem ) merken
					tmp->from = h->hulleIndex;
					tmp->elem = elem;

					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hulle_anz );

					//Meldung ausgeben?
					if( argv_str->verbose )
						//Ja
						cout << "sslr: " << hulle_anz << " Generate Jump(" << h->hulleIndex << ", " << name << ")..." << endl;

					//Hülle eintragen
					insertHulle( tmp );

					//Ausgeben
//					outputHulle( tmp );
				}

				else
				{
					//Die Hülle existiert schon
					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hInd );

					//Hülle löschen
					deleteHulle( tmp );
				}
			}
		}
	}
}


void SSLRParser::genLR0Items( HULLE_STR *h )
{
	//Hier werden alle LR(0)-Items einer Hülle erzeugt.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr;
	char		*name, *tmpName;
	long		pi;
	int			j, k;

	//Alle Elemente dieser Hülle
	for( j = 0; j < h->anzElem; j++ )
	{
		/*
			Bsp:	expr	->	.expr ADD expr
							|	.expr SUB expr
							|	.term
		*/
		//Index der ersten Alternative der Produktion nach dem Punkt holen

		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[j];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Namen holen
			name = hash_tab->getName( p2->right[lr->dot] );

			//Ist es ein Nichtterminal?
			if( hash_tab->getType( p2->right[lr->dot] ) == SSLR_NTERM )
			{
				//Ja, diese Produktion als Elemente mit dot = 0 aufnehmen

				//prod_index dieses Nichtterminals
				pi = hash_tab->getProdStr( p2->right[lr->dot] );

				//Zeiger auf PROD_STR
				p1 = &prod_str[pi];

				//Namen holen
				tmpName = hash_tab->getName( p1->hash_index );

				//Index der ersten Alternative in der PROD2_STR
				for( k = p1->prod2_index; k < ( p1->prod2_index + p1->altAnz ); k++ )
					//Als LR(0)-Item hinzufügen
					insertItem( h, k, 0, SSLR_ITEM );
			}
		}
	}
}


void SSLRParser::genLR1Items( HULLE_STR *h )
{
	//Hier werden alle LR(1)-Items einer Hülle erzeugt.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr, *lr2;
	Terminal	*la;
	char		*name, *tmpName;
	long		pi, cInd;
	int			j, k, changed, anzElem;

	do
	{
		//solange etwas hinzugefügt wurde
		changed = 0;

		//Alle Elemente dieser Hülle
		for( j = 0; j < h->anzElem; j++ )
		{
			/*
				Bsp:	expr	->	.expr ADD expr
								|	.expr SUB expr
								|	.term
			*/
			//Index der ersten Alternative der Produktion nach dem Punkt holen

			//Zeiger auf LR(0)-Element
			lr = &h->lr_str[j];

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[lr->prod2_index];

			//Ist der Punkt am Ende?
			if( lr->dot < p2->riAnz )
			{
				//Namen holen
				name = hash_tab->getName( p2->right[lr->dot] );

				//Ist es ein Nichtterminal?
				if( hash_tab->getType( p2->right[lr->dot] ) == SSLR_NTERM )
				{
					//Ja, diese Produktion als Elemente mit dot = 0 aufnehmen

					//prod_index dieses Nichtterminals
					/*
						Bsp:
							term	->	.term MUL factor

						Also PROD_STR-Index von term
					*/
					pi = hash_tab->getProdStr( p2->right[lr->dot] );

					//Zeiger auf PROD_STR
					p1 = &prod_str[pi];

					//Namen holen
					tmpName = hash_tab->getName( p1->hash_index );

					//Speicher für die Lookaheads holen
					la = new Terminal( epsHashIndex );

					//FIRST-Menge bilden nach dot
					genFirst( la, p2->riAnz - lr->dot - 1, &p2->right[lr->dot + 1] );

					//EPSILON in FIRST-Menge?
					if( la->isEpsilon() )
					{
						//Ja, alle Lookaheads des LR(1)-Items hinzufügen
						la->add( lr->la );

						//EPSILON aus FIRST-Menge löschen
						la->del( epsHashIndex );
					}

					//Index der ersten Alternative in der PROD2_STR
					for( k = p1->prod2_index; k < ( p1->prod2_index + p1->altAnz ); k++ )
					{
						//Ist dieses Item schon in der Hülle, also nur die Lookaheads ergänzen?
						if( ( cInd = findItem( h, k, 0 ) ) < 0 )
							//Nein, noch nicht da, als LR(1)-Item hinzufügen
							insertItem( h, k, 0, SSLR_ITEM, la );

						else
						{
							//Ja, Item schon da

							//Zeiger auf Item
							lr2 = &h->lr_str[cInd];

							//Anzahl der Lookaheads merken
							anzElem = lr2->la->getAnzElem();

							//Lookaheads ergänzen
							insertItem( h, k, 0, SSLR_ITEM, la );

							//Wurden Terminale hinzugefügt?
							if( anzElem != lr2->la->getAnzElem() )
								//Ja
								changed++;


							/*

								statement_list
									:	statement
									|	statement_list statement
									;

								Wegen solchen Produktionen muss man mehrmals über die Items hinweggehen,
								da im zweiten Schritt .statement_list statement FIRST(statement)
								als Lookaheads hinzukommt, die im ersten Schritt .statement nicht
								erfasst wurden!
							*/
						}
					}

					//Speicher wieder freigeben
					delete( la );
				}
			}
		}

		//Solange Änderungen vorgenommen wurden

	}while( changed );
}


SSLRParser::HULLE_STR *SSLRParser::createHulle( void )
{
	//Eine HULLE_STR-Struktur erzeugen
	HULLE_STR	*h;

	//Speicher anfordern
	h = new HULLE_STR;

	//Initailisieren
	h->anzCore = 0;
	h->anzElem = 0;
	h->lr_str = 0;

	//Zeiger auf Hülle zurückliefern
	return( h );
}


void SSLRParser::deleteHulle( HULLE_STR *h )
{
	//Eine HULLE_STR-Struktur löschen
	LR_STR	*lr;
	int		i;

	//Alle Elemente einer Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0/1)-Item
		lr = &h->lr_str[i];

		//Lookahead-Terminale freigeben
		if( lr->la )
			delete( lr->la );

		//Lookahead-Terminale freigeben
		if( lr->lalr )
			delete( lr->lalr );
	}

	//LR_STR freigeben
	delete[] ( h->lr_str );

	//HULLE_STR löschen
	delete( h );
}


void SSLRParser::insertItem( HULLE_STR *h, long prod2_index, int dot, int type )
{
	//LR(0)-Element in HULLE h eintragen
	LR_STR	*tmp;

	//Item schon enthalten?
	if( findItem( h, prod2_index, dot ) < 0 )
	{
		//nein, Speicher für das LR(0)-Element
		tmp = new( LR_STR[h->anzElem + 1] );

		//kopieren
		memmove( tmp, h->lr_str, sizeof( LR_STR ) * h->anzElem );

		//alten Speicher freigeben
		if( h->lr_str )
			delete[] ( h->lr_str );

		//Zeiger
		h->lr_str = tmp;

		//eintragen
		h->lr_str[h->anzElem].dot = dot;
		h->lr_str[h->anzElem].prod2_index = prod2_index;

		//keine Lookaheads
		h->lr_str[h->anzElem].la = new Terminal( epsHashIndex );

		//Lookaheads eintragen
		h->lr_str[h->anzElem++].lalr = new Terminal( epsHashIndex );

		//ein weiterer Kern hinzugefügt?
		if( type == SSLR_CORE )
			//Ja
			h->anzCore++;

		//Warnung?
		if( ( type == SSLR_CORE ) && ( h->anzElem > h->anzCore ) )
			cerr << "sslr: SSLRParser::insertItem: Es wurde ein Kern eingetragen, obwohl schon alle Items berechnet sein sollten!" << endl;
	}
}


void SSLRParser::insertItem( HULLE_STR *h, long prod2_index, int dot, int type, Terminal *la )
{
	//LR(1)-Element in HULLE h eintragen
	LR_STR	*tmp;
	long	hInd;

	//Item schon enthalten?
	if( ( hInd = findItem( h, prod2_index, dot ) ) < 0 )
	{
		//nein, Speicher für das LR(1)-Element
		tmp = new( LR_STR[h->anzElem + 1] );

		//kopieren
		memmove( tmp, h->lr_str, sizeof( LR_STR ) * h->anzElem );

		//alten Speicher freigeben
		if( h->lr_str )
			delete[] ( h->lr_str );

		//Zeiger
		h->lr_str = tmp;

		//eintragen
		h->lr_str[h->anzElem].dot = dot;
		h->lr_str[h->anzElem].prod2_index = prod2_index;

		//Lookaheads eintragen
		h->lr_str[h->anzElem].la = new Terminal( epsHashIndex );
		h->lr_str[h->anzElem].la->add( la );

		//keine Lookahead-Terminale
		h->lr_str[h->anzElem++].lalr = 0L;

		//ein weiterer Kern hinzugefügt?
		if( type == SSLR_CORE )
			//Ja
			h->anzCore++;

		//Warnung?
		if( ( type == SSLR_CORE ) && ( h->anzElem > h->anzCore ) )
			cerr << "sslr: SSLRParser::insertItem: Es wurde ein Kern eingetragen, obwohl schon alle Items berechnet sein sollten!" << endl;
	}

	else
	{
		//Item schon in der Hülle enthalten, also nur die Lookaheads la hinzufügen
		tmp = &h->lr_str[hInd];

		//Lookaheads hinzufügen
		tmp->la->add( la );
	}
}


int SSLRParser::cmpLR0Hulle( HULLE_STR *h )
{
	//Prüft, ob die Hülle h schon in hulle_str enthalten ist
	HULLE_STR	*tmp;
	LR_STR		*lr;
	int			i, j, elemCnt = 0;
	int			anzCore = h->anzCore, cInd;

	//Alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zähler
		elemCnt = 0;

		//Zeiger auf Hülle
		tmp = hulle_str[i];

		//Anzahl der Items gleich?
		if( ( h->anzElem == tmp->anzElem ) && ( h->anzCore == tmp->anzCore ) )
		{
			//Alle LR(0)-Kerne von tmp
			for( j = 0; j < tmp->anzCore; j++ )
			{
				//Zeiger auf LR(0)-Item
				lr = &tmp->lr_str[j];

				//Item in h enthalten?
				if( ( cInd = findItem( h, lr->prod2_index, lr->dot ) ) < 0 )
					//nein
					break;

				//Ist es ein Kern-Item von h?
				else if( cInd <= ( anzCore - 1 ) )
					//Ja
					elemCnt++;
			}

			//gefunden?
			if( elemCnt == anzCore )
				//Ja
				break;
		}
	}

	//h noch nicht in hulle_str enthalten
	return( anzCore == elemCnt ? i : -1 );
}


int SSLRParser::cmpLR1Hulle( HULLE_STR *h )
{
	//Prüft, ob die Hülle h schon in hulle_str enthalten ist
	HULLE_STR	*tmp;
	LR_STR		*lr;
	int			i, j, elemCnt = 0;
	int			anzCore = h->anzCore, cInd;

	//Alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zähler
		elemCnt = 0;

		//Zeiger auf Hülle
		tmp = hulle_str[i];

		//Anzahl der Items gleich?
		if( ( h->anzElem == tmp->anzElem ) && ( h->anzCore == tmp->anzCore ) )
		{
			//Alle LR(1)-Kerne
			for( j = 0; j < tmp->anzCore; j++ )
			{
				//Zeiger auf LR(0)-Item
				lr = &tmp->lr_str[j];

				//Item in h enthalten?
				if( ( cInd = findItem( h, lr->prod2_index, lr->dot, lr->la ) ) < 0 )
					//nein
					break;

				//Ist es ein Kern-Item von h?
				else if( cInd <= ( anzCore - 1 ) )
					//Ja
					elemCnt++;
			}

			//gefunden?
			if( elemCnt == anzCore )
				//Ja
				break;
		}
	}

	//h noch nicht in hulle_str enthalten
	return( anzCore == elemCnt ? i : -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index )
{
	//prüft, ob in der Hülle h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &h->lr_str[i];

		//gleich?
		if( prod2_index == lr->prod2_index )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index, int dot )
{
	//prüft, ob in h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Item
		lr = &h->lr_str[i];

		//gleich?
		if( ( prod2_index == lr->prod2_index ) && ( dot == lr->dot ) )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index, int dot, Terminal *la )
{
	//prüft, ob in h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Item
		lr = &h->lr_str[i];

		//gleich?
		if( ( prod2_index == lr->prod2_index ) && ( dot == lr->dot ) && ( lr->la->cmp( la ) ) )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


void SSLRParser::outputHulle ( HULLE_STR *h )
{
	//Eine Hülle ausgeben
	Terminal	*la;
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr;
	char		*name = "";
	long		*tArr, *nArr, elem, LRTabIndex;
	int			i, r, v, anz, typ;
	bool		draw;

	//Namen der Produktion holen
	name = hash_tab->getName( h->elem );

	//erster name ist leer
	if( name )
		//ausgeben
		cout << "\n\nHülle " << h->hulleIndex << " = Sprung( " << h->from << ", " << name << " )" << endl;

	else
		//ohne "Vererbung"
		cout << "\n\nHülle " << h->hulleIndex << endl;

	//Alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Kern?
		if( i < h->anzCore )
			//Ja
			cout << "Kern:\t";

		else
			//Kein Kern-Element
			cout << "     \t";

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//ausgeben
		cout << " " << name << " -> ";

		//rechte Seite ausgeben
		for( r = 0; r < p2->riAnz; r++ )
		{
			//Position des Punktes?
			if( lr->dot == r )
				//Ja
				cout << ".";

			//Namen holen
			name = hash_tab->getName( p2->right[r] );

			//Terminal?
			if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
				//Ja
				cout << " '" << name << "' ";

			else
				//Nichtterminal
				cout << " " << name << " ";
		}

		//Position des Punktes?
		if( lr->dot == r )
			//Ja
			cout << ".";

		//Lookaheads ausgeben?
		if( lr->la )
		{
			//Ja, Lookaheads ausgeben
			la = lr->la;

			//Anzahl der Lookaheads
			anz = lr->la->getAnzElem();

			//Alle Lookaheads ausgeben
			for( v = 0; v < anz; v++ )
				//Terminal ausgeben
				cout << "," << hash_tab->getName( (*la)[v] );
		}

		//nächste Zeile
		cout << endl;
	}

	//Alle Sprung-Übergänge nur einmal zeigen
	tArr = new( long[termArrCount + 1] );
	nArr = new( long[ntermArrCount] );

	//initialisieren
	memset( tArr, 0, sizeof( long ) * ( termArrCount + 1 ) );
	memset( nArr, 0, sizeof( long ) * ( ntermArrCount ) );

	//Alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Position des Punktes?
		if( lr->dot < p2->riAnz )
		{
			//Sprung-Hülle ausgeben
			elem = p2->right[lr->dot];

			//Index des Element in der LR-Tabelle
			LRTabIndex = hash_tab->getLRTabIndex( elem );

			//Namen holen
			name = hash_tab->getName( elem );

			//Typ holen
			typ = hash_tab->getType( elem );

			//Terminal?
			if( typ == SSLR_TERM )
			{
				//hinter dem Punkt folgt ein Terminal
				if( tArr[LRTabIndex] )
					//wurde schon ausgegeben
					draw = false;

				else
				{
					//ausgeben
					draw = true;

					//markieren, damit es nicht mehr ausgegeben wird
					tArr[LRTabIndex]++;
				}
			}

			else
			{
				//hinter dem Punkt folgt ein Nichtterminal
				if( nArr[LRTabIndex] )
					//wurde schon ausgegeben
					draw = false;

				else
				{
					//ausgeben
					draw = true;

					//markieren, damit es nicht mehr ausgegeben wird
					nArr[LRTabIndex]++;
				}
			}

			//Epsilon?
			if( ( draw == true ) && ( p2->right[lr->dot] != epsHashIndex ) )
				//Jump ausgeben
				cout << "Sprung(" << name << ") = " << lr->jumpTo << endl;
		}
	}

	//Speicher freigeben
	delete[] ( tArr );
	delete[] ( nArr );

	//nächste Zeile
	cout << endl << endl;
}


void SSLRParser::insertHulle( HULLE_STR *h )
{
	//Eine Hülle in die Sammlung von Elementen eintragen.
	HULLE_STR	**tmp;

	//Hülle schon eingetragen?
//	if( cmpLR0Hulle( h ) == -1 )
	{
		//Speicher anfordern
		tmp = new( HULLE_STR *[hulle_anz + 1] );

		//kopieren
		memmove( tmp, hulle_str, sizeof( HULLE_STR * ) * hulle_anz );

		//alten Speicher freigeben
		if( hulle_str )
			delete[] ( hulle_str );

		//Zeiger
		hulle_str = tmp;

		//eintragen
		hulle_str[hulle_anz] = h;
		h->hulleIndex = hulle_anz++;

		//Anzahl der Kerne
		coreAnz += h->anzCore;
	}
}


void SSLRParser::genLALR( void )
{
	//Aus der Sammlung der LR(0)-Elemente die Lookaheads anfügen.
	HULLE_STR	*h, *checkHulle, *hTmp, *hTmp2;
	PROD2_STR	*p2;
	Terminal	*checkTerm, *la;
	LR_STR		*lr, *lr2, *lr3;
	long		elem;
	char		*name;
	int			i, j, k, v, hInd, cInd, laAnz, changed;
	int			pass = 0;

	//Check-Terminal # (s. Drache S. 295)
	checkTerm = new Terminal( epsHashIndex );
	checkTerm->ins( lalrHashIndex );

	/******************************************/
	/* spontan generierte Lookaheads erzeugen */
	/******************************************/


	//Alle Hüllen, I
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//für jeden Kern, B -> gamma .delta in K
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//neue Hülle anfordern, erzeuge J' := Hülle({[B -> gamma .delta, #]});
			checkHulle = createHulle();

			//Diesen Kern mit Check-Terminal # in checkHulle eintragen
			insertItem( checkHulle, lr->prod2_index, lr->dot, SSLR_CORE, checkTerm );

			//Hülle bilden
			genLR1Items( checkHulle );

			//Hülle ausgeben
//			outputHulle( checkHulle );

			//Alle LR(1)-Elemente dieser Hülle
			for( k = 0; k < checkHulle->anzElem; k++ )
			{
				//Zeiger auf das LR(1)-Item, [A -> alpha .X beta, a]
				lr2 = &checkHulle->lr_str[k];

				//Zeiger auf die Terminale
				la = lr2->la;

				//Alle Terminale
				for( v = 0; v < la->getAnzElem(); v++ )
				{
					//lalrHashIndex?
					if( (*la)[v] == lalrHashIndex )
						//Ja, Lookaheads breiten sich aus; werden später behandelt
						continue;

					//Zeiger auf die Alternative
					p2 = &prod2_str[lr2->prod2_index];

					//Position des Punktes < maximale Position?
					if( lr2->dot < p2->riAnz )
					{
						//.index holen
						elem = p2->right[lr2->dot];

						//darf nicht Epsilon sein
						if( elem != epsHashIndex )
						{
							//Namen holen
							name = hash_tab->getName( elem );

							//Das LR(0)-Item k in h suchen
							cInd = findItem( h, lr2->prod2_index, lr2->dot );

							//Kern nicht gefunden?
							if( cInd < 0 )
							{
								//Kern nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf Item
							lr3 = &h->lr_str[cInd];

							//Index der Sprung-Hülle
							hInd = lr3->jumpTo;

							//Hülle nicht gefunden?
							if( hInd < 0 )
							{
								//Hülle nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf Hülle
							hTmp2 = hulle_str[hInd];

							//Kern k in hTmp2 finden
							cInd = findItem( hTmp2, lr2->prod2_index, lr2->dot + 1 );

							//Kern nicht gefunden?
							if( cInd < 0 )
							{
								//Kern nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf LR(1)-Item, A -> alpha X .beta in Sprung(I,X)
							lr3 = &hTmp2->lr_str[cInd];

							//spontan generierte Lookaheads aufnehmen
							lr3->lalr->add( la );

							//das checkTerminal löschen
							lr3->lalr->del( lalrHashIndex );

							//Speicher freigeben
//							delete( hTmp );
						}
					}
				}
			}

			//Speicher wieder freigeben
			deleteHulle( checkHulle );
		}
	}

/*
	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Meldung
			cout << "\nKern " << j << ": spontan generierte Lookaheads für " << i << ":" << endl;

			//spontan generierte Lookaheads ausgeben
			outputTerminal( lr->lalr );

			//Absatz
			cout << endl;
		}
	}
*/

	/********************************************/
	/* spontan generierte Lookaheads verbreiten */
	/********************************************/

	//Im ersten Kern ist ACCEPT ein spontan generiertes Lookahead
	hulle_str[0]->lr_str[0].lalr->ins( acceptHashIndex );


	//Ab hier sollten alle spontan generierten Lookaheads verfügbar sein,
	//nun auf die übrigen Kerne verbreiten.

	do
	{
		//keine Änderungen
		changed = 0;

		//Anzahl der Pässe
		pass++;

		//Alle Hüllen, I
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hülle
			h = hulle_str[i];

			//Alle Kerne dieser Hülle, B -> gamma .delta in K
			for( j = 0; j < h->anzCore; j++ )
			{
				//Zeiger auf das LR(0)-Item des Kerns
				lr = &h->lr_str[j];

				//Position des Punktes < maximale Position?
				if( lr->dot < prod2_str[lr->prod2_index].riAnz )
				{
					//Hülle erzeugen, erzeuge J' := Hülle({[B -> gamma .delta, #]});
					hTmp = createHulle();

					//Hülle erzeugen, wo die Terminale hinvererbt werden
					insertItem( hTmp, lr->prod2_index, lr->dot, SSLR_CORE, checkTerm );

					//alle Items erzeugen
					genLR1Items( hTmp );

					//Hülle ausgeben
//					outputHulle( hTmp );

					/*
						Nun alle Elemente dieser Hülle untersuchen, die # als Lookahead haben.
						Von diesen Elementen die Sprung-Hüllen bilden und an die Kerne
						die Looakheads verbreiten.
					*/
					for( k = 0; k < hTmp->anzElem; k++ )
					{
						//Zeiger auf Item, [A -> alpha .X beta, #]
						lr2 = &hTmp->lr_str[k];

						//Hat dieses Element # als Lookahead?
						if( lr2->la->find( lalrHashIndex ) )
						{
							//Ja, die Sprung-Hülle dieses Elements bilden
							p2 = &prod2_str[lr2->prod2_index];

							//Punkt am Ende?
							if( lr2->dot < p2->riAnz )
							{
								//.index holen
								elem = p2->right[lr2->dot];

								//darf nicht Epsilon sein
								if( elem != epsHashIndex )
								{
									//Namen holen
									name = hash_tab->getName( elem );

									//Das LR(0)-Item k in h suchen
									cInd = findItem( h, lr2->prod2_index, lr2->dot );

									//Kern nicht gefunden?
									if( cInd < 0 )
									{
										//Kern nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf Item
									lr3 = &h->lr_str[cInd];

									//Index der Spring-Hülle
									hInd = lr3->jumpTo;

									//Hülle nicht gefunden?
									if( hInd < 0 )
									{
										//Hülle nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf die Hülle
									hTmp2 = hulle_str[hInd];

									//Kern k in hTmp2 finden
									cInd = findItem( hTmp2, lr2->prod2_index, lr2->dot + 1 );

									//Kern nicht gefunden?
									if( cInd < 0 )
									{
										//Kern nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf Item, A -> alpha X .beta in Sprung(I,X)
									lr3 = &hTmp2->lr_str[cInd];

									//Anzahl der Terminale
									laAnz = lr3->lalr->getAnzElem();

									//Lookaheads hinzufügen
									lr3->lalr->add( lr->lalr );

									//# löschen
									lr3->lalr->del( lalrHashIndex );

									//Wurde etwas hinzugefügt?
									if( laAnz != lr3->lalr->getAnzElem() )
										//Ja
										changed++;
								}
							}
						}
					}

					//Speicher freigeben
					deleteHulle( hTmp );
				}
			}
		}

/*
		//alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hülle
			h = hulle_str[i];

			//alle Kerne
			for( j = 0; j < h->anzCore; j++ )
			{
				//Zeiger auf das LR(0)-Item
				lr = &h->lr_str[j];

				//Meldung
				cout << "\nspontan generierte Lookaheads für " << i << ":" << endl;

				//spontan generierte Lookaheads ausgeben
				outputTerminal( lr->lalr );

				//Absatz
				cout << endl;
			}
		}
*/


	}while( changed );

	//Meldung?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate LALR-Items!" << endl;

	//Speicher für Check-Terminal # freigeben (s. Drache S. 295)
	delete( checkTerm );


	//überall die Hüllen neu generieren
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//Hülle ausgeben
//		outputHulle( h );

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//alten Speicher freigeben
			delete( lr->la );

			//Lookaheads eintragen
			lr->la = lr->lalr;

			//zurücksetzen
			lr->lalr = 0L;
		}

		//Hüllen erzeugen
		genLR1Items( h );
	}

/*
	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Meldung
			cout << "\nspontan generierte Lookaheads für " << i << ":" << endl;

			//spontan generierte Lookaheads ausgeben
			outputTerminal( lr->lalr );

			//Absatz
			cout << endl;
		}
	}
*/
}


void SSLRParser::genLR0Jump( HULLE_STR *I0, HULLE_STR *I1, long index )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name, *tmpName;
	int			i;

	//Name von index
	name = hash_tab->getName( index );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt em Ende?
		if( lr->dot < p2->riAnz )
		{
			//Name von Element nach Punkt
			tmpName = hash_tab->getName( p2->right[lr->dot] );

			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == index )
				//Ja, als Kern in I1 eintragen
				insertItem( I1, lr->prod2_index, lr->dot + 1, SSLR_CORE );
		}
	}

	//Alle LR(0)-Elemente dieser Hülle erzeugen
	genLR0Items( I1 );
}


void SSLRParser::genLR1Jump( HULLE_STR *I0, HULLE_STR *I1, long index )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	int			i;

	//Name von index
	name = hash_tab->getName( index );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt em Ende?
		if( lr->dot < p2->riAnz )
		{
			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == index )
				//Ja, als Kern in I1 eintragen
				insertItem( I1, lr->prod2_index, lr->dot + 1, SSLR_CORE, lr->la );
		}
	}

	//Alle LR(1)-Elemente dieser Hülle erzeugen
	genLR1Items( I1 );
}


void SSLRParser::outputTerminal( Terminal *la )
{
	//Terminale ausgeben
	int	i, anz;

	//Anzahl der Terminale
	anz = la->getAnzElem();

	//alle Terminale ausgeben
	for( i = 0; i < anz; i++ )
		//ausgaben
		cout << hash_tab->getName( (*la)[i] ) << ", ";
}


void SSLRParser::setJump( HULLE_STR *I0, long elem, long HIindex )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	int			i;

	//Name von index
	name = hash_tab->getName( elem );

	//Alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == elem )
				//Ja, den Index der Hülle eintragen, die durch Sprung( I0, elem ) erzeugt wird
				lr->jumpTo = HIindex;
		}
	}
}


bool SSLRParser::cmp2LR0Hulle( HULLE_STR *a, HULLE_STR *b )
{
	//Hier werden die LR(0)-Kerne beider Hüllen verglichen
	LR_STR	*lr;
	int		i, cInd;

	//Kerne gleich?
	if( ( a->anzElem == b->anzElem ) && ( a->anzCore == b->anzCore ) )
	{
		//Ja, gleich
		for( i = 0; i < a->anzCore; i++ )
		{
			//Zeiger auf Kern von a
			lr = &a->lr_str[i];

			//Ist dieses Item in b?
			if( ( cInd = findItem( b, lr->prod2_index, lr->dot ) ) < 0 )
				//Nein
				return( false );

			//Ist es ein Kern?
			else if( cInd > ( a->anzCore - 1 ) )
				//Ist kein Kern
				return( false );
		}

		//gleich
		return( true );
	}

	//nicht gleich
	return( false );
}


void SSLRParser::LR2LALR( void )
{
	//Wandelt die LR(1)-Hüllen in LR(0)-Hüllen
	HULLE_STR	*a, *b, **tmp;
	LR_STR		*lr;
	int			i, j, k;

	//Meldung?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Making LR to LALR..." << endl;

	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf Hülle
		a = hulle_str[i];

		//Alle anderen Hüllen mit dieser vergleichen
		for( j = i + 1; j < hulle_anz; j++ )
		{
			//Zeiger auf Hülle
			b = hulle_str[j];

			//beiden Hüllen vergleichen
			if( cmp2LR0Hulle( a, b ) == true )
			{
				//Meldung?
				if( argv_str->verbose )
					//ja
					cout << "Closure " << i << " and " << j << " equal..." << endl;

				//Die Terminale der Kerne von b in a eintragen, dann b löschen
				for( k = 0; k < b->anzCore; k++ )
				{
					//Zeiger auf Kern
					lr = &b->lr_str[k];

					//Kern in a eintragen
					insertItem( a, lr->prod2_index, lr->dot, SSLR_CORE, lr->la );
				}

				//Hülle nochmal bilden, da Lookaheads möglicherweise anders
				genLR1Items( a );

				//den Speicher der Hülle freigeben
				deleteHulle( b );

				//Speicher für alle Hüllen
				tmp = new( HULLE_STR *[hulle_anz - 1] );

				//Hüllen kopieren
				memmove( tmp, hulle_str, sizeof( HULLE_STR * ) * j );
				memmove( &tmp[j], &hulle_str[j + 1], sizeof( HULLE_STR * ) * ( hulle_anz - j - 1 ) );

				//Hülle b löschen

				//eine Hülle weniger
				hulle_anz--;

				//alten Speicher freigeben
				delete[] ( hulle_str );

				//Zeiger
				hulle_str = tmp;

				//Index erniedrigen
				j--;
			}
		}

		//Hüllennummerierung
		a->hulleIndex = i;
	}
}


void SSLRParser::LRTab( void )
{
	//LR-Tabelle erzeugen
	PROD2_STR	*p2;
	HULLE_STR	*h;
	PROD_STR	*p1;
	Terminal	*la;
	LR_STR		*lr;
	char		*name;
	long		elem;
	int			i, j, type, lrTabIndex;

	//Meldugn ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Generate LR-Table..." << endl;

	//Speicher für die LR-Tabelle
	lrTab = new( LR_TAB *[hulle_anz] );

	//Speicher für die Sprung-Tabelle
	jumpTab = new( int *[hulle_anz] );

	//Für jeden Zustand die Spalten anfordern
	for( i = 0; i < hulle_anz; i++ )
	{
		//Speicher für Spalte
		lrTab[i] = new( LR_TAB[termArrCount + 1] );

		//Speicher für Spalte
		jumpTab[i] = new( int[ntermArrCount] );

		//Initialisieren
		memset( lrTab[i], 0, sizeof( LR_TAB ) * termArrCount );
		memset( jumpTab[i], 0, sizeof( int ) * ntermArrCount );
	}


	//Alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//Alle LR(0)/LR(1)-Elemente der Hülle
		for( j = 0; j < h->anzElem; j++ )
		{
			//Zeiger auf das LR(0)/LR(1)-Item
			lr = &h->lr_str[j];

			//Zeiger auf die Alternative
			p2 = &prod2_str[lr->prod2_index];

			//Zeiger auf die Alternative
			p1 = &prod_str[p2->prod_index];

			//ist es ein Element der Art .expr?
			if( lr->dot < p2->riAnz )
			{
				//Element nach Punkt, hier z.B. expr
				elem = p2->right[lr->dot];

				//Index des Elements in der LR-Tabelle
				lrTabIndex = hash_tab->getLRTabIndex( elem );

				//Typ holen
				type = hash_tab->getType( elem );

				//Name holen
				name = hash_tab->getName( elem );

				//Nichtterminal vor Punkt?
				if( type == SSLR_NTERM )
				{
					//ja, Eintrag in Sprung-Hülle
					jumpTab[i][lrTabIndex] = lr->jumpTo;

					//Meldung?
					if( argv_str->verbose == 2 )
						//ja
						cout << "sslr: LRTab: jump[" << i << "][" << name << "] = " << lr->jumpTo << "..." << endl;
				}

				else if( elem == epsHashIndex )
				{
					//Spezial-Fall, reduzieren

					//SLR-Parser?
					if( argv_str->type == SSLR_SLR )
						//Follow-Menge
						la = hash_tab->getFollow( p1->hash_index );

					else
						//bei LALR und LR sind es die Lookaheads
						la = lr->la;

					//reduzieren eintragen
					setReduce( i, lr->prod2_index, la );
				}

				else
					//Terminal schieben
					setShift( i, elem, lr->jumpTo );

			}

			else
			{
				//Reduce-Zustand

				//SLR-Parser?
				if( argv_str->type == SSLR_SLR )
					//Follow-Menge
					la = hash_tab->getFollow( p1->hash_index );

				else
					//bei LALR und LR sind es die Lookaheads
					la = lr->la;

				//Reduzieren eintragen
				setReduce( i, lr->prod2_index, la );
			}
		}
	}

	//ltTab[1][ACCEPT] = Akzeptiere
	lrTab[1][termArrCount].state = SSLR_ACCEPT;

	//Shift-Reduce-Fehler aufgetreten?
	if( srError )
		//Meldung
		cerr << "sslr: " << srError << " shift-reduce error(s) occured!" << endl;

	//Reduce-Reduce-Fehler aufgetreten?
	if( rrError )
		//Meldung
		cerr << "sslr: " << rrError << " reduce-reduce error(s) occured!" << endl;
}


void SSLRParser::setReduce( int hInd, long prod2_index, Terminal *la )
{
	//Einen Reduce-Eintrag erzeugen und dabei Reduce-Reduce- und Shift-Reduce-Fehler behandeln.
	PROD2_STR	*p2, *p3, *p4;
	PROD_STR	*p1;
	long		elem;
	char		*name;
	int			i, laAnz, lrTabIndex;
	int			tAssoc, pPriority, tPriority, state;

	//hier mit der Produktion prod2_index reduzieren
//	h = hulle_str[hInd];

	//Zeiger auf die Alternative
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die Alternative
	p1 = &prod_str[p2->prod_index];

	//Anzahl der Lookaheads
	laAnz = la->getAnzElem();

	//für jedes Lookahead
	for( i = 0; i < laAnz; i++ )
	{
		//nächstes Lookahead holen
		elem = (*la)[i];

		//Namen
		name = hash_tab->getName( elem );

		//Spalten-Index in LR-Tabelle holen
		lrTabIndex = hash_tab->getLRTabIndex( elem );

		//ist dieser Eintrag in der Hash-Tabelle schon belegt?
		if( lrTab[hInd][lrTabIndex].state == SSLR_REDUCE )
		{
			//Reduce-Reduce-Konflikt

			//Zeiger auf die PROD2_STR
			p3 = &prod2_str[lrTab[hInd][lrTabIndex].value];
			p4 = &prod2_str[prod2_index];

			//ist ein "echter" Reduce-Reduce-Konflikt
			if( argv_str->verbose == 1 )
			{
				//Meldung ausgeben
				cout << "sslr: Reduce-Reduce conflict in closure " << hInd << " between" << endl;

				//eingetragene Produktion ausgeben
				outputAlt( cout, lrTab[hInd][lrTabIndex].value );

				cout << "and" << endl;

				//eingetragene Produktion ausgeben
				outputAlt( cout, prod2_index );

				//neue Zeile
				cout << endl;
			}

			//Fehler
			rrError++;
		}

		else if( lrTab[hInd][lrTabIndex].state == SSLR_SHIFT )
		{
			//Shift-Reduce-Fehler

			//Fehler ausgeben?
			if( argv_str->verbose == 1 )
			{
				//Meldung ausgeben
				cout << "sslr: Shift-Reduce conflict in closure " << hInd << " between reducing" << endl;

				//Alternative ausgeben, mit der reduziert werden soll
				outputAlt( cout, prod2_index ),

				//Schieben mit Terminal
				name = hash_tab->getName( lrTab[hInd][lrTabIndex].termHashIndex );
				cout << "and shifting " << name << "!" << endl << endl;
			}

			//Priorität des geschobenen Terminals
			tPriority = hash_tab->getPriority( lrTab[hInd][lrTabIndex].termHashIndex );

			//Priorität der Produktion holen
			pPriority = p2->priority;

			//Assoziation des Terminals holen
			tAssoc = hash_tab->getAssociation( lrTab[hInd][lrTabIndex].termHashIndex );

			//wurde die Priorität überhaupt angegeben?
			if( ( tPriority > 0 ) && ( pPriority > 0 ) )
			{
				//ja, Priorität der Produktion > Priorität des Terminals?
				if( pPriority > tPriority )
					//ja, reduzieren
					state = SSLR_REDUCE;

				else if( ( tPriority == pPriority ) && ( tAssoc == isLeftAssoc ) )
					//beide Prioritäten gleich, zu schiebendes Terminal ist links-assoziativ
					state = SSLR_REDUCE;

				//nicht-assoziatives Terminal?
				else if( ( tPriority == pPriority ) && ( tAssoc == isNonAssoc ) )
				{
					//Ja, Fehlereintrag
					lrTab[hInd][lrTabIndex].state = 0;
					lrTab[hInd][lrTabIndex].value = 0;

					//ausgeben
					state = SSLR_ERROR;
				}

				else
					//nichts von alledem
					state = SSLR_SHIFT;
			}

			else
				//schieben
				state = SSLR_SHIFT;

			//schieben oder reduzieren?
			if( state == SSLR_REDUCE )
			{
				//reduzieren
				lrTab[hInd][lrTabIndex].state = SSLR_REDUCE;
				lrTab[hInd][lrTabIndex].value = prod2_index;

				//Meldung?
				if( argv_str->verbose == 1 )
					//ausgeben
					cout << "reduce..." << endl;

				//merken, dass reduziert wird
				prod2_str[prod2_index].reduce--;

				//Meldung ausgeben?
				if( argv_str->verbose == 2 )
				{
					//ja
//					cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce " << hash_tab->getName( p1->hash_index ) << "..." << endl;
					cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce with ";

					//rechte Seite ausgeben
					outputAlt( cout, prod2_index );
				}
			}

			else if( ( state == SSLR_SHIFT ) && ( argv_str->verbose == 1 ) )
				//geschobenen beibehalten
				cout << "shift..." << endl << endl;

			else if( ( state == SSLR_ERROR ) && ( argv_str->verbose == 1 ) )
				//Terminal ist nicht-assoziativ
				cout << "Terminal is non-associative!" << endl;

			//Fehler
			srError++;
		}

		else
		{
			//kein Fehler aufgetreten
			lrTab[hInd][lrTabIndex].state = SSLR_REDUCE;
			lrTab[hInd][lrTabIndex].value = prod2_index;

			//merken, dass reduziert wird
			prod2_str[prod2_index].reduce++;

			//Meldung ausgeben?
			if( argv_str->verbose == 2 )
			{
				//ja
//				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce " << hash_tab->getName( p1->hash_index ) << "..." << endl;
				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce with ";

				//rechte Seite ausgeben
				outputAlt( cout, prod2_index );
			}
		}
	}
}


void SSLRParser::setShift( int hInd, long termHashIndex, int jumpTo )
{
	//Einen Shift-Eintrag erzeugen und dabei Shift-Reduce-Fehler behandeln.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	long		prod2_index;
	char		*name;
	int			lrTabIndex;
	int			tAssoc, pPriority, tPriority, state;

	//Spalten-Index in LR-Tabelle holen
	lrTabIndex = hash_tab->getLRTabIndex( termHashIndex );

	//Name holen
	name = hash_tab->getName( termHashIndex );

	//Ist dieser Eintrag in der Hash-Tabelle schon belegt?
	if( lrTab[hInd][lrTabIndex].state == SSLR_REDUCE )
	{
		//Shift-Reduce-Fehler

		//Index der Alternative in PROD2_STR
		prod2_index = lrTab[hInd][lrTabIndex].value;

		//Zeiger auf die Alternative
		p2 = &prod2_str[prod2_index];

		//Zeiger auf die Alternative
		p1 = &prod_str[p2->prod_index];

		//Fehler ausgeben?
		if( argv_str->verbose == 1 )
		{
			//Meldung ausgeben
			cout << "sslr: Shift-Reduce conflict in closure " << hInd << " between reducing" << endl;

			//Alternative ausgeben, mit der reduziert werden soll
			outputAlt( cout, prod2_index ),

			//Schieben mit Terminal
			cout << "and shifting " << name << "!" << endl;
		}

		//Priorität des geschobenen Terminals
		tPriority = hash_tab->getPriority( termHashIndex );

		//Priorität der Produktion holen
		pPriority = p2->priority;

		//Assoziation des Terminals holen
		tAssoc = hash_tab->getAssociation( termHashIndex );

		//wurde die Priorität überhaupt angegeben?
		if( ( tPriority > 0 ) && ( pPriority > 0 ) )
		{
			//ja, Priorität der Produktion > Priorität des Terminals?
			if( pPriority > tPriority )
				//ja, reduzieren
				state = SSLR_REDUCE;

			else if( ( tPriority == pPriority ) && ( tAssoc == isLeftAssoc ) )
				//beide Prioritäten gleich, Terminal ist links-assoziativ
				state = SSLR_REDUCE;

			//nicht-assoziatives Terminal?
			else if( ( tPriority == pPriority ) && ( tAssoc == isNonAssoc ) )
			{
				//ja, Fehlereintrag
				lrTab[hInd][lrTabIndex].state = 0;
				lrTab[hInd][lrTabIndex].value = 0;

				//ausgeben
				state = SSLR_ERROR;
			}

			else
				//nichts von alledem
				state = SSLR_SHIFT;
		}

		else
			//Schieben
			state = SSLR_SHIFT;

		//schieben oder reduzieren?
		if( state == SSLR_SHIFT )
		{
			//schieben
			lrTab[hInd][lrTabIndex].state = SSLR_SHIFT;
			lrTab[hInd][lrTabIndex].value = jumpTo;
			lrTab[hInd][lrTabIndex].termHashIndex = termHashIndex;

			//merken, dass nicht reduziert, sondern geschoben wird
			prod2_str[prod2_index].reduce--;

			//Meldung?
			if( argv_str->verbose == 1 )
				//ausgeben
				cout << "shift..." << endl << endl;

			//Meldung ausgeben?
			if( argv_str->verbose == 2 )
				//ja
				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = shift " << jumpTo << "..." << endl;
		}

		else if( ( state == SSLR_REDUCE ) && ( argv_str->verbose == 1 ) )
			//Reduktion mit Alternative beibehalten
			cout << "reduce..." << endl << endl;

		else if( ( state == SSLR_ERROR ) && ( argv_str->verbose == 1 ) )
			//Terminal ist nicht-assoziativ
			cout << "Terminal is non-associative!" << endl;

		//Fehler
		srError++;
	}

	else
	{
		//kein Fehler aufgetreten
		lrTab[hInd][lrTabIndex].state = SSLR_SHIFT;
		lrTab[hInd][lrTabIndex].value = jumpTo;
		lrTab[hInd][lrTabIndex].termHashIndex = termHashIndex;

		//Meldung ausgeben?
		if( argv_str->verbose == 2 )
			//ja
			cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = shift " << jumpTo << "..." << endl;
	}
}


void SSLRParser::processErrorStr( void )
{
	/*
		Innerhalb der Grammatik kann man mittels %error Fehleranweisungen
		in den erzeugten Parser einbauen.
		Ein LR-Parser kann aber nötige Reduktionen verweigern, wenn das
		darauffolgend zu schiebende Terminal nich als Lookahead vorliegt.
		Also werden hier die Zustände gefunden, die vor dem Item mit der
		Fehleranweisung stehen und die reduzieren.
	*/

	//falls noch gar keine Hüllen erzeugt wurden
	assert( hulle_anz );

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		HulleErrorIndexStr	*hInd;
		LRReduceErrorItem	*lrItemArr;
		unsigned long		i, j, k, lrItemArrCnt = 0, anzLRItem = 0;
		unsigned long		*lrStack;
		ERRTERM_STR			*errTermStr;
		PROD2_STR			*p2;
		HULLE_STR			*hStr = 0L;
		ERROR_STR			*errorStr;
		PROD_STR			*p1;
		int					*lrMarked, lrStackSp, *errTermArr;
		int					termIndex;


		//Anzahl aller möglichen LR-Items bestimmen
		for( i = 0; i < hulle_anz; i++ )
			//Anzahl der LR-Items dieser Hülle addieren
			anzLRItem += hulle_str[i]->anzElem;

		//einen Stack einrichten
		lrStack = new( unsigned long[prod2_anz] );

		//zum Markieren von Nichtterminalen
		lrMarked = new( int[prod2_anz] );

		/*
			Für jede Fehleranweisung der Art
			prod1 -> prod2 .prod3 ...
			werden ja die reduzierenden LR-Items gesucht, bei denen
			LA >= FIRST(prod3) ist.

 			Wenn
			prod1 -> prod2 prod3.
			dann gilt LA >= FOLLOW(prod1).

 			Ist hingegen
			prod1 -> .prod2 prod3, dann suche zuerst die LR-Items, bei denen
			gilt
			prodX -> prodY .prod1
		*/
		lrItemArr = new( LRReduceErrorItem[anzLRItem] );


		/*
			Jede Fehleranweisung der Art
			prod1 -> prod2 .prod3
			steht in einer ERROR_STR.
		*/
		for( j = 0; j < error_anz; j++ )
		{
			//Zeiger auf ERROR_STR holen
			errorStr = &error_str[j];

			/*
				Für jede ERROR_STR die Zustände eintragen, für die die
				Fehlermeldung auch ausgegeben werden soll. Dies entspricht
				den case-Anweisungen in der SSLR_error-Routine des erzeugten
				Parser-Files sslrparser.cpp.
			*/
			hInd = &errorStr->hInd;
			hInd->arr = new( unsigned long[hulle_anz] );
			hInd->anzArr = 0;


			//Zeiger auf die Produktion des Fehler-LR-Items
			p1 = &prod_str[errorStr->prod_index];

			//Zeiger auf die Alternative des Fehler-LR-Items
			p2 = &prod2_str[errorStr->prod2_index];

//Fehler-LR-Item ausgeben
//outputItem( errorStr->prod2_index, errorStr->dot );


			/*
				Sei das Fehler-LR-Item von der Form
				prod1 -> ... prod2 .prod3
				Wenn nun prod2 ein Terminal ist, dann überspringen.
			*/
			if( !( errorStr->dot && ( hash_tab->getType( p2->right[errorStr->dot - 1] ) == SSLR_TERM ) ) )
			{
				Terminal 		*t;
				unsigned long	prod2_index;
				/*
					PROBLEM:

					union
						:	startUnion 'BOPEN' unionBody 'BCLOSE'
							|	'EPSILON'
							;

					startUnion
						:	'UNION'
							%error
							{
								1:OVERREAD(BCLOSE):		"Missing { in %union!"
							}
							;

					unionBody
						:	unionBody unionBody2
						|	unionBody2
						;

					unionBody2
						:	'IDENT' 'IDENT' 'SEMIKOLON'
						|	'IDENT' 'AST' 'IDENT' 'SEMIKOLON'
						;

					Wenn der Parser im Zustand
					startUnion : 'UNION'., BOPEN
					ist, dann reduziert er nur, wenn LA=BOPEN ist, d.h. der
					Fehler für die Fehleranweisung muss schon in diesem
					Zustand ausgegeben werden.
				*/

				//eine neue Terminal-Struktur für die FIRST-Elemente
				t = new Terminal( epsHashIndex );

				/*
					Wenn das Fehler-Item der Art
					prod1 -> ... prod2 .prod3 ...
					ist, dann muss die LA-Menge der reduzierenden Items
					FIRST(prod3) enthalten.
				*/
				if( errorStr->dot == p2->riAnz )
					//FOLLOW-Menge der Produktion
					t->add( hash_tab->getFollow( p1->hash_index ) );

				else
				{
					//FIRST-Menge des Elements for dem Punkt
					int	i;

					//alle Elemente auf der rechten Seite, ab errorStr->dot
					for( i = errorStr->dot; i < p2->riAnz; i++ )
					{
						//FIRST-Menge hinzufügen
						t->add( hash_tab->getFirst( p2->right[i] ) );

						//ist EPSILON enthalten?
						if( t->isEpsilon() && ( ( i + 1 ) < p2->riAnz ) )
							//ja, löschen und weiter
							t->del( epsHashIndex );

						else
							//Schleife beenden
							break;
					}

					//ist EPSILON enthalten?
					if( t->isEpsilon() )
					{
						//ja, die FOLLOW-Menge der Produktion hinzunehmen
						t->add( hash_tab->getFollow( p1->hash_index ) );

						//EPSILON löschen
						t->del( epsHashIndex );
					}
				}


				/*
					Nun alle Hüllen nach Reduce-LR-Items durchsuchen,
					die für LA >= t ist.
				*/
				for( i = 0; i < hulle_anz; i++ )
				{
					//in der Hülle i nach Reduce-LR-Items suchen
					if( findReduceItem( i, prod2_index, t ) == true )
					{
						//Reduce-LR-Item eintragen
						lrItemArr[lrItemArrCnt].prod_index = prod2_str[prod2_index].prod_index;
						lrItemArr[lrItemArrCnt].prod2_index = prod2_index;
						lrItemArr[lrItemArrCnt++].hulleIndex = i;
					}
				}

				/*
					Nun stehen in lrItemArr die Hüllen-Indices, in denen
					LR-Items gefunden wurden, die reduzieren, wenn die
					Terminal-Menge t in deren Lookahead-Mange steht.
					Damit sollen die LR-Items gefunden werden, die vor
					dem Punkt in der Fehlerangabe stehen dürfen.
					Dies heisst aber noch nicht, dass alle LR-Items in
					lrItemArr auch erlaubte Zustände repräsentieren.
					Dies wird nun herausgefunden.
				*/

				//eine neue Hüllen-Struktur erzeugen
				hStr = createHulle();

				//ist der Punkt des Fehler-LR-Items an erster Stelle?
				if( !errorStr->dot && lrItemArrCnt )
				{
					unsigned long	hash_index;
					PROD2_STR		*p2;
					HULLE_STR		*h;
					PROD_STR		*p1;
					LR_STR			*lrStr;
					int				dot, i, j;

					/*
						Der Punkt des Fehler-LR-Items steht an erster Stelle,
						also es ist von der Art
						prod1 -> .prod2 prod3...
						Wir müssen also nun in ALLEN Hüllen nach LR-Items
						suche, die prod1 auf der rechten Seite haben, also
						prodX -> prodY prod1, denn für prod1 in prodX können
						wir ja prod1 einsetzen, also
						prodX -> prodY .prod2 prod3 ...
						Dann müssen wir somit
						prodX -> .prodY prod1
						in die Hülle eintragen um zu sehen, welche LR-Items
						vor prod1 stehen dürfen.

					*/

					//Stack-Pointer zurücksetzen
					lrStackSp = 0;

					//Array mit den Markierungen initialisieren
					memset( lrMarked, 0, sizeof( int ) * prod2_anz );

					//als erstes wird das Fehler-LR-Item auf den Stack gepushed
					lrStack[lrStackSp++] = errorStr->prod_index;

					//solange Einträge auf den Stack sind
					while( lrStackSp )
					{
						//Zeiger auf Stack-Struktur
						unsigned long prodIndex = lrStack[--lrStackSp];

						//bereits markiert?
						if( !lrMarked[prodIndex] )
						{
							//Nicht-Terminal markieren
							lrMarked[prodIndex]++;

							//Hash-Index des Nicht-Terminals
							hash_index = prod_str[prodIndex].hash_index;

//char *name = hash_tab->getName( hash_index );
//cout << "\nSuche nach Nicht-Terminal " << name << endl;

							//alle Hüllen absuchen
							for( i = 0; i < hulle_anz; i++ )
							{
								//Zeiger auf die Hülle
								h = hulle_str[i];

								//alle Items absuchen
								for( j = 0; j < h->anzElem; j++ )
								{
									//Zeiger auf das LR-Item
									lrStr = &h->lr_str[j];

									//das Nicht-Terminal suchen
									dot = findNTERMRightSide( h, j, hash_index );

									//dieses LR-Item interessiert nur, wenn dot != -1
									if( dot != -1 )
									{
										//Zeiger auf die Alternative des Fehler-LR-Items
										p2 = &prod2_str[lrStr->prod2_index];

										//Zeiger auf die Produktion des Fehler-LR-Items
										p1 = &prod_str[p2->prod_index];

//Fehler-LR-Item ausgeben
//outputItem( lrStr->prod2_index, dot );

										//steht der Punkt auch hier am Anfang?
										if( !dot )
											/*
												ja, Nicht-Terminal der Produktion
												auf den Stack pushen
											*/
											lrStack[lrStackSp++] = p2->prod_index;

										else
										{
											/*
												Der Punkt des Fehler-LR-Items steht an erster Stelle,
												also es ist von der Art
												prod1 -> .prod2 prod3...
												Wir müssen also nun in ALLEN Hüllen nach LR-Items
												suche, die prod1 auf der rechten Seite haben, also
												prodX -> prodY prod1, denn für prod1 in prodX können
												wir ja prod1 einsetzen, also
												prodX -> prodY .prod2 prod3 ...

												Hier haben wir ein LR-Item der Art
												prodX -> prodY .prod1 prod3 ...
												gefunden, also
												prodX -> .prodY prod1 prod3 ...
												in die Hülle eintragen.
											*/
											insertItem( hStr, lrStr->prod2_index, dot - 1, SSLR_CORE );
										}
									}
								}
							}
						}
					}
				}

				else if( lrItemArrCnt )
				{
					//der Punkt des Fehler-LR-Items ist nicht an erster Stelle

					/*
						Fehler-LR-Item mit Punkt um eine Position nach links
						verschoben in die Hülle eintragen.
					*/
					insertItem( hStr, errorStr->prod2_index, errorStr->dot - 1, SSLR_CORE );
				}

				//die Hülle generieren
				genLR0Items( hStr );

//Hülle ausgeben
//outputHulle( hStr );


				/*
					In der Hülle hStr stehen nun alle LR-Items, die in Frage kommen.
					Nur diese LR-Items von lrItemArr in hInd->arr eintragen, die
					in der Hülle enthalten sind.
				*/
				for( i = 0; i < lrItemArrCnt; i++ )
				{
					//dieses LR-Item in hStr suchen
					if( findItem( hStr, lrItemArr[i].prod2_index ) != -1 )
						//den Index in der Hülle von lrItemArr in hInd eintragen
						hInd->arr[hInd->anzArr++] = lrItemArr[i].hulleIndex;
				}

				//für nächste ERROR_STR zurücksetzen
				lrItemArrCnt = 0;

				//Terminale freigeben
				delete( t );
			}

			/*
				Nun in allen Hüllen nach dem Fehler-LR-Item suchen, denn
				für diese Zustände muss die Fehlermeldung ja auch ausgegeben
				werden.
			*/
			//Anzahl aller möglichen LR-Items bestimmen
			for( i = 0; i < hulle_anz; i++ )
			{
				//ist das Fehler-Item in der Hülle i enthalten?
				if( findItem( hulle_str[i], errorStr->prod2_index, errorStr->dot ) != -1 )
				{
					//ja, nun prüfen, ob es schon in errorStr->hInd enthalten ist
//cout << "SSLRParser::processErrorStr: Fehler-LR-Item ist in Hülle " << i << " enthalten!" << endl;

					//alle Einträge in errorStr->hInd prüfen
					for( k = 0; k < hInd->anzArr; k++ )
					{
						//Hüllen-Indices gleich?
						if( hInd->arr[k] == i )
							//ja, abbrechen
							break;
					}

					//war es schon enthalten?
					if( k == hInd->anzArr )
						//nein, eintragen
						hInd->arr[hInd->anzArr++] = i;
				}
			}

			//Meldung ausgeben?
			if( argv_str->verbose )
			{
				//ja, informieren
				cout << "sslr: SSLRParser::processErrorStr: Error action in line " << errorStr->line << " is active in ";

				//gibt es nur einen Zustand, in dem die Fehleranweisung aktiv ist?
				if( hInd->anzArr == 1 )
					//ja, ausgeben
					cout << "state " << hInd->arr[0] << "!" << endl;

				else
				{
					int	i;

					//abschliessen
					cout << "states ";

					//alle Zustände ausgeben
					for( i = 0; i < hInd->anzArr; i++ )
					{
						//Zustand ausgeben
						cout << hInd->arr[i];

						//folgt ein weiterer?
						if( ( i + 1 ) < hInd->anzArr )
							//ja
							cout << ",";
					}

					//abschliessen
					cout << "!" << endl;
				}
			}

			//Hülle freigeben?
			if( hStr )
			{
				//Hülle freigeben
				deleteHulle( hStr );

				//initialisieren
				hStr = 0L;
			}
		}

		//Speicher freigeben
		delete[] ( lrItemArr );
		delete[] ( lrMarked );
		delete[] ( lrStack );




		/*
			An dieser Stelle sind alle Fehleranweisungen komplett eingetragen.
			Die Terminale, die zu einer Fehleranweisung der Art
			1:ADD,SUB:	""
			eingetragen wurden, befinden sich in der ERRTERM_STR der Struktur
			ERROR_STR, denn zur Zeit des Scannens der Grammatik ist die
			Gesamtzahl der Terminale noch nicht bekannt, jetzt aber.
		*/
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR holen
			errorStr = &error_str[i];

			/*
				Die Terminale, für die die Fehleraktion gelten soll,
				werden nun linear in ein Array eingetragen. Der Index
				ist der in termArr, die Länge beträgt termArrCount
				Einträge.
			*/
			errTermArr = new( int[termArrCount] );

			//vorab initialisieren
			memset( errTermArr, 0, sizeof( int ) * termArrCount );

			//alle Terminal-Anweisungen
			for( j = 0; j < errorStr->errTermStrAnz; j++ )
			{
				//Zeiger auf die ERRTERM_STR holen
				errTermStr = &errorStr->errTermStr[j];

				//die erste ERRTERM_STR?
				if( !j && errTermStr->neg )
				{
					/*
						errTermArr muss initialisiert werden.
						Dabei wird es mit 1 initialisiert, wenn die
						Terminal-Angaben negiert sind, sonst
						mit 0.
					*/
					for( int i = 0; i < termArrCount; i++ )
						//auf 1 setzen
						errTermArr[i] = 1;
				}

				//den Index des Terminals in termArr holen
				termIndex = getTermArrIndex( errTermStr->terminal );

				//gefunden?
				if( termIndex != -1 )
				{
					//Fehler, das Terminal wurde nicht gefunden
					char *name = hash_tab->getName( errTermStr->terminal );

					//negieren?
					if( errTermStr->neg )
						//ja, auf Null setzen
						errTermArr[termIndex] = 0;

					else
						//nicht negieren, auf 1 setzen
						errTermArr[termIndex] = 1;
				}

				else
				{
					//Fehler, das Terminal wurde nicht gefunden
					char *name = hash_tab->getName( errTermStr->terminal );

					//Fehlermeldung
					cerr << "sslr: SSLRParser::processErrorStr: ERROR: Terminal " << name << " not found in termArr!" << endl;
				}
			}

			//errTermArr in die ERROR_STR eintragen
			errorStr->errTermArr = errTermArr;
		}
	}
}


int SSLRParser::getTermArrIndex( unsigned long hash_index )
{
	//liefere den Index des Terminals in termArr zurück
	int	i;

	//prüfen, ob termArrCount schon angelegt ist
	assert( termArr );

	//alle Einträge in termArr
	for( i = 0; i < termArrCount; i++ )
	{
		//Hash-Indices gleich?
		if( termArr[i] == hash_index )
			//ja, Index zurückliefern
			return( i );
	}

	//Terminal nicht gefunden!
	return( -1 );
}


int SSLRParser::findNTERMRightSide( HULLE_STR *hStr, int item, unsigned long hash_index )
{
	/*
		Hier wird geprüft, ob auf der rechten Seite des LR-Item item
		der Hülle hStr das Nicht-Terminal hash_index auftaucht.
	*/
	PROD2_STR	*p2;
	LR_STR		*lrStr = &hStr->lr_str[item];
	int			i;

	//Zeiger auf die Alternative des LR-Items
	p2 = &prod2_str[lrStr->prod2_index];

	//alle Einträge auf der rechten Seite des LR-Items prüfen
	for( i = 0; i < p2->riAnz; i++ )
	{
		//ist es das gesuchte Nicht-Terminal?
		if( p2->right[i] == hash_index )
			//ja, Position des Punktes wiedergeben
			return( i );
	}

	/*
		Nein, Nicht-Terminal hash_index nicht auf rechter Seite des
		LR-Items gefunden.
	*/
	return( -1 );
}


bool SSLRParser::findReduceItem( unsigned long hulleIndex, unsigned long &prod2_index, Terminal *t )
{
	/*
		Hier wird in der Hülle hulleIndex nach einem LR-Item gesucht,
		das reduziert, wobei seine LA-Symbole mind. t umfassen müssen.
	*/
	unsigned int	i;
	HULLE_STR		*hStr = hulle_str[hulleIndex];
	PROD2_STR		*p2;
	LR_STR			*lr;
	Terminal		*la;

	/*
		Hier müssen wir tatsächlich ALLE LR-Elemente der Hülle untersuchen,
		denn die der Art
		prod -> .'EPSILON'
		sind ja auch reduzierende LR-Items, sie sind aber nicht unbedingt
		im Kern der Hülle!
	*/
	for( i = 0; i < hStr->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &hStr->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//gleich?
		if( ( ( lr->dot == 0 ) && ( p2->right[0] == epsHashIndex ) ) || ( lr->dot == p2->riAnz ) )
		{
			//es ist ein Reduce-LR-Item, nun die Lookahead-Menge prüfen

			/*
				Bei einem SLR-Parser ist die Lookahead-Menge die FOLLOW-Menge
				der Produktion.
			*/
			if( argv_str->type == SSLR_SLR )
				//Zeiger auf die Follow-Menge der Produktion
				la = hash_tab->getFollow( prod_str[p2->prod_index].hash_index );

			else
				//bei LALR und LR sind es die Lookaheads
				la = lr->la;

			//ist die Menge t in la enthalten?
			if( la->bgt( t ) == true )
			{
//den Namen der Produktion ausgeben
//char *name = hash_tab->getName( prod_str[p2->prod_index].hash_index );
//cout << "Nehme FOLLOW(" << name << ") als Lookahead-Menge..." << endl;

//LR-Item ausgeben
//outputItem( lr->prod2_index, lr->dot );

				//die Alternative (prod2_index) zurückliefern
				prod2_index = lr->prod2_index;

				//die Terminale t sind in la enthalten
				return( true );
			}
		}
	}

	//nein, kein passendes LR-Item gefunden
	return( false );
}


void SSLRParser::generateFiles( void )
{
	//hier werden die Source-Files des Parsers erzeugt
	ofstream	cppFile( "sslrparser.cpp" );
	ofstream	hFile( "sslrparser.h" );
	ofstream	termDefHFile( "sslrtermdef.h" );
	char		puf[256];

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Generate parser file..." << endl;

	/*
		Die längste rechte Seite bestimmen.
		Diese Information wird in das Header-File übernommen, falls die
		Debug-Version des Parsers erzeugt werden soll. Mit Hilfe dieser
		Information kann eine formatierte Ausgabe der rechten Seiten
		erfolgen.
	*/
	maxAltRightSideWidth = 0;

	//längstes Terminal/Nichtterminal
	maxElemWidth = 0;

	/*
		Die Breite des längesten Zustands bestimmen. Dazu in einen
		Pufferschreiben.
	*/
	sprintf( puf, "%ld", hulle_anz );

	//Breite des größtes Zustands
	maxStateWidth = strlen( puf ) + 2;







	/*
		Der Scanner liefert ja Tokens zum Parser zurück, die im Prinzip
		für die Auswahl der nächsten Aktion (schieben/reduzieren) benötigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	outputTermDefHFile( termDefHFile );

	//den Header des cpp-Files ausgeben
	outputCPPHeader( cppFile );

	//Terminal-Defines als enum ausgeben
	outputCPPTerminal( cppFile );

	//etwaige Include-Anweisungen einfügen
	outputIncl( cppFile );

	//LR-Tabelle ausgeben
	outputLRTab( cppFile );

	//Sprung-Tabelle ausgeben
	outputJumpTab( cppFile );

	//die Follow-Sets ausgeben
	outputFollow( cppFile );

	//die rechten Seiten ausgeben
	outputAlternatives( cppFile );

	//alle NTERM_STR ausgeben
	outputNtermStr( cppFile );

	//Debug-Mode?
	if( argv_str->debug == true )
		//ja
		outputTermName( cppFile );

	//Fehlerbehandlung ausgeben
	outputErrorRecovery( cppFile );

	//alle übrigen Routinen ausgeben
	outputCPPEnd( cppFile );

	//semantische Aktionen ausgeben
	outputSemAct( cppFile );

	//etwaige eigene Erweiterungen einfügen
	outputExt( cppFile );






	//Mindestbreite festlegen
	maxAltRightSideWidth = ( ( maxAltRightSideWidth + 18 ) < 21 ) ? 21 : ( maxAltRightSideWidth + 18 );
	maxElemWidth = ( ( maxElemWidth + 2 ) < 7 ) ? 7 : ( maxElemWidth + 2 );
	maxStateWidth = ( ( maxStateWidth + 2 ) < 8 ) ? 8 : ( maxStateWidth + 2 );

	//das Header-File generieren
	outputHFile( hFile );
}


void SSLRParser::outputCPPHeader( ofstream &file )
{
	//Den Header des cpp-Files ausgeben

	//Header des cpp-Files
file << "/***************************************************************************\n";
file << "                          sslrparser.cpp  -  description\n";
file << "                             -------------------\n";
file << "    copyright            : (C) 2002 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#include \"sslrparser.h\"\n";
file << "#include <iostream>\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug version *\n";
		file << "****************************/\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug version *\n";
		file << "********************************/\n\n\n";
	}
}


void SSLRParser::outputCPPEnd( ofstream &file )
{
	//alle übrigen Routinen des cpp-Files ausgeben

file << "\n";
file << "\n";
file << "SSLRParser::SSLRParser( SSLEXScanner *scan )\n";
file << "{\n";
file << "	//call reset to initialize the parser\n";
file << "	reset();\n";
file << "\n";
file << "	//scanner class\n";
file << "	SSLR_scanner = scan;\n";
file << "\n";
file << "#ifdef SSLR_INIT\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "SSLRParser::~SSLRParser()\n";
file << "{\n";
file << "#ifdef SSLR_INIT\n";
file << "	//uninizialize user defined variables\n";
file << "	deinit();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::reset( void )\n";
file << "{\n";
file << "	//resets the whole parser\n";
file << "\n";
file << "#ifdef SSLR_DEBUG\n";
file << "	//output\n";
file << "	cout << setw( SSLR_maxStateWidth ) << \" state |\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \" stack |\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \" action |\" << setw( SSLR_maxElemWidth ) << \" next |\" << endl;\n";
file << "\n";
file << "	//separator\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << \"|\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//initialize\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' ) << \" 0 |\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//set debug stack pointer\n";
file << "	SSLR_dbgSp = 0;\n";
file << "#endif\n";
file << "\n";
file << "	//parse stack pointer\n";
file << "	SSLR_sp = 0;\n";
file << "\n";
file << "	//start with state 0\n";
file << "	SSLR_push( 0 );\n";
file << "	SSLR_state = 0;\n";
file << "\n";
file << "	//no errors yet\n";
file << "	SSLR_anzError = 0;\n";
file << "	SSLR_anzSuppressError = 0;\n";
file << "\n";


	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja
		file << "	//semantic actions\n";
		file << "	SSLR_semAct = true;\n";
		file << "\n";
		file << "	//stack counter for semantic action stack\n";
		file << "	SSLR_semStackCnt = 0;\n";
	}

file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::SSLR_getTerminal( void )\n";
file << "{\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Attribut des Scanners auf den Stack schieben
		file << "	//semantic actions allowed?\n";
		file << "	if( SSLR_semAct == true )\n";
		file << "	{\n";
		file << "		//semantic stack overflow?\n";
		file << "		if( SSLR_semStackCnt >= SSLR_maxStackSize )\n";
		file << "		{\n";
		file << "			//yes, print an error message\n";
		file << "			cerr << \"SSLRParser::SSLR_getTerminal: Semantic stack overflow!\" << endl;\n";
		file << "\n";
		file << "			//no more semantic actions allowed\n";
		file << "			SSLR_semAct = false;\n";
		file << "		}\n";
		file << "\n";
		file << "		else\n";
		file << "			//push attribute on stack for semantic actions\n";
		file << "			SSLR_semStack[SSLR_semStackCnt++] = SSLR_attributeStr;\n";
		file << "	}\n";
		file << "\n";
	}

file << "	//get line\n";
file << "	SSLR_line = SSLR_scanner->getYYLineno();\n";
file << "\n";
file << "	//get next terminal\n";
file << "	SSLR_terminal = SSLR_scanner->yyLex( &SSLR_attributeStr );\n";
file << "\n";
file << "	//return terminal\n";
file << "	return( SSLR_terminal );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::yyParse( void )\n";
file << "{\n";
file << "	//start parsing\n";
file << "\n";
file << "	//get first terminal\n";
file << "	SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "	//start parsing\n";
file << "	return( SSLR_parse() );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_push( long ast )\n";
file << "{\n";
file << "	//push a new state on the parse stack\n";
file << "	SSLR_stack[SSLR_sp++] = ast;\n";
file << "\n";
file << "	//stack overflow?\n";
file << "	if( SSLR_sp > SSLR_maxStackSize )\n";
file << "	{\n";
file << "		//stack-overflow\n";
file << "		cerr << \"SSLRParser::SSLR_push: stack overflow!\\nExiting...\" << endl;\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//set new state\n";
file << "	SSLR_state = ast;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "long SSLRParser::SSLR_pop( int anz )\n";
file << "{\n";
file << "	//pop anz elements from the parse stack\n";
file << "	SSLR_sp -= anz;\n";
file << "\n";
file << "	//stack underflow?\n";
file << "	if( SSLR_sp < 0 )\n";
file << "	{\n";
file << "		//stack underflow\n";
file << "		cerr << \"SSLRParser::SSLR_pop: stack underflow!\\nExiting...\" << endl;\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//return new state\n";
file << "	return( SSLR_stack[SSLR_sp - 1] );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::SSLR_parse( void )\n";
file << "{\n";
file << "	//begin parsing\n";
file << "	while( 1 )\n";
file << "	{\n";
file << "		//end of parsing?\n";
file << "		if( ( SSLR_state == 1 ) && ( SSLR_terminal == ACCEPT ) )\n";
file << "			//return number of errors\n";
file << "			return( SSLR_anzError );\n";
file << "\n";
file << "		//shift terminal SSLR_terminal?\n";
file << "		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_SHIFT )\n";
file << "		{\n";
file << "			//yes\n";
file << "			SSLR_shift( &SSLR_lrTab[SSLR_state][SSLR_terminal] );\n";
file << "\n";
file << "			//get new terminal\n";
file << "			SSLR_terminal = SSLR_getTerminal();\n";
file << "		}\n";
file << "\n";
file << "		//reduce with production?\n";
file << "		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_REDUCE )\n";
file << "			//reduce\n";
file << "			SSLR_reduce( &SSLR_lrTab[SSLR_state][SSLR_terminal] );\n";
file << "\n";
file << "		//otherwise an error occured\n";
file << "		else\n";
file << "			//call error recovery\n";
file << "			SSLR_error();\n";
file << "	}\n";
file << "}\n";
	file << "\n";
	file << "\n";

	//Debug-Version
	if( argv_str->debug == true )
	{
		//ja
		file << "void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//shift a terminal onto the parse stack\n";
		file << "\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until it is zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";

		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		file << "	//debug stack overflow?\n";
		file << "	if( SSLR_dbgSp >= SSLR_maxStackSize )\n";
		file << "	{\n";
		file << "		//debug stack overflow\n";
		file << "		cerr << \"SSLRParser::SSLR_shift: Debug stack overflow!\" << endl;\n";
		file << "\n";
		file << "		//exit\n";
		file << "		exit( 1 );\n";
		file << "	}\n";
		file << "\n";
		file << "	//set debug stack\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp].elem = true;\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp++].index = SSLR_terminal;\n";
		file << "\n";
		file << "	//output\n";
		file << "	SSLR_outputDbgStack( SSLR_state, LR_SHIFT, SSLR_terminal, SSLR_terminal );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//shift a new state onto the stack\n";
		file << "	SSLR_push( tab->value );\n";

		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//reduce with production\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "\n";

		//semantische Aktionen?
		if( semActCnt )
		{
			//Ja
			file << "	//perform a semantic action accociated with the reduced production\n";
			file << "	SSLR_doSemAct( tab );\n";
			file << "\n";
		}

		file << "	//get a pointer to the alternative\n";
		file << "	n = &SSLR_ntermStr[tab->value];\n";

		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "	//pop elements from debug stack\n";
		file << "	SSLR_dbgSp -= n->elem;\n";
		file << "\n";
		file << "	//debug stack overflow?\n";
		file << "	if( SSLR_dbgSp >= SSLR_maxStackSize )\n";
		file << "	{\n";
		file << "		//debug stack overflow\n";
		file << "		cerr << \"SSLRParser::SSLR_reduce: Debug stack overflow!\" << endl;\n";
		file << "\n";
		file << "		//exit\n";
		file << "		exit( 1 );\n";
		file << "	}\n";
		file << "\n";
		file << "	//set debug stack\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp].elem = false;\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp++].index = tab->value;\n";
		file << "\n";
		file << "	//output\n";
		file << "	SSLR_outputDbgStack( SSLR_state, LR_REDUCE, tab->value, SSLR_terminal );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//remove states form stack\n";
		file << "	SSLR_state = SSLR_pop( n->elem );\n";
		file << "\n";
		file << "	//get new state\n";
		file << "	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];\n";
		file << "\n";
		file << "	//push new state on stack\n";
		file << "	SSLR_push( SSLR_state );\n";
		file << "}\n";
		file << "\n\n";


		//Routine zur Ausgabe des Debug-Stacks SSLR_dbgStack

		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

file << "void SSLRParser::SSLR_outputDbgStack( int state, int action, int index, int next )\n";
file << "{\n";
file << "	//print the debugging stack\n";
file << "	char	statePuf[SSLR_maxStateWidth + 1];\n";
file << "	char	stackPuf[SSLR_maxElemWidth + 1];\n";
file << "	char	actionPuf[SSLR_maxAltRightSideWidth + 1];\n";
file << "	char	nextPuf[SSLR_maxElemWidth + 1];\n";
file << "	int		stackIndex, i;\n";
file << "\n";
file << "	//curent state in string\n";
file << "	sprintf( statePuf, \"%d\", SSLR_state );\n";
file << "\n";
file << "	//print first element\n";
file << "	stackIndex = SSLR_dbgStack[0].index;\n";
file << "\n";
file << "	//terminal?\n";
file << "	if( SSLR_dbgStack[0].elem == true )\n";
file << "		//terminal\n";
file << "		sprintf( stackPuf, \"%s\", SSLR_termName[stackIndex] );\n";
file << "\n";
file << "	else\n";
file << "		//is nonterminal\n";
file << "		sprintf( stackPuf, \"%s\", SSLR_ntermStr[stackIndex].name );\n";
file << "\n";
file << "	//action\n";
file << "	if( action == LR_SHIFT )\n";
file << "	{\n";
file << "		//shift state\n";
file << "		sprintf( actionPuf, \"push %s\", SSLR_termName[index] );\n";
file << "\n";
file << "\n";
file << "		//next is empty\n";
file << "		sprintf( nextPuf, \"%s\", \" \" );\n";
file << "	}\n";
file << "\n";
file << "	else\n";
file << "	{\n";
file << "		SSLR_NTERM_STR	*str = &SSLR_ntermStr[index];\n";
file << "		int				i;\n";
file << "\n";
file << "		//reduce with alternative\n";
file << "		sprintf( actionPuf, \"reduce with \" );\n";
file << "\n";
file << "		//print name of alternative\n";
file << "		strcat( actionPuf, str->name );\n";
file << "		strcat( actionPuf, \" -> \" );\n";
file << "\n";
file << "		//print all elements on the right side\n";
file << "		for( i = 0; i < str->elem; i++ )\n";
file << "		{\n";
file << "			//print element\n";
file << "			strcat( actionPuf, str->ri[i] );\n";
file << "\n";
file << "			//more elements?\n";
file << "			if( i < ( str->elem - 1 ) )\n";
file << "				//yes\n";
file << "				strcat( actionPuf, \" \" );\n";
file << "		}\n";
file << "\n";
file << "		//alternatives with zero elements have EPSILON on the right side\n";
file << "		if( !str->elem )\n";
file << "			//print EPSILON\n";
file << "			strcat( actionPuf, str->ri[0] );\n";
file << "\n";
file << "		//next is the current terminal\n";
file << "		sprintf( nextPuf, \"%s\", SSLR_termName[next] );\n";
file << "	}\n";
file << "\n";
file << "	//separator\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << \"|\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//initialize\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )\n";
file << "	<< ( string( statePuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxAltRightSideWidth ) << ( string( actionPuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxElemWidth ) << ( string( nextPuf ) + \" |\" ) << endl;\n";
file << "\n";
file << "\n";
file << "\n";
file << "	//print all other debug stack entries\n";
file << "	for( i = 1; i < SSLR_dbgSp; i++ )\n";
file << "	{\n";
file << "		//print element\n";
file << "		stackIndex = SSLR_dbgStack[i].index;\n";
file << "\n";
file << "		//terminal?\n";
file << "		if( SSLR_dbgStack[i].elem == true )\n";
file << "			//terminal\n";
file << "			sprintf( stackPuf, \"%s\", SSLR_termName[stackIndex] );\n";
file << "\n";
file << "		else\n";
file << "			//is nonterminal\n";
file << "			sprintf( stackPuf, \"%s\", SSLR_ntermStr[stackIndex].name );\n";
file << "\n";
file << "		cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )\n";
file << "		<< \"|\" << setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + \" |\" )\n";
file << "		<< setw( SSLR_maxAltRightSideWidth ) << \"|\"\n";
file << "		<< setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "	}\n";
file << "}\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until it is zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";
		file << "	//shift a new state onto the stack\n";
		file << "	SSLR_push( tab->value );\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//reduce with production\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until ists zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";

		//semantische Aktionen?
		if( semActCnt )
		{
			//ja
			file << "	//perform a semantic action accociated with the reduced production\n";
			file << "	SSLR_doSemAct( tab );\n";
			file << "\n";
		}

		file << "	//get a pointer to the alternative\n";
		file << "	n = &SSLR_ntermStr[tab->value];\n";
		file << "\n";
		file << "	//remove states form stack\n";
		file << "	SSLR_state = SSLR_pop( n->elem );\n";
		file << "\n";
		file << "	//get new state\n";
		file << "	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];\n";
		file << "\n";
		file << "	//push new state on stack\n";
		file << "	SSLR_push( SSLR_state );\n";
		file << "}\n";
		file << "\n";
		file << "\n";
	}
}


void SSLRParser::outputCPPTerminal( ofstream &file )
{
	//Terminal-Defines als enum ausgeben
	char	*name;
	int		i, width;

	//Header ausgeben
	file << "//Terminals for debugging\n";
	file << "char *SSLR_scannerToken[] =\n{\n";

	for( i = 0; i < termArrCount; i++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//Define-Anweisung ausgeben
		file << "\t/*" << i << "*/ \"" << name << "\",\n";

		//Breite des Namens
		width = strlen( name );

		//länger?
		if( width > maxElemWidth )
			//ja, merken
			maxElemWidth = width;
	}

	//Abschluss
	file << "\t0L\n};\n\n\n";
}


void SSLRParser::outputLRTab( ofstream &file )
{
	//LR-Tabelle in Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_TAB		*lrtab;
	char		puf1[256+1], puf2[256+1], *name;
	int			i, j, k, id;


	//Überschrift
	file << "//syntax analyze table\n";

	//Definition der LR-Tabelle
	file << "SSLRParser::SSLR_LR_TAB SSLRParser::SSLR_lrTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzTerm] = {\n";

	//Alle Zustände
	for( i = 0; i < hulle_anz; i++ )
	{
		//Öffnen
		file << "/* State " << i << " */\n{ ";

		//Alle Terminale
		for( j = 0, k = 0; j < termArrCount; j++, k++ )
		{
			//Zeiger auf LR_TAB-Struktur
			lrtab = &lrTab[i][j];

			//Zustand ausgeben
			switch( lrtab->state )
			{
				//Fehler?
				case SSLR_ERROR:
				{
					//ja, Fehlerbehandlung
					sprintf( puf1, "%s", "LR_ERROR" );
					break;
				}

				//shift?
				case SSLR_SHIFT:
				{
					//ja, Zustand schieben
					sprintf( puf1, "%s", "LR_SHIFT" );
					break;
				}

				//reduce?
				case SSLR_REDUCE:
				{
					//ja, mit Produktion reduzieren
					sprintf( puf1, "%s", "LR_REDUCE" );

					//Produktion ausschreiben
					p2 = &prod2_str[lrtab->value];

					//Zeiger auf PROD_STR
					p1 = &prod_str[p2->prod_index];

					//Name der Produktion
					name = hash_tab->getName( p1->hash_index );

					//Nummer der Alternative
					id = lrtab->value - p1->prod2_index;

					//Namen generieren
					sprintf( puf2, "%s_%d", name, id );
					break;
				}

				//akzeptieren?
				case SSLR_ACCEPT:
				{
					//ja, akzeptieren
					sprintf( puf1, "%s", "LR_ACCEPT" );
					break;
				}

				default:
				{
					//anderer Wert
					sprintf( puf1, "%d", lrTab[i][j].state );
					break;
				}
			}

			//Werte-Paar ausgeben
			file << "{ " << puf1 << ", ";

			//reduce?
			if( lrtab->state == SSLR_REDUCE )
				//ja
				file << puf2 << " }";

			else
				//ausgeben
				file << lrtab->value << " }";

			//Kommt noch etwas?
			if( j < ( termArrCount - 1 ) )
				//Ja
				file << ",";

			//neue Zeile?
			if( k == 8 )
			{
				//Ja
				file << "\n";
				k = 0;
			}
		}

		//Nächster Zustand?
		if( i < ( hulle_anz - 1 ) )
			//Ja
			file << " },\n";

		else
			//Nein
			file << " }\n";
	}

	//abschliessen
	file << "};\n";
}


void SSLRParser::outputJumpTab( ofstream &file )
{
	//Sprung-Tabelle ausgeben
	PROD_STR	*p1;
	long		index, prod_index;
	char		*name, widthChar[128];
	int			i, j, k, width;

	//Breite des größten Zustands
	sprintf( widthChar, "%ld", hulle_anz );
	width = strlen( widthChar );

	//Definition der Sprung-Tabelle
	file << "\n\n//jump table\n";
	file << "long SSLRParser::SSLR_jumpTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzNTerm] = {\n";

	//zuerst alle Produktionen ausgeben, dient der Orientierung
	file << "//";
	for( i = 0, k = 0; i < ntermArrCount; i++, k++ )
	{
		//neue Zeile?
		if( k == 10 )
			//ja
			file << "\n//";

		//Produktion ausgeben
		file << hash_tab->getName( ntermArr[i] ) << ", ";
	}

	//neue Zeile
	file << "\n\n";

	//Alle Zustände
	for( i = 0; i < hulle_anz; i++ )
	{
		//Öffnen
		file << "/* State " << i << " */\n{ ";

		//Alle Produktionen
		for( j = 0, k = 0; j < ntermArrCount; j++, k++ )
		{
			//Name der Produktion
			name = hash_tab->getName( ntermArr[j] );

			//prod_index holen
			prod_index = hash_tab->getProdStr( ntermArr[j] );

			//Zeiger auf PROD_STR
			p1 = &prod_str[prod_index];

			//Index in Jump-Tabelle
			index = hash_tab->getLRTabIndex( p1->hash_index );

			//Wert ausgeben
			file.width( width );
			file << jumpTab[i][index];

			//Folgt noch etwas?
			if( j < ( prod_anz - 1 ) )
				//Ja
				file << ", ";

			//neue Zeile?
			if( k == 15 )
			{
				//Ja
				file << "\n";
				k = 0;
			}
		}

		//Nächster Zustand?
		if( i < ( hulle_anz - 1 ) )
			//Ja
			file << " },\n";

		else
			//Nein
			file << " }\n";
	}

	//abschliessen
	file << "};\n\n";
}


void SSLRParser::outputAlternatives( ofstream &file )
{
	//die Alternativen in die cpp-Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, puf1[256+1];
	int			i, j, id, type, rs, ns;

	//nur bei Debug-Version
	if( argv_str->debug == true )
	{
		//Header
		file << "\n//all alternatives\n";

		//alle Alternativen
		for( i = 0; i < prod2_anz; i++ )
		{
			//Länge der rechten Seite dieser Alternative
			rs = ns = 0;

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//den Namen der Alternative holen
			name = hash_tab->getName( p1->hash_index );

			//Nummer der Alternative
			id = i - p1->prod2_index;

			//Namen generieren
			sprintf( puf1, "%s%d", name, id );

			//Länge des Namens der Alternative
			ns = strlen( puf1 );

			//addieren zur Länge der rechten Seite dieser Alternative
			rs += ns;

			//länger?
			if( ns > maxElemWidth )
				//ja, merken
				maxElemWidth = ns;

			//initialisieren
			file << "char *SSLRParser::SSLR_" << puf1 << "Ri[" << p2->riAnz << "] = { ";

			//alle Elemente auf der rechten Seite ausgeben
			for( j = 0; j < p2->riAnz; j++ )
			{
				//Namen holen
				name = hash_tab->getName( p2->right[j] );

				//addieren
				rs += strlen( name );

				//Typ holen
				type = hash_tab->getType( p2->right[j] );

				//Terminal?
				if( type == SSLR_TERM )
				{
					//ja
					file << "\"\\\'" << name << "\\\'\"";

					//Terminale werden in ' ausgegeben
					rs += 2;
				}

				else
					//Nichtterminal
					file << "\"" << name << "\"";

				//folgt noch ein Eintrag?
				if( j < ( p2->riAnz - 1 ) )
				{
					//ja
					file << ", ";

					//Space zwischen zwei Elementen auf der rechten Seite
					rs++;
				}
			}

			//abschließen
			file << " };\n";

			//rechte Seite größer?
			if( rs > maxAltRightSideWidth )
				//ja, merken
				maxAltRightSideWidth = rs;
		}
	}
}


void SSLRParser::outputNtermStr( ofstream &file )
{
	//die NTERM_STR ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, puf1[256+1];
	long		followAnz;
	int			i, id, riAnz;

	//Header
	file << "\n\n//all alternatives\n";
	file << "SSLRParser::SSLR_NTERM_STR SSLRParser::SSLR_ntermStr[SSLRParser::SSLR_anzProd] = {\n";

	//alle Alternativen
	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf PROD2_STR
		p2 = &prod2_str[i];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//den Namen der Alternative holen
		name = hash_tab->getName( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Nummer der Alternative
		id = i - p1->prod2_index;

		//Namen generieren
		sprintf( puf1, "%s%d", name, id );

		//ist es eine EPSILON-Produktion?
		if( p2->right[0] == epsHashIndex )
			//ja
			riAnz = 0;

		else
			//nein, ganz normal
			riAnz = p2->riAnz;

		//Debug-Version?
		if( argv_str->debug == true )
			//nein, entsprechende SSLR_NTERM_STR ausgeben
			file << "{ \"" << name << "\", SSLRParser::SSLR_" << puf1 << "Ri, " << name << ", " << riAnz << ", SSLRParser::SSLR_" << name << "Follow, " << followAnz << " }";

		else
			//ja, entsprechende SSLR_NTERM_STR ausgeben
			file << "{ " << name << ", " << riAnz << ", SSLRParser::SSLR_" << name << "Follow, " << followAnz << " }";

		//folgt noch ein Eintrag?
		if( i < ( prod2_anz - 1 ) )
			//ja
			file << ",\n";
	}

	//abschließen
	file << "};\n\n";
}


void SSLRParser::outputFollow( ofstream &file )
{
	//Die Alternativen in die cpp-Datei ausgeben.
	PROD_STR	*p1;
	Terminal	*followSet;
	char		*name;
	long		followAnz, *followTerm;
	int			i, j;

	//Header
	file << "\n//follow sets for the error recovery\n";

	//Alle Produktionen
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Den Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//Zeiger auf die Follow-Elemente
		followSet = hash_tab->getFollow( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Initialisieren
		file << "long SSLRParser::SSLR_" << name << "Follow[" << followAnz << "] = { ";

		//Alle Follow-Elemente ausgeben
		for( j = 0; j < followAnz; j++ )
		{
			//Namen holen
			name = hash_tab->getName( (*followSet)[j] );

			//Terminal ausgeben
			file << name;

			//folgt noch ein Eintrag?
			if( j < ( followAnz - 1 ) )
				//Ja
				file << ", ";
		}

		//abschließen
		file << " };\n";
	}
}


void SSLRParser::outputTermName( ofstream &file )
{
	//Die Namen der Terminale ausgeben, nur im debug-mode
	char	*name;
	int		i, k;

	//Debug-Makro ausgeben
	file << "\n#ifdef SSLR_DEBUG\n";

	//Header
	file << "\n//names of the terminals\n";
	file << "char *SSLRParser::SSLR_termName[SSLRParser::SSLR_anzTerm] =\n{ ";

	//Alle Terminale
	for( i = k = 0; i < termArrCount; i++, k++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//neue Zeile?
		if( k == 16 )
		{
			//Ja
			file << "\n";
			k = 0;
		}

		//Define-Anweisung ausgeben
		file << "\"" << name << "\"";

		//Folgt noch ein Terminal?
		if( i < ( termArrCount - 1 ) )
			//Ja
			file << ", ";
	}

	//abschliessen
	file << " };\n\n";
	file << "#endif\n\n";
}


void SSLRParser::outputSemAct( ofstream &file )
{
	//semantische Aktionen ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, *pos, *tmp, *semTypeName;
	long		_line, LRTabIndex;
	bool		semTypeOK = false;
	int			i, state, depth, semIndex, semTypeIndex, id;
	int			*nArr, *tArr, type, sign, err;

	//gibt es überhaupt welche?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//dient der Vermeidung von Fehlerlawinen
		nArr = new( int[ntermArrCount] );
		tArr = new( int[termArrCount] );

		//initialisieren
		memset( nArr, 0, sizeof( int ) * ntermArrCount );
		memset( tArr, 0, sizeof( int ) * termArrCount );

		//Funktions-Header ausgeben
		file << "void SSLRParser::SSLR_doSemAct( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//do semantic actions before reduction\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "	SSLR_TYPE		tmp;\n";
		file << "\n";
		file << "	//semantic actions allowed?\n";
		file << "	if( SSLR_semAct == true )\n";
		file << "	{\n";
		file << "		//get a pointer to the alternative\n";
		file << "		n = &SSLR_ntermStr[tab->value];\n";
		file << "\n";
		file << "		//Alternative to reduce with\n";
		file << "		switch( tab->value )\n";
		file << "		{\n";

		//alle Alternativen
		for( i = 0; i < prod2_anz; i++ )
		{
			//Fehlerflag zurücksetzen
			err = 0;

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//gibt es semantische Aktionen?
			if( p2->semAct )
			{
				//ja, ausgeben
				name = hash_tab->getName( p1->hash_index );

				//das entsprechende Item ausgeben
				file << "\t\t\t//";
				outputItem( i, p2->riAnz, file );
				file << "\n";

				//case ausgeben
				file << "\t\t\tcase " << name << "_" << i - p1->prod2_index << ":\n";
				file << "\t\t\t{\n\t\t\t\t";

				//Zustand setzen
				state = 0;
				_line = p2->semActLine;

				//Verschachtelung von Kommentaren
				depth = 0;

				//Zeiger auf den text
				pos = p2->semAct;

				//den Text analysieren
				while( *pos && !err )
				{
					//Blancs löschen
					switch( state )
					{
						case 0:
						{
							//Leerzeichen löschen
							while( isspace( *pos ) && ( *pos != '\n' ) )
								//nächstes Zeichen
								file << *pos++;

							break;
						}
					}

					//neue Zeile?
					if( *pos == '\n' )
					{
						//neue Zeile
						_line++;

						//Status: 2?
						if( state != 2 )
						{
							//Status 2 ist Kommentar //
							file << *pos++;
							continue;
						}
					}

					//semantischer Typ?
					if( !state && ( *pos == '$' ) )
					{
						//Ja
						state = 10;
						pos++;
					}

					switch( state )
					{
						//Default-Zustand
						case 10:
						{
							//semantischer Typ?
							if( *pos == '$' )
							{
								//den semantischen Typ der Produktion holen
								semIndex = hash_tab->getUnionType( p1->hash_index );

								//gibt es einen semantischen Typ?
								if( semIndex )
								{
									//ja, mit semantischem Typ ausgeben
									file << "tmp." << unionStr->id[semIndex];

									//ist überflüssigerweise ein semantischer Typ in Form von <typ>
									//angegeben worden?
									if( semTypeOK )
									{
										//sind die Typen gleich?
										if( semIndex == semTypeIndex )
											//Ja, Angabe ist überflüssig
											cerr << "sslr: line " << _line << ": Explicit semantic type statement not necessary!" << endl;

										else
											//nein, sind verschieden!
											cerr << "sslr: line " << _line << ": Explicit semantic type statement does not coincide with %union statement!" << endl;

										//Speicher für Namen freigeben
										delete( semTypeName );

										//Flag zurücksetzen
										semTypeOK = false;
									}
								}

								else
								{
									//nein, ohne semantischen Typ ausgeben
									file << "tmp";

									//ist ein semantischer Typ in Form von <typ> angegeben worden?
									if( semTypeOK )
									{
										//Typ ausgeben
										file << "." << unionStr->id[semTypeIndex];

										//Speicher für Namen freigeben
										delete( semTypeName );

										//Flag zurücksetzen
										semTypeOK = false;
									}

									else
									{
										//nein, Fehler

										//den Namen der Produktion
										name = hash_tab->getName( p1->hash_index );

										//den Index in der LR-Tabelle holen
										LRTabIndex = hash_tab->getLRTabIndex( p1->hash_index );

										//Warnung ausgeben?
										if( !nArr[LRTabIndex] )
											//ja, Warnung ausgeben
											cerr << "sslr: line " << _line << ": No semantic type defined for production " << name << "!" << endl;

										//Vermeidung von Fehlerlawinen
										nArr[LRTabIndex]++;
									}
								}

								//überspringen
								pos++;

								//Zustand zurücksetzen
								state = 0;
							}

							else if( *pos == '<' )
							{
								//ist vom Typ $<...>
								pos++;

								//Position merken
								tmp = pos;

								//solange kein >
								while( ( *pos != '>' ) && *pos )
									//übertragen
									pos++;

								//genügend Speicher anfordern
								semTypeName = new( char[pos - tmp + 1] );

								//kopieren
								strncpy( semTypeName, tmp, pos - tmp );
								semTypeName[pos - tmp] = 0;

								//den Index in unionStr finden
								if( ( semTypeIndex = getSemIndex( semTypeName ) ) < 0 )
								{
									//Typ nicht in %union definiert
									cerr << "sslr: ERROR: line " << _line << ": Type " << semTypeName << " for semantic action not defined in %union!" << endl;

									//Speicher gleich wieder freigeben
									delete( semTypeName );

									//Fehler
									semTypeOK = false;
								}

								else
									//Flag setzen
									semTypeOK = true;

								//> löschen
								pos++;
							}

							else if( isdigit( *pos ) || ( *pos == '-' ) )
							{
								//bezieht sich auf ein Element auf der rechten Seite
								//semStack[semStackCnt-1] ist das letzte Element

								//negativer Index?
								if( *pos == '-' )
								{
									//ja, negativ
									sign = -1;
									pos++;
								}

								else
									//ist positiv
									sign = 1;

								//Zahl einlesen
								id = strtol( pos, 0L, 10 );

								//Vorzeichen
								id *= sign;

								//Ziffern löschen
								while( isdigit( *pos ) )
									pos++;

								//gibt es überhaupt so viele Elemente auf der rechten Seite wie angegeben?
								if( ( id - 1 ) < p2->riAnz )
								{
									//ist es der Form prod -> 'EPSILON'`?
									if( ( p2->riAnz == 1 ) && ( p2->right[0] == epsHashIndex ) )
									{
										//Warnung ausgeben
										cerr << "sslr: line " <<  _line << ": $" << id << " not allowed inside 'EPSILON'-alternative!" << endl;

										//nächste semantische Aktion behandelt
										err++;
										break;
									}

									else
									{
										//den semantischen Typ des Elements holen
										semIndex = hash_tab->getUnionType( p2->right[id - 1] );

										//gibt es einen semantischen Typ?
										if( semIndex )
										{
											//ja, Stack-Zugriff
											file << "SSLR_semStack[SSLR_semStackCnt - 1 - " << p2->riAnz << " + (" << id << ")]." << unionStr->id[semIndex];

											//ist überflüssigerweise ein semantischer Typ in Form von <typ>
											//angegeben worden?
											if( semTypeOK )
											{
												//sind die Typen gleich?
												if( semIndex == semTypeIndex )
													//Ja, Angabe ist überflüssig
													cerr << "sslr: line " << _line << ": Explicit semantic type statement not necessary!" << endl;

												else
													//Nein, sind verschieden!
													cerr << "sslr: line " << _line << ": Explicit semantic type statement does not coincide with %union-Statement!" << endl;

												//Speicher für Namen freigeben
												delete( semTypeName );

												//Flag zurücksetzen
												semTypeOK = false;
											}
										}

										else
										{
											//nein, Stack-Zugriff
											file << "SSLR_semStack[SSLR_semStackCnt - 1 - " << p2->riAnz << " + (" << id << ")]";

											//ist ein semantischer Typ in Form von <typ> angegeben worden?
											if( semTypeOK )
											{
												//Typ ausgeben
												file << "." << unionStr->id[semTypeIndex];

												//Speicher für Namen freigeben
												delete( semTypeName );

												//Flag zurücksetzen
												semTypeOK = false;

												//überspringen
												pos++;
											}

											else
											{
												//den Namen des Elements
												name = hash_tab->getName( p2->right[id - 1] );

												//den Index in der LR-Tabelle holen
												LRTabIndex = hash_tab->getLRTabIndex( p2->right[id - 1] );

												//Typ holen
												type = hash_tab->getType( p2->right[id - 1] );

												//Terminal?
												if( type == SSLR_TERM )
												{
													//ja

													//Warnung ausgeben?
													if( !tArr[LRTabIndex] )
														//Warnung ausgeben
														cerr << "sslr: line " << _line << ": No semantic type defined for terminal " << name << "!" << endl;

													//Vermeidung von Fehlerlawinen
													tArr[LRTabIndex]++;
												}

												else
												{
													//ist ein Nicht-Terminal

													//Warnung ausgeben?
													if( !nArr[LRTabIndex] )
														//Warnung ausgeben
														cerr << "sslr: line " << _line << ": No semantic type defined for nonterminal " << name << "!" << endl;

													//Vermeidung von Fehlerlawinen
													nArr[LRTabIndex]++;
												}
											}
										}
									}
								}

								else
								{
									//Indiziertes Element zu groß!
									cerr << "sslr: line " << _line << ": Number in semantic type statement too big!" << endl;

									//abbrechen
									err++;
									break;
								}

								//Zustand zurücksetzen
								state = 0;
							}

							break;
						}

						case 0:
						{
							//Kommentar?
							if( ( pos[0] == '/' ) && ( pos[1] == '*' ) )
							{
								//ja, Kommentar
								state = 1;

								//Verschachtelung
								depth++;
								pos += 2;

								//ausgeben
								file << "/*";
							}

							else if( ( pos[0] == '/' ) && ( pos[1] == '/' ) )
							{
								//Kommentar
								pos += 2;
								file << "//";
								state = 2;
							}

							else if( *pos )
								//einfach übertragen
								file << *pos++;

							break;
						}

						case 1:
						{
							//Kommentar /*
							if( ( pos[0] == '*' ) && ( pos[1] == '/' ) )
							{
								//Kommentar schliessen
								file << "*/";
								pos += 2;

								//Verschachtelungstiefe
								depth--;

								//Default-Zustand?
								if( !depth )
									//ja
									state = 0;
							}

							else if( ( pos[0] == '/' ) && ( pos[1] == '*' ) )
							{
								//ja, Kommentar

								//Verschachtelung
								depth++;
								pos += 2;

								//ausgeben
								file << "/*";
							}

							else
								//einfach übertragen
								file << *pos++;

							break;
						}

						case 2:
						{
							//Kommentar //
							file << *pos;

							//Newline?
							if( *pos++ == '\n' )
								//ja
								state = 0;

							break;
						}

						default:
							//einfach kopieren
							file << *pos++;
					}
				}

				//case abschliessen
				file << "\t\t\t\tbreak;\n";
				file << "\t\t\t}\n";
				file << "\n";
			}
		}

		file << "//\t\t\tdefault:\n";
		file << "\t\t\t\t//error\n";
		file << "//\t\t\t\tcerr << \"SSLRParser::SSLR_doSemAct: Unknown alternative \" << tab->value << \"!\" << endl;\n";
		file << "\t\t}\n";
		file << "\n\t\t//correct stack pointer\n";
		file << "\t\tSSLR_semStackCnt -= n->elem;\n";
		file << "\n";
		file << "		//semantic stack overflow?\n";
		file << "		if( SSLR_semStackCnt >= SSLR_maxStackSize )\n";
		file << "		{\n";
		file << "			//yes, print an error message\n";
		file << "			cerr << \"SSLRParser::SSLR_doSemAct: Semantic stack overflow!\" << endl;\n";
		file << "\n";
		file << "			//no more semantic actions allowed\n";
		file << "			SSLR_semAct = false;\n";
		file << "		}\n";
		file << "\n";
		file << "		else\n";
		file << "			//push last value on stack\n";
		file << "			SSLR_semStack[SSLR_semStackCnt++] = tmp;\n";
		file << "\t}\n";
		file << "}\n";
		file << "\n";

		//Speicher freigeben
		delete[] ( nArr );
		delete[] ( tArr );
	}
}


void SSLRParser::outputErrorRecovery( ofstream &file )
{
	//Hier wird die komplette Fehlerbehandlung ausgegeben
	LR_TAB	*lrtab;
	char	*name;

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		file << "\n";
		file << "\n";
file << "void SSLRParser::SSLR_printErrorMsg( bool print, char *errMsg  )\n";
file << "{\n";
file << "	//print an error message, but only when it is allowed\n";
file << "	if( ( print == true ) && !SSLR_anzSuppressError )\n";
file << "		//allowed\n";
file << "		cerr << \"sslr: ERROR: line \" << SSLR_line << \": \" << errMsg << endl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errPop( long termi )\n";
file << "{\n";
file << "\t//get current state\n";
file << "\tlong state = SSLR_state;\n";
file << "\n";
file << "\t//pop states from the parse stack untill termi may be shifted\n";
file << "\twhile( SSLR_lrTab[state][termi].state != LR_SHIFT )\n";
file << "\t{\n";
file << "\t\t//pop one element\n";
file << "\t\tstate = SSLR_pop( 1 );\n";
file << "\n";
file << "\t\t//are we in state 1, that is could'n termi be shifted?\n";
file << "\t\tif( state == 1 )\n";
file << "\t\t{\n";
file << "\t\t\t//all states poped from parse stack, exit\n";
file << "\t\t\tSSLR_state = state;\n";
file << "\n";
file << "\t\t\t//set current terminal to ACCEPT to simulate successful parsing\n";
file << "\t\t\tSSLR_terminal = ACCEPT;\n";
file << "\t\t\treturn;\n";
file << "\t\t}\n";
file << "\t}\n";
file << "\n";
file << "\t//set new state\n";
file << "\tSSLR_state = state;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errShift( long termi )\n";
file << "{\n";
file << "\t//can we reduce here?\n";
file << "\twhile( SSLR_lrTab[SSLR_state][termi].state == LR_REDUCE )\n";
file << "\t\t//yes, that might allow recovery\n";
file << "\t\tSSLR_reduce( &SSLR_lrTab[SSLR_state][termi] );\n";
file << "\n";
file << "	//shift a new state\n";
file << "	if( SSLR_lrTab[SSLR_state][termi].state == LR_SHIFT )\n";
file << "		//push new state onto the parse stack\n";
file << "		SSLR_push( SSLR_lrTab[SSLR_state][termi].value );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errDelete( void )\n";
file << "{\n";
file << "	//delete current terminal\n";
file << "	SSLR_terminal = SSLR_getTerminal();\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errOverRead( long termi )\n";
file << "{\n";
file << "	//delete all terminals untill termi is found\n";
file << "	do\n";
file << "	{\n";
file << "		//get next terminal\n";
file << "		SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "		//equal?\n";
file << "		if( SSLR_terminal == termi )\n";
file << "			//yes, return\n";
file << "			return;\n";
file << "\n";
file << "		else if( SSLR_terminal == ACCEPT )\n";
file << "		{\n";
file << "			//abort parsing\n";
file << "			SSLR_state = 1;\n";
file << "			return;\n";
file << "		}\n";
file << "\n";
file << "	}while( 1 );\n";
file << "}\n";
	}

	//Fehler-Routine ausgeben
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_error( void )\n";
file << "{\n";
file << "	//error handling\n";
file << "	long	tmpState, tmpSp;\n";
file << "	int		rec = 0;\n";
file << "\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Flag ausgeben
		file << "	//no more semantic actions allowed\n";
		file << "	SSLR_semAct = false;\n";
		file << "\n";
	}

file << "	//count error\n";
file << "	SSLR_anzError++;\n";
file << "\n";
file << "\n";



	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		unsigned long	i, j, k, m;
		ERROR_STR		*errorStr;
		bool			outputCase;
		long			LRTabIndex;
		int				pass, autoErr;

		//ja, Header ausgeben
		file << "	switch( SSLR_state )\n";
		file << "	{\n";

		//alle Hüllen-Indices prüfen
		for( i = 0; i < hulle_anz; i++ )
		{
			/*
				vor Verarbeitung der ersten Hülle muss ein case-Statement
				ausgegeben werden
			*/
			outputCase = true;

			//einen neuen Zustand prüfen, dazu zwei Pässe
			for( pass = 0; pass < 2; pass++ )
			{
				/*
					Für alle ERROR_STR prüfen, ob sie eine Fehleranweisung
					für den Zustand i haben.
				*/
				for( j = 0; j < error_anz; j++ )
				{
					//Zeiger auf ERROR_STR
					errorStr = &error_str[j];

					//hat diese Hülle eine Fehleraktion für Zustand i?
					for( k = 0; k < errorStr->hInd.anzArr; k++ )
					{
						//gesuchter Zustand?
						if( errorStr->hInd.arr[k] == i )
						{
							//Fehleraktion ausgeben

							//case-Statement ausgeben?
							if( outputCase == true )
							{
								//Einleitung
								file << "\t\tcase " << i << ":\n";
								file << "\t\t{\n";
								file << "\t\t\tswitch( SSLR_terminal )\n";
								file << "\t\t\t{\n";

								//nicht noch einmal ausgeben
								outputCase = false;
							}

							/*
								Im ersten Pass werden nur Terminal-gebundene
								Fehleraktionen bearbeitet, also der Art
								1:ADD,SUB:AKTION:		"Fehlermeldung!" oder
								1:!(ADD,SUB):AKTION:	"Fehlermeldung!"
							*/
							if( !pass & errorStr->errTermStrAnz )
							{
								//das Fehler-Item ausgeben
								file << "\t\t\t\t//line " << errorStr->line << ", ";

								//entsprechende Alternative ausgeben
								outputItem( errorStr->prod2_index, errorStr->dot, file );
								file << "\n";

								//hat die ERROR_STR überhaupt Terminal-gebundenen Fehleraktionen?
								if( errorStr->errTermStr )
								{
									//alle Terminale durchgehen
									for( m = 0; m < termArrCount; m++ )
									{
										//Terminal gesetzt?
										if( errorStr->errTermArr[m] )
										{
											//den Namen des Terminals holen
											name = hash_tab->getName( termArr[m] );

											//case-Statement ausgeben
											file << "\t\t\t\tcase " << name << ":\n";
										}
									}
								}

								//neue Zeile
								file << "\t\t\t\t{\n";

								//interne Fehlerbehandlung standardmässig ausgeben
								autoErr = 1;

								//Fehlermeldung ausgeben?
								if( errorStr->msg )
								{
									/*
										Die Fehlermeldung MUSS vor den Fehler-Aktionen ausgegeben werden, da,
										wenn z.B. EXIT verwendet wird, die Fehlermeldung nicht gezeigt
										würde!
									*/
									file << "\t\t\t\t\t//show user defined error message\n";
									file << "\t\t\t\t\tSSLR_printErrorMsg( true, \"" << errorStr->msg << "\" );\n\n";
								}


								//Zustände vom Parse-Stack poppen?
								if( errorStr->pop )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->pop );

									//Zustände vom Parse-Stack poppen
									file << "\t\t\t\t\t//pop states from parse stack\n";
									file << "\t\t\t\t\tSSLR_ERROR_POP( " << name << " );\n\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//Terminal auf den Parse-Stack schieben?
								if( errorStr->shift )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->shift );

									//neuen Zustand schieben
									file << "\t\t\t\t\t//shift terminal " << name << "\n";
									file << "\t\t\t\t\tSSLR_ERROR_SHIFT( " << name << " );\n\n";

									//Index des Terminals in der LR-Tabelle holen
									LRTabIndex = hash_tab->getLRTabIndex( errorStr->shift );
//LRTabIndex = getTermArrIndex( errorStr->shift );

									//prüfen, ob das Terminal tatsächlich in diesem Zustand i geschoben werden kann

									//Zeiger auf LR_TAB-Struktur
									lrtab = &lrTab[errorStr->hInd.arr[k]][LRTabIndex];

									//kann das Terminal geschoben werden?
									if( lrtab->state != LR_SHIFT )
										//nein, Warnung ausgeben
										cerr << "sslr: line " << errorStr->line << ": Terminal " << name << " cannot be shifted in state " << i << "!" << endl;

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//Terminale überlesen?
								if( errorStr->overread )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->overread );

									//Terminale überlesen
									file << "\t\t\t\t\t//delete terminals until " << name << " ist the current terminal\n";
									file << "\t\t\t\t\tSSLR_ERROR_OVERREAD( " << name << " );\n\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//aktuelles Terminal aus der Eingabe löschen?
								if( errorStr->del )
								{
									//ein Terminal löschen
									file << "\t\t\t\t\t//delete current terminal\n";

									//mehrfaches Auftreten von DELETE ist erlaubt
									for( m = 0; m < errorStr->del; m++ )
										file << "\t\t\t\t\tSSLR_ERROR_DELETE();\n";

									//neue Zeile
									file << "\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//den Parse-Prozess beenden?
								if( errorStr->exit )
								{
									//Parsen abbrechen
									file << "\t\t\t\t\t//stop parsing\n";
									file << "\t\t\t\t\tSSLR_ERROR_EXIT;\n";
								}


								//semantische Aktionen trotz Fehlers weiterführen?
								if( errorStr->sem )
								{
									//semantische Aktionen trotz Fehler zulassen

									//gibt es überhaupt semantische Aktionen?
									if( semActCnt && ( unionStr->anz > 1 ) )
									{
										//ja
										file << "\t\t\t\t\t//allow semantic actions despite the error\n";
										file << "\t\t\t\t\tSSLR_ERROR_SEM;\n\n";
									}

									else
										//nein
										cerr << "sslr: line " << errorStr->line << ": There are no semantic actions not to allow!" << endl;
								}


								//automatische Fehlerbehandlung überspringen, wenn keine Aktion gewählt wurde oder nur SEM
								if( autoErr )
								{
									//nein, automatische Fehlerbehandlung trotz eigener Fehler-Angaben ausführen
									file << "\t\t\t\t\t//skip automatic error recovery\n";
									file << "\t\t\t\t\trec++;\n";
								}

								//case für diese ERROR_STR abschliessen
								file << "\n";
								file << "\t\t\t\t\t//leave\n";
								file << "\t\t\t\t\tbreak;\n";
								file << "\t\t\t\t}\n";

								//nächste ERROR_STR prüfen
								break;
							}

							//zweiter Pass?
							else if( pass )
							{
								/*
									zweiter Pass, hier nun die Fehleraktionen ausgeben, die
									nicht mit einem Terminal verbunden sind, also der Art
									1:AKTION:	"Fehlermeldung!
								*/
								if( !errorStr->errTermStr )
								{
									//das Fehler-Item ausgeben
									file << "\t\t\t\t//line " << errorStr->line << ", ";

									//entsprechende Alternative ausgeben
									outputItem( errorStr->prod2_index, errorStr->dot, file );
									file << "\n";

									//alle nicht-Terminal-gebundenen Fehleranweisung unter default subsummieren
									file << "\t\t\t\tdefault:\n";

									//neue Zeile
									file << "\t\t\t\t{\n";

									//interne Fehlerbehandlung standardmässig ausgeben
									autoErr = 1;

									//Fehlermeldung ausgeben?
									if( errorStr->msg )
									{
										/*
											Die Fehlermeldung MUSS vor den Fehler-Aktionen ausgegeben werden, da,
											wenn z.B. EXIT verwendet wird, die Fehlermeldung nicht gezeigt
											würde!
										*/
										file << "\t\t\t\t\t//show user defined error message\n";
										file << "\t\t\t\t\tSSLR_printErrorMsg( true, \"" << errorStr->msg << "\" );\n\n";
									}


									//Zustände vom Parse-Stack poppen?
									if( errorStr->pop )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->pop );

										//Zustände vom Parse-Stack poppen
										file << "\t\t\t\t\t//pop states from parse stack\n";
										file << "\t\t\t\t\tSSLR_ERROR_POP( " << name << " );\n\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//Terminal auf den Parse-Stack schieben?
									if( errorStr->shift )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->shift );

										//neuen Zustand schieben
										file << "\t\t\t\t\t//shift terminal " << name << "\n";
										file << "\t\t\t\t\tSSLR_ERROR_SHIFT( " << name << " );\n\n";

										//Index des Terminals in der LR-Tabelle holen
										LRTabIndex = hash_tab->getLRTabIndex( errorStr->shift );
//LRTabIndex = getTermArrIndex( errorStr->shift );

										//prüfen, ob das Terminal tatsächlich in diesem Zustand i geschoben werden kann

										//Zeiger auf LR_TAB-Struktur
										lrtab = &lrTab[errorStr->hInd.arr[k]][LRTabIndex];

										//kann das Terminal geschoben werden?
										if( lrtab->state != LR_SHIFT )
											//nein, Warnung ausgeben
											cerr << "sslr: line " << errorStr->line << ": Terminal " << name << " cannot be shifted in state " << i << "!" << endl;

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//Terminale überlesen?
									if( errorStr->overread )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->overread );

										//Terminale überlesen
										file << "\t\t\t\t\t//delete terminals until " << name << " ist the current terminal\n";
										file << "\t\t\t\t\tSSLR_ERROR_OVERREAD( " << name << " );\n\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//aktuelles Terminal aus der Eingabe löschen?
									if( errorStr->del )
									{
										//ein Terminal löschen
										file << "\t\t\t\t\t//delete current terminal\n";

										//mehrfaches Auftreten von DELETE ist erlaubt
										for( m = 0; m < errorStr->del; m++ )
											file << "\t\t\t\t\tSSLR_ERROR_DELETE();\n";

										//neue Zeile
										file << "\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//den Parse-Prozess beenden?
									if( errorStr->exit )
									{
										//Parsen abbrechen
										file << "\t\t\t\t\t//stop parsing\n";
										file << "\t\t\t\t\tSSLR_ERROR_EXIT;\n";
									}


									//semantische Aktionen trotz Fehlers weiterführen?
									if( errorStr->sem )
									{
										//semantische Aktionen trotz Fehler zulassen

										//gibt es überhaupt semantische Aktionen?
										if( semActCnt && ( unionStr->anz > 1 ) )
										{
											//ja
											file << "\t\t\t\t\t//allow semantic actions despite the error\n";
											file << "\t\t\t\t\tSSLR_ERROR_SEM;\n\n";
										}

										else
											//nein
											cerr << "sslr: line " << errorStr->line << ": There are no semantic actions not to allow!" << endl;
									}


									//automatische Fehlerbehandlung überspringen, wenn keine Aktion gewählt wurde oder nur SEM
									if( autoErr )
									{
										//nein, automatische Fehlerbehandlung trotz eigener Fehler-Angaben ausführen
										file << "\t\t\t\t\t//skip automatic error recovery\n";
										file << "\t\t\t\t\trec++;\n";
									}

									//default für diese ERROR_STR abschliessen
									file << "\n";
									file << "\t\t\t\t\t//leave\n";
									file << "\t\t\t\t\tbreak;\n";
									file << "\t\t\t\t}\n";

									//pro Zustand ist nur eine nicht-Terminal-gebundene Fehleranweisung zulässig
//									j = error_anz;
//									break;
								}

								//case-Anweisung abschliessen
								file << "\t\t\t}\n";

								//pro Zustand ist nur eine nicht-Terminal-gebundene Fehleranweisung zulässig
								j = error_anz;
								break;
							}
						}
					}
				}
			}

			//Zustand abschliessen?
			if( outputCase == false )
			{
				//ja, es gab für die Hülle i Fehleranweisungen
				file << "\n";
				file << "\t\t\t//leave\n";
				file << "\t\t\tbreak;\n";
				file << "\t\t}\n\n";
			}
		}


		//default ausgeben
		file << "		default:\n";
		file << "		{\n";
		file << "			//default error message\n";
		file << "			SSLR_printErrorMsg( true, \"Syntax error!\" );\n";
		file << "			break;\n";
		file << "		}\n";

		//switch-Statement abschliessen
		file << "\t}\n\n";
	}

	else
	{
		//es gibt keine benutzter-definierten Fehleranweisungen, nun default-Fehlermeldung ausgeben
		file << "	//default error message\n";
		file << "	cerr << \"line: \" << SSLR_line << \": Syntax error!\" << endl;\n";
	}

	//nun die Standard-Fehlerbehandlung

file << "\n";
file << "	//supress further error messages\n";
file << "	SSLR_anzSuppressError = SSLR_anzSuppressErrorMsg;\n";
file << "\n";
file << "	//skip intern error recovery?\n";
file << "	if( rec )\n";
file << "		//yes, return\n";
file << "		return;\n";
file << "\n";
file << "	//save current stack position\n";
file << "	tmpSp = SSLR_sp;\n";
file << "\n";
file << "	//pop states from the parse stack until a valid transition is found\n";
file << "	do\n";
file << "	{\n";
file << "		//pop one state from the parse stack\n";
file << "		tmpState = SSLR_pop( 1 );\n";
file << "\n";
file << "		//is there a transition?\n";
file << "		if( ( SSLR_sp > 0 ) && ( SSLR_lrTab[tmpState][SSLR_terminal].state == LR_SHIFT ) )\n";
file << "		{\n";
file << "			//we found a valid transition, consider recovered\n";
file << "			SSLR_state = tmpState;\n";
file << "			return;\n";
file << "		}\n";
file << "\n";
file << "		//did we check the whole stack?\n";
file << "		else if( SSLR_sp < 1 )\n";
file << "		{\n";
file << "			//the whole stack has been visited without success\n";
file << "			SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "			//end of input, that is ACCEPT?\n";
file << "			if( SSLR_terminal == ACCEPT )\n";
file << "			{\n";
file << "				//yes, stop parsing\n";
file << "				SSLR_state = 1;\n";
file << "				return;\n";
file << "			}\n";
file << "\n";
file << "			//set stack pointer\n";
file << "			SSLR_sp = tmpSp;\n";
file << "		}\n";
file << "\n";
file << "	}while( 1 );\n";
file << "}\n";
}


void SSLRParser::outputIncl( ofstream &file )
{
	//Include-Anweisungen in das cpp-File ausgeben
	char	*incl = SSLR_scanner->getInclude(), *beg;
	ulong	len;

	//gibt es include-Anweisungen?
	if( incl )
	{
		//am Anfang das \{ löschen
		while( !( ( incl[0] == '\\' ) && ( incl[1] == '{' ) ) )
			incl++;

		//löschen
		incl = &incl[2];

		//die Länge der Include-Anweisungen
		len = strlen( incl );

		//merken
		beg = &incl[len - 2];

		//am Ende das \{ löschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << incl;
	}
}


void SSLRParser::outputExt( ofstream &file )
{
	//eigene Erweiterungen in das cpp-File ausgeben
	char	*ext = SSLR_scanner->getExtension(), *beg;
	ulong	len;

	//gibt es Extensionen?
	if( ext )
	{
		//am Anfang das \{ löschen
		while( !( ( ext[0] == '\\' ) && ( ext[1] == '{' ) ) )
			ext++;

		//löschen
		ext = &ext[2];

		//die Länge der eigenen Erweiterungen
		len = strlen( ext );

		//merken
		beg = &ext[len - 2];

		//am Ende das \{ löschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << ext;
	}
}


void SSLRParser::outputTermDefHFile( ofstream &file )
{
	/*
		Der Scanner liefert ja Tokens zum Parser zurück, die im Prinzip
		für die Auswahl der nächsten Aktion (schieben/reduzieren) benötigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	char *name;
	int	i;

	//Kopf ausgeben
file << "/***************************************************************************\n";
file << "                          sslrtermdef.h  -  description\n";
file << "                             -------------------\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLRTERMDEF_H\n";
file << "#define SSLRTERMDEF_H\n";
file << "\n";
file << "\n";
file << "/**\n";
file << "\t@author SSLR V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";

	//Terminale, die der Scanner zurückliefert
	file << "//Terminals returned by the scanner\n";

	for( i = 0; i < termArrCount; i++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//Define-Anweisung ausgeben
		file << "#define " << name << "\t" << i << "\n";
	}


	//wurde eine %union-Angabe vorgenommen?
	if( unionStr->anz > 1 )
	{
		//ja, ausgeben
		file << "\n\n\n//Type for semantic actions\n";
		file << "typedef union\n{\n";

		//Text ausgeben
		file << unionStr->text;

		//abschliessen
		file << "\n}SSLR_TYPE;\n\n\n";
	}

	//Ende des Header-Files
	file << "#endif\n\n";
}


void SSLRParser::outputHFile( ofstream &file )
{
	//Header-File ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char 		*name, puf1[256+1];
	char 		**userDefHeader;
	long		followAnz;
	int			i, j, id, userDefHeaderCnt;

	//Kopf ausgeben
file << "/***************************************************************************\n";
file << "                          sslrparser.h  -  description\n";
file << "                             -------------------\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLRPARSER_H\n";
file << "#define SSLRPARSER_H\n";
file << "\n";
file << "\n";
file << "/**\n";
file << "\t@author SSLR V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";


	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug version *\n";
		file << "****************************/\n\n\n";

		//Debug-Makro
		file << "//define debug macro\n";
		file << "#define SSLR_DEBUG\n";
		file << "//#undef SSLR_DEBUG\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug version *\n";
		file << "********************************/\n\n\n";
	}

	//Include-Files
	file << "//Include-Files\n";
	file << "#include <iostream>\n";
	file << "#include <iomanip>\n";
	file << "#include \"sslexscanner.h\"\n\n";

	//allgemeine Definitionen

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		//ja, die Fehlerroutinen als Defines ausgeben
		file << "\n//error routines\n";
		file << "#define SSLR_ERROR_POP\t\t\tSSLR_errPop\n";
		file << "#define SSLR_ERROR_DELETE\t\tSSLR_errDelete\n";
		file << "#define SSLR_ERROR_SHIFT\t\tSSLR_errShift\n";
		file << "#define SSLR_ERROR_OVERREAD\t\tSSLR_errOverRead\n";
		file << "#define SSLR_ERROR_SEM\t\t\tSSLR_semAct = true\n";
		file << "#define SSLR_ERROR_EXIT\t\t\texit( 1 )\n";
		file << "\n";
	}



	//Nicht-Terminal-Defines für Sprung-Tabelle
	file << "\n//Nonterminal defines for the jump table\n";

	for( i = 0; i < ntermArrCount; i++ )
	{
		//Name des Nicht-Terminals
		name = hash_tab->getName( ntermArr[i] );

		//Define-Anweisung ausgeben
		file << "#define " << name << "\t" << i << "\n";
	}



	//Nicht-Terminale für die LR-Tabelle
	file << "\n\n//Nontermials for the LR table\n";

	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf PROD2_STR
		p2 = &prod2_str[i];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Name der Produktion
		name = hash_tab->getName( p1->hash_index );

		//Nummer der Alternative
		id = i - p1->prod2_index;

		//Namen generieren
		sprintf( puf1, "%s_%d", name, id );

		//Define-Anweisung ausgeben
		file << "#define " << puf1 << "\t" << i << "\n";
	}



	//Klassen-Deklaration
	file << "\n\nclass SSLRParser\n";
	file << "{\n";
	file << "private:\n";


	//Struktur für die LR-Tabelle
	file << "\n\t//LR table\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";
	file << "\t\tint\t\t\tstate;\n";
	file << "\t\tlong\t\tvalue;\n";
	file << "\n\t}SSLR_LR_TAB;\n\n";


	//Struktur für alle Alternativen
	file << "\n";
	file << "\t//all productions\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		file << "\t\t//name of alternative\n";
		file << "\t\tchar\t*name;\n";
		file << "\n";
		file << "\t\t//pointer to right side of alternative\n";
		file << "\t\tchar\t**ri;\n";
		file << "\n";
	}

	//Zeiger auf die Follow-Terminale
	file << "\t\t//index in jumpTab\n";
	file << "\t\tint\t\tjump_index;\n";
	file << "\n";
	file << "\t\t//number of elements on the right side\n";
	file << "\t\tint\t\telem;\n";
	file << "\n";
	file << "\t\t//pointer to follow sets\n";
	file << "\t\tlong\t*follow;\n";
	file << "\n";
	file << "\t\t//number of follow terminals\n";
	file << "\t\tlong\tfollowCnt;\n";
	file << "\n";
	file << "\t}SSLR_NTERM_STR;\n";
	file << "\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		//Debug-Stack-Struktur ausgeben
		file << "\t//stack for debugging\n";
		file << "\ttypedef struct\n";
		file << "\t{\n";
		file << "\t\t//true: terminal, false: nonterminal\n";
		file << "\t\tbool\telem;\n";
		file << "\n";
		file << "\t\t//terminal: index in SSLR_termName, nonterminal: index in SSLR_NTERM_STR\n";
		file << "\t\tint\t\tindex;\n";
		file << "\n";
		file << "\t}SSLR_debugStack;\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	file << "\n\n\n\t//private class variables\n\n\n\n";

	//Anzahl der Zustände
	file << "\t//Number of lr states\n";
	file << "\tstatic const unsigned long\tSSLR_anzLRStates = " << hulle_anz << ";\n\n";

	//Anzahl der Terminale
	file << "\t//Number of terminals = number of columns in lrTab\n";
	file << "\tstatic const unsigned long\tSSLR_anzTerm = " << termArrCount << ";\n\n";

	//Anzahl der Produktionen
	file << "\t//Number of productions = number of rows in jumpTab\n";
	file << "\tstatic const unsigned long\tSSLR_anzNTerm = " << prod_anz << ";\n\n";

	//Anzahl der Alternativen
	file << "\t//Number of alternatives\n";
	file << "\tstatic const unsigned long\tSSLR_anzProd = " << prod2_anz << ";\n\n";

	//Zustände in der LR-Tabelle
	file << "\n\t//Actions in lrTab\n";
	file << "\tstatic const int\t\t\tLR_ERROR = 1;\n";
	file << "\tstatic const int\t\t\tLR_SHIFT = 2;\n";
	file << "\tstatic const int\t\t\tLR_REDUCE = 3;\n";
	file << "\tstatic const int\t\t\tLR_ACCEPT = 4;\n\n";

	//Stack-Größe
	file << "\n\t//maximum stack size\n";
	file << "\tstatic const int\t\t\tSSLR_maxStackSize = 100;\n\n";


	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Breite der längsten rechten Seite aller Alternativen
		file << "\t//longest right side of all alternatives\n";
		file << "\tstatic const int\t\t\tSSLR_maxAltRightSideWidth = " << maxAltRightSideWidth << ";\n\n";

		//Breite des längsten Elements (Terminal/Nicht-Terminal)
		file << "\t//longest terminal or nonterminal\n";
		file << "\tstatic const int\t\t\tSSLR_maxElemWidth = " << maxElemWidth << ";\n\n";

		//Breite des größten Zustands
		file << "\t//longest state\n";
		file << "\tstatic const int\t\t\tSSLR_maxStateWidth = " << maxStateWidth << ";\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	/*
		Anzahl der erfolgreichen Reduktionen bzw. Shifts nach einem Fehler,
		um wieder Fehlermeldungen zu zeigen.
	*/
	file << "	//number of seccessful reduce - and shift actions\n";
	file << "	//neccassary after an error occured\n";
	file << "	static const int\t\t\tSSLR_anzSuppressErrorMsg = 3;\n";
	file << "\n";

	//Anzahl der erfolgreichen Reduktionen bzw. Shifts nach einem Fehler
	file << "	//number of seccessful reduce - and shift actions after an error occured\n";
	file << "	int\t\t\t\t\t\t\tSSLR_anzSuppressError;\n";
	file << "\n";


	//Stack für Zustände
	file << "\n";
	file << "	//parse stack\n";
	file << "	long\t\t\t\t\t\tSSLR_stack[SSLR_maxStackSize];\n";
	file << "\n";


	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Stack fürs Debugging
		file << "\t//debug stack\n";
		file << "\tSSLR_debugStack\t\t\t\tSSLR_dbgStack[SSLR_maxStackSize];\n\n";

		//Stack-Pointer fürs Debugging
		file << "\t//debug stack pointer\n";
		file << "\tlong\t\t\t\t\t\tSSLR_dbgSp;\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	file << "	//stack counter\n";
	file << "	long\t\t\t\t\t\tSSLR_sp;\n";
	file << "\n";
	file << "\n";

	//LR-Tabelle
	file << "\t//LR table\n";
	file << "\tstatic SSLR_LR_TAB\t\t\tSSLR_lrTab[SSLR_anzLRStates][SSLR_anzTerm];\n\n";

	//Sprung-Tabelle
	file << "\t//jump table\n";
	file << "\tstatic long\t\t\t\t\tSSLR_jumpTab[SSLR_anzLRStates][SSLR_anzNTerm];\n\n";

	//Scanner-Klasse
	file << "\t//scanner class\n";
	file << "\tSSLEXScanner *\t\t\t\tSSLR_scanner;\n\n";

	//array with all alternatives
	file << "\t//array with all alternatives\n";
	file << "\tstatic SSLR_NTERM_STR\t\tSSLR_ntermStr[SSLR_anzProd];\n\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Array mit den Namen der Terminale
		file << "\t//array with the names of the terminals\n";
		file << "\tstatic char *\t\t\t\tSSLR_termName[SSLR_anzTerm];\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	//Typ des Terminals, dass der Scanner zurückliefert
	file << "	//current terminal\n";
	file << "	int\t\t\t\t\t\t\tSSLR_terminal;\n";
	file << "\n";

	//Atrribut des Terminals wie z.B. Zahlenwert
	file << "	//attributes returned form scanner\n";
	file << "	SSLR_TYPE\t\t\t\t\tSSLR_attributeStr;\n";
	file << "\n";

	//Zeile, in der ein Fehler auftrat
	file << "	//line number\n";
	file << "	unsigned long\t\t\t\tSSLR_line;\n";
	file << "\n";

	//aktueller Zustand des Parsers
	file << "	//current state\n";
	file << "	int\t\t\t\t\t\t\tSSLR_state;\n";
	file << "\n";

	//Anzahl der aufgetretenen Fehler
	file << "	//number of errors\n";
	file << "	int\t\t\t\t\t\t\tSSLR_anzError;\n";
	file << "\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//semantische Aktionen, für Fehlerbehandlung
		file << "	//allow/deny semantic actions\n";
		file << "	bool\t\t\t\t\t\tSSLR_semAct;\n";
		file << "\n";
		file << "	//stack for semantic actions\n";
		file << "	SSLR_TYPE\t\t\t\t\tSSLR_semStack[SSLR_maxStackSize];\n";
		file << "\n";
		file << "	//stack counter for semantic action stack\n";
		file << "	unsigned int\t\t\t\tSSLR_semStackCnt;\n";
		file << "\n";
	}

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//die rechten Seiten
		file << "\t//Alternatives\n";

		//alle rechten Seiten (nur Debug)
		for( i = 0; i < prod2_anz; i++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//den Namen der Alternative holen
			name = hash_tab->getName( p1->hash_index );

			//Nummer der Alternative
			id = i - p1->prod2_index;

			//Namen generieren
			sprintf( puf1, "%s%d", name, id );

			//initialisieren
			file << "\tstatic char *\t\t\t\tSSLR_" << puf1 << "Ri[" << p2->riAnz << "];\n";
		}
	}

	//alle Follow-Mengen ausgeben
	file << "\n	//all follow sets for the error recovery\n";

	//alle Follow-Mengen ausgeben
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//den Namen der Alternative holen
		name = hash_tab->getName( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//initialisieren
		file << "\tstatic long\t\t\t\t\tSSLR_" << name << "Follow[" << followAnz << "];\n";
	}

	//private Methoden
	file << "\n\n\t//private methods\n\n";


	//Methoden der Klasse
file << "\n";
file << "	//push a new state on parse stack\n";
file << "	void SSLR_push( long );\n";
file << "\n";
file << "	//pop elements from parse stack\n";
file << "	long SSLR_pop( int );\n";
file << "\n";
file << "	//begin parsing\n";
file << "	int SSLR_parse( void );\n";
file << "\n";
file << "	//shift a new state onto the parse stack\n";
file << "	void SSLR_shift( SSLR_LR_TAB * );\n";
file << "\n";
file << "	//reduce with a production\n";
file << "	void SSLR_reduce( SSLR_LR_TAB * );\n";
file << "\n";
file << "	//error handling\n";
file << "	void SSLR_error( void );\n";
file << "\n";
file << "	//print an error message, but only when it is allowed\n";
file << "	void SSLR_printErrorMsg( bool, char * );\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Ausgaberoutine für den Debug-Stack
		file << "	//print the debug stack SSLR_dbgStack\n";
		file << "	void SSLR_outputDbgStack( int, int, int, int );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		//ja, Hilfsroutinen ausgeben
		file << "	//shift a new state onto the parse stack\n";
		file << "	void SSLR_errShift( long );\n";
		file << "\n";
		file << "	//pop elements from the parse stack untill term may be shifted\n";
		file << "	void SSLR_errPop( long );\n";
		file << "\n";
		file << "	//delete next terminal\n";
		file << "	void SSLR_errDelete( void );\n";
		file << "\n";
		file << "	//delete all terminals untill term is found\n";
		file << "	void SSLR_errOverRead( long );\n";
		file << "\n";
	}

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Prototypen ausgeben
		file << "\t//perform semantic actions associated with the production\n";
		file << "\t//to be reduced\n";
		file << "\tvoid SSLR_doSemAct( SSLR_LR_TAB * );\n";
		file << "\n";
	}

file << "	//get next terminal\n";
file << "	int SSLR_getTerminal( void );\n";
file << "\n";
file << "public:\n";
file << "\n";
file << "	//public methods \n";
file << "	SSLRParser( SSLEXScanner * );\n";
file << "	~SSLRParser();\n";
file << "\n";
file << "	//resets the whole parser\n";
file << "	void reset( void );\n";
file << "\n";
file << "	//start parsing\n";
file << "	int yyParse( void );\n";
file << "\n";
file << "\n";

	//benutzerdefinierte Daten holen
	userDefHeader = SSLR_scanner->getUserDefHeader( userDefHeaderCnt );

	//alle Zeilen
	for( j = 0; j < userDefHeaderCnt; j++ )
		//ausgeben
		file << userDefHeader[j];

file << "};\n";
file << "\n";
file << "\n";

	//Ende des Header-Files
	file << "#endif\n\n";
}

