/*
	Dies ist die sslr-Grammatik. Diese habe ich selbst entwickelt und nicht
	wie bei SSLEX, einem GNU-Projekt entnommen.
	(c) 2005 by Sven Schmidt
	s.schmidt@lboro.ac.uk

	Last modified: 23.04.2005
*/


%include
\{
	//SSLR initialisieren
	#define SSLR_INIT

\}


%definition


/*
	Die später verwendeten semantischen Typen müssen hier definiert sein.
	Der Attribut-Parsestack (SSLR_TYPE) besteht aus diesen Elementen.
*/
%union
{
	//Strings
	char		*name;

	//einfache Zahl
	int			integer;
}


//hier werden den Nicht-Terminalen semantische Typen zugewiesen
%ntermType <integer> ntermDef initBeforeNumber
%ntermType <name> semanticAction errorMsg startUnion

//hier werden den Terminalen semantische Typen zugewiesen
%termType <name> TERMINAL NON_TERMINAL IDENT TYPE SEMACT STRING UNION
%termType <integer> NUMBER




	/**********************************************
	 ** hier stehen Deklarationen, die später im **
	 ** Header-File des erzeugten Parsers stehen **
	 **********************************************/


	private:

	//Hier werden die Produktionen abgelegt, ohne die rechte Seite.
	//Die rechten Seiten sind in PROD2_STR abgelegt.
	typedef struct
	{
		//Index der Produktion in der Hash-Tabelle
		long	hash_index;

		//Index der ersten Alternative in PROD2_STR
		long	prod2_index;

		//Anzahl der Alternativen dieser Produktion
		int		altAnz;

	}PROD_STR;



	//Hier werden die zu den Produktionen gehörenden rechten Seiten abgelegt.
	typedef struct
	{
		//Index der Produktion in PROD_STR
		long			prod_index;

		//Zeile, in der die Alternative steht
		long			line;

		//Anzahl der Elemente auf der rechten Seite dieser Alternative
		int				riAnz;

		//Index der Hash-Einträge
		long			*right;

		//Priorität der Alternative
		int				priority;

		//String mit semantischer Aktion
		char			*semAct;

		//Zeile, in der die semantische Aktion angegeben wurde
		unsigned long	semActLine;

		//false: normale semantische Aktion, true: embedded semantic action
		bool			isEmbeddedSemAct;

		//falls in Folge eines Reduce-Reduce-Fehlers mit dieser Alternative nie reduziert wird
		int				reduce;

	}PROD2_STR;



	//%union
	typedef struct
	{
		/*
			Beispiel:
				int		a;
				long	b;
				bool	c;
		*/

		//Typen
		char		**type;

		//Bezeichner
		char		**id;

		/*
			Die union-Angabe wird zwar gescannt um die Richtigkeit der semantischen Typen zu bestimmen,
			aber in den Quelltext wird die Angabe des Grammatik-Files unverändert übernommen, weil sonst
			z.B. Pointer und Kommentare verschwinden würden.
		*/
		char		*text;

		//Anzahl der Elemente
		int			anz;

	}UNION_STR;



	//Hier stehen die Terminale, die mit einer bestimmten Fehleraktion verbunden sind
	typedef struct
	{
		//Terminal, bei dem eine bestimmte Fehleraktion ausgeführt werden soll
		long	terminal;

		//0: Fehleraktion bei diesem Terminal, 1: bei allen anderen (Negation)
		int		neg;

	}ERRTERM_STR;



	/*
		Wenn eine Fehlermeldung für ein LR-Item ausgegeben werden soll, so stehen hier
		die Hüllen-Indices, in denen sich ein LR-Item befindet, für das die Fehlermeldung
		ausgegeben werden soll. Dies entspricht später in der SSLR_error-Routine des
		erzeugten Parsers den case-Anweisungen.
	*/
	typedef struct
	{
		//Index der Hüllen
		ulong	*arr;

		//Anzahl der Einträge in arr
		ulong	anzArr;

	}HulleErrorIndexStr;



	//%error
	/*
		Man hat die Möglichkeit, die Fehler-Behandlung beim Parsen zu beeinflussen.
		Aufbau:
			%error
			{
				Poition des Punktes eines Elementes:Aktion:Fehlermeldung
			}

			Aktion:
				ESHIFT(TERMINAL):		TERMINAL einfügen
				EPOP(TERMINAL):			solange Zustände vom Parse-Stack entfernen,
										bis TERMINAL geschoben werden darf
				EDELETE:				ein Terminal löschen
				EOVERREAD(TERMINAL):	bis TERMINAL erscheint, alles überlesen
				EEXIT:					Parsing beenden
				ESEM:					semantische Aktionen trotz Fehler zulassen
	*/
	typedef struct
	{
		//Index der Produktion in PROD_STR
		long				prod_index;

		//Nummer der Alternative, also Index in der PROD2_STR
		long				prod2_index;

		//Position des Punktes (LR-Item)
		int					dot;

		//ESHIFT(TERMINAL)
		long				shift;

		//EPOP(TERMINAL)
		long				pop;

		//EOVERREAD(TERMINAL)
		long				overread;

		//ESEM
		int					sem;

		//EEXIT
		int					exit;

		//EDELETE
		int					del;

		//Fehlermeldung
		char				*msg;

		//Zeile der Deklaration der Fehleranweisung
		long				line;

		//hier stehen die termArr-Indices der Terminale, für die eine Aktion augeführt werden soll
		int					*errTermArr;

		//Terminale, verbunden mit Fehleraktionen
		ERRTERM_STR			*errTermStr;

		//Anzahl der ERRTERM_STR-Strukturen
		int					errTermStrAnz;

		/*
			Wenn eine Fehlermeldung für ein LR-Item ausgegeben werden soll, so stehen hier
			die Hüllen-Indices, in denen such dieses LR-Item befindet.
		*/
		HulleErrorIndexStr	hInd;

	}ERROR_STR;



	/*
		Hier stehen die LR-Items und deren zugehöriger Hüllen-Index, die reduzieren
		mit der richtigen Lookahead-Menge. Dies wird benötigt, um die Zustände
		zu finden, die für die %error-Anweisung in Frage kommen.
	*/
	typedef struct
	{
		//Index der Produktion in PROD_STR des LR-Items
		long	prod_index;

		//Nummer der Alternative, also Index in der PROD2_STR des LR-Items
		long	prod2_index;

		//Index der Hülle, in der es steht
		ulong	hulleIndex;

	}LRReduceErrorItem;



	//EBNF-Stack für die Analyse der Grammatik
	typedef struct
	{
		//Index der Produktion in PROD_STR
		long	prod_index;

		//Index der Alternative in PROD2_STR
		long	prod2_index;

		//Nummer der Alternativen
		int		altCount;

	}EBNF_STACK;



	//Struktur für EIN LR(0/1)-Element
	typedef struct
	{
		//Index in PROD2_STR
		long		prod2_index;

		//Position des Punktes im LR-Item
		int			dot;

		//Hülle, die aus diesem Item durch Sprung erzeugt wird
		long		jumpTo;

		//Lookahead-Terminale
		Terminal	*la;

		//spontan generierte Terminale bei LALR
		Terminal	*lalr;

	}LR_STR;



	//Hülle-Struktur
	typedef struct
	{
		//Anzahl der Kerne
		int		anzCore;

		//Anzahl der LR(0)-Elemente
		int		anzElem;

		//LR(0/1)-Elemente
		LR_STR	*lr_str;

		/*
			Wenn für diese Hülle gilt:

				this = Sprung( i, X ),

				dann ist from = i und elem = X.
		*/
		long	from;
		long	elem;

		//Index dieser Hülle in hulle_str
		long	hulleIndex;

	}HULLE_STR;



	//LR-Tabelle
	typedef struct
	{
		/*
			1: Fehler
			2: Shift
			3: Reduce
			4: Akzeptieren
		*/
		int		state;

		/*
			bei Shift: zu schiebender Zustand
			bei Reduce: Index der Alternative, d.h. prod2_index
		*/
		long	value;

		//bei Shift: Hash-Index des Terminals, bei dem geschoben wird
		long	termHashIndex;

	}LR_TAB;



	//Struktur für semantische Aktionen u.a. wegen embedded actions wie bei YACC
	typedef struct
	{
		//Text mit semantischer Aktion
		char	*semAct;

		//Zeilennummer
		long	line;

	}SEMACT_STR;




	//links-assoziativ
	static const int			isLeftAssoc = 1;

	//rechts-assoziativ
	static const int			isRightAssoc = 2;

	//nicht-assoziativ
	static const int			isNonAssoc = 3;

	//Typ eines LR-Items
	static const int			SSLR_CORE = 0;
	static const int			SSLR_ITEM = 1;

	//mögliche Zustände in der LR-Tabelle
	static const int			SSLR_ERROR = 1;
	static const int			SSLR_SHIFT = 2;
	static const int			SSLR_REDUCE = 3;
	static const int			SSLR_ACCEPT = 4;

	//Informationen über das Grammatik-File
	struct stat					st;

	//Hash-Tabelle
	hashClass					*hash_tab;

	//Array für die Produktionen
	PROD_STR					*prod_str;

	//Anzahl der Produktionen
	int							prod_anz;

	//Array für alle rechten Seiten
	PROD2_STR					*prod2_str;

	//Anzahl aller rechten Seiten
	int							prod2_anz;

	//Array für die %error-Angaben
	ERROR_STR					*error_str;

	//Anzahl der Einträge in error_str
	int							error_anz;

	/*
		Die Verwendung der Terminale/Nichtterminale wird geprüft. In diesem Array
		sind die Hash-Indices aufgereiht.
	*/
	long						*check;

	//Anzahl der Einträge in check
	long						anzCheck;

	//für %union-Definition
	UNION_STR					*unionStr;

	//Argumente
	ARGV_STR					*argv_str;

	//Hash-Index von EPSILON
	long						epsHashIndex;

	//Hash-Index von ACCEPT
	long						acceptHashIndex;

	//Check-Terminal # bei Generierung von LALR-Parsern
	long						lalrHashIndex;

	//Array mit allen Hüllen
	HULLE_STR					**hulle_str;

	//Anzahl der Hüllen
	long						hulle_anz;

	//Anzahl aller Kerne
	long						coreAnz;

	//LR-Tabelle
	LR_TAB						**lrTab;

	//Sprung-Tabelle
	int							**jumpTab;

	//Array mit den Hash-Indices aller Terminale
	long						*termArr;

	//Anzahl der Einträge in termArr
	int							termArrCount;

	//Array mit den Hash-Indices aller Nichtterminale
	long						*ntermArr;

	//Anzahl der Einträge in ntermArr
	int							ntermArrCount;

	//Anzahl der Shift-Reduce-Fehler
	int							srError;

	//Anzahl der Reduce-Reduce-Fehler
	int							rrError;

	//Zähler für semantische Aktionen
	int							semActCnt;

	//Struktur für semantische Aktionen
	SEMACT_STR					semActStr;

	//es gibt eine einzutragende semantische Aktion
	bool						semAct;

	//Priorität eines Terminals
	int							priority;

	//Assoziativität eines Terminals
	int							assocDef;

	//Definition einer %union-Struktur
	bool						unionDef;

	//Index der Produktion in PROD_STR
	long						prod_index;

	//Index der Alternative in PROD2_STR
	long						prod2_index;

	//%ntermDef, also für Nicht-Terminale, oder %termDef für Terminale in %definition
	int							typeDef;

	//Fehler währen des Parsens
	int							err;

	/*
		Wenn %termDef/%ntermDef <semantischer Typ> (in der %definition-Sektion)
		angegeben wurde, dann prüfen, ob dieser semantische Typ auch in der
		%union-Struktur angegeben wurde.
	*/

	int							semIndex;

	//Index des Elements in der HASH_TAB
	long						hash_index;

	/*
		Die Priorität eines Terminals wird indirekt durch %left/%right angegeben: Je tiefer die
		Angabe steht, desto größer ist die Priorität des Terminals.
	*/
	unsigned long				priLine;

	//Anzahl der Alternativen der aktuellen Produktion prod_index
	int							altCount;

	/*
		Bei der Verwendung von EBNF-Symbolen treten Hierachien auf,
		für die diverse Informationen gesichert werden müssen.
	*/
	EBNF_STACK					*ebnfStack;

	//Stack-Pointer für den EBNF-Stack
	int							ebnfSP;

	/*
		Bei der Verwendung von eingebetteten semantischen Aktionen
		sowie bei der verwendung von EBNF-Symbolen müssen
		dummy-Nichtterminale eingeschoben werden, die hier
		auxsym heissen.
	*/
	char						*auxsym;

	//Zähler für die Anzahl der auxsym-Nichtterminale
	int							auxsym_count;


	/*
		Bei der Angabe der Grammatik kann man Fehlerangeben machen, diese
		Struktur enthält pro Alternative und Position des Punktes in einem
		LR-Item diese Informationen.
	*/
	ERROR_STR					*errorStr;

	//Index der aktuellen errorStr
	long						errorIndex;

	//gibt an, ob die Terminale negiert werden sollen
	bool						errorNeg;

	/*
		Länge der längsten rechten Seite einer Alternative. Wird für die
		formatierte Ausgabe der rechten Seite einer Alternative für die
		Debug-Version des Parsers benötigt.
	*/
	int							maxAltRightSideWidth;

	//längstes Terminal/Nichtterminal
	int							maxElemWidth;

	//Breite des größtes Zustands
	int							maxStateWidth;




	/*******************
	* private Methoden *
	*******************/

	//Überprüfung der (Nicht)Terminals
	void setCheck( long );

	//Neues %union-Paar eintragen
	void insertUnion( char *, char * );

	//Index des Type der semantischen Aktion in unionStr finden
	int getSemIndex( char * );

	//eine neue Produktion anfordern
	long getNewProd( void );

	//eine neue Alternative anfordern
	long getNewProd2( long );

	//ein Elemente in eine rechte Seite einer Alternative eintragen
	void insertElement( long, long, long );

	//die Fehleraktionen auf doppelte EInträge prüfen
	int checkErrorStr( void );

	//PROD2_STR sortieren
	void sortProd2Str( void );

	//Grammatik in Datei ausgeben
	void outputGrammar( void );

	//alle Alternativen ausgeben
	void outputAllAlt( void );

	//eine Alternativen ausgeben
	void outputAlt( ostream &, long );

	//eine Hülle ausgeben
	void outputHulle ( HULLE_STR * );

	//ein LR-Item in ofstream file ausgeben
	void outputItem( long, int, ofstream & );

	//ein LR-Item auf cout ausgeben
	void outputItem( long, int );

	//Start-Produktion eintragen
	void insertStartProd( long &, long & );

	//(Nicht)Terminale überprüfen
	int checkAll( void );

	//prüfen, ob mit allen Alternativen reduziert wurde
	int checkAllReduce( void );

	//alle FIRST-Mengen bilden
	void genAllFirst( void );

	//hier werden die FIRST-Mengen eines Terminals/Nichtterminals erzeugt
	void genFirst( Terminal *, int, long * );

	//alle FOLLOW-Mengen bilden
	void genAllFollow( void );

	//prüft, ob die Hülle h schon in hulle_str enthalten ist
	int cmpLR0Hulle( HULLE_STR * );

	//prüft, ob die Hülle h schon in hulle_str enthalten ist
	int cmpLR1Hulle( HULLE_STR * );

	//alle Hüllen der SLR und LALR bilden
	void genLR0Hulle( void );

	//alle Hüllen der LR
	void genLR1Hulle( void );

	//LR(0)-Kern in HULLE h eintragen
	void insertItem( HULLE_STR *, long, int, int );

	//LR(1)-Kern in HULLE h eintragen
	void insertItem( HULLE_STR *, long, int, int, Terminal * );

	//eine HULLE_STR-Struktur erzeugen
	HULLE_STR *createHulle( void );

	//eine HULLE_STR-Struktur löschen
	void deleteHulle( HULLE_STR * );

	//prüft, ob in der Hülle h das LR-Item schon enthalten ist
	int findItem( HULLE_STR *, long );

	//prüft, ob in der Hülle h das LR-Item schon enthalten ist
	int findItem( HULLE_STR *, long, int );

	//prüft, ob in der Hülle h das LR-Item schon enthalten ist
	int findItem( HULLE_STR *, long, int, Terminal * );

	//eine Hülle in die Sammlung von Elementen eintragen
	void insertHulle( HULLE_STR * );

	//LR(0)-Items der Hülle erzeugen
	void genLR0Items( HULLE_STR * );

	//LR(1)-Items der Hülle erzeugen
	void genLR1Items( HULLE_STR * );

	//hier werden die Hüllen erzeugt, die sich durch Spring( h, X ) ergeben
	void makeLR0Jump( HULLE_STR * );

	//hier werden die Hüllen erzeugt, die sich durch Spring( h, X ) ergeben
	void makeLR1Jump( HULLE_STR * );

	//aus der Sammlung der LR(0)-Elemente die Lookaheads anfügen
	void genLALR( void );

	//die Hülle erzeugen, die sich durch Sprung( I0, index ) ergibt
	void genLR0Jump( HULLE_STR *, HULLE_STR *, long );

	//die Hülle erzeugen, die sich durch Sprung( I0, index ) ergibt
	void genLR1Jump( HULLE_STR *, HULLE_STR *, long );

	//Terminale ausgeben
	void outputTerminal( Terminal * );

	//Index der Hülle in die entsprechenden Elemente von I0 eintragen, die durch Sprung( I0, elem )
	//erzeugt wird.
	void setJump( HULLE_STR *, long, long );

	//hier werden die LR(0)-Kerne beider Hüllen verglichen
	bool cmp2LR0Hulle( HULLE_STR *, HULLE_STR * );

	//wandelt die LR(1)-Hüllen in LR(0)-Hüllen
	void LR2LALR( void );

	//LR-Tabelle erzeugen
	void LRTab( void );

	//einen Reduce-Eintrag erzeugen
	void setReduce( int, long, Terminal * );

	//einen Shift-Eintrag erzeugen und dabei Shift-Reduce-Fehler behandeln
	void setShift( int, long, int );

	//hier werden die Source-Files des Parsers erzeugt
	void generateFiles( void );

	//LR-Tabelle in Datei ausgeben
	void outputLRTab( ofstream & );

	//Sprung-Tabelle ausgeben
	void outputJumpTab( ofstream & );

	/*
		Der Scanner liefert ja Tokens zum Parser zurück, die im Prinzip
		für die Auswahl der nächsten Aktion (schieben/reduzieren) benötigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	void outputTermDefHFile( ofstream & );

	//Header-File ausgeben
	void outputHFile( ofstream & );

	//Terminal-Defines als enum ausgeben
	void outputCPPTerminal( ofstream & );

	//die Alternativen in die cpp-Datei ausgeben.
	void outputAlternatives( ofstream & );

	//Follow-Mengen in cpp-File ausgeben
	void outputFollow( ofstream & );

	//die SSLR_NTERM_STR ausgeben
	void outputNtermStr( ofstream & );

	//die Namen der Terminale ausgeben, nur im debug-mode
	void outputTermName( ofstream & );

	//hier wird die komplette Fehlerbehandlung ausgegeben
	void outputErrorRecovery( ofstream & );

	//den Header des cpp-Files ausgeben
	void outputCPPHeader( ofstream & );

	//alle übrigen Routinen des cpp-Files ausgeben
	void outputCPPEnd( ofstream & );

	//erzeuge eine neue ERROR_STR und liefere den Index zurück
	int getErrorStr( void );

	//fügt eine ERRTERM_STR zu einer ERROR_STR hinzu.
	int insertErrTermStr( ERROR_STR *, long, int );

	//semantische Aktionen ausgeben
	void outputSemAct( ofstream & );

	//Include-Anweisungen in das cpp-File ausgeben
	void outputIncl( ofstream & );

	//eigene Erweiterungen in das cpp-File ausgeben
	void outputExt( ofstream & );

	//doppelte Alternativen finden
	int findDoubleAlt( void );

	//fügt ein auxsym-Nichtterminal auf rechter Seite von prod2_index ein für eine embedded semantic
	//action.
	void insertEmbeddedSemanticAction( long, long, long, int & );

	/*
		Diese Routine wird vom Konstruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	void init( void );

	/*
		Diese Routine wird vom Destruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	void deinit( void );

	/*
		Innerhalb der Grammatik kann man mittels %error Fehleranweisungen
		in den erzeugten Parser einbauen.
		Ein LR-Parser kann aber nötige Reduktionen verweigern, wenn das
		darauffolgend zu schiebende Terminal nich als Lookahead vorliegt.
		Also werden hier die Zustände gefunden, die vor dem Item mit der
		Fehleranweisung stehen und die reduzieren.
	*/
	void processErrorStr( void );

	/*
		Hier wird in der Hülle hulleIndex nach einem LR-Item gesucht,
		das reduziert, wobei seine LA-Symbole mind. t umfassen müssen.
	*/
	bool findReduceItem( unsigned long, unsigned long &, Terminal * );

	/*
		Hier wird geprüft, ob auf der rechten Seite des LR-Item item
		der Hülle hStr das Nicht-Terminal hash_index auftaucht.
	*/
	int findNTERMRightSide( HULLE_STR *, int, unsigned long );

	//liefere den Index des Terminals in termArr zurück
	int getTermArrIndex( unsigned long );




	public:

	/*
		Diese Funktion dient der Übergabe der Kommandozeilen-Argumente, die
		SSLR steuern.
	*/
	void giveArgs( ARGV_STR * );



%grammar


goal
	:	initSSLR sect1 sect2
\{
	//die komplette Eingabe wurde erfolgreich geparst, nun die LR-Tabellen erzeugen

	//Meldung?
	if( argv_str->verbose )
		//ja, start-Produktion nicht mitzählen
		cout << "sslr: " << prod_anz - 1 << " productions analyzed!" << endl;

	//(Nicht)Terminale checken
	err += checkAll();

	//die PROD2_STR sortieren
	sortProd2Str();

	//finde doppelte Alternativen innerhalb einer Produktion
	err += findDoubleAlt();

	//alles OK?
	if( !err && !SSLR_anzError )
	{
		//Grammatik ausgeben
		outputGrammar();

		//FIRST-Mengen berechnen
		genAllFirst();

		//FOLLOW-Mengen berechnen
		genAllFollow();

		//welchen Parser-Typ erzeugen?
		if( argv_str->type == SSLR_SLR )
			//SLR-Parser erzeugen
			genLR0Hulle();

		else if( argv_str->type == SSLR_LALR )
		{
#ifndef LR2LALR
			//LALR-Parser erzeugen
			genLR0Hulle();

			//Die Lookaheads erzeugen
			genLALR();
#else
			/*
				Es gibt zu Debuggingzwecken auch die Möglichkeit, erst die LR(1)-Items zu erzeugen,
				und dann diese zu den LALR-Items zusammenzufassen.
			*/

			//LR(1)-Hüllen erzeugen
			genLR1Hulle();

			//LR(1)-Hüllen in LR(0)-Hüllen mit Lookaheads
			LR2LALR();
#endif
		}

		else if( argv_str->type == SSLR_LR )
			//LR-Parser erzeugen
			genLR1Hulle();

		//LR-Tabelle erzeugen
		LRTab();


		//die Fehleranweisungen verarbeiten
		processErrorStr();

		//die ERROR_STR prüfen
		checkErrorStr();


		//Hüllen ausgeben?
		if( argv_str->showHulle )
		{
			//Zeiger auf HULLE_STR
			HULLE_STR	*h;

			//Hüllen ausgeben
			for( unsigned long i = 0; i < hulle_anz; i++ )
			{
				//Zeiger auf Hülle
				h = hulle_str[i];

				//ausgeben
				outputHulle( h );
			}
		}

		//Quell-Files des Parsers erzeugen
		generateFiles();

		//prüfen, ob mit allen Alternativen reduziert wurde
		checkAllReduce();
	}

	else
		//Abbruch-Meldung ausgeben
		cerr << "\n\nsslr: Aborting..." << endl;

	//das war's
//	return( err );
\}
	;


//dient der Initialisierung von SSLR
initSSLR
	:	'EPSILON'
\{
	//hier wird SSLR initialisiert

	/*
		Terminalen wird per %left, %right, %nonassoc eine Assoziativität sowie eine
		Priorität zugewiesen. Je später ein Terminal erscheint, deste höher ist seine
		Priorität, z.b.

		%left ADD SUB
		%right MUL DIV

		ADD und SUB haben gleiche Priorität und sind links-assoziativ, wohingegen MUL und DIV
		rechts-assoziativ sind und höhere Priorität haben.
	*/
	priority = 0;

	/*
		Die Priorität eines Terminals wird indirekt durch %left/%right angegeben: Je tiefer die
		Angabe steht, desto größer ist die Priorität des Terminals.
	*/
	priLine = 0;


	/*
		Wenn eingebettete semantische Aktionen auftreten, oder EBNF-Symbole benutzt werden,
		so wird dafür auf der rechten Seite ein dummy-Nicht-Terminal auxsym eingetragen.
	*/
	auxsym_count = 1;


	//noch keine Fehler
	err = 0;

	//es wurde noch keine %union-Struktur angegeben
	unionDef = false;

	/*
		Bei der Verwendung von EBNF-Symbolen treten Hierachien auf,
		für die diverse Informationen gesichert werden müssen.
	*/
	ebnfStack = new( EBNF_STACK[100] );

	//Stack-Pointer für den EBNF-Stack
	ebnfSP = 0;


	/*
		Bei der Verwendung von eingebetteten semantischen Aktionen
		sowie bei der verwendung von EBNF-Symbolen müssen
		dummy-Nichtterminale eingeschoben werden, die hier
		auxsym heissen.
	*/
	auxsym = new( char[11] );

	//Zähler für die Anzahl der auxsym-Nichtterminale
	auxsym_count = 1;



	//Speicher für die %union-Angabe
	unionStr = new( UNION_STR );
	memset( unionStr, 0, sizeof( UNION_STR ) );


	//falls kein semantischer Typ angegeben wird
	insertUnion( "", "" );

	//keine semantische Aktion
	semAct = false;

	//Start-Produktion eintragen
	insertStartProd( prod_index, prod2_index );
\}
	;


/*********************************
 ********** %definition **********
 *********************************/


sect1
	:	'DEFINITION' union definition1
	;


//Zuweisung von semantischen Typen und Assoziativität
definition1
	:	definition1 definition2
	|	definition2
	|	'EPSILON'
	;


/*
	Die %union-Angabe soll auch geparst werden, da die semantischen Typen extrahiert werden können,
	um später die Angaben in %termType und %ntermType vergleichen zu können.
*/
union
	:	startUnion 'BOPEN' unionBody 'BCLOSE'
\{
	/*
		Den Inhalt der %union-Angabe merken, denn dieser wird später unverändert ins Header-File
		des generierten Parsers aufgenommen. Das dieser hier geparst wird liegt daran, dass die Typen
		ja in %ntermDef/%termDef benutzt werden, und dies wird geprüft.
	*/
	unionStr->text = $1;
\}
%error
{
	//wenn in der %union-Angabe eine offene geschweifte Klammer vergessen wurde
	1:SHIFT(BOPEN):		"Missing { in %union!"
}
	|	'EPSILON'
	;


startUnion
	:	'UNION'
\{
	//es wurde eine %union-Struktur angegeben
	unionDef = true;

	//den Inhalt der %union-Angabe weitergeben
	$$ = $1;
\}
	;


unionBody
	:	unionBody unionBody2 'SEMIKOLON'
	|	unionBody2 'SEMIKOLON'
	;


unionBody2
	:	'TYPE' 'IDENT'
\{
	//einen neuen Eintrag in der unionStr eintragen
	insertUnion( $1, $2 );

\}
	|	'TYPE' 'AST' 'IDENT'
\{
	//einen neuen Eintrag in der unionStr eintragen
	insertUnion( $1, $3 );
\}
	;


//Zuweisung von semantischen Typen und Assoziativität
definition2

		//%termType <i> TERM1 TERM2 ...
		//ntermType <k> nterm1 nterm2 ...
	:	ntermDef semType namelist1

		//%left ADD SUB ...
	|	associativity namelist2
	;



ntermDef
		//es folgen Anweisungen für ein Nichtterminal
	:	'NTERM_TYPE'
\{
		//Nicht-Terminal
		typeDef = SSLR_NTERM;
\}
	|	'TERM_TYPE'
\{
		//Terminal
		typeDef = SSLR_TERM;
\}
	;


semType
	:	'semTypeOpen' 'IDENT' 'semTypeClose'
\{
	/*
		In $2 steht eine Zeichenkette (<name>), die den semantischen Typ
		gem. der %union-Angabe enthält.
	*/

	//Typ für semantische Aktion, sollte in %union definiert sein.

	//%union schon angegeben?
	if( !unionDef )
	{
		//nein
		cerr << "sslr: ERROR: line " << SSLR_line << ": %union missing!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//den Eintrag in unionStr finden
		if( ( semIndex = getSemIndex( $2 ) ) < 0 )
		{
			//Typ nicht in %union definiert
			cerr << "sslr: ERROR: line " << SSLR_line << ": Type for semantic action " << $2 << " not defined in %union!" << endl;

			//Fehler
			err++;
		}
	}
\}

	|	'EPSILON'
\{
	//ohne Angabe von semantischen Typen, Warnung ausgeben
	cerr << "sslr: line " << SSLR_line << ": No semantic type given!" << endl;
\}
	;


//Priorität für ein Terminal festlegen
associativity
	:	'LEFT_ASSOC'
\{
	//links-assoziativ
	assocDef = LEFT_ASSOC;
\}
	|	'RIGHT_ASSOC'
\{
	//rechts-assoziativ
	assocDef = RIGHT_ASSOC;
\}
	|	'NON_ASSOC'
\{
	//nicht-assoziativ
	assocDef = NON_ASSOC;
\}
	;


/*
	Bei der Zuweisung von semantischen Typen folgen i.d.R. mehrere (Nicht)Terminale, gefolgt
	von einem Leerzeichen, also z.B.
	%ntermType nterm1 nterm2 ...
*/
namelist1
	:	namelist1 'IDENT'
\{
	int	type;

	//ist es ein reserviertes Terminal?
	if( ( typeDef == SSLR_TERM ) && !strcmp( $2, "LALR" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	else if( ( typeDef == SSLR_NTERM ) && !strcmp( $2, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Element in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( $2 );

		//für Fehlerbehandlung merken
		setCheck( hash_index );

		//%termType: Terminal wird definiert
		//%ntermType: Nicht-Terminal wird definiert
		hash_tab->setDefined( hash_index, SSLR_line );

		//Index des Eintrags in unionStr in die Hash-Tabelle eintragen
		hash_tab->setUnionType( hash_index, semIndex );

		//ist es ein Terminal oder ein Nicht-Terminal?
		if( typeDef == SSLR_TERM )
		{
			//ist ein Terminal
			type = hash_tab->setType( hash_index, SSLR_TERM );

			//etwa schon als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nichtterminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}

		else
		{
			//ist ein Nicht-Terminal
			type = hash_tab->setType( hash_index, SSLR_NTERM );

			//etwa schon als Terminal definiert?
			if( type != SSLR_NTERM )
			{
				//Fehler, Nicht-Terminal wurde schon als Terminal definiert

				//Name des Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}
	}
\}
	|	'IDENT'
\{
	int	type;

	//ist es ein reserviertes Terminal?
	if( ( typeDef == SSLR_TERM ) && !strcmp( $1, "LALR" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	else if( ( typeDef == SSLR_NTERM ) && !strcmp( $1, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Element in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( $1 );

		//für Fehlerbehandlung merken
		setCheck( hash_index );

		//%termType: Terminal wird definiert
		//%ntermType: Nicht-Terminal wird definiert
		hash_tab->setDefined( hash_index, SSLR_line );

		//Index des Eintrags in unionStr in die Hash-Tabelle eintragen
		hash_tab->setUnionType( hash_index, semIndex );

		//ist es ein Terminal oder ein Nicht-Terminal?
		if( typeDef == SSLR_TERM )
		{
			//ist ein Terminal
			type = hash_tab->setType( hash_index, SSLR_TERM );

			//etwa schon als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nichtterminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}

		else
		{
			//ist ein Nicht-Terminal
			type = hash_tab->setType( hash_index, SSLR_NTERM );

			//etwa schon als Terminal definiert?
			if( type != SSLR_NTERM )
			{
				//Fehler, Nicht-Terminal wurde schon als Terminal definiert

				//Name des Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}
		}
	}
\}
	;


/*
	Bei der Zuweisung von Prioritäten und Assoziativitäten folgen i.d.R. mehrere Terminale, gefolgt
	von einem Leerzeichen, also z.B.
	%ntermType nterm1 nterm2 ...
*/
namelist2
	:	namelist2 'IDENT'
\{
	//in assocDef steht die Assoziativität dieses Terminals
	long	tmpPriority;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $2 );

	//Terminal wird definiert
//	hash_tab->setDefined( hash_index, SSLR_line );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Assoziativität eintragen
	hash_tab->setAssociation( hash_index, assocDef );

	//Priorität erhöhen
	if( SSLR_line > priLine )
	{
		//ja, erhöhen
		priority++;
		priLine = SSLR_line;
	}

	//Priorität eintragen
	tmpPriority = hash_tab->setPriority( hash_index, priority );

	//wurde die Priorität des Terminals bereits festgesetzt?
	if( tmpPriority != priority )
	{
		//ja, doppeltes Auftreten

		//Name des Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Priority for terminal " << name << " already set!" << endl;

		//Fehler
		err++;
	}
\}
	|	'IDENT'
\{
	//in assocDef steht die Assoziativität dieses Terminals
	long	tmpPriority;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $1 );

	//Terminal wird definiert
//	hash_tab->setDefined( hash_index, SSLR_line );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Assoziativität eintragen
	hash_tab->setAssociation( hash_index, assocDef );

	//Priorität erhöhen
	if( SSLR_line > priLine )
	{
		//ja, erhöhen
		priority++;
		priLine = SSLR_line;
	}

	//Priorität eintragen
	tmpPriority = hash_tab->setPriority( hash_index, priority );

	//wurde die Priorität des Terminals bereits festgesetzt?
	if( tmpPriority != priority )
	{
		//ja, doppeltes Auftreten

		//Name des Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Priority for terminal " << name << " already set!" << endl;

		//Fehler
		err++;
	}
\}
	;



/******************************
 ********** %grammar **********
 ******************************/


sect2
	:	'GRAMMAR' sc2
	|	'EPSILON'
	;


sc2
	:	sc2 sslrRule 'END_OF_PRODUCTION'
\{
	/*
		Es folgt eine neue Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Anzahl der Alternativen dieser Produktion eintragen
	prod_str[prod_index].altAnz = altCount;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}
\}
	|	sslrRule 'END_OF_PRODUCTION'
\{
	/*
		Es folgt eine neue Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Anzahl der Alternativen dieser Produktion eintragen
	prod_str[prod_index].altAnz = altCount;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}
\}
	;


sslrRule
	:	newProduction 'SEP' rightSide
	;


newProduction
	:	'IDENT'
\{
	//es folgt eine Produktion

	//Produktion in die Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $1 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//Produktion wurde definiert
	if( hash_tab->setProdDef( hash_index ) < 0 )
	{
		//die Produktion wurde bereits definiert
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung ausgeben
		cerr << "sslr: ERROR: line " << SSLR_line << ": Production " << name << " already defined!" << endl;

		//Fehler
		err++;
	}

	/*
		Wenn dies die erste Produktion ist, dann diese in die rechte Seite der
		Start-Produktion "start" eintragen.
	*/
	if( !prod_index )
	{
		//ja, eintragen
		insertElement( prod_index, prod2_index, hash_index );

		//eine Alternative
		prod_str[prod_index].altAnz = 1;

		//Produktion wurde benutzt
		hash_tab->setUsed( hash_index );
	}


	//Start-Produktion "start" nicht erlaubt
	if( !strcmp( hash_tab->getName( hash_index ), "start" ) )
	{
		//Fehler
		err++;

		//Meldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Production start reserved!" << endl;
	}



	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index der Produktion eintragen
	prod_str[prod_index].hash_index = hash_index;

	//ist ein Nichtterminal
	int type = hash_tab->setType( hash_index, SSLR_NTERM );

	//vorher schon mal als Terminal definiert?
	if( type != SSLR_NTERM )
	{
		//Fehler, Produktion wurde schon als Terminal definiert

		//Name des Nicht-Terminals
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": Nonterminal " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

		//Fehler
		err++;
	}

	//PROD2_STR anfordern, für die nächste Alternative
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;

	//Meldung ausgeben
	if( argv_str->verbose )
		cout << "sslr: line " << SSLR_line << ": Analyze " << $1 << "..." << endl;
\}
	;


rightSide
	:	item1 precedence error
	|	rightSide newAlternative item1 precedence error
	;


newAlternative
	:	'NEW_ALTERNATIVE'
\{
	/*
		Es folgt eine neue Alternative zu einer bestehenden Produktion.
		Wenn es zu der alten Alternative noch eine semantische Aktion gibt, dann diese jetzt
		einfügen.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//nächste Produktion
	altCount++;

	//wurden Elemente auf der rechten Seite eingetragen?
	if( !prod2_str[prod2_index].riAnz )
	{
		//nein, Fehlermeldung
		cerr << "sslr: ERROR: line " << ( SSLR_line - 1 ) << ": No elements on right side of alternative!" << endl;

		//Fehler
		err++;
	}

	//PROD2_STR für eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;
\}
	;


item1
	:	item1 rhs
	|	rhs
	;

rhs
	:	ebnfKLOpen rightSide ebnfKLClose
	|	ebnfBOpen rightSide ebnfBClose
	|	ebnfEOpen rightSide ebnfEClose
	|	item2
	;

item2
	:	item2 item3
	|	item3
	;

item3
	:	'TERMINAL'
\{
	//Terminal auf rechte Seite der aktuellen Alternative prod2_index eintragen

	//ist es ein reserviertes Terminal?
	if( !strcmp( $1, "LALR" ) )
	{
		//nein, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal LALR reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Terminal in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( $1 );

		//ist es ein EPSILON, dass nicht als erstes Element auf der rechten Seite steht?
		if( ( prod2_str[prod2_index].riAnz ) && ( hash_index == epsHashIndex ) )
		{
			//Fehler
			cerr << "sslr: ERROR: line " << SSLR_line << ": EPSILON must always be the only element on the right side!" << endl;

			//Fehler
			err++;
		}

		else
		{
			//semantische Aktion vorher eintragen?
			if( semAct == true )
			{
				//ja
				insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

				//zurücksetzen
				semAct = false;
			}

			//für Fehlerbehandlung merken
			setCheck( hash_index );

			//Terminal benutzt
			hash_tab->setUsed( hash_index );

			//Terminal in rechte Seite der aktuellen Alternative eintragen
			insertElement( prod_index, prod2_index, hash_index );

			//ist ein Terminal
			int type = hash_tab->setType( hash_index, SSLR_TERM );

			//wurde das Terminal früher bereits als Nicht-Terminal definiert?
			if( type != SSLR_TERM )
			{
				//Fehler, Terminal wurde schon als Nicht-Terminal definiert

				//Name des Nicht-Terminals
				char *name = hash_tab->getName( hash_index );

				//Fehlermeldung
				cerr << "sslr: ERROR: line " << SSLR_line << ": Terminal " << name << " already defined as nonterminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

				//Fehler
				err++;
			}

			//Priorität der Alternative ist die des am weitesten rechts stehenden Terminals
			prod2_str[prod2_index].priority = hash_tab->getPriority( hash_index );
		}
	}
\}
	|	'NON_TERMINAL'
\{
	//Nicht-Terminal auf rechte Seite der Alternative eintragen

	//gibt es eine semantische Aktion, die einzutragen ist, bevor das Nicht-Terminal eingetragen wird?
	if( semAct == true )
	{
		//ja, es gibt eine eingebettete semantische Aktion
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//ist es das reservierte Nicht-Terminal "start"?
	if( !strcmp( $1, "start" ) )
	{
		//ja, ist reserviert
		cerr << "sslr: ERROR: line " << SSLR_line << ": Non-terminal start is reserved!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//Nicht-Terminal in Hash-Tabelle eintragen
		hash_index = hash_tab->insert( $1 );

		//für Fehlerbehandlung merken
		setCheck( hash_index );

		//Nicht-Terminal benutzt
		hash_tab->setUsed( hash_index );

		//ist ein Nicht-Terminal
		int type = hash_tab->setType( hash_index, SSLR_NTERM );

		//wurde das Nicht-Terminal vorher als Terminal definiert?
		if( type != SSLR_NTERM )
		{
			//Fehler, Nicht-Terminal wurde schon als Terminal definiert

			//Name des Nichtterminals
			char *name = hash_tab->getName( hash_index );

			//Fehlermeldung
			cerr << "sslr: ERROR: line " << SSLR_line << ": Nonterminal " << name << " already defined as terminal in line " << hash_tab->getDefLine( hash_index ) << "!" << endl;

			//Fehler
			err++;
		}

		//Nicht-Terminal in rechte Seite der Alternative prod2_index eintragen
		insertElement( prod_index, prod2_index, hash_index );
	}
\}
	|	semanticAction
	;


semanticAction
	:	'SEMACT'
\{
	//eine Alternative ist mit einer semantischen Aktion verbunden

	//%union schon angegeben?
	if( !unionDef )
	{
		//nein
		cerr << "sslr: ERROR: line " << SSLR_line << ": Semantic action useless without %union!" << endl;

		//Fehler
		err++;
	}

	else
	{
		//schon eine semantische Aktion in der Struktur, d.h. doppeltes Auftreten?
		if( semAct == true )
		{
			//doppelte semantische Aktion
			cerr << "sslr: ERROR: line " << SSLR_line << ": Double semantic action!" << endl;

			//Fehler
			err++;
		}

		else
		{
			//semantische Aktionen übertragen
			semActStr.semAct = $1;

			//Zeile merken
			semActStr.line = SSLR_line;

			//semantische Aktion wurde definiert
			semAct = true;

			//Zähler
			semActCnt++;
		}
	}
\}
	;


ebnfKLOpen
	:	'KLOPEN'
\{
	/*
		Hier wird das EBNF-Symbol ( benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 ( 'TERM1' | 'TERM2' ) prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym1 prod3
				;

		auxsym1
				:	'TERM1'
				|	'TERM2'
				;
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist eine eingebettete semantische Aktion
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
\}
	;


ebnfBOpen
	:	'BOPEN'
\{
	/*
		Hier wird das EBNF-Symbol { benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 { 'TERM1' | 'TERM2' } prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym_1 prod3
				;

		auxsym_1
				:	'TERM1' auxsym_1
				|	'TERM2' auxsym_1
				|	'EPSILON'
				;

		{} bedeutet also beliebig oft.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}


	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );


	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
\}
	;


ebnfEOpen
	:	'EOPEN'
\{
	/*
		Hier wird das EBNF-Symbol [ benutzt.
		Aus der EBNF-Form

		prod1
				:	prod2 [ 'TERM1' | 'TERM2' ] prod3
				;

		wird die BNF-Form

		prod1
				:	prod2 auxsym1 prod3
				;

		auxsym1
				:	'TERM1'
				|	'TERM2'
				|	'EPSILON'
				;

		[] bedeutet also optional, also einmal oder keinmal.
	*/

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja
		insertEmbeddedSemanticAction( prod_index, prod2_index, SSLR_line, auxsym_count );

		//zurücksetzen
		semAct = false;
	}

	//alte Daten auf dem EBNF-Stack sichern
	ebnfStack[ebnfSP].prod_index = prod_index;
	ebnfStack[ebnfSP].prod2_index = prod2_index;
	ebnfStack[ebnfSP++].altCount = altCount;


	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsym_count++ );

	//auxsym in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//auxsym wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//auxsym wird benutzt
	hash_tab->setUsed( hash_index );

	//auxsym wird definiert
	hash_tab->setDefined( hash_index, SSLR_line );

	//auxsym ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//auxsym-Produktion auf rechter Seite der aktuellen Alternative eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//eine neue Produktion anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion (auxsym) in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index von auxsym eintragen
	prod_str[prod_index].hash_index = hash_index;

	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Anzahl der Alternativen
	altCount = 1;
\}
	;


ebnfKLClose
	:	'KLCLOSE'
\{
	//schliessendes EBNF-Symbol )

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols )!" << endl;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;

	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
\}
	;


ebnfBClose
	:	'BCLOSE'
\{
	//schliessendes EBNF-Symbol }
	long	baseProd2Index, count;

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols }!" << endl;


	//prod2_index der ersten Alternative der Produktion
	baseProd2Index = prod_str[prod_index].prod2_index;

	//nun das auxsym selbst als letztes Element auf rechter Seite eintragen,
	//damit beliebiges Ausführen möglich ist
	for( count = baseProd2Index; count < ( baseProd2Index + altCount ); count ++ )
		//auxsym auf rechter Seite eintragen
		insertElement( prod_index, count, prod_str[prod_index].hash_index );


	/*
		Nun EPSILON als Alternative in die aktuelle Produktion eintragen, da {} ja
		belibieg oft bedeutet.
	*/
	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//EPSILON in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//EPSILON ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen
	altCount++;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;


	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
\}
	;

ebnfEClose
	:	'ECLOSE'
\{
	//schliessendes EBNF-Symbol ]

	//semantische Aktion vorher eintragen?
	if( semAct == true )
	{
		//ja, ist aber keine embedded semantic action

		//Zeiger auf PROD2_STR
		PROD2_STR *p2 = &prod2_str[prod2_index];

		//semantische Aktionen übertragen
		p2->semAct = semActStr.semAct;

		//Zeile merken
		p2->semActLine = semActStr.line;

		//ist keine embedded semantic action
		p2->isEmbeddedSemAct = false;

		//zurücksetzen
		semAct = false;
	}

	//Daten holen
	ebnfSP--;

	//EBNF-Stack Unterlauf?
	if( ebnfSP < 0 )
		//ja, zu viele schliessende EBNF-Symbole
		cerr << "sslr: ERROR: line " << SSLR_line << ": Too many closing EBNF-Symbols ]!" << endl;


	/*
		Nun EPSILON als Alternative in die aktuelle Produktion eintragen, da [] ja
		optional bedeutet.
	*/
	//eine neue Alternative anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//EPSILON in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//EPSILON ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen
	altCount++;

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = altCount;


	//alte Daten vom EBNF-Stack zurückholen
	prod_index = ebnfStack[ebnfSP].prod_index;
	prod2_index = ebnfStack[ebnfSP].prod2_index;
	altCount = ebnfStack[ebnfSP].altCount;
\}
	;


precedence
	:	'PREC' 'TERMINAL'
\{
	/*
		Man kann durch Angabe von %prec die Prioriät des Terminals auf die
		Priorität der aktuellen Alternative übertragen.
	*/

	//Zeiger auf PROD_STR
	PROD_STR *p1 = &prod_str[prod_index];

	//Hash-Index des Terminals holen
	hash_index = hash_tab->insert( $2 );

	//wurde dem Terminal überhaupt mittels %left/%right/%nonassoc eine Priorität zugewiesen?
	if( hash_tab->getPriority( hash_index ) != -1 )
	{
		//ja, Terminal wird benutzt
		hash_tab->setUsed( hash_index );

		//Priorität der aktuellen Alternative holen
		int pri = prod2_str[prod2_index].priority;

		//Priorität der Alternative > Priorität des Terminals?
		if( pri <=  hash_tab->getPriority( hash_index ) )
		{
			//nein, übernehmen
			int	pPriority = hash_tab->getPriority( hash_index );

			//Priorität der aktuellen Alternative setzen
			prod2_str[prod2_index].priority = pPriority;
		}

		else
			//Meldung
			cerr << "sslr: Warning: line " << SSLR_line << ": Priority of " << hash_tab->getName( p1->hash_index ) << " > than priority of " << hash_tab->getName( hash_index ) << "!" << endl;
	}

	else
	{
		//dem Terminal wurde keine Priorität zugewiesen
		char *name = hash_tab->getName( hash_index );

		//Fehlermeldung
		cerr << "sslr: ERROR: line " << SSLR_line << ": %prec used but terminal " << name << " was not assigned a priority!" << endl;

		//Fehler
		err++;
	}
\}
	|	'EPSILON'
	;


error
	:	'ERROR' 'BOPEN' errorBody 'BCLOSE'
	|	'EPSILON'
	;


errorBody
	:	errorBody errorBody2
	|	errorBody2
	;


errorBody2
	:	initBeforeNumber 'DB' termList 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $5;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	initBeforeNumber 'DB' termList 'DB' errorAction 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $7;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	initBeforeNumber 'DB' negTerm 'KLOPEN' termList 'KLCLOSE' 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $8;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	initBeforeNumber 'DB' negTerm 'KLOPEN' termList 'KLCLOSE' 'DB' errorAction 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $10;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	initBeforeNumber 'DB' errorAction 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $5;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	|	initBeforeNumber 'DB' errorMsg
\{
	//Position des Punktes
	errorStr->dot = $1;

	//Fehlermeldung
	errorStr->msg = $3;

	//Terminal-Angaben nicht negieren
	errorNeg = false;
\}
	;


initBeforeNumber
	:	'NUMBER'
\{
	//es folgt eine Fehleranweisung

	//eine ERROR_STR anfordern
	errorIndex = getErrorStr();

	//Zeiger auf die ERROR_STR
	errorStr = &error_str[errorIndex];

	//Index der Produktion eintragen
	errorStr->prod_index = prod_index;

	//Index der Alternative in PROD2_STR eintragen
	errorStr->prod2_index = prod2_index;

	//die Zeile merken
	errorStr->line = SSLR_line;

	//Terminal-Angaben nicht negieren
	errorNeg = false;

	//Position des Punktes
	$$ = $1;
\}
	;


negTerm
	:	'NOT'
\{
	//Terminal-Angaben negieren
	errorNeg = true;
\}
	;


termList
	:	termList 'COMMA' 'TERMINAL'
\{
	//Index des Terminals holen
	hash_index = hash_tab->insert( $3 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//negieren?
	if( errorNeg == true )
		//ERRTERM_STR in errorStr eintragen
		insertErrTermStr( errorStr, hash_index, 1 );

	else
		//nicht negieren
		insertErrTermStr( errorStr, hash_index, 0 );
\}
	|	'TERMINAL'
\{
	//Index des Terminals holen
	hash_index = hash_tab->insert( $1 );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//negieren?
	if( errorNeg == true )
		//ERRTERM_STR in errorStr eintragen
		insertErrTermStr( errorStr, hash_index, 1 );

	else
		//nicht negieren
		insertErrTermStr( errorStr, hash_index, 0 );
\}
	;


errorAction
	:	errorAction 'DB' errorAction2
	|	errorAction2
	;


errorAction2
	:	'OVERREAD' 'KLOPEN' 'TERMINAL' 'KLCLOSE'
\{
	//Terminale in der Eingabe löschen, nis das Terminal geschoben werden darf

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $3 );

	//schon in der ERROR_STR enthalten?
	if( errorStr->overread )
		//es war schon eine OVERREAD(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used overread(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->overread = hash_index;
\}
	|	'SHIFT' 'KLOPEN' 'TERMINAL' 'KLCLOSE'
\{
	//ein Terminal auf den Parse-Stack schieben

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $3 );

	//schon in der ERROR_STR enthalten?
	if( errorStr->shift )
		//es war schon eine SHIFT(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used shift(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->shift = hash_index;
\}
	|	'POP' 'KLOPEN' 'TERMINAL' 'KLCLOSE'
\{
	//Zustände vom Parse-Stack löschen, bis Terminal geschoben werden darf

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( $3 );

	//schon in der ERROR_STR enthalten?
	if( errorStr->pop )
		//es war schon eine POP(TERMINAL)-Aktion eingetragen worden
		cerr << "sslr: Warning: line: " << SSLR_line << ": Double used pop(terminal)-error-actions make no sense!" << endl;

	else
		//eintragen
		errorStr->pop = hash_index;
\}
	|	'EXIT'
\{
	//das Parsen abbrechen
	if( errorStr->exit++ )
		//wurde schon einmal verwendet
		cerr << "sslr: Warning: line " << SSLR_line << ": EXIT already used!" << endl;

\}
	|	'DELETE'
\{
	//es soll der nächste Eingebesymbol aus der Eingabe entfernt werden
	errorStr->del++;
\}
	|	'SEM'
\{
	//semantische Aktionen trotz Fehlers weiterführen
	if( errorStr->sem++ )
		//schon eingetragen
		cerr << "sslr: Warning: line " << SSLR_line << ": SEM already used!" << endl;
\}
	;

errorMsg
	:	'STRING'
\{
		//Fehlermeldung zurückliefern
		$$ = $1;
\}
	|	'EPSILON'
\{
		//es wurde keine Fehlermeldung angegeben
		$$ = 0L;
\}
	;



%extension
\{


	//Hilfsroutinen für SSLR


void SSLRParser::giveArgs( ARGV_STR *argv )
{
	/*
		Diese Funktion dient der Übergabe der Kommandozeilen-Argumente, die
		SSLR steuern.
	*/

	//Argumente
	argv_str = argv;
}


void SSLRParser::init( void )
{
	/*
		Diese Routine wird vom Konstruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	anzCheck = 0;
	check = 0L;
	prod_anz = 0;
	prod_str = 0L;
	prod2_anz = 0;
	prod2_str = 0L;
	error_anz = 0;
	error_str = 0L;
	hulle_str = 0L;
	hulle_anz =  0;
	coreAnz = 0;
	srError = 0;
	rrError = 0;
	semActCnt = 0;
	termArr = 0L;
	ntermArr = 0L;
	unionStr = 0L;
	lrTab = 0L;
	jumpTab = 0L;
	hash_tab = 0L;
	auxsym = 0L;
	ebnfStack = 0L;

	//Speicher für die Hash-Tabelle anfordern
	hash_tab = new( hashClass );
}


void SSLRParser::deinit( void )
{
	/*
		Diese Routine wird vom Destruktor der SSLRParser-Klasse aufgerufen, wenn
		im %include-Teil das Makro SSLR_INIT definiert wurde.
	*/
	int	i;

	//Speicher freigeben
	delete( hash_tab );

	//Speicher für die %union-Angabe freigeben?
	if( unionStr )
	{
		//alle Einträge
		for( i = 1; i < unionStr->anz; i++ )
		{
			//Typ und Name der deklarierten Variable freigeben
			delete[] ( unionStr->type[i] );
			delete[] ( unionStr->id[i] );
		}

		//Speicher für die Struktur freigeben
		delete[] ( unionStr->type );
		delete[] ( unionStr->id );
		delete( unionStr );
	}

	if( auxsym )
		delete[] ( auxsym );


	//gab es Fehlerangaben?
	if( error_anz )
	{
		ERROR_STR	*errorStr;

		//Speicher freigeben
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr = &error_str[i];

			//hat die ERROR_STR Terminal-genbundene Fehleranweisungen?
			if( errorStr->errTermStrAnz )
				//ja, Speicher freigeben
				delete[] ( errorStr->errTermStr );

			//Speicher für die Terminale freigeben?
			if( errorStr->errTermArr )
				//ja, freigeben
				delete[] ( errorStr->errTermArr );

			//die Hüllen, die mit dieser Fehleranweisung verbunden ist, freigeben
			if( errorStr->hInd.anzArr )
				//ja, freigeben
				delete[] ( errorStr->hInd.arr );
		}

		//Speicher für die ERROR_STR selbst freigeben
		delete[] ( error_str );
	}


	//Speicher für Nicht-Terminale freigeben
	if( ntermArr )
		delete[] ( ntermArr );

	//Speicher für Terminale freigeben
	if( termArr )
		delete[] ( termArr );

	//Speicher freigeben
	if( check )
		delete[] ( check );


	//Speicher für die Produktionen freigeben
	if( prod_anz )
		//freigeben
		delete[]( prod_str );

	//Speicher für die Alternativen freigeben
	if( prod2_anz )
	{
		//alle PROD2_STR
		for( i = 0; i < prod2_anz; i++ )
		{
			//rechte Seite freigeben
			if( prod2_str[i].riAnz )
				delete[] ( prod2_str[i].right );
		}

		//PROD2_STR freigeben
		delete[]( prod2_str );
	}

	//Speicher für die Hüllen freigeben
	if( hulle_str )
	{
		HULLE_STR	*hStr;
		LR_STR		*lrStr;
		int			i, j;

		//alle Hüllen durchgehen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hülle
			hStr = hulle_str[i];

			//alle LR-Items der Hülle
			for( j = 0; j < hStr->anzElem; j++ )
			{
				//Zeiger auf LR_STR-Struktur
				lrStr = &hStr->lr_str[j];

				//Lookaheads?
				if( lrStr->la )
					//ja, freigeben
					delete( lrStr->la );

				//LALR-Lookaheads?
				if( lrStr->lalr )
					//ja, freigeben
					delete( lrStr->lalr );
			}

			//LR_STR freigeben
			delete[] ( hStr->lr_str );

			//Hülle freigeben
			delete( hStr );
		}

		//Speicher aller Hüllen-Strukturen freigeben
		delete[] ( hulle_str );
	}

	//Speicher für die Sprung-Tabelle freigeben?
	if( jumpTab )
	{
		//die jumpTab hat hulle_anz Spalten
		for( i = 0; i < hulle_anz; i++ )
			//Spalte freigeben
			delete[] ( jumpTab[i] );

		//Struktur freigeben
		delete[] ( jumpTab );
	}

	//Speicher für die LR-Tabelle freigeben?
	if( lrTab )
	{
		//die lrTab hat hulle_anz Spalten
		for( i = 0; i < hulle_anz; i++ )
			//Spalte freigeben
			delete[] ( lrTab[i] );

		//Struktur freigeben
		delete[] ( lrTab );
	}

	//Stack für die Verarbeitung von EBNF freigeben
	if( ebnfStack )
		//ja, freigeben
		delete[] ( ebnfStack );
}


void SSLRParser::insertEmbeddedSemanticAction( long prod_index, long prod2_index, long line, int &auxsymCount )
{
	//fügt ein auxsym-Nichtterminal auf rechter Seite von prod2_index ein für eine embedded semantic
	//action.
	PROD2_STR	*p2;
	long		hash_index;
	char		auxsym[11];

	//auxsym erstellen
	sprintf( auxsym, "auxsym_%d", auxsymCount++ );

	//in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( auxsym );

	//Produktion wurde definiert
	hash_tab->setProdDef( hash_index );

	//für Fehlerbehandlung merken
	setCheck( hash_index );

	//Nichtterminal wird benutzt
	hash_tab->setUsed( hash_index );

	//Nichtterminal wird definiert
	hash_tab->setDefined( hash_index, line );

	//ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );


	//auxsym-Produktion auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );


	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//prod_index dieser Produktion in die Hash-Tabelle eintragen
	hash_tab->setProdStr( hash_index, prod_index );

	//Hash-Index des Nichtterminals eintragen
	prod_str[prod_index].hash_index = hash_index;

	//PROD2_STR anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//Zeiger auf PROD2_STR
	p2 = &prod2_str[prod2_index];

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;

	//Priorität der Produktion eintragen
	p2->priority = 0;

	//Terminal in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "EPSILON" );

	//EPSILON auf rechter Seite eintragen
	insertElement( prod_index, prod2_index, hash_index );

	//ist ein Terminal
	hash_tab->setType( hash_index, SSLR_TERM );

	//Anzahl der Alternativen eintragen
	prod_str[prod_index].altAnz = 1;



	//semantische Aktion eintragen
	p2->semAct = semActStr.semAct;

	//Zeile merken
	p2->semActLine = semActStr.line;

	//ist eine embedded semantic action
	p2->isEmbeddedSemAct = true;
}


int SSLRParser::findDoubleAlt( void )
{
	//doppelte Alternativen finden
	PROD_STR	*p1;
	PROD2_STR	*p2, *p3;
	char		*name;
	int			i, j, k, l, err = 0, ri;

	//alle Produktionen
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//alle rechten Seiten
		ri = p1->altAnz;

		//alle Alternativen
		for( j = p1->prod2_index; j < ( p1->prod2_index + ri ); j++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[j];

			//alle anderen Alternativen
			for( k = j + 1; k < ( p1->prod2_index + ri ); k++ )
			{
				//Zeiger auf PROD2_STR
				p3 = &prod2_str[k];

				//Anzahl der Elemente gleich?
				if( p2->riAnz == p3->riAnz )
				{
					//die rechten Seiten von p2 und p3 vergleichen
					for( l = 0; l < p2->riAnz; l++ )
					{
						//Elemente gleich?
						if( p2->right[l] != p3->right[l] )
							//nein
							break;
					}

					//gleich, wenn l = p2->riAnz
					if( l == p2->riAnz )
					{
						//die Zeilen der Laternativen holen
						long	l1 = p2->line, l2 = p3->line;

						//Alternativen sind gleich
						cerr << "sslr: ERROR: Alternatives in lines " << l1 << " and " << l2 << " are equal in production " << name << "!" << endl;

						//Alternative ausgeben
//						outputAlt( cerr, k );

						//Fehler
						err++;
					}
				}
			}
		}
	}

	//zurück
	return( err );
}


int SSLRParser::getErrorStr( void )
{
	//erzeuge eine neue ERROR_STR und liefere den Index zurück
	ERROR_STR	*tmp;

	//eine neue ERROR_STR anfordern
	tmp = new( ERROR_STR[error_anz + 1] );

	//Inhalt kopieren
	memmove( tmp, error_str, sizeof( ERROR_STR ) * error_anz );

	//initalisieren
	memset( &tmp[error_anz], 0, sizeof( ERROR_STR ) );

	//alten Speicher freigeben?
	if( error_anz )
		//ja
		delete[]( error_str );

	//Adressen kopieren
	error_str = tmp;

	//Index zurückliefern
	return( error_anz++ );
}


int SSLRParser::insertErrTermStr( ERROR_STR *errStr, long terminal, int neg )
{
	//fügt eine ERRTERM_STR zu einer ERROR_STR hinzu
	ERRTERM_STR		*tmp, *tmp2;
	int				i;

	//alle ERRTERM_STR prüfen, ob das Terminal schon da ist
	for( i = 0; i < errStr->errTermStrAnz; i++ )
	{
		//Zeiger auf die ERRTERM_STR holen
		tmp = &errStr->errTermStr[i];

		//Terminle gleich?
		if( tmp->terminal == terminal )
		{
			//gleich
			cerr << "sslr: Warning: line " << errStr->line << ": Terminal " << hash_tab->getName( terminal ) << " already used in user-defined error-action!" << endl;

			//zurück
			return( -1 );
		}
	}

	//ERRTERM_STR erzeugen und zu errStr hinzufügen

	//eine neue ERRTERM_STR anfordern
	tmp = new( ERRTERM_STR[errStr->errTermStrAnz + 1] );

	//eintragen
	tmp2 = &tmp[errStr->errTermStrAnz];
	tmp2->terminal = terminal;
	tmp2->neg = neg;

	//Inhalt kopieren
	memmove( tmp, errStr->errTermStr, sizeof( ERRTERM_STR ) * errStr->errTermStrAnz );

	//Adressen
	errStr->errTermStr = tmp;

	//Index zurückliefern
	return( errStr->errTermStrAnz++ );
}


void SSLRParser::insertStartProd( long &prod_index, long &prod2_index )
{
	//Start-Produktion eintragen
	long	hash_index;

	//EPSILON eintragen
	epsHashIndex = hash_tab->insert( "EPSILON" );

	//EPSILON ist ein Terminal
	hash_tab->setType( epsHashIndex, SSLR_TERM );

	//ACCEPT eintragen
	acceptHashIndex = hash_tab->insert( "ACCEPT" );

	//ACCEPT ist ein Terminal
	hash_tab->setType( acceptHashIndex, SSLR_TERM );

	//Check-Index für LALR-Parser
	lalrHashIndex = hash_tab->insert( "LALR" );

	//das reservierte Terminal LALR ist ein Terminal
	hash_tab->setType( lalrHashIndex, SSLR_TERM );



	//Startproduktion in Hash-Tabelle eintragen
	hash_index = hash_tab->insert( "start" );

	//die Start-Produktion "start" ist ein Nichtterminal
	hash_tab->setType( hash_index, SSLR_NTERM );

	//Nichtterminal wird definiert
	hash_tab->setDefined( hash_index, 0 );

	//für Fehlerbehandlung merken
//	setCheck( hash_index );

	//neue PROD_STR anfordern
	prod_index = getNewProd();

	//Hash-Index des Nichtterminals eintragen
	prod_str[prod_index].hash_index = hash_index;

	//PROD2_STR anfordern
	prod2_index = getNewProd2( prod_index );

	//Zeile eintragen
	prod2_str[prod2_index].line = SSLR_line;

	//den Index der ersten Alternative der Produktion merken
	prod_str[prod_index].prod2_index = prod2_index;
}


void SSLRParser::setCheck( long hash_index )
{
	//Hash-Index in Liste eintragen zur allgemeinen Überprüfung
	long	i, *tmp;

	//alle durchgehen
	for( i = 0; i < anzCheck; i++ )
	{
		//gleich?
		if( check[i] == hash_index )
			//ja
			return;

		else if( check[i] > hash_index )
		{
			//mehr Speicher
			tmp = new( long[anzCheck + 1] );

			//umkopieren
			memcpy( tmp, check, sizeof( long ) * i );
			tmp[i] = hash_index;
			memcpy( &tmp[i+1], &check[i], sizeof( long ) * ( anzCheck - i ) );

			//ein Eintrag mehr
			anzCheck++;

			//Speicher freigeben
			if( check )
				delete[] ( check );

			//Zeiger
			check = tmp;

			//Schleife verlassen
			break;
		}
	}

	//leer?
	if( i == anzCheck )
	{
		//ja, anhängen

		//mehr Speicher
		tmp = new( long[anzCheck + 1] );

		//umkopieren
		memcpy( tmp, check, sizeof( long ) * anzCheck );
		tmp[anzCheck] = hash_index;

		//ein Eintrag mehr
		anzCheck++;

		//Speicher freigeben
		if( check )
			delete[] ( check );

		//Zeiger
		check = tmp;
	}
}


int SSLRParser::checkAllReduce( void )
{
	//prüfen, ob mit allen Alternativen reduziert wurde
	/*
		Hier wird geprüft, ob
		- jemals mit einer Alternative reduziert wird
	*/
	PROD2_STR	*pStr;
	int			i, err = 0;

	//prüfen, ob mit allen Alternativen auch reduziert wurde
	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf Struktur
		pStr = &prod2_str[i];

		//wurde reduziert?
		if( pStr->reduce <= 0 )
		{
			//nein, Warnung ausgeben
			cerr << "sslr: ERROR: Never reduced with ";

			//rechte Seite ausgeben
			outputAlt( cerr, i );

			//Fehler
			err++;
		}
	}

	//Wenn Fehler, zurückgeben
	return( err );
}


int SSLRParser::checkAll( void )
{
	/*
		Hier wird geprüft, ob
		- (Nicht)Terminale definiert wurden
		- (Nicht)Terminale benutzt wurden
		- (Nicht)Terminale schon als Terminale benutzt wurden
		- Mehrfachdefinitionen
	*/
	char	*id[3] = { "", "Terminal", "Nonterminal" }, *name;
	int		type, i, err = 0;
	int		tc = 0, nc = 0;

	//alle eingetragenen Elemente
	for( i = 0; i < anzCheck; i++ )
	{
		//Typ holen
		type = hash_tab->getType( check[i] );

		//Terminal?
		if( type == SSLR_TERM )
			//ja
			tc++;

		//Nichtterminal?
		else if( type == SSLR_NTERM )
			//ja
			nc++;

		//Name holen
		name = hash_tab->getName( check[i] );

		//Definiert?
		if( !hash_tab->getDefined( check[i] ) )
		{
			//Element wurde nicht definiert
			cerr << "sslr: Warning: " << id[type] << " " << name << " not defined!" << endl;

			//Fehler
//			err++;
		}

		//benutzt?
		if( hash_tab->getUsed( check[i] ) == false )
		{
			//Element wurde nicht benutzt
			cerr << "sslr: ERROR: " << id[type] << " " << name << " not used!" << endl;

			//Fehler
			err++;
		}

		//mehrfach benutzt?
		if( hash_tab->getDefined( check[i] ) > 1 )
		{
			//Element wurde nicht benutzt
			cerr << "sslr: ERROR: " << id[type] << " " << name << " more than once defined!" << endl;

			//Fehler
			err++;
		}

		//Produktion definiert?
		if( ( type == SSLR_NTERM ) && ( hash_tab->getProdDef( check[i] ) == false ) )
		{
			//Produktion wurde nicht definiert
			cerr << "sslr: ERROR: Production " << name << " not defined!" << endl;

			//Fehler
			err++;
		}
	}

	//Speicher für das Array für die Terminale
	termArr = new( long[tc + 1] );

	//Speicher für das Array für die Nichtterminale
	ntermArr = new( long[nc + 1] );

	//Anazhl der Einträge merken
	termArrCount = tc + 1;
	ntermArrCount = nc + 1;

	//start-Produktion als erste Produktion eintragen
	ntermArr[0] = prod_str[0].hash_index;

	//Index in der LR-Tabelle eintragen
	hash_tab->setLRTabIndex( ntermArr[0], 0 );

	//Hash-Indices aus checkArr
	for( i = 0, tc = 0, nc = 1; i < anzCheck; i++ )
	{
		//Name holen
		name = hash_tab->getName( check[i] );

		//Typ holen
		type = hash_tab->getType( check[i] );

		//Terminal?
		if( type == SSLR_TERM )
		{
			//ja, eintragen
			termArr[tc] = check[i];

			//Index in der LR-Tabelle eintragen
			hash_tab->setLRTabIndex( check[i], tc++ );
		}

		//Nichtterminal?
		else if( type == SSLR_NTERM )
		{
			//ja
			ntermArr[nc] = check[i];

			//Index in der LR-Tabelle eintragen
			hash_tab->setLRTabIndex( check[i], nc++ );
		}
	}

	//ACCEPT als letztes Terminal eintragen
	termArr[tc] = acceptHashIndex;

	//Index in der LR-Tabelle eintragen
	hash_tab->setLRTabIndex( acceptHashIndex, tc );

	//Wenn Fehler, zurückgeben
	return( err );
}


void SSLRParser::insertUnion( char *type, char *id )
{
	/*
		Neuen Eintrag aus der %union-Angabe erzeugen.
		ACHTUNG: Der Scanner liefert schon eine Kopie von type und id, hier muss
		also kein zusätzlicher Speicher angefordert werden!
	*/
	char	**t1, **t2;
	int		i;

	//Speicher für die Typen
	t1 = new( char *[unionStr->anz + 1] );

	//Speicher für die Bezeichner
	t2 = new( char *[unionStr->anz + 1] );

	//kopieren
	for( i = 0; i < unionStr->anz; i++ )
	{
		//nur die Adressen kopieren
		t1[i] = unionStr->type[i];
		t2[i] = unionStr->id[i];
	}

	//den alten Speicher freigeben
	if( unionStr->type )
		delete[] ( unionStr->type );

	if( unionStr->id )
		delete[] ( unionStr->id );

	//die neuen Einträge merken
	t1[unionStr->anz] = type;
	t2[unionStr->anz] = id;

	//ein weiterer Eintrag
	unionStr->anz++;

	//Adressen kopieren
	unionStr->type = t1;
	unionStr->id = t2;
}


int SSLRParser::getSemIndex( char *name )
{
	//In name steht der Typ zur semantischen Aktion. Den Index in unionStr suchen.
	/*
		Beispiel:
			%union
			{
				int		a;
			}

		In name steht nun a, den Index in unionStr zurückliefern.
	*/
	UNION_STR	*h = unionStr;
	int			i;

	//alle Einträge durchgehen
	for( i = 0; i < h->anz; i++ )
	{
		//Vergleichen
		if( !strcmp( h->id[i], name ) )
			//gefunden
			return( i );
	}

	//nicht gefunden
	return( -1 );
}


long SSLRParser::getNewProd( void )
{
	//PROD_STR anfordern
	PROD_STR	*tmp;

	//Speicher für PROD_STR anfordern
	tmp = new( PROD_STR[prod_anz + 1] );

	//kopieren
	memmove( tmp, prod_str, sizeof( PROD_STR ) * prod_anz );

	//alten Speicher freigeben
	if( prod_str )
		delete[] ( prod_str );

	//Adressen
	prod_str = tmp;

	//initialisieren
	memset( &prod_str[prod_anz], 0, sizeof( PROD_STR ) );

	//Index der ersten Alternative in PROD2_STR eintragen
	prod_str[prod_anz].prod2_index = prod2_anz;

	//Index zurückliefern
	return( prod_anz++ );
}


long SSLRParser::getNewProd2( long prod_index )
{
	//PROD2_STR anfordern
	PROD2_STR	*tmp;

	//Speicher für PROD2_STR anfordern
	tmp = new( PROD2_STR[prod2_anz + 1] );

	//kopieren
	memmove( tmp, prod2_str, sizeof( PROD2_STR ) * prod2_anz );

	//alten Speicher freigeben
	if( prod2_str )
		delete[] ( prod2_str );

	//Adressen
	prod2_str = tmp;

	//initialisieren
	memset( &prod2_str[prod2_anz], 0, sizeof( PROD2_STR ) );

	//Index der Produktion in PROD_STR
	prod2_str[prod2_anz].prod_index = prod_index;

	//zurücksetzen
	prod2_str[prod2_anz].reduce = 0;

	//die Alternative hat noch keine Priorität
	prod2_str[prod2_anz].priority = 0;

	//Index zurückliefern
	return( prod2_anz++ );
}


void SSLRParser::insertElement( long prod_index, long prod2_index, long hash_index )
{
	//Element auf der rechten Seite der Produktion eintragen
//	PROD_STR	*p1 = &prod_str[prod_index];
	PROD2_STR	*p2 = &prod2_str[prod2_index];
	long		*tmp;

	//Index der Produktion eintragen
	p2->prod_index = prod_index;

	//Speicher für die Elemente anfordern
	tmp = new( long[p2->riAnz + 1] );

	//kopieren
	memmove( tmp, p2->right, sizeof( long ) * p2->riAnz );

	//alten Speicher freigeben
	if( p2->right )
		delete[] ( p2->right );

	//Adressen
	p2->right = tmp;

	//Index des Elemente in der rechten Seite eintragen
	p2->right[p2->riAnz++] = hash_index;
}


int SSLRParser::checkErrorStr( void )
{
	//die ERROR_STR prüfen

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		PROD2_STR	*p2;
		ERROR_STR	*errorStr1, *errorStr2;
		int			i, j, k, l, m;
		int			errTermCnt1, errTermCnt2, anzColl, coll;
		int			*noTermErrActErrorStrIndex, *noTermErrActHulleIndex, noTermErrActCnt;
		int			*errTerm, anzErrTerm;

		/*
			Hier werden Fehlerangaben gefunden, die nie ausgeführt werden.
			Beim folgenden Beispiel wird die letzte Fehlerangabe nicht ausgeführt.
			1:!ADD:			"Fehlermeldung1"
			1:ADD			"Fehlermeldung2"
			1:SHIFT(ADD)	"Fehlermeldung3"
		*/
		noTermErrActErrorStrIndex = new( int[error_anz] );
		noTermErrActHulleIndex = new( int[error_anz] );
		errTerm = new( int[termArrCount] );

		/*
			Hier wird geprüft, ob es zu zwei Fehlerangaben Überschneidungen
			seitens der Terminale gibt.
			Dazu werden immer die Fehlerangaben verglichen, die den selben
			Hüllenindex haben sowie dieselbe Punktposition.
		*/
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//initialisieren
			memset( noTermErrActErrorStrIndex, 0, sizeof( int) * error_anz );
			memset( noTermErrActHulleIndex, 0, sizeof( int) * error_anz );
			memset( errTerm, 0, sizeof( int) * termArrCount );
			noTermErrActCnt = 0;
			anzErrTerm = 0;

			//alle nachfolgenden ERROR_STR
			for( j = i + 1; j < error_anz; j++ )
			{
				//Zeiger auf ERROR_STR
				errorStr2 = &error_str[j];

//Meldung ausgeben
//cerr << "process %error " << errorStr1->line << endl;
//cerr << "process %error " << errorStr2->line << endl << endl;

				//alle Einträge der ersten ERROR_STR
				for( k = 0; k < errorStr1->hInd.anzArr; k++ )
				{
					//alle Einträge der zweiten ERROR_STR
					for( l = 0; l < errorStr2->hInd.anzArr; l++ )
					{
						//gleiche Hüllen-Indices?
						if( errorStr1->hInd.arr[k] == errorStr2->hInd.arr[l] )
						{
							/*
								hat diese ERROR_STR überhaupt Aktionen, die mit Terminalen
								verbunden sind?
							*/
							if( !errorStr1->errTermStrAnz )
							{
								/*
									nein, eine Fehleraktion ohne Angabe von Terminalen,
									also der Art
									1:AKTION:	"Fehler!"
									Nun den Index j der errorStr2 merken, damit später
									geprüft werden kann, ob diese Fehleraktion jemals
									ausgeführt werden kann.
								*/
								int	k;

								//da mehrere Hüllen-Indices zu einer Fehleraktionen gehören können, nur einmal eintragen
								for( k = 0; k < noTermErrActCnt; k++ )
								{
									//den Hüllen-Index j schon eingetragen?
									if( noTermErrActErrorStrIndex[k] == i )
										//ja, nicht noch einmal eintragen
										break;
								}

								//schon eingetragen?
								if( k == noTermErrActCnt )
								{
									//nein, eintragen
									noTermErrActErrorStrIndex[noTermErrActCnt] = i;
									noTermErrActHulleIndex[noTermErrActCnt++] = errorStr2->hInd.arr[l];
								}
							}

							/*
								die zweite ERROR_STR kann auch eine Fehleraktion
								ohne Terminal haben
							*/
							if( !errorStr2->errTermStrAnz )
							{
								/*
									nein, eine Fehleraktion ohne Angabe von Terminalen,
									also der Art
									1:AKTION:	"Fehler!"
									Nun den Index j der errorStr2 merken, damit später
									geprüft werden kann, ob diese Fehleraktion jemals
									ausgeführt werden kann.
								*/
								int	k;

								//da mehrere Hüllen-Indices zu einer Fehleraktionen gehören können, nur einmal eintragen
								for( k = 0; k < noTermErrActCnt; k++ )
								{
									//den Hüllen-Index j schon eingetragen?
									if( noTermErrActErrorStrIndex[k] == j )
										//ja, nicht noch einmal eintragen
										break;
								}

								//schon eingetragen?
								if( k == noTermErrActCnt )
								{
									//nein, eintragen
									noTermErrActErrorStrIndex[noTermErrActCnt] = j;
									noTermErrActHulleIndex[noTermErrActCnt++] = errorStr2->hInd.arr[l];
								}
							}

							/*
								PROBLEM: Es kann durchaus sein, dass zwei
								Fehleranweisungen zu verschiedenen
								LR-Items den gleichen Zustand erhalten.
								Nun auf Kollisionen prüfen.
							*/
							errTermCnt1 = errTermCnt2 = 0;
							anzColl = 0;

							//für alle Terminale prüfen
							for( m = 0; m < termArrCount; m++ )
							{
								//and
								coll = ( errorStr1->errTermArr[m] & errorStr2->errTermArr[m] );
								anzColl += coll;

								/*
									Anzahl der Terminale merken, für die
									eine Aktion ausgeführt wird.
								*/
								if( !errTerm[m] )
								{
									//noch keine Fehleraktion mit dem Terminal m verbunden
									anzErrTerm += ( errorStr1->errTermArr[m] | errorStr2->errTermArr[m] );
									errTerm[m] = ( errorStr1->errTermArr[m] | errorStr2->errTermArr[m] );
								}

								//zählen
								errTermCnt1 += errorStr1->errTermArr[m];
								errTermCnt2 += errorStr2->errTermArr[m];

								//gab es eine Kollision?
								if( coll )
								{
									//ja, Name des Terminals
									char *name = hash_tab->getName( termArr[m] );

									//Meldung ausgeben
									cerr << "sslr: ERROR: Collision in terminal " << name << " between error action in line " << errorStr1->line << " and " << errorStr2->line << "!" << endl;

									//Fehler
									err++;
								}
							}
						}
					}
				}
			}

			//Fehleraktion ohne Terminale prüfen
			if( noTermErrActCnt )
			{
				//sind alle Terminale mit Fehleraktionen versehen?
				if( anzErrTerm == termArrCount )
				{
					/*
						Für den Zustand errorStr1->hInd.arr[k] gibt es für jedes Terminal
						eine Fehleraktion.
						Da es auch Fehleraktionen ohne Terminal gibt, werden diese folglich
						nie ausgeführt.
					*/
					ERROR_STR	*tmp;
					int			i;

					//alle nicht-terminalgebundenen Fehleraktionen
					for( i = 0; i < noTermErrActCnt; i++ )
					{
						//Zeiger auf die zugehörige ERROR_STR
						tmp = &error_str[noTermErrActErrorStrIndex[i]];

						//Warnung ausgeben
						cerr << "sslr: Warning: line " << tmp->line << ": Error action will never be used!" << endl;
					}
				}

				//es gibt noch "freie" Terminale
				else if( noTermErrActCnt > 1 )
				{
					/*
						Hier wird geprüft, ob Fehlerangaben der folgenden Form auftauchen

						1:SHIFT(ADD):		"Fehlermeldung 1"
						1:OVERREAD(SUB):	"Fehlermeldung 2"

						Dies geht nicht, da nicht beide Fehlermeldungen gleichzeitig
						ausgegeben werden können, besser:
						1:SHIFT(ADD):OVERREAD(SUB):	"Fehlermeldung 1 und 2"
					*/
					unsigned long	state;
					ERROR_STR		*tmp1, *tmp2;
					int				i, j;

					//alle Fehleraktionen miteinander vergleichen
					for( i = 0; i < noTermErrActCnt; i++ )
					{
						for( j = i + 1; j < noTermErrActCnt; j++ )
						{
							//Zeiger auf beide ERROR_STR
							tmp1 = &error_str[noTermErrActErrorStrIndex[i]];
							tmp2 = &error_str[noTermErrActErrorStrIndex[j]];

							//Zustand der Kollision
							state = noTermErrActHulleIndex[i];

							/*
								nur eine nicht-Terminal-gebundene Fehleraktion
								pro Zustand erlaubt
							*/
							cerr << "sslr: Warning: Two error actions in line " << tmp1->line << " and line " << tmp2->line << " without terminals in the same state " << state << "!" << endl;
						}
					}
				}
			}
		}

		//Speicher wieder freigeben
		delete[] ( noTermErrActErrorStrIndex );
		delete[] ( noTermErrActHulleIndex );
		delete[] ( errTerm );




		//nun prüfen, ob EXIT mit etwas anderem zusammen steht
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//ist EXIT aktiviert?
			if( errorStr1->exit )
			{
				//mit anderen Aktionen?
				if( errorStr1->shift || errorStr1->del || errorStr1->overread || errorStr1->sem )
					//unsinnig
					cerr << "sslr: Warning: line " << errorStr1->line << ": It makes no sense to use EXIT together with other user-defined error-actions!" << endl;
			}
		}






		//nun prüfen, ob eine Fehlerangabe jemals ausgeführt wird
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR
			errorStr1 = &error_str[i];

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[errorStr1->prod2_index];

			//ist die Position des Punktes zu groß?
			if( errorStr1->dot > p2->riAnz )
			{
				//wird niemals ausgeführt
				cerr << "sslr: ERROR: line " << errorStr1->line << ": Position of dot " << errorStr1->dot << " to big!" << endl;

				//Fehler
				err++;
			}
		}
	}

	//Anzahl der Fehler zurückgeben
	return( err );
}


void SSLRParser::sortProd2Str( void )
{
	//Die PROD2_STR sortieren
	PROD2_STR	*a, *b, *source, *dest, tmp;
	PROD_STR	*p1;
	char		*name1, *name2;
	int			i, j, k, anz;

	//initialisieren
	i = 0;

	//alle Alternativen
	while( i < ( prod2_anz - 1 ) )
	{
		//Zeiger auf PROD2_STR
		a = &prod2_str[i];

		//den Namen holen
		name1 = hash_tab->getName( prod_str[a->prod_index].hash_index );

		//Index
		j = i++;

		do
		{
			//nächsten
			j++;

			//Zeiger auf PROD2_STR
			b = &prod2_str[j];

			//Zeiger auf PROD_STR
			p1 = &prod_str[b->prod_index];

			//den Namen holen
			name2 = hash_tab->getName( p1->hash_index );

		}while( ( a->prod_index == b->prod_index ) && ( j < ( prod2_anz - 1 ) ) );

		//alle Alternativen
		for( k = j++; j < prod2_anz; j++ )
		{
			//Zeiger auf PROD2_STR
			b = &prod2_str[j];

			//Den Namen holen
			name2 = hash_tab->getName( prod_str[b->prod_index].hash_index );

			//gleiche Produktionen, d.h. prod_index gleich?
			if( a->prod_index == b->prod_index )
			{
				//ja

				//Zeiger auf PROD2_STR
				source = &prod2_str[j];

				//Zeiger auf PROD2_STR
				dest = &prod2_str[k];

				//j sichern
				tmp.prod_index = source->prod_index;
				tmp.riAnz = source->riAnz;
				tmp.right = source->right;
				tmp.priority = source->priority;
				tmp.semAct = source->semAct;
				tmp.semActLine = source->semActLine;

				//verschieben
				memmove( &prod2_str[k+1], &prod2_str[k], sizeof( PROD2_STR ) * ( j - k ) );

				//eintragen
				dest->prod_index = tmp.prod_index;
				dest->riAnz = tmp.riAnz;
				dest->right = tmp.right;
				dest->priority = tmp.priority;
				dest->semAct = tmp.semAct;
				dest->semActLine = tmp.semActLine;

				//nächste Position
				k++;
			}
		}

		//ab k + 1
		i = k;
	}

	//Indices anpassen
	for( i = 0, k = 0; i < prod_anz; i++ )
	{
		//Anzahl der Alternativen
		anz = prod_str[i].altAnz;

		//prod2_index anpassen
		prod_str[i].prod2_index = k;

		//alle zugehörigen Alternativen
		for( j = k; j < ( k + anz ); j++ )
			//PROD_STR-Index eintragen
			prod2_str[j].prod_index = i;

		//überspringen
		k += anz;
	}
}


void SSLRParser::outputGrammar( void )
{
	//Grammatik in Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name;
	int			i, j, k, r;

	//Grammatik in Datei ausgeben?
	if( argv_str->outputGrammar )
	{
		//Stream öffnen
		ofstream	out( argv_str->name );

		//Header ausgeben
		out << "/*\n";
		out << "Grammatik in BNF-Form. Generiert vom SSLR-Parser-Generator V" << VERSION << ".\n";
		out << "(c) 2002-2005 by Sven Schmidt\n";
		out << "s.schmidt@lboro.ac.uk\n";
		out << "*/\n\n";

		//alle Produktionen
		for( i = 1; i < prod_anz; i++ )
		{
			//Zeiger auf die PROD_STR holen
			p1 = &prod_str[i];

			//Den Namen der Produktion holen
			name = hash_tab->getName( p1->hash_index );

			//Produktion ausgeben
			out << name << "\n";

			//Seperator ausgeben
			out << "\t->\t";

			//alle Alternativen ausgeben
			for( j = p1->prod2_index, k = 0; j < ( p1->prod2_index + p1->altAnz ); j++, k++ )
			{
				//Zeiger auf die PROD2_STR holen
				p2 = &prod2_str[j];

				//neue Alternative?
				if( k )
					//ja
					out << "\t|\t";

				//rechte Seite ausgeben
				for( r = 0; r < p2->riAnz; r++ )
				{
					//Namen holen
					name = hash_tab->getName( p2->right[r] );

					//Terminal?
					if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
						//ja
						out << " '" << name << "' ";

					else
						//Nichtterminal
						out << " " << name << " ";
				}

				//Priorität ausgeben
				out << "\t/* Priority: " << p2->priority << " */\n";
			}

			//Produktion abschliessen
			out << "\t;\n\n";
		}
	}
}


void SSLRParser::outputAlt( ostream &s, long prod2_index )
{
	//alle Alternativen der Produktion ausgeben, zu der die Alternative prod2_index gehört
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	s << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			s << " '" << name << "' ";

		else
			//Nichtterminal
			s << " " << name << " ";
	}

	//nächste Zeile
	s << "\n";
}


void SSLRParser::outputItem( long prod2_index, int dot, ofstream &file )
{
	//Ein Item ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	file << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Position des Punktes?
		if( dot == r )
			//ja
			file << ".";

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			file << " '" << name << "' ";

		else
			//Nichtterminal
			file << " " << name << " ";
	}

	//Position des Punktes?
	if( dot == r )
		//ja
		file << ".";
}


void SSLRParser::outputItem( long prod2_index, int dot )
{
	//Ein Item ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	char		*name;
	int			r;

	//Zeiger auf die PROD2_STR holen
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die PROD_STR holen
	p1 = &prod_str[p2->prod_index];

	//Namen der Produktion holen
	name = hash_tab->getName( p1->hash_index );

	//ausgeben
	cout << " " << name << " -> ";

	//rechte Seite ausgeben
	for( r = 0; r < p2->riAnz; r++ )
	{
		//Namen holen
		name = hash_tab->getName( p2->right[r] );

		//Position des Punktes?
		if( dot == r )
			//ja
			cout << ".";

		//Terminal?
		if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
			//ja
			cout << " '" << name << "' ";

		else
			//Nichtterminal
			cout << " " << name << " ";
	}

	//Position des Punktes?
	if( dot == r )
		//ja
		cout << ".";
}


void SSLRParser::outputAllAlt( void )
{
	//alle Alternativen ausgeben
	PROD_STR	*p1;
	PROD2_STR	*p2;
	ofstream	out( argv_str->name );
	char		*name;
	int			j, r;

	//alle Alternativen ausgeben
	for( j = 0; j < prod2_anz; j++ )
	{
		//Zeiger auf die PROD2_STR holen
		p2 = &prod2_str[j];

		//Zeiger auf die PROD_STR holen
		p1 = &prod_str[p2->prod_index];

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//ausgeben
		out << " " << name << " -> ";

		//rechte Seite ausgeben
		for( r = 0; r < p2->riAnz; r++ )
		{
			//Namen holen
			name = hash_tab->getName( p2->right[r] );

			//Terminal?
			if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
				//ja
				out << " '" << name << "' ";

			else
				//Nichtterminal
				out << " " << name << " ";
		}

		//nächste Zeile
		out << "\n";
	}
}


void SSLRParser::genAllFirst( void )
{
	//alle FIRST-Mengen bilden
	PROD2_STR	*p2;
	PROD_STR	*p1;
	Terminal	*f1;
	long		anzFirst;
	char		*name;
	int			i, j, changed;
	int			pass = 0;
	int			*pArr;

	//keine doppelten Ausgaben
	pArr = new( int[prod_anz] );

	//Initialisieren
	memset( pArr, 0, sizeof( int ) * prod_anz );

	do
	{
		//prüft, ob weitere Terminale zur FIRST-Menge hinzugefügt wurden
		changed = 0;

		//ein weiterer Pass
		pass++;

		//alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//ausführliche Ausgaben?
			if( ( argv_str->verbose ) && !( pArr[i] ) )
			{
				//ja
				cout << "sslr: Generate FIRST(" << name << ")..." << endl;

				//Meldung nicht nocheinmal ausgeben
				pArr[i]++;
			}

			//Anzahl der FIRST-Elemente holen
			anzFirst = hash_tab->getFirstAnz( p1->hash_index );

			//Zeiger auf FIRST-Mengen holen
			f1 = hash_tab->getFirst( p1->hash_index );

			//alle Alternativen
			for( j = p1->prod2_index; j < ( p1->prod2_index + p1->altAnz ); j++ )
			{
				//Zeiger auf PROD2_STR
				p2 = &prod2_str[j];

				//FIRST-Menge berechnen
				genFirst( f1, p2->riAnz, p2->right );
			}

			//geändert?
			if( anzFirst != hash_tab->getFirstAnz( p1->hash_index ) )
				//ja
				changed++;
		}

	}while( changed );

	//Speicher wieder freigeben
	delete[] ( pArr );

	//ausführliche Ausgaben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate FIRST-Sets!" << endl;

	//FIRST-Mengen ausgeben?
	if( argv_str->showFirst )
	{
		//alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//Meldung
			cout << "\nFIRST(" << name << ")=" << endl;

			//FIRST-Menge ausgeben
			hash_tab->printFirst( p1->hash_index );
		}
	}
}


void SSLRParser::genFirst( Terminal *f, int anzElem, long *arr )
{
	//Hier werden die FIRST-Mengen eines Terminals/Nichtterminals erzeugt
	Terminal	*f2, *f3;
	char		*name;
	int			i, eps = 0;

	//für jeden Durchgang eine eigene FIRST-Menge
	f3 = new Terminal( epsHashIndex );

	//gibt es überhaupt noch Elemente
	if( anzElem > 0 )
	{
		//alle Elemente
		for( i = 0; i < anzElem; i++ )
		{
			//Namen holen
			name = hash_tab->getName( arr[i] );

			//Zeiger auf die FIRST-Menge holen
			f2 = hash_tab->getFirst( arr[i] );

			//hinzufügen
			f3->add( f2 );

			//beinhaltet die FIRST-Menge EPSILON?
			if( f2->isEpsilon() )
				//ja, hochzählen
				eps++;

			else
				//nein, for-Schleife verlassen
				break;
		}

		//Epsilon zu dieser Menge hinzufügen?
		if( eps && ( eps < anzElem ) )
		{
			//nein, aus der FIRST-Menge löschen

			//EPSILON aus FIRST-Menge löschen
			f3->del( epsHashIndex );
		}
	}

	else
		//leere Menge, EPSILON hinzufügen
		f3->ins( epsHashIndex );

	//FIRST-Menge hinzufügen
	f->add( f3 );

	//Speicher freigeben
	delete( f3 );
}


void SSLRParser::genAllFollow( void )
{
	//alle FOLLOW-Mengen bilden
	PROD2_STR	*p2;
	PROD_STR	*p1, *p3;
	Terminal	*f1, *f2, *first;
	long		anzFollow;
	char		*name, *tmpName;
	int			i, j, r, changed;
	int			pass = 0;
	int			*pArr;

	//keine doppelten Ausgaben
	pArr = new( int[prod_anz] );

	//Initialisieren
	memset( pArr, 0, sizeof( int ) * prod_anz );

	//ACCEPT in die Start-Produktion aufnehmen
	f1 = hash_tab->getFollow( prod_str[0].hash_index );

	//ACCEPT eintragen
	f1->ins( acceptHashIndex );

	do
	{
		//prüft, ob weitere Terminale zur FOLLOW-Menge hinzugefügt wurden
		changed = 0;

		//ein weiterer Pass
		pass++;

		//alle Produktionen
		for( i = 1; i < prod_anz; i++ )
		{
			//nein, Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//ausführliche Ausgaben?
			if( ( argv_str->verbose ) && !( pArr[i] ) )
			{
				//ja
				cout << "sslr: Generate FOLLOW(" << name << ")..." << endl;

				//Meldung nicht nocheinmal ausgeben
				pArr[i]++;
			}

			//Anzahl der FOLLOW-Elemente holen
			anzFollow = hash_tab->getFollowAnz( p1->hash_index );

			//Zeiger auf FOLLOW-Mengen holen
			f1 = hash_tab->getFollow( p1->hash_index );

			//alle Alternativen
			for( j = 0; j < prod2_anz; j++ )
			{
				//Zeiger auf PROD2_STR
				p2 = &prod2_str[j];

//Debug-Modus?
#ifdef SSLR_INTERN_DEBUG
				//Alternative ausgeben
				outputAlt( j );
#endif

				//Nichtterminal check[i] auf rechter Seite suchen
				for( r = 0; r < p2->riAnz; r++ )
				{
					//Name holen
					tmpName = hash_tab->getName( p2->right[r] );

					//Gefunden?
					if( p2->right[r] == p1->hash_index )
					{
						//FIRST-Mengen bilden
						first = new Terminal( epsHashIndex );

						//FIRST-Mengen bilden
						genFirst( first, p2->riAnz - r - 1, &p2->right[r+1] );

						//EPSILON in FIRST-Menge?
						if( first->isEpsilon() )
						{
							//ja, Zeiger auf PROD_STR
							p3 = &prod_str[p2->prod_index];

							//Namen holen
							tmpName = hash_tab->getName( p3->hash_index );

//							cerr << "FOLLOW(" << name << ") += FOLLOW(" << tmpName << ")" << endl;

							//ja, FOLLOW(p2->prodindex) = FOLLOW(check[i])
							f2 = hash_tab->getFollow( p3->hash_index );

							//hinzufügen
							f1->add( f2 );

							//EPSILON aus FIRST-Menge löschen
							first->del( epsHashIndex );
						}

						//hinzufügen
						f1->add( first );

						//FIRST-Mengen löschen
						delete( first );
					}
				}
			}

			//geändert?
			if( anzFollow != hash_tab->getFollowAnz( p1->hash_index ) )
				//ja
				changed++;
		}

	}while( changed );

	//Speicher wieder freigeben
	delete[] ( pArr );

	//ausführliche Ausgaben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate FOLLOW-Sets!" << endl;

	//FOLLOW-Mengen ausgeben?
	if( argv_str->showFollow )
	{
		//alle Produktionen
		for( i = 0; i < prod_anz; i++ )
		{
			//Zeiger auf PROD_STR
			p1 = &prod_str[i];

			//ja, Name holen
			name = hash_tab->getName( p1->hash_index );

			//Meldung
			cout << "\nFOLLOW(" << name << ")=" << endl;

			//FOLLOW-Menge ausgeben
			hash_tab->printFollow( p1->hash_index );
		}
	}
}


void SSLRParser::genLR0Hulle( void )
{
	//Generiere alle Hüllen der LR(0)-Elemente für SLR und LALR
	HULLE_STR	*h;
	int			changed = 0, pass = 0, i;

	//1. Hülle generieren
	h = createHulle();

	//ersten Kern eintragen
	insertItem( h, 0, 0, SSLR_CORE );

	//Hülle eintragen
	insertHulle( h );

	//Wurde nicht durch Sprung-Funktion erzeugt
	h->from = 0;
	h->elem = 0;

	//bei Hülle 0 anfangen
	i = 0;

	do
	{
		//Passe zählen
		pass++;

		//Keine Änderungen
//		changed = 0;

		//Anzahl der Hüllen merken
//		anzH = hulle_anz;

		//alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf Hülle
			h = hulle_str[i];

			//alle Elemente dieser Hülle erzeugen
			genLR0Items( h );

			//Ausgeben
//			outputHulle( h );

			//Anhand der Items die Hüllen erzeugen, die sich durch Spring( h, X ) ergeben
			makeLR0Jump( h );
/*
			//Anzahl der Hüllen geändert?
			if( hulle_anz != anzH )
				//ja
				changed++;
*/
		}

	}while( changed );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate " << hulle_anz << " LR(0)-Items!" << endl;
}


void SSLRParser::genLR1Hulle( void )
{
	//Generiere alle Hüllen der LR(1)-Elemente für LR
	HULLE_STR	*h;
	Terminal	*la;
	int			changed = 0, pass = 0, i;

	//1. Hülle generieren
	h = createHulle();

	//Speicher für die Lookaheads
	la = new Terminal( epsHashIndex );

	//Accept eintragen
	la->ins( acceptHashIndex );

	//ersten Kern eintragen
	insertItem( h, 0, 0, SSLR_CORE, la );

	//Hülle eintragen
	insertHulle( h );

	//Wurde nicht durch Sprung-Funktion erzeugt
	h->from = 0;
	h->elem = 0;

	//bei Hülle 0 anfangen
	i = 0;

	do
	{
		//Passe zählen
		pass++;

		//Keine Änderungen
//		changed = 0;

		//Anzahl der Hüllen merken
//		anzH = hulle_anz;

		//alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf Hülle
			h = hulle_str[i];

			//alle Elemente dieser Hülle erzeugen
			genLR1Items( h );

			//Ausgeben
//			outputHulle( h );

			//Anhand der Items die Hüllen erzeugen, die sich durch Spring( h, X ) ergeben
			makeLR1Jump( h );
/*
			//Anzahl der Hüllen geändert?
			if( hulle_anz != anzH )
				//ja
				changed++;
*/
		}

	}while( changed );

	//Speicher freigeben
	delete( la );

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate " << hulle_anz << " LR(1)-Items!" << endl;
}


void SSLRParser::makeLR0Jump( HULLE_STR *h )
{
	//Hier werden die Hüllen erzeugt, die sich durch Sprung( h, X ) ergeben
	HULLE_STR	*tmp;
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	long		elem, hInd;
	int			i;

	//alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Punkt eine Position weiter und Element eintragen

			//Das (Nicht)Terminal holen, das nach dem Punkt kommt
			/*
				Bsp: expr
							->	.expr ADD expr
							|	.expr SUB expr
							|	term
							;

				Hier also ist expr vor dem Punkt.
			*/
			elem = p2->right[lr->dot];

			/*
				Die hier erzeugte Hülle ergibt sich also aus:

				tmp = Sprung( h, elem )
			*/

			//darf nicht .EPSILON sein
			if( elem != epsHashIndex )
			{
				//Den Namen holen
				name = hash_tab->getName( elem );

				//Hülle anfordern
				tmp = createHulle();

				//Hülle erzeugen
				genLR0Jump( h, tmp, elem );

				//Hülle schon in hulle_str?
				if( ( hInd = cmpLR0Hulle( tmp ) ) < 0 )
				{
					//nein

					// this = Sprung( h, elem ) merken
					tmp->from = h->hulleIndex;
					tmp->elem = elem;

					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hulle_anz );

					//Meldung ausgeben?
					if( argv_str->verbose )
						//ja
						cout << "sslr: Generate Jump(" << name << ")..." << endl;

					//Hülle eintragen
					insertHulle( tmp );

					//Ausgeben
//					outputHulle( tmp );
				}

				else
				{
					//Die Hülle existiert schon
					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hInd );

					//Hülle löschen
					deleteHulle( tmp );
				}
			}
		}
	}
}


void SSLRParser::makeLR1Jump( HULLE_STR *h )
{
	//Hier werden die Hüllen erzeugt, die sich durch Sprung( h, X ) ergeben
	HULLE_STR	*tmp;
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	long		elem, hInd;
	int			i;

	//alle LR(1)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Punkt eine Position weiter und Element eintragen

			//Das (Nicht)Terminal holen, das nach dem Punkt kommt
			/*
				Bsp: expr
							->	.expr ADD expr
							|	.expr SUB expr
							|	.term
							;

				Hier sind expr und term vor dem Punkt.
			*/
			elem = p2->right[lr->dot];

			/*
				Die hier erzeugte Hülle ergibt sich also aus:

				tmp = Sprung( h, elem )
			*/

			//darf nicht .EPSILON sein
			if( elem != epsHashIndex )
			{
				//Den Namen holen
				name = hash_tab->getName( elem );

				//Hülle anfordern
				tmp = createHulle();

				//Hülle erzeugen
				genLR1Jump( h, tmp, elem );

				//Hülle schon in hulle_str?
				if( ( hInd = cmpLR1Hulle( tmp ) ) < 0 )
				{
					//nein

					// this = Sprung( h, elem ) merken
					tmp->from = h->hulleIndex;
					tmp->elem = elem;

					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hulle_anz );

					//Meldung ausgeben?
					if( argv_str->verbose )
						//ja
						cout << "sslr: " << hulle_anz << " Generate Jump(" << h->hulleIndex << ", " << name << ")..." << endl;

					//Hülle eintragen
					insertHulle( tmp );

					//Ausgeben
//					outputHulle( tmp );
				}

				else
				{
					//Die Hülle existiert schon
					//In den Elementen von h, aus denen Sprung(h,elem) entsteht, den Index von tmp
					//eintragen.
					setJump( h, elem, hInd );

					//Hülle löschen
					deleteHulle( tmp );
				}
			}
		}
	}
}


void SSLRParser::genLR0Items( HULLE_STR *h )
{
	//Hier werden alle LR(0)-Items einer Hülle erzeugt.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr;
	char		*name, *tmpName;
	long		pi;
	int			j, k;

	//alle Elemente dieser Hülle
	for( j = 0; j < h->anzElem; j++ )
	{
		/*
			Bsp:	expr	->	.expr ADD expr
							|	.expr SUB expr
							|	.term
		*/
		//Index der ersten Alternative der Produktion nach dem Punkt holen

		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[j];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Ist der Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//Namen holen
			name = hash_tab->getName( p2->right[lr->dot] );

			//Ist es ein Nichtterminal?
			if( hash_tab->getType( p2->right[lr->dot] ) == SSLR_NTERM )
			{
				//ja, diese Produktion als Elemente mit dot = 0 aufnehmen

				//prod_index dieses Nichtterminals
				pi = hash_tab->getProdStr( p2->right[lr->dot] );

				//Zeiger auf PROD_STR
				p1 = &prod_str[pi];

				//Namen holen
				tmpName = hash_tab->getName( p1->hash_index );

				//Index der ersten Alternative in der PROD2_STR
				for( k = p1->prod2_index; k < ( p1->prod2_index + p1->altAnz ); k++ )
					//Als LR(0)-Item hinzufügen
					insertItem( h, k, 0, SSLR_ITEM );
			}
		}
	}
}


void SSLRParser::genLR1Items( HULLE_STR *h )
{
	//Hier werden alle LR(1)-Items einer Hülle erzeugt.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr, *lr2;
	Terminal	*la;
	char		*name, *tmpName;
	long		pi, cInd;
	int			j, k, changed, anzElem;

	do
	{
		//solange etwas hinzugefügt wurde
		changed = 0;

		//alle Elemente dieser Hülle
		for( j = 0; j < h->anzElem; j++ )
		{
			/*
				Bsp:	expr	->	.expr ADD expr
								|	.expr SUB expr
								|	.term
			*/
			//Index der ersten Alternative der Produktion nach dem Punkt holen

			//Zeiger auf LR(0)-Element
			lr = &h->lr_str[j];

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[lr->prod2_index];

			//Ist der Punkt am Ende?
			if( lr->dot < p2->riAnz )
			{
				//Namen holen
				name = hash_tab->getName( p2->right[lr->dot] );

				//Ist es ein Nichtterminal?
				if( hash_tab->getType( p2->right[lr->dot] ) == SSLR_NTERM )
				{
					//ja, diese Produktion als Elemente mit dot = 0 aufnehmen

					//prod_index dieses Nichtterminals
					/*
						Bsp:
							term	->	.term MUL factor

						Also PROD_STR-Index von term
					*/
					pi = hash_tab->getProdStr( p2->right[lr->dot] );

					//Zeiger auf PROD_STR
					p1 = &prod_str[pi];

					//Namen holen
					tmpName = hash_tab->getName( p1->hash_index );

					//Speicher für die Lookaheads holen
					la = new Terminal( epsHashIndex );

					//FIRST-Menge bilden nach dot
					genFirst( la, p2->riAnz - lr->dot - 1, &p2->right[lr->dot + 1] );

					//EPSILON in FIRST-Menge?
					if( la->isEpsilon() )
					{
						//ja, alle Lookaheads des LR(1)-Items hinzufügen
						la->add( lr->la );

						//EPSILON aus FIRST-Menge löschen
						la->del( epsHashIndex );
					}

					//Index der ersten Alternative in der PROD2_STR
					for( k = p1->prod2_index; k < ( p1->prod2_index + p1->altAnz ); k++ )
					{
						//Ist dieses Item schon in der Hülle, also nur die Lookaheads ergänzen?
						if( ( cInd = findItem( h, k, 0 ) ) < 0 )
							//nein, noch nicht da, als LR(1)-Item hinzufügen
							insertItem( h, k, 0, SSLR_ITEM, la );

						else
						{
							//ja, Item schon da

							//Zeiger auf Item
							lr2 = &h->lr_str[cInd];

							//Anzahl der Lookaheads merken
							anzElem = lr2->la->getAnzElem();

							//Lookaheads ergänzen
							insertItem( h, k, 0, SSLR_ITEM, la );

							//Wurden Terminale hinzugefügt?
							if( anzElem != lr2->la->getAnzElem() )
								//ja
								changed++;


							/*

								statement_list
									:	statement
									|	statement_list statement
									;

								Wegen solchen Produktionen muss man mehrmals über die Items hinweggehen,
								da im zweiten Schritt .statement_list statement FIRST(statement)
								als Lookaheads hinzukommt, die im ersten Schritt .statement nicht
								erfasst wurden!
							*/
						}
					}

					//Speicher wieder freigeben
					delete( la );
				}
			}
		}

		//Solange Änderungen vorgenommen wurden

	}while( changed );
}


SSLRParser::HULLE_STR *SSLRParser::createHulle( void )
{
	//Eine HULLE_STR-Struktur erzeugen
	HULLE_STR	*h;

	//Speicher anfordern
	h = new HULLE_STR;

	//Initailisieren
	h->anzCore = 0;
	h->anzElem = 0;
	h->lr_str = 0;

	//Zeiger auf Hülle zurückliefern
	return( h );
}


void SSLRParser::deleteHulle( HULLE_STR *h )
{
	//Eine HULLE_STR-Struktur löschen
	LR_STR	*lr;
	int		i;

	//alle Elemente einer Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0/1)-Item
		lr = &h->lr_str[i];

		//Lookahead-Terminale freigeben
		if( lr->la )
			delete( lr->la );

		//Lookahead-Terminale freigeben
		if( lr->lalr )
			delete( lr->lalr );
	}

	//LR_STR freigeben
	delete[] ( h->lr_str );

	//HULLE_STR löschen
	delete( h );
}


void SSLRParser::insertItem( HULLE_STR *h, long prod2_index, int dot, int type )
{
	//LR(0)-Element in HULLE h eintragen
	LR_STR	*tmp;

	//Item schon enthalten?
	if( findItem( h, prod2_index, dot ) < 0 )
	{
		//nein, Speicher für das LR(0)-Element
		tmp = new( LR_STR[h->anzElem + 1] );

		//kopieren
		memmove( tmp, h->lr_str, sizeof( LR_STR ) * h->anzElem );

		//alten Speicher freigeben
		if( h->lr_str )
			delete[] ( h->lr_str );

		//Zeiger
		h->lr_str = tmp;

		//eintragen
		h->lr_str[h->anzElem].dot = dot;
		h->lr_str[h->anzElem].prod2_index = prod2_index;

		//keine Lookaheads
		h->lr_str[h->anzElem].la = new Terminal( epsHashIndex );

		//Lookaheads eintragen
		h->lr_str[h->anzElem++].lalr = new Terminal( epsHashIndex );

		//ein weiterer Kern hinzugefügt?
		if( type == SSLR_CORE )
			//ja
			h->anzCore++;

		//Warnung?
		if( ( type == SSLR_CORE ) && ( h->anzElem > h->anzCore ) )
			cerr << "sslr: SSLRParser::insertItem: Es wurde ein Kern eingetragen, obwohl schon alle Items berechnet sein sollten!" << endl;
	}
}


void SSLRParser::insertItem( HULLE_STR *h, long prod2_index, int dot, int type, Terminal *la )
{
	//LR(1)-Element in HULLE h eintragen
	LR_STR	*tmp;
	long	hInd;

	//Item schon enthalten?
	if( ( hInd = findItem( h, prod2_index, dot ) ) < 0 )
	{
		//nein, Speicher für das LR(1)-Element
		tmp = new( LR_STR[h->anzElem + 1] );

		//kopieren
		memmove( tmp, h->lr_str, sizeof( LR_STR ) * h->anzElem );

		//alten Speicher freigeben
		if( h->lr_str )
			delete[] ( h->lr_str );

		//Zeiger
		h->lr_str = tmp;

		//eintragen
		h->lr_str[h->anzElem].dot = dot;
		h->lr_str[h->anzElem].prod2_index = prod2_index;

		//Lookaheads eintragen
		h->lr_str[h->anzElem].la = new Terminal( epsHashIndex );
		h->lr_str[h->anzElem].la->add( la );

		//keine Lookahead-Terminale
		h->lr_str[h->anzElem++].lalr = 0L;

		//ein weiterer Kern hinzugefügt?
		if( type == SSLR_CORE )
			//ja
			h->anzCore++;

		//Warnung?
		if( ( type == SSLR_CORE ) && ( h->anzElem > h->anzCore ) )
			cerr << "sslr: SSLRParser::insertItem: Es wurde ein Kern eingetragen, obwohl schon alle Items berechnet sein sollten!" << endl;
	}

	else
	{
		//Item schon in der Hülle enthalten, also nur die Lookaheads la hinzufügen
		tmp = &h->lr_str[hInd];

		//Lookaheads hinzufügen
		tmp->la->add( la );
	}
}


int SSLRParser::cmpLR0Hulle( HULLE_STR *h )
{
	//Prüft, ob die Hülle h schon in hulle_str enthalten ist
	HULLE_STR	*tmp;
	LR_STR		*lr;
	int			i, j, elemCnt = 0;
	int			anzCore = h->anzCore, cInd;

	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zähler
		elemCnt = 0;

		//Zeiger auf Hülle
		tmp = hulle_str[i];

		//Anzahl der Items gleich?
		if( ( h->anzElem == tmp->anzElem ) && ( h->anzCore == tmp->anzCore ) )
		{
			//alle LR(0)-Kerne von tmp
			for( j = 0; j < tmp->anzCore; j++ )
			{
				//Zeiger auf LR(0)-Item
				lr = &tmp->lr_str[j];

				//Item in h enthalten?
				if( ( cInd = findItem( h, lr->prod2_index, lr->dot ) ) < 0 )
					//nein
					break;

				//Ist es ein Kern-Item von h?
				else if( cInd <= ( anzCore - 1 ) )
					//ja
					elemCnt++;
			}

			//gefunden?
			if( elemCnt == anzCore )
				//ja
				break;
		}
	}

	//h noch nicht in hulle_str enthalten
	return( anzCore == elemCnt ? i : -1 );
}


int SSLRParser::cmpLR1Hulle( HULLE_STR *h )
{
	//Prüft, ob die Hülle h schon in hulle_str enthalten ist
	HULLE_STR	*tmp;
	LR_STR		*lr;
	int			i, j, elemCnt = 0;
	int			anzCore = h->anzCore, cInd;

	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zähler
		elemCnt = 0;

		//Zeiger auf Hülle
		tmp = hulle_str[i];

		//Anzahl der Items gleich?
		if( ( h->anzElem == tmp->anzElem ) && ( h->anzCore == tmp->anzCore ) )
		{
			//alle LR(1)-Kerne
			for( j = 0; j < tmp->anzCore; j++ )
			{
				//Zeiger auf LR(0)-Item
				lr = &tmp->lr_str[j];

				//Item in h enthalten?
				if( ( cInd = findItem( h, lr->prod2_index, lr->dot, lr->la ) ) < 0 )
					//nein
					break;

				//Ist es ein Kern-Item von h?
				else if( cInd <= ( anzCore - 1 ) )
					//ja
					elemCnt++;
			}

			//gefunden?
			if( elemCnt == anzCore )
				//ja
				break;
		}
	}

	//h noch nicht in hulle_str enthalten
	return( anzCore == elemCnt ? i : -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index )
{
	//prüft, ob in der Hülle h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &h->lr_str[i];

		//gleich?
		if( prod2_index == lr->prod2_index )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index, int dot )
{
	//prüft, ob in h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Item
		lr = &h->lr_str[i];

		//gleich?
		if( ( prod2_index == lr->prod2_index ) && ( dot == lr->dot ) )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


int SSLRParser::findItem( HULLE_STR *h, long prod2_index, int dot, Terminal *la )
{
	//prüft, ob in h das LR-Item schon enthalten ist
	LR_STR	*lr;
	int		i;

	//alle bisherigen Elemente
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Item
		lr = &h->lr_str[i];

		//gleich?
		if( ( prod2_index == lr->prod2_index ) && ( dot == lr->dot ) && ( lr->la->cmp( la ) ) )
			//ja
			return( i );
	}

	//nicht enthalten
	return( -1 );
}


void SSLRParser::outputHulle ( HULLE_STR *h )
{
	//Eine Hülle ausgeben
	Terminal	*la;
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_STR		*lr;
	char		*name = "";
	long		*tArr, *nArr, elem, LRTabIndex;
	int			i, r, v, anz, typ;
	bool		draw;

	//Namen der Produktion holen
	name = hash_tab->getName( h->elem );

	//erster name ist leer
	if( name )
		//ausgeben
		cout << "\n\nHülle " << h->hulleIndex << " = Sprung( " << h->from << ", " << name << " )" << endl;

	else
		//ohne "Vererbung"
		cout << "\n\nHülle " << h->hulleIndex << endl;

	//alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Kern?
		if( i < h->anzCore )
			//ja
			cout << "Kern:\t";

		else
			//Kein Kern-Element
			cout << "     \t";

		//Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//ausgeben
		cout << " " << name << " -> ";

		//rechte Seite ausgeben
		for( r = 0; r < p2->riAnz; r++ )
		{
			//Position des Punktes?
			if( lr->dot == r )
				//ja
				cout << ".";

			//Namen holen
			name = hash_tab->getName( p2->right[r] );

			//Terminal?
			if( hash_tab->getType( p2->right[r] ) == SSLR_TERM )
				//ja
				cout << " '" << name << "' ";

			else
				//Nichtterminal
				cout << " " << name << " ";
		}

		//Position des Punktes?
		if( lr->dot == r )
			//ja
			cout << ".";

		//Lookaheads ausgeben?
		if( lr->la )
		{
			//ja, Lookaheads ausgeben
			la = lr->la;

			//Anzahl der Lookaheads
			anz = lr->la->getAnzElem();

			//alle Lookaheads ausgeben
			for( v = 0; v < anz; v++ )
				//Terminal ausgeben
				cout << "," << hash_tab->getName( (*la)[v] );
		}

		//nächste Zeile
		cout << endl;
	}

	//alle Sprung-Übergänge nur einmal zeigen
	tArr = new( long[termArrCount + 1] );
	nArr = new( long[ntermArrCount] );

	//initialisieren
	memset( tArr, 0, sizeof( long ) * ( termArrCount + 1 ) );
	memset( nArr, 0, sizeof( long ) * ( ntermArrCount ) );

	//alle LR(0)-Elemente der Hülle
	for( i = 0; i < h->anzElem; i++ )
	{
		//Zeiger auf LR(0)-Element
		lr = &h->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Position des Punktes?
		if( lr->dot < p2->riAnz )
		{
			//Sprung-Hülle ausgeben
			elem = p2->right[lr->dot];

			//Index des Element in der LR-Tabelle
			LRTabIndex = hash_tab->getLRTabIndex( elem );

			//Namen holen
			name = hash_tab->getName( elem );

			//Typ holen
			typ = hash_tab->getType( elem );

			//Terminal?
			if( typ == SSLR_TERM )
			{
				//hinter dem Punkt folgt ein Terminal
				if( tArr[LRTabIndex] )
					//wurde schon ausgegeben
					draw = false;

				else
				{
					//ausgeben
					draw = true;

					//markieren, damit es nicht mehr ausgegeben wird
					tArr[LRTabIndex]++;
				}
			}

			else
			{
				//hinter dem Punkt folgt ein Nichtterminal
				if( nArr[LRTabIndex] )
					//wurde schon ausgegeben
					draw = false;

				else
				{
					//ausgeben
					draw = true;

					//markieren, damit es nicht mehr ausgegeben wird
					nArr[LRTabIndex]++;
				}
			}

			//Epsilon?
			if( ( draw == true ) && ( p2->right[lr->dot] != epsHashIndex ) )
				//Jump ausgeben
				cout << "Sprung(" << name << ") = " << lr->jumpTo << endl;
		}
	}

	//Speicher freigeben
	delete[] ( tArr );
	delete[] ( nArr );

	//nächste Zeile
	cout << endl << endl;
}


void SSLRParser::insertHulle( HULLE_STR *h )
{
	//Eine Hülle in die Sammlung von Elementen eintragen.
	HULLE_STR	**tmp;

	//Hülle schon eingetragen?
//	if( cmpLR0Hulle( h ) == -1 )
	{
		//Speicher anfordern
		tmp = new( HULLE_STR *[hulle_anz + 1] );

		//kopieren
		memmove( tmp, hulle_str, sizeof( HULLE_STR * ) * hulle_anz );

		//alten Speicher freigeben
		if( hulle_str )
			delete[] ( hulle_str );

		//Zeiger
		hulle_str = tmp;

		//eintragen
		hulle_str[hulle_anz] = h;
		h->hulleIndex = hulle_anz++;

		//Anzahl der Kerne
		coreAnz += h->anzCore;
	}
}


void SSLRParser::genLALR( void )
{
	//Aus der Sammlung der LR(0)-Elemente die Lookaheads anfügen.
	HULLE_STR	*h, *checkHulle, *hTmp, *hTmp2;
	PROD2_STR	*p2;
	Terminal	*checkTerm, *la;
	LR_STR		*lr, *lr2, *lr3;
	long		elem;
	char		*name;
	int			i, j, k, v, hInd, cInd, laAnz, changed;
	int			pass = 0;

	//Check-Terminal # (s. Drache S. 295)
	checkTerm = new Terminal( epsHashIndex );
	checkTerm->ins( lalrHashIndex );

	/******************************************/
	/* spontan generierte Lookaheads erzeugen */
	/******************************************/


	//alle Hüllen, I
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//für jeden Kern, B -> gamma .delta in K
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//neue Hülle anfordern, erzeuge J' := Hülle({[B -> gamma .delta, #]});
			checkHulle = createHulle();

			//Diesen Kern mit Check-Terminal # in checkHulle eintragen
			insertItem( checkHulle, lr->prod2_index, lr->dot, SSLR_CORE, checkTerm );

			//Hülle bilden
			genLR1Items( checkHulle );

			//Hülle ausgeben
//			outputHulle( checkHulle );

			//alle LR(1)-Elemente dieser Hülle
			for( k = 0; k < checkHulle->anzElem; k++ )
			{
				//Zeiger auf das LR(1)-Item, [A -> alpha .X beta, a]
				lr2 = &checkHulle->lr_str[k];

				//Zeiger auf die Terminale
				la = lr2->la;

				//alle Terminale
				for( v = 0; v < la->getAnzElem(); v++ )
				{
					//lalrHashIndex?
					if( (*la)[v] == lalrHashIndex )
						//ja, Lookaheads breiten sich aus; werden später behandelt
						continue;

					//Zeiger auf die Alternative
					p2 = &prod2_str[lr2->prod2_index];

					//Position des Punktes < maximale Position?
					if( lr2->dot < p2->riAnz )
					{
						//.index holen
						elem = p2->right[lr2->dot];

						//darf nicht Epsilon sein
						if( elem != epsHashIndex )
						{
							//Namen holen
							name = hash_tab->getName( elem );

							//Das LR(0)-Item k in h suchen
							cInd = findItem( h, lr2->prod2_index, lr2->dot );

							//Kern nicht gefunden?
							if( cInd < 0 )
							{
								//Kern nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf Item
							lr3 = &h->lr_str[cInd];

							//Index der Sprung-Hülle
							hInd = lr3->jumpTo;

							//Hülle nicht gefunden?
							if( hInd < 0 )
							{
								//Hülle nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf Hülle
							hTmp2 = hulle_str[hInd];

							//Kern k in hTmp2 finden
							cInd = findItem( hTmp2, lr2->prod2_index, lr2->dot + 1 );

							//Kern nicht gefunden?
							if( cInd < 0 )
							{
								//Kern nicht gefunden
								cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

								//Ende
								exit( 1 );
							}

							//Zeiger auf LR(1)-Item, A -> alpha X .beta in Sprung(I,X)
							lr3 = &hTmp2->lr_str[cInd];

							//spontan generierte Lookaheads aufnehmen
							lr3->lalr->add( la );

							//das checkTerminal löschen
							lr3->lalr->del( lalrHashIndex );

							//Speicher freigeben
//							delete( hTmp );
						}
					}
				}
			}

			//Speicher wieder freigeben
			deleteHulle( checkHulle );
		}
	}

/*
	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Meldung
			cout << "\nKern " << j << ": spontan generierte Lookaheads für " << i << ":" << endl;

			//spontan generierte Lookaheads ausgeben
			outputTerminal( lr->lalr );

			//Absatz
			cout << endl;
		}
	}
*/

	/********************************************/
	/* spontan generierte Lookaheads verbreiten */
	/********************************************/

	//Im ersten Kern ist ACCEPT ein spontan generiertes Lookahead
	hulle_str[0]->lr_str[0].lalr->ins( acceptHashIndex );


	//Ab hier sollten alle spontan generierten Lookaheads verfügbar sein,
	//nun auf die übrigen Kerne verbreiten.

	do
	{
		//keine Änderungen
		changed = 0;

		//Anzahl der Pässe
		pass++;

		//alle Hüllen, I
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hülle
			h = hulle_str[i];

			//alle Kerne dieser Hülle, B -> gamma .delta in K
			for( j = 0; j < h->anzCore; j++ )
			{
				//Zeiger auf das LR(0)-Item des Kerns
				lr = &h->lr_str[j];

				//Position des Punktes < maximale Position?
				if( lr->dot < prod2_str[lr->prod2_index].riAnz )
				{
					//Hülle erzeugen, erzeuge J' := Hülle({[B -> gamma .delta, #]});
					hTmp = createHulle();

					//Hülle erzeugen, wo die Terminale hinvererbt werden
					insertItem( hTmp, lr->prod2_index, lr->dot, SSLR_CORE, checkTerm );

					//alle Items erzeugen
					genLR1Items( hTmp );

					//Hülle ausgeben
//					outputHulle( hTmp );

					/*
						Nun alle Elemente dieser Hülle untersuchen, die # als Lookahead haben.
						Von diesen Elementen die Sprung-Hüllen bilden und an die Kerne
						die Looakheads verbreiten.
					*/
					for( k = 0; k < hTmp->anzElem; k++ )
					{
						//Zeiger auf Item, [A -> alpha .X beta, #]
						lr2 = &hTmp->lr_str[k];

						//Hat dieses Element # als Lookahead?
						if( lr2->la->find( lalrHashIndex ) )
						{
							//ja, die Sprung-Hülle dieses Elements bilden
							p2 = &prod2_str[lr2->prod2_index];

							//Punkt am Ende?
							if( lr2->dot < p2->riAnz )
							{
								//.index holen
								elem = p2->right[lr2->dot];

								//darf nicht Epsilon sein
								if( elem != epsHashIndex )
								{
									//Namen holen
									name = hash_tab->getName( elem );

									//Das LR(0)-Item k in h suchen
									cInd = findItem( h, lr2->prod2_index, lr2->dot );

									//Kern nicht gefunden?
									if( cInd < 0 )
									{
										//Kern nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf Item
									lr3 = &h->lr_str[cInd];

									//Index der Spring-Hülle
									hInd = lr3->jumpTo;

									//Hülle nicht gefunden?
									if( hInd < 0 )
									{
										//Hülle nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf die Hülle
									hTmp2 = hulle_str[hInd];

									//Kern k in hTmp2 finden
									cInd = findItem( hTmp2, lr2->prod2_index, lr2->dot + 1 );

									//Kern nicht gefunden?
									if( cInd < 0 )
									{
										//Kern nicht gefunden
										cerr << "sslr: SSLRParser::genLALR: Fatal internal error!" << endl;

										//Ende
										exit( 1 );
									}

									//Zeiger auf Item, A -> alpha X .beta in Sprung(I,X)
									lr3 = &hTmp2->lr_str[cInd];

									//Anzahl der Terminale
									laAnz = lr3->lalr->getAnzElem();

									//Lookaheads hinzufügen
									lr3->lalr->add( lr->lalr );

									//# löschen
									lr3->lalr->del( lalrHashIndex );

									//Wurde etwas hinzugefügt?
									if( laAnz != lr3->lalr->getAnzElem() )
										//ja
										changed++;
								}
							}
						}
					}

					//Speicher freigeben
					deleteHulle( hTmp );
				}
			}
		}

/*
		//alle Hüllen
		for( i = 0; i < hulle_anz; i++ )
		{
			//Zeiger auf die Hülle
			h = hulle_str[i];

			//alle Kerne
			for( j = 0; j < h->anzCore; j++ )
			{
				//Zeiger auf das LR(0)-Item
				lr = &h->lr_str[j];

				//Meldung
				cout << "\nspontan generierte Lookaheads für " << i << ":" << endl;

				//spontan generierte Lookaheads ausgeben
				outputTerminal( lr->lalr );

				//Absatz
				cout << endl;
			}
		}
*/


	}while( changed );

	//Meldung?
	if( argv_str->verbose )
		//ja
		cout << "sslr: " << pass << " pass(es) to generate LALR-Items!" << endl;

	//Speicher für Check-Terminal # freigeben (s. Drache S. 295)
	delete( checkTerm );


	//überall die Hüllen neu generieren
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//Hülle ausgeben
//		outputHulle( h );

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//alten Speicher freigeben
			delete( lr->la );

			//Lookaheads eintragen
			lr->la = lr->lalr;

			//zurücksetzen
			lr->lalr = 0L;
		}

		//Hüllen erzeugen
		genLR1Items( h );
	}

/*
	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//alle Kerne
		for( j = 0; j < h->anzCore; j++ )
		{
			//Zeiger auf das LR(0)-Item
			lr = &h->lr_str[j];

			//Meldung
			cout << "\nspontan generierte Lookaheads für " << i << ":" << endl;

			//spontan generierte Lookaheads ausgeben
			outputTerminal( lr->lalr );

			//Absatz
			cout << endl;
		}
	}
*/
}


void SSLRParser::genLR0Jump( HULLE_STR *I0, HULLE_STR *I1, long index )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name, *tmpName;
	int			i;

	//Name von index
	name = hash_tab->getName( index );

	//alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt em Ende?
		if( lr->dot < p2->riAnz )
		{
			//Name von Element nach Punkt
			tmpName = hash_tab->getName( p2->right[lr->dot] );

			//ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == index )
				//ja, als Kern in I1 eintragen
				insertItem( I1, lr->prod2_index, lr->dot + 1, SSLR_CORE );
		}
	}

	//alle LR(0)-Elemente dieser Hülle erzeugen
	genLR0Items( I1 );
}


void SSLRParser::genLR1Jump( HULLE_STR *I0, HULLE_STR *I1, long index )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	int			i;

	//Name von index
	name = hash_tab->getName( index );

	//alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt em Ende?
		if( lr->dot < p2->riAnz )
		{
			//ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == index )
				//ja, als Kern in I1 eintragen
				insertItem( I1, lr->prod2_index, lr->dot + 1, SSLR_CORE, lr->la );
		}
	}

	//alle LR(1)-Elemente dieser Hülle erzeugen
	genLR1Items( I1 );
}


void SSLRParser::outputTerminal( Terminal *la )
{
	//Terminale ausgeben
	int	i, anz;

	//Anzahl der Terminale
	anz = la->getAnzElem();

	//alle Terminale ausgeben
	for( i = 0; i < anz; i++ )
		//ausgaben
		cout << hash_tab->getName( (*la)[i] ) << ", ";
}


void SSLRParser::setJump( HULLE_STR *I0, long elem, long HIindex )
{
	/*
		Bsp:
			expr	->	.expr ADD expr
					|	.expr SUB expr
					|	.term
					;

		Hier werden also die ersten beiden Elemente bei index = expr bzw.
		das letzte bei index = term hinzugefügt.
	*/
	PROD2_STR	*p2;
	LR_STR		*lr;
	char		*name;
	int			i;

	//Name von index
	name = hash_tab->getName( elem );

	//alle Elemente von I0
	for( i = 0; i < I0->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &I0->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//Punkt am Ende?
		if( lr->dot < p2->riAnz )
		{
			//ja, index nach Punkt, d.h. .expr?
			if( p2->right[lr->dot] == elem )
				//ja, den Index der Hülle eintragen, die durch Sprung( I0, elem ) erzeugt wird
				lr->jumpTo = HIindex;
		}
	}
}


bool SSLRParser::cmp2LR0Hulle( HULLE_STR *a, HULLE_STR *b )
{
	//Hier werden die LR(0)-Kerne beider Hüllen verglichen
	LR_STR	*lr;
	int		i, cInd;

	//Kerne gleich?
	if( ( a->anzElem == b->anzElem ) && ( a->anzCore == b->anzCore ) )
	{
		//ja, gleich
		for( i = 0; i < a->anzCore; i++ )
		{
			//Zeiger auf Kern von a
			lr = &a->lr_str[i];

			//Ist dieses Item in b?
			if( ( cInd = findItem( b, lr->prod2_index, lr->dot ) ) < 0 )
				//nein
				return( false );

			//Ist es ein Kern?
			else if( cInd > ( a->anzCore - 1 ) )
				//Ist kein Kern
				return( false );
		}

		//gleich
		return( true );
	}

	//nicht gleich
	return( false );
}


void SSLRParser::LR2LALR( void )
{
	//Wandelt die LR(1)-Hüllen in LR(0)-Hüllen
	HULLE_STR	*a, *b, **tmp;
	LR_STR		*lr;
	int			i, j, k;

	//Meldung?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Making LR to LALR..." << endl;

	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf Hülle
		a = hulle_str[i];

		//alle anderen Hüllen mit dieser vergleichen
		for( j = i + 1; j < hulle_anz; j++ )
		{
			//Zeiger auf Hülle
			b = hulle_str[j];

			//beiden Hüllen vergleichen
			if( cmp2LR0Hulle( a, b ) == true )
			{
				//Meldung?
				if( argv_str->verbose )
					//ja
					cout << "Closure " << i << " and " << j << " equal..." << endl;

				//Die Terminale der Kerne von b in a eintragen, dann b löschen
				for( k = 0; k < b->anzCore; k++ )
				{
					//Zeiger auf Kern
					lr = &b->lr_str[k];

					//Kern in a eintragen
					insertItem( a, lr->prod2_index, lr->dot, SSLR_CORE, lr->la );
				}

				//Hülle nochmal bilden, da Lookaheads möglicherweise anders
				genLR1Items( a );

				//den Speicher der Hülle freigeben
				deleteHulle( b );

				//Speicher für alle Hüllen
				tmp = new( HULLE_STR *[hulle_anz - 1] );

				//Hüllen kopieren
				memmove( tmp, hulle_str, sizeof( HULLE_STR * ) * j );
				memmove( &tmp[j], &hulle_str[j + 1], sizeof( HULLE_STR * ) * ( hulle_anz - j - 1 ) );

				//Hülle b löschen

				//eine Hülle weniger
				hulle_anz--;

				//alten Speicher freigeben
				delete[] ( hulle_str );

				//Zeiger
				hulle_str = tmp;

				//Index erniedrigen
				j--;
			}
		}

		//Hüllennummerierung
		a->hulleIndex = i;
	}
}


void SSLRParser::LRTab( void )
{
	//LR-Tabelle erzeugen
	PROD2_STR	*p2;
	HULLE_STR	*h;
	PROD_STR	*p1;
	Terminal	*la;
	LR_STR		*lr;
	char		*name;
	long		elem;
	int			i, j, type, lrTabIndex;

	//Meldugn ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Generate LR-Table..." << endl;

	//Speicher für die LR-Tabelle
	lrTab = new( LR_TAB *[hulle_anz] );

	//Speicher für die Sprung-Tabelle
	jumpTab = new( int *[hulle_anz] );

	//Für jeden Zustand die Spalten anfordern
	for( i = 0; i < hulle_anz; i++ )
	{
		//Speicher für Spalte
		lrTab[i] = new( LR_TAB[termArrCount + 1] );

		//Speicher für Spalte
		jumpTab[i] = new( int[ntermArrCount] );

		//Initialisieren
		memset( lrTab[i], 0, sizeof( LR_TAB ) * termArrCount );
		memset( jumpTab[i], 0, sizeof( int ) * ntermArrCount );
	}


	//alle Hüllen
	for( i = 0; i < hulle_anz; i++ )
	{
		//Zeiger auf die Hülle
		h = hulle_str[i];

		//alle LR(0)/LR(1)-Elemente der Hülle
		for( j = 0; j < h->anzElem; j++ )
		{
			//Zeiger auf das LR(0)/LR(1)-Item
			lr = &h->lr_str[j];

			//Zeiger auf die Alternative
			p2 = &prod2_str[lr->prod2_index];

			//Zeiger auf die Alternative
			p1 = &prod_str[p2->prod_index];

			//ist es ein Element der Art .expr?
			if( lr->dot < p2->riAnz )
			{
				//Element nach Punkt, hier z.B. expr
				elem = p2->right[lr->dot];

				//Index des Elements in der LR-Tabelle
				lrTabIndex = hash_tab->getLRTabIndex( elem );

				//Typ holen
				type = hash_tab->getType( elem );

				//Name holen
				name = hash_tab->getName( elem );

				//Nichtterminal vor Punkt?
				if( type == SSLR_NTERM )
				{
					//ja, Eintrag in Sprung-Hülle
					jumpTab[i][lrTabIndex] = lr->jumpTo;

					//Meldung?
					if( argv_str->verbose == 2 )
						//ja
						cout << "sslr: LRTab: jump[" << i << "][" << name << "] = " << lr->jumpTo << "..." << endl;
				}

				else if( elem == epsHashIndex )
				{
					//Spezial-Fall, reduzieren

					//SLR-Parser?
					if( argv_str->type == SSLR_SLR )
						//Follow-Menge
						la = hash_tab->getFollow( p1->hash_index );

					else
						//bei LALR und LR sind es die Lookaheads
						la = lr->la;

					//reduzieren eintragen
					setReduce( i, lr->prod2_index, la );
				}

				else
					//Terminal schieben
					setShift( i, elem, lr->jumpTo );

			}

			else
			{
				//Reduce-Zustand

				//SLR-Parser?
				if( argv_str->type == SSLR_SLR )
					//Follow-Menge
					la = hash_tab->getFollow( p1->hash_index );

				else
					//bei LALR und LR sind es die Lookaheads
					la = lr->la;

				//Reduzieren eintragen
				setReduce( i, lr->prod2_index, la );
			}
		}
	}

	//ltTab[1][ACCEPT] = Akzeptiere
	lrTab[1][termArrCount].state = SSLR_ACCEPT;

	//Shift-Reduce-Fehler aufgetreten?
	if( srError )
		//Meldung
		cerr << "sslr: " << srError << " shift-reduce error(s) occured!" << endl;

	//Reduce-Reduce-Fehler aufgetreten?
	if( rrError )
		//Meldung
		cerr << "sslr: " << rrError << " reduce-reduce error(s) occured!" << endl;
}


void SSLRParser::setReduce( int hInd, long prod2_index, Terminal *la )
{
	//Einen Reduce-Eintrag erzeugen und dabei Reduce-Reduce- und Shift-Reduce-Fehler behandeln.
	PROD2_STR	*p2, *p3, *p4;
	PROD_STR	*p1;
	long		elem;
	char		*name;
	int			i, laAnz, lrTabIndex;
	int			tAssoc, pPriority, tPriority, state;

	//hier mit der Produktion prod2_index reduzieren
//	h = hulle_str[hInd];

	//Zeiger auf die Alternative
	p2 = &prod2_str[prod2_index];

	//Zeiger auf die Alternative
	p1 = &prod_str[p2->prod_index];

	//Anzahl der Lookaheads
	laAnz = la->getAnzElem();

	//für jedes Lookahead
	for( i = 0; i < laAnz; i++ )
	{
		//nächstes Lookahead holen
		elem = (*la)[i];

		//Namen
		name = hash_tab->getName( elem );

		//Spalten-Index in LR-Tabelle holen
		lrTabIndex = hash_tab->getLRTabIndex( elem );

		//ist dieser Eintrag in der Hash-Tabelle schon belegt?
		if( lrTab[hInd][lrTabIndex].state == SSLR_REDUCE )
		{
			//Reduce-Reduce-Konflikt

			//Zeiger auf die PROD2_STR
			p3 = &prod2_str[lrTab[hInd][lrTabIndex].value];
			p4 = &prod2_str[prod2_index];

			//ist ein "echter" Reduce-Reduce-Konflikt
			if( argv_str->verbose == 1 )
			{
				//Meldung ausgeben
				cout << "sslr: Reduce-Reduce conflict in closure " << hInd << " between" << endl;

				//eingetragene Produktion ausgeben
				outputAlt( cout, lrTab[hInd][lrTabIndex].value );

				cout << "and" << endl;

				//eingetragene Produktion ausgeben
				outputAlt( cout, prod2_index );

				//neue Zeile
				cout << endl;
			}

			//Fehler
			rrError++;
		}

		else if( lrTab[hInd][lrTabIndex].state == SSLR_SHIFT )
		{
			//Shift-Reduce-Fehler

			//Fehler ausgeben?
			if( argv_str->verbose == 1 )
			{
				//Meldung ausgeben
				cout << "sslr: Shift-Reduce conflict in closure " << hInd << " between reducing" << endl;

				//Alternative ausgeben, mit der reduziert werden soll
				outputAlt( cout, prod2_index ),

				//Schieben mit Terminal
				name = hash_tab->getName( lrTab[hInd][lrTabIndex].termHashIndex );
				cout << "and shifting " << name << "!" << endl << endl;
			}

			//Priorität des geschobenen Terminals
			tPriority = hash_tab->getPriority( lrTab[hInd][lrTabIndex].termHashIndex );

			//Priorität der Produktion holen
			pPriority = p2->priority;

			//Assoziation des Terminals holen
			tAssoc = hash_tab->getAssociation( lrTab[hInd][lrTabIndex].termHashIndex );

			//wurde die Priorität überhaupt angegeben?
			if( ( tPriority > 0 ) && ( pPriority > 0 ) )
			{
				//ja, Priorität der Produktion > Priorität des Terminals?
				if( pPriority > tPriority )
					//ja, reduzieren
					state = SSLR_REDUCE;

				else if( ( tPriority == pPriority ) && ( tAssoc == isLeftAssoc ) )
					//beide Prioritäten gleich, zu schiebendes Terminal ist links-assoziativ
					state = SSLR_REDUCE;

				//nicht-assoziatives Terminal?
				else if( ( tPriority == pPriority ) && ( tAssoc == isNonAssoc ) )
				{
					//ja, Fehlereintrag
					lrTab[hInd][lrTabIndex].state = 0;
					lrTab[hInd][lrTabIndex].value = 0;

					//ausgeben
					state = SSLR_ERROR;
				}

				else
					//nichts von alledem
					state = SSLR_SHIFT;
			}

			else
				//schieben
				state = SSLR_SHIFT;

			//schieben oder reduzieren?
			if( state == SSLR_REDUCE )
			{
				//reduzieren
				lrTab[hInd][lrTabIndex].state = SSLR_REDUCE;
				lrTab[hInd][lrTabIndex].value = prod2_index;

				//Meldung?
				if( argv_str->verbose == 1 )
					//ausgeben
					cout << "reduce..." << endl;

				//merken, dass reduziert wird
				prod2_str[prod2_index].reduce--;

				//Meldung ausgeben?
				if( argv_str->verbose == 2 )
				{
					//ja
//					cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce " << hash_tab->getName( p1->hash_index ) << "..." << endl;
					cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce with ";

					//rechte Seite ausgeben
					outputAlt( cout, prod2_index );
				}
			}

			else if( ( state == SSLR_SHIFT ) && ( argv_str->verbose == 1 ) )
				//geschobenen beibehalten
				cout << "shift..." << endl << endl;

			else if( ( state == SSLR_ERROR ) && ( argv_str->verbose == 1 ) )
				//Terminal ist nicht-assoziativ
				cout << "Terminal is non-associative!" << endl;

			//Fehler
			srError++;
		}

		else
		{
			//kein Fehler aufgetreten
			lrTab[hInd][lrTabIndex].state = SSLR_REDUCE;
			lrTab[hInd][lrTabIndex].value = prod2_index;

			//merken, dass reduziert wird
			prod2_str[prod2_index].reduce++;

			//Meldung ausgeben?
			if( argv_str->verbose == 2 )
			{
				//ja
//				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce " << hash_tab->getName( p1->hash_index ) << "..." << endl;
				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = reduce with ";

				//rechte Seite ausgeben
				outputAlt( cout, prod2_index );
			}
		}
	}
}


void SSLRParser::setShift( int hInd, long termHashIndex, int jumpTo )
{
	//Einen Shift-Eintrag erzeugen und dabei Shift-Reduce-Fehler behandeln.
	PROD2_STR	*p2;
	PROD_STR	*p1;
	long		prod2_index;
	char		*name;
	int			lrTabIndex;
	int			tAssoc, pPriority, tPriority, state;

	//Spalten-Index in LR-Tabelle holen
	lrTabIndex = hash_tab->getLRTabIndex( termHashIndex );

	//Name holen
	name = hash_tab->getName( termHashIndex );

	//Ist dieser Eintrag in der Hash-Tabelle schon belegt?
	if( lrTab[hInd][lrTabIndex].state == SSLR_REDUCE )
	{
		//Shift-Reduce-Fehler

		//Index der Alternative in PROD2_STR
		prod2_index = lrTab[hInd][lrTabIndex].value;

		//Zeiger auf die Alternative
		p2 = &prod2_str[prod2_index];

		//Zeiger auf die Alternative
		p1 = &prod_str[p2->prod_index];

		//Fehler ausgeben?
		if( argv_str->verbose == 1 )
		{
			//Meldung ausgeben
			cout << "sslr: Shift-Reduce conflict in closure " << hInd << " between reducing" << endl;

			//Alternative ausgeben, mit der reduziert werden soll
			outputAlt( cout, prod2_index ),

			//Schieben mit Terminal
			cout << "and shifting " << name << "!" << endl;
		}

		//Priorität des geschobenen Terminals
		tPriority = hash_tab->getPriority( termHashIndex );

		//Priorität der Produktion holen
		pPriority = p2->priority;

		//Assoziation des Terminals holen
		tAssoc = hash_tab->getAssociation( termHashIndex );

		//wurde die Priorität überhaupt angegeben?
		if( ( tPriority > 0 ) && ( pPriority > 0 ) )
		{
			//ja, Priorität der Produktion > Priorität des Terminals?
			if( pPriority > tPriority )
				//ja, reduzieren
				state = SSLR_REDUCE;

			else if( ( tPriority == pPriority ) && ( tAssoc == isLeftAssoc ) )
				//beide Prioritäten gleich, Terminal ist links-assoziativ
				state = SSLR_REDUCE;

			//nicht-assoziatives Terminal?
			else if( ( tPriority == pPriority ) && ( tAssoc == isNonAssoc ) )
			{
				//ja, Fehlereintrag
				lrTab[hInd][lrTabIndex].state = 0;
				lrTab[hInd][lrTabIndex].value = 0;

				//ausgeben
				state = SSLR_ERROR;
			}

			else
				//nichts von alledem
				state = SSLR_SHIFT;
		}

		else
			//Schieben
			state = SSLR_SHIFT;

		//schieben oder reduzieren?
		if( state == SSLR_SHIFT )
		{
			//schieben
			lrTab[hInd][lrTabIndex].state = SSLR_SHIFT;
			lrTab[hInd][lrTabIndex].value = jumpTo;
			lrTab[hInd][lrTabIndex].termHashIndex = termHashIndex;

			//merken, dass nicht reduziert, sondern geschoben wird
			prod2_str[prod2_index].reduce--;

			//Meldung?
			if( argv_str->verbose == 1 )
				//ausgeben
				cout << "shift..." << endl << endl;

			//Meldung ausgeben?
			if( argv_str->verbose == 2 )
				//ja
				cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = shift " << jumpTo << "..." << endl;
		}

		else if( ( state == SSLR_REDUCE ) && ( argv_str->verbose == 1 ) )
			//Reduktion mit Alternative beibehalten
			cout << "reduce..." << endl << endl;

		else if( ( state == SSLR_ERROR ) && ( argv_str->verbose == 1 ) )
			//Terminal ist nicht-assoziativ
			cout << "Terminal is non-associative!" << endl;

		//Fehler
		srError++;
	}

	else
	{
		//kein Fehler aufgetreten
		lrTab[hInd][lrTabIndex].state = SSLR_SHIFT;
		lrTab[hInd][lrTabIndex].value = jumpTo;
		lrTab[hInd][lrTabIndex].termHashIndex = termHashIndex;

		//Meldung ausgeben?
		if( argv_str->verbose == 2 )
			//ja
			cout << "sslr: LRTab: lrTab[" << hInd << "][" << name << "] = shift " << jumpTo << "..." << endl;
	}
}


void SSLRParser::processErrorStr( void )
{
	/*
		Innerhalb der Grammatik kann man mittels %error Fehleranweisungen
		in den erzeugten Parser einbauen.
		Ein LR-Parser kann aber nötige Reduktionen verweigern, wenn das
		darauffolgend zu schiebende Terminal nich als Lookahead vorliegt.
		Also werden hier die Zustände gefunden, die vor dem Item mit der
		Fehleranweisung stehen und die reduzieren.
	*/

	//falls noch gar keine Hüllen erzeugt wurden
	assert( hulle_anz );

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		HulleErrorIndexStr	*hInd;
		LRReduceErrorItem	*lrItemArr;
		unsigned long		i, j, k, lrItemArrCnt = 0, anzLRItem = 0;
		unsigned long		*lrStack;
		ERRTERM_STR			*errTermStr;
		PROD2_STR			*p2;
		HULLE_STR			*hStr = 0L;
		ERROR_STR			*errorStr;
		PROD_STR			*p1;
		int					*lrMarked, lrStackSp, *errTermArr;
		int					termIndex;


		//Anzahl aller möglichen LR-Items bestimmen
		for( i = 0; i < hulle_anz; i++ )
			//Anzahl der LR-Items dieser Hülle addieren
			anzLRItem += hulle_str[i]->anzElem;

		//einen Stack einrichten
		lrStack = new( unsigned long[prod2_anz] );

		//zum Markieren von Nichtterminalen
		lrMarked = new( int[prod2_anz] );

		/*
			Für jede Fehleranweisung der Art
			prod1 -> prod2 .prod3 ...
			werden ja die reduzierenden LR-Items gesucht, bei denen
			LA >= FIRST(prod3) ist.

 			Wenn
			prod1 -> prod2 prod3.
			dann gilt LA >= FOLLOW(prod1).

 			Ist hingegen
			prod1 -> .prod2 prod3, dann suche zuerst die LR-Items, bei denen
			gilt
			prodX -> prodY .prod1
		*/
		lrItemArr = new( LRReduceErrorItem[anzLRItem] );


		/*
			Jede Fehleranweisung der Art
			prod1 -> prod2 .prod3
			steht in einer ERROR_STR.
		*/
		for( j = 0; j < error_anz; j++ )
		{
			//Zeiger auf ERROR_STR holen
			errorStr = &error_str[j];

			/*
				Für jede ERROR_STR die Zustände eintragen, für die die
				Fehlermeldung auch ausgegeben werden soll. Dies entspricht
				den case-Anweisungen in der SSLR_error-Routine des erzeugten
				Parser-Files sslrparser.cpp.
			*/
			hInd = &errorStr->hInd;
			hInd->arr = new( unsigned long[hulle_anz] );
			hInd->anzArr = 0;


			//Zeiger auf die Produktion des Fehler-LR-Items
			p1 = &prod_str[errorStr->prod_index];

			//Zeiger auf die Alternative des Fehler-LR-Items
			p2 = &prod2_str[errorStr->prod2_index];

//Fehler-LR-Item ausgeben
//outputItem( errorStr->prod2_index, errorStr->dot );


			/*
				Sei das Fehler-LR-Item von der Form
				prod1 -> ... prod2 .prod3
				Wenn nun prod2 ein Terminal ist, dann überspringen.
			*/
			if( !( errorStr->dot && ( hash_tab->getType( p2->right[errorStr->dot - 1] ) == SSLR_TERM ) ) )
			{
				Terminal 		*t;
				unsigned long	prod2_index;
				/*
					PROBLEM:

					union
						:	startUnion 'BOPEN' unionBody 'BCLOSE'
							|	'EPSILON'
							;

					startUnion
						:	'UNION'
							%error
							{
								1:OVERREAD(BCLOSE):		"Missing { in %union!"
							}
							;

					unionBody
						:	unionBody unionBody2
						|	unionBody2
						;

					unionBody2
						:	'IDENT' 'IDENT' 'SEMIKOLON'
						|	'IDENT' 'AST' 'IDENT' 'SEMIKOLON'
						;

					Wenn der Parser im Zustand
					startUnion : 'UNION'., BOPEN
					ist, dann reduziert er nur, wenn LA=BOPEN ist, d.h. der
					Fehler für die Fehleranweisung muss schon in diesem
					Zustand ausgegeben werden.
				*/

				//eine neue Terminal-Struktur für die FIRST-Elemente
				t = new Terminal( epsHashIndex );

				/*
					Wenn das Fehler-Item der Art
					prod1 -> ... prod2 .prod3 ...
					ist, dann muss die LA-Menge der reduzierenden Items
					FIRST(prod3) enthalten.
				*/
				if( errorStr->dot == p2->riAnz )
					//FOLLOW-Menge der Produktion
					t->add( hash_tab->getFollow( p1->hash_index ) );

				else
				{
					//FIRST-Menge des Elements for dem Punkt
					int	i;

					//alle Elemente auf der rechten Seite, ab errorStr->dot
					for( i = errorStr->dot; i < p2->riAnz; i++ )
					{
						//FIRST-Menge hinzufügen
						t->add( hash_tab->getFirst( p2->right[i] ) );

						//ist EPSILON enthalten?
						if( t->isEpsilon() && ( ( i + 1 ) < p2->riAnz ) )
							//ja, löschen und weiter
							t->del( epsHashIndex );

						else
							//Schleife beenden
							break;
					}

					//ist EPSILON enthalten?
					if( t->isEpsilon() )
					{
						//ja, die FOLLOW-Menge der Produktion hinzunehmen
						t->add( hash_tab->getFollow( p1->hash_index ) );

						//EPSILON löschen
						t->del( epsHashIndex );
					}
				}


				/*
					Nun alle Hüllen nach Reduce-LR-Items durchsuchen,
					die für LA >= t ist.
				*/
				for( i = 0; i < hulle_anz; i++ )
				{
					//in der Hülle i nach Reduce-LR-Items suchen
					if( findReduceItem( i, prod2_index, t ) == true )
					{
						//Reduce-LR-Item eintragen
						lrItemArr[lrItemArrCnt].prod_index = prod2_str[prod2_index].prod_index;
						lrItemArr[lrItemArrCnt].prod2_index = prod2_index;
						lrItemArr[lrItemArrCnt++].hulleIndex = i;
					}
				}

				/*
					Nun stehen in lrItemArr die Hüllen-Indices, in denen
					LR-Items gefunden wurden, die reduzieren, wenn die
					Terminal-Menge t in deren Lookahead-Mange steht.
					Damit sollen die LR-Items gefunden werden, die vor
					dem Punkt in der Fehlerangabe stehen dürfen.
					Dies heisst aber noch nicht, dass alle LR-Items in
					lrItemArr auch erlaubte Zustände repräsentieren.
					Dies wird nun herausgefunden.
				*/

				//eine neue Hüllen-Struktur erzeugen
				hStr = createHulle();

				//ist der Punkt des Fehler-LR-Items an erster Stelle?
				if( !errorStr->dot && lrItemArrCnt )
				{
					unsigned long	hash_index;
					PROD2_STR		*p2;
					HULLE_STR		*h;
					PROD_STR		*p1;
					LR_STR			*lrStr;
					int				dot, i, j;

					/*
						Der Punkt des Fehler-LR-Items steht an erster Stelle,
						also es ist von der Art
						prod1 -> .prod2 prod3...
						Wir müssen also nun in ALLEN Hüllen nach LR-Items
						suche, die prod1 auf der rechten Seite haben, also
						prodX -> prodY prod1, denn für prod1 in prodX können
						wir ja prod1 einsetzen, also
						prodX -> prodY .prod2 prod3 ...
						Dann müssen wir somit
						prodX -> .prodY prod1
						in die Hülle eintragen um zu sehen, welche LR-Items
						vor prod1 stehen dürfen.

					*/

					//Stack-Pointer zurücksetzen
					lrStackSp = 0;

					//Array mit den Markierungen initialisieren
					memset( lrMarked, 0, sizeof( int ) * prod2_anz );

					//als erstes wird das Fehler-LR-Item auf den Stack gepushed
					lrStack[lrStackSp++] = errorStr->prod_index;

					//solange Einträge auf den Stack sind
					while( lrStackSp )
					{
						//Zeiger auf Stack-Struktur
						unsigned long prodIndex = lrStack[--lrStackSp];

						//bereits markiert?
						if( !lrMarked[prodIndex] )
						{
							//Nicht-Terminal markieren
							lrMarked[prodIndex]++;

							//Hash-Index des Nicht-Terminals
							hash_index = prod_str[prodIndex].hash_index;

//char *name = hash_tab->getName( hash_index );
//cout << "\nSuche nach Nicht-Terminal " << name << endl;

							//alle Hüllen absuchen
							for( i = 0; i < hulle_anz; i++ )
							{
								//Zeiger auf die Hülle
								h = hulle_str[i];

								//alle Items absuchen
								for( j = 0; j < h->anzElem; j++ )
								{
									//Zeiger auf das LR-Item
									lrStr = &h->lr_str[j];

									//das Nicht-Terminal suchen
									dot = findNTERMRightSide( h, j, hash_index );

									//dieses LR-Item interessiert nur, wenn dot != -1
									if( dot != -1 )
									{
										//Zeiger auf die Alternative des Fehler-LR-Items
										p2 = &prod2_str[lrStr->prod2_index];

										//Zeiger auf die Produktion des Fehler-LR-Items
										p1 = &prod_str[p2->prod_index];

//Fehler-LR-Item ausgeben
//outputItem( lrStr->prod2_index, dot );

										//steht der Punkt auch hier am Anfang?
										if( !dot )
											/*
												ja, Nicht-Terminal der Produktion
												auf den Stack pushen
											*/
											lrStack[lrStackSp++] = p2->prod_index;

										else
										{
											/*
												Der Punkt des Fehler-LR-Items steht an erster Stelle,
												also es ist von der Art
												prod1 -> .prod2 prod3...
												Wir müssen also nun in ALLEN Hüllen nach LR-Items
												suche, die prod1 auf der rechten Seite haben, also
												prodX -> prodY prod1, denn für prod1 in prodX können
												wir ja prod1 einsetzen, also
												prodX -> prodY .prod2 prod3 ...

												Hier haben wir ein LR-Item der Art
												prodX -> prodY .prod1 prod3 ...
												gefunden, also
												prodX -> .prodY prod1 prod3 ...
												in die Hülle eintragen.
											*/
											insertItem( hStr, lrStr->prod2_index, dot - 1, SSLR_CORE );
										}
									}
								}
							}
						}
					}
				}

				else if( lrItemArrCnt )
				{
					//der Punkt des Fehler-LR-Items ist nicht an erster Stelle

					/*
						Fehler-LR-Item mit Punkt um eine Position nach links
						verschoben in die Hülle eintragen.
					*/
					insertItem( hStr, errorStr->prod2_index, errorStr->dot - 1, SSLR_CORE );
				}

				//die Hülle generieren
				genLR0Items( hStr );

//Hülle ausgeben
//outputHulle( hStr );


				/*
					In der Hülle hStr stehen nun alle LR-Items, die in Frage kommen.
					Nur diese LR-Items von lrItemArr in hInd->arr eintragen, die
					in der Hülle enthalten sind.
				*/
				for( i = 0; i < lrItemArrCnt; i++ )
				{
					//dieses LR-Item in hStr suchen
					if( findItem( hStr, lrItemArr[i].prod2_index ) != -1 )
						//den Index in der Hülle von lrItemArr in hInd eintragen
						hInd->arr[hInd->anzArr++] = lrItemArr[i].hulleIndex;
				}

				//für nächste ERROR_STR zurücksetzen
				lrItemArrCnt = 0;

				//Terminale freigeben
				delete( t );
			}

			/*
				Nun in allen Hüllen nach dem Fehler-LR-Item suchen, denn
				für diese Zustände muss die Fehlermeldung ja auch ausgegeben
				werden.
			*/
			//Anzahl aller möglichen LR-Items bestimmen
			for( i = 0; i < hulle_anz; i++ )
			{
				//ist das Fehler-Item in der Hülle i enthalten?
				if( findItem( hulle_str[i], errorStr->prod2_index, errorStr->dot ) != -1 )
				{
					//ja, nun prüfen, ob es schon in errorStr->hInd enthalten ist
//cout << "SSLRParser::processErrorStr: Fehler-LR-Item ist in Hülle " << i << " enthalten!" << endl;

					//alle Einträge in errorStr->hInd prüfen
					for( k = 0; k < hInd->anzArr; k++ )
					{
						//Hüllen-Indices gleich?
						if( hInd->arr[k] == i )
							//ja, abbrechen
							break;
					}

					//war es schon enthalten?
					if( k == hInd->anzArr )
						//nein, eintragen
						hInd->arr[hInd->anzArr++] = i;
				}
			}

			//Meldung ausgeben?
			if( argv_str->verbose )
			{
				//ja, informieren
				cout << "sslr: SSLRParser::processErrorStr: Error action in line " << errorStr->line << " is active in ";

				//gibt es nur einen Zustand, in dem die Fehleranweisung aktiv ist?
				if( hInd->anzArr == 1 )
					//ja, ausgeben
					cout << "state " << hInd->arr[0] << "!" << endl;

				else
				{
					int	i;

					//abschliessen
					cout << "states ";

					//alle Zustände ausgeben
					for( i = 0; i < hInd->anzArr; i++ )
					{
						//Zustand ausgeben
						cout << hInd->arr[i];

						//folgt ein weiterer?
						if( ( i + 1 ) < hInd->anzArr )
							//ja
							cout << ",";
					}

					//abschliessen
					cout << "!" << endl;
				}
			}

			//Hülle freigeben?
			if( hStr )
			{
				//Hülle freigeben
				deleteHulle( hStr );

				//initialisieren
				hStr = 0L;
			}
		}

		//Speicher freigeben
		delete[] ( lrItemArr );
		delete[] ( lrMarked );
		delete[] ( lrStack );




		/*
			An dieser Stelle sind alle Fehleranweisungen komplett eingetragen.
			Die Terminale, die zu einer Fehleranweisung der Art
			1:ADD,SUB:	""
			eingetragen wurden, befinden sich in der ERRTERM_STR der Struktur
			ERROR_STR, denn zur Zeit des Scannens der Grammatik ist die
			Gesamtzahl der Terminale noch nicht bekannt, jetzt aber.
		*/
		for( i = 0; i < error_anz; i++ )
		{
			//Zeiger auf ERROR_STR holen
			errorStr = &error_str[i];

			/*
				Die Terminale, für die die Fehleraktion gelten soll,
				werden nun linear in ein Array eingetragen. Der Index
				ist der in termArr, die Länge beträgt termArrCount
				Einträge.
			*/
			errTermArr = new( int[termArrCount] );

			//vorab initialisieren
			memset( errTermArr, 0, sizeof( int ) * termArrCount );

			//alle Terminal-Anweisungen
			for( j = 0; j < errorStr->errTermStrAnz; j++ )
			{
				//Zeiger auf die ERRTERM_STR holen
				errTermStr = &errorStr->errTermStr[j];

				//die erste ERRTERM_STR?
				if( !j && errTermStr->neg )
				{
					/*
						errTermArr muss initialisiert werden.
						Dabei wird es mit 1 initialisiert, wenn die
						Terminal-Angaben negiert sind, sonst
						mit 0.
					*/
					for( int i = 0; i < termArrCount; i++ )
						//auf 1 setzen
						errTermArr[i] = 1;
				}

				//den Index des Terminals in termArr holen
				termIndex = getTermArrIndex( errTermStr->terminal );

				//gefunden?
				if( termIndex != -1 )
				{
					//Fehler, das Terminal wurde nicht gefunden
					char *name = hash_tab->getName( errTermStr->terminal );

					//negieren?
					if( errTermStr->neg )
						//ja, auf Null setzen
						errTermArr[termIndex] = 0;

					else
						//nicht negieren, auf 1 setzen
						errTermArr[termIndex] = 1;
				}

				else
				{
					//Fehler, das Terminal wurde nicht gefunden
					char *name = hash_tab->getName( errTermStr->terminal );

					//Fehlermeldung
					cerr << "sslr: SSLRParser::processErrorStr: ERROR: Terminal " << name << " not found in termArr!" << endl;
				}
			}

			//errTermArr in die ERROR_STR eintragen
			errorStr->errTermArr = errTermArr;
		}
	}
}


int SSLRParser::getTermArrIndex( unsigned long hash_index )
{
	//liefere den Index des Terminals in termArr zurück
	int	i;

	//prüfen, ob termArrCount schon angelegt ist
	assert( termArr );

	//alle Einträge in termArr
	for( i = 0; i < termArrCount; i++ )
	{
		//Hash-Indices gleich?
		if( termArr[i] == hash_index )
			//ja, Index zurückliefern
			return( i );
	}

	//Terminal nicht gefunden!
	return( -1 );
}


int SSLRParser::findNTERMRightSide( HULLE_STR *hStr, int item, unsigned long hash_index )
{
	/*
		Hier wird geprüft, ob auf der rechten Seite des LR-Item item
		der Hülle hStr das Nicht-Terminal hash_index auftaucht.
	*/
	PROD2_STR	*p2;
	LR_STR		*lrStr = &hStr->lr_str[item];
	int			i;

	//Zeiger auf die Alternative des LR-Items
	p2 = &prod2_str[lrStr->prod2_index];

	//alle Einträge auf der rechten Seite des LR-Items prüfen
	for( i = 0; i < p2->riAnz; i++ )
	{
		//ist es das gesuchte Nicht-Terminal?
		if( p2->right[i] == hash_index )
			//ja, Position des Punktes wiedergeben
			return( i );
	}

	/*
		nein, Nicht-Terminal hash_index nicht auf rechter Seite des
		LR-Items gefunden.
	*/
	return( -1 );
}


bool SSLRParser::findReduceItem( unsigned long hulleIndex, unsigned long &prod2_index, Terminal *t )
{
	/*
		Hier wird in der Hülle hulleIndex nach einem LR-Item gesucht,
		das reduziert, wobei seine LA-Symbole mind. t umfassen müssen.
	*/
	unsigned int	i;
	HULLE_STR		*hStr = hulle_str[hulleIndex];
	PROD2_STR		*p2;
	LR_STR			*lr;
	Terminal		*la;

	/*
		Hier müssen wir tatsächlich ALLE LR-Elemente der Hülle untersuchen,
		denn die der Art
		prod -> .'EPSILON'
		sind ja auch reduzierende LR-Items, sie sind aber nicht unbedingt
		im Kern der Hülle!
	*/
	for( i = 0; i < hStr->anzElem; i++ )
	{
		//Zeiger auf LR-Item
		lr = &hStr->lr_str[i];

		//Zeiger auf PROD2_STR
		p2 = &prod2_str[lr->prod2_index];

		//gleich?
		if( ( ( lr->dot == 0 ) && ( p2->right[0] == epsHashIndex ) ) || ( lr->dot == p2->riAnz ) )
		{
			//es ist ein Reduce-LR-Item, nun die Lookahead-Menge prüfen

			/*
				Bei einem SLR-Parser ist die Lookahead-Menge die FOLLOW-Menge
				der Produktion.
			*/
			if( argv_str->type == SSLR_SLR )
				//Zeiger auf die Follow-Menge der Produktion
				la = hash_tab->getFollow( prod_str[p2->prod_index].hash_index );

			else
				//bei LALR und LR sind es die Lookaheads
				la = lr->la;

			//ist die Menge t in la enthalten?
			if( la->bgt( t ) == true )
			{
//den Namen der Produktion ausgeben
//char *name = hash_tab->getName( prod_str[p2->prod_index].hash_index );
//cout << "Nehme FOLLOW(" << name << ") als Lookahead-Menge..." << endl;

//LR-Item ausgeben
//outputItem( lr->prod2_index, lr->dot );

				//die Alternative (prod2_index) zurückliefern
				prod2_index = lr->prod2_index;

				//die Terminale t sind in la enthalten
				return( true );
			}
		}
	}

	//nein, kein passendes LR-Item gefunden
	return( false );
}


void SSLRParser::generateFiles( void )
{
	//hier werden die Source-Files des Parsers erzeugt
	ofstream	cppFile( "sslrparser.cpp" );
	ofstream	hFile( "sslrparser.h" );
	ofstream	termDefHFile( "sslrtermdef.h" );
	char		puf[256];

	//Meldung ausgeben?
	if( argv_str->verbose )
		//ja
		cout << "sslr: Generate parser file..." << endl;

	/*
		Die längste rechte Seite bestimmen.
		Diese Information wird in das Header-File übernommen, falls die
		Debug-Version des Parsers erzeugt werden soll. Mit Hilfe dieser
		Information kann eine formatierte Ausgabe der rechten Seiten
		erfolgen.
	*/
	maxAltRightSideWidth = 0;

	//längstes Terminal/Nichtterminal
	maxElemWidth = 0;

	/*
		Die Breite des längesten Zustands bestimmen. Dazu in einen
		Pufferschreiben.
	*/
	sprintf( puf, "%ld", hulle_anz );

	//Breite des größtes Zustands
	maxStateWidth = strlen( puf ) + 2;







	/*
		Der Scanner liefert ja Tokens zum Parser zurück, die im Prinzip
		für die Auswahl der nächsten Aktion (schieben/reduzieren) benötigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	outputTermDefHFile( termDefHFile );

	//den Header des cpp-Files ausgeben
	outputCPPHeader( cppFile );

	//Terminal-Defines als enum ausgeben
	outputCPPTerminal( cppFile );

	//etwaige Include-Anweisungen einfügen
	outputIncl( cppFile );

	//LR-Tabelle ausgeben
	outputLRTab( cppFile );

	//Sprung-Tabelle ausgeben
	outputJumpTab( cppFile );

	//die Follow-Sets ausgeben
	outputFollow( cppFile );

	//die rechten Seiten ausgeben
	outputAlternatives( cppFile );

	//alle NTERM_STR ausgeben
	outputNtermStr( cppFile );

	//Debug-Mode?
	if( argv_str->debug == true )
		//ja
		outputTermName( cppFile );

	//Fehlerbehandlung ausgeben
	outputErrorRecovery( cppFile );

	//alle übrigen Routinen ausgeben
	outputCPPEnd( cppFile );

	//semantische Aktionen ausgeben
	outputSemAct( cppFile );

	//etwaige eigene Erweiterungen einfügen
	outputExt( cppFile );






	//Mindestbreite festlegen
	maxAltRightSideWidth = ( ( maxAltRightSideWidth + 18 ) < 21 ) ? 21 : ( maxAltRightSideWidth + 18 );
	maxElemWidth = ( ( maxElemWidth + 2 ) < 7 ) ? 7 : ( maxElemWidth + 2 );
	maxStateWidth = ( ( maxStateWidth + 2 ) < 8 ) ? 8 : ( maxStateWidth + 2 );

	//das Header-File generieren
	outputHFile( hFile );
}


void SSLRParser::outputCPPHeader( ofstream &file )
{
	//Den Header des cpp-Files ausgeben

	//Header des cpp-Files
file << "/***************************************************************************\n";
file << "                          sslrparser.cpp  -  description\n";
file << "                             -------------------\n";
file << "    copyright            : (C) 2002 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#include \"sslrparser.h\"\n";
file << "#include <iostream>\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug version *\n";
		file << "****************************/\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug version *\n";
		file << "********************************/\n\n\n";
	}
}


void SSLRParser::outputCPPEnd( ofstream &file )
{
	//alle übrigen Routinen des cpp-Files ausgeben

file << "\n";
file << "\n";
file << "SSLRParser::SSLRParser( SSLEXScanner *scan )\n";
file << "{\n";
file << "	//call reset to initialize the parser\n";
file << "	reset();\n";
file << "\n";
file << "	//scanner class\n";
file << "	SSLR_scanner = scan;\n";
file << "\n";
file << "#ifdef SSLR_INIT\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "SSLRParser::~SSLRParser()\n";
file << "{\n";
file << "#ifdef SSLR_INIT\n";
file << "	//uninizialize user defined variables\n";
file << "	deinit();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::reset( void )\n";
file << "{\n";
file << "	//resets the whole parser\n";
file << "\n";
file << "#ifdef SSLR_DEBUG\n";
file << "	//output\n";
file << "	cout << setw( SSLR_maxStateWidth ) << \" state |\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \" stack |\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \" action |\" << setw( SSLR_maxElemWidth ) << \" next |\" << endl;\n";
file << "\n";
file << "	//separator\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << \"|\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//initialize\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' ) << \" 0 |\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//set debug stack pointer\n";
file << "	SSLR_dbgSp = 0;\n";
file << "#endif\n";
file << "\n";
file << "	//parse stack pointer\n";
file << "	SSLR_sp = 0;\n";
file << "\n";
file << "	//start with state 0\n";
file << "	SSLR_push( 0 );\n";
file << "	SSLR_state = 0;\n";
file << "\n";
file << "	//no errors yet\n";
file << "	SSLR_anzError = 0;\n";
file << "	SSLR_anzSuppressError = 0;\n";
file << "\n";


	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja
		file << "	//semantic actions\n";
		file << "	SSLR_semAct = true;\n";
		file << "\n";
		file << "	//stack counter for semantic action stack\n";
		file << "	SSLR_semStackCnt = 0;\n";
	}

file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::SSLR_getTerminal( void )\n";
file << "{\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Attribut des Scanners auf den Stack schieben
		file << "	//semantic actions allowed?\n";
		file << "	if( SSLR_semAct == true )\n";
		file << "	{\n";
		file << "		//semantic stack overflow?\n";
		file << "		if( SSLR_semStackCnt >= SSLR_maxStackSize )\n";
		file << "		{\n";
		file << "			//yes, print an error message\n";
		file << "			cerr << \"SSLRParser::SSLR_getTerminal: Semantic stack overflow!\" << endl;\n";
		file << "\n";
		file << "			//no more semantic actions allowed\n";
		file << "			SSLR_semAct = false;\n";
		file << "		}\n";
		file << "\n";
		file << "		else\n";
		file << "			//push attribute on stack for semantic actions\n";
		file << "			SSLR_semStack[SSLR_semStackCnt++] = SSLR_attributeStr;\n";
		file << "	}\n";
		file << "\n";
	}

file << "	//get line\n";
file << "	SSLR_line = SSLR_scanner->getYYLineno();\n";
file << "\n";
file << "	//get next terminal\n";
file << "	SSLR_terminal = SSLR_scanner->yyLex( &SSLR_attributeStr );\n";
file << "\n";
file << "	//return terminal\n";
file << "	return( SSLR_terminal );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::yyParse( void )\n";
file << "{\n";
file << "	//start parsing\n";
file << "\n";
file << "	//get first terminal\n";
file << "	SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "	//start parsing\n";
file << "	return( SSLR_parse() );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_push( long ast )\n";
file << "{\n";
file << "	//push a new state on the parse stack\n";
file << "	SSLR_stack[SSLR_sp++] = ast;\n";
file << "\n";
file << "	//stack overflow?\n";
file << "	if( SSLR_sp > SSLR_maxStackSize )\n";
file << "	{\n";
file << "		//stack-overflow\n";
file << "		cerr << \"SSLRParser::SSLR_push: stack overflow!\\nExiting...\" << endl;\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//set new state\n";
file << "	SSLR_state = ast;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "long SSLRParser::SSLR_pop( int anz )\n";
file << "{\n";
file << "	//pop anz elements from the parse stack\n";
file << "	SSLR_sp -= anz;\n";
file << "\n";
file << "	//stack underflow?\n";
file << "	if( SSLR_sp < 0 )\n";
file << "	{\n";
file << "		//stack underflow\n";
file << "		cerr << \"SSLRParser::SSLR_pop: stack underflow!\\nExiting...\" << endl;\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//return new state\n";
file << "	return( SSLR_stack[SSLR_sp - 1] );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLRParser::SSLR_parse( void )\n";
file << "{\n";
file << "	//begin parsing\n";
file << "	while( 1 )\n";
file << "	{\n";
file << "		//end of parsing?\n";
file << "		if( ( SSLR_state == 1 ) && ( SSLR_terminal == ACCEPT ) )\n";
file << "			//return number of errors\n";
file << "			return( SSLR_anzError );\n";
file << "\n";
file << "		//shift terminal SSLR_terminal?\n";
file << "		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_SHIFT )\n";
file << "		{\n";
file << "			//yes\n";
file << "			SSLR_shift( &SSLR_lrTab[SSLR_state][SSLR_terminal] );\n";
file << "\n";
file << "			//get new terminal\n";
file << "			SSLR_terminal = SSLR_getTerminal();\n";
file << "		}\n";
file << "\n";
file << "		//reduce with production?\n";
file << "		else if( SSLR_lrTab[SSLR_state][SSLR_terminal].state == LR_REDUCE )\n";
file << "			//reduce\n";
file << "			SSLR_reduce( &SSLR_lrTab[SSLR_state][SSLR_terminal] );\n";
file << "\n";
file << "		//otherwise an error occured\n";
file << "		else\n";
file << "			//call error recovery\n";
file << "			SSLR_error();\n";
file << "	}\n";
file << "}\n";
	file << "\n";
	file << "\n";

	//Debug-Version
	if( argv_str->debug == true )
	{
		//ja
		file << "void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//shift a terminal onto the parse stack\n";
		file << "\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until it is zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";

		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		file << "	//debug stack overflow?\n";
		file << "	if( SSLR_dbgSp >= SSLR_maxStackSize )\n";
		file << "	{\n";
		file << "		//debug stack overflow\n";
		file << "		cerr << \"SSLRParser::SSLR_shift: Debug stack overflow!\" << endl;\n";
		file << "\n";
		file << "		//exit\n";
		file << "		exit( 1 );\n";
		file << "	}\n";
		file << "\n";
		file << "	//set debug stack\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp].elem = true;\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp++].index = SSLR_terminal;\n";
		file << "\n";
		file << "	//output\n";
		file << "	SSLR_outputDbgStack( SSLR_state, LR_SHIFT, SSLR_terminal, SSLR_terminal );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//shift a new state onto the stack\n";
		file << "	SSLR_push( tab->value );\n";

		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//reduce with production\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "\n";

		//semantische Aktionen?
		if( semActCnt )
		{
			//ja
			file << "	//perform a semantic action accociated with the reduced production\n";
			file << "	SSLR_doSemAct( tab );\n";
			file << "\n";
		}

		file << "	//get a pointer to the alternative\n";
		file << "	n = &SSLR_ntermStr[tab->value];\n";

		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		file << "	//pop elements from debug stack\n";
		file << "	SSLR_dbgSp -= n->elem;\n";
		file << "\n";
		file << "	//debug stack overflow?\n";
		file << "	if( SSLR_dbgSp >= SSLR_maxStackSize )\n";
		file << "	{\n";
		file << "		//debug stack overflow\n";
		file << "		cerr << \"SSLRParser::SSLR_reduce: Debug stack overflow!\" << endl;\n";
		file << "\n";
		file << "		//exit\n";
		file << "		exit( 1 );\n";
		file << "	}\n";
		file << "\n";
		file << "	//set debug stack\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp].elem = false;\n";
		file << "	SSLR_dbgStack[SSLR_dbgSp++].index = tab->value;\n";
		file << "\n";
		file << "	//output\n";
		file << "	SSLR_outputDbgStack( SSLR_state, LR_REDUCE, tab->value, SSLR_terminal );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";

		file << "	//remove states form stack\n";
		file << "	SSLR_state = SSLR_pop( n->elem );\n";
		file << "\n";
		file << "	//get new state\n";
		file << "	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];\n";
		file << "\n";
		file << "	//push new state on stack\n";
		file << "	SSLR_push( SSLR_state );\n";
		file << "}\n";
		file << "\n\n";


		//Routine zur Ausgabe des Debug-Stacks SSLR_dbgStack

		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

file << "void SSLRParser::SSLR_outputDbgStack( int state, int action, int index, int next )\n";
file << "{\n";
file << "	//print the debugging stack\n";
file << "	char	statePuf[SSLR_maxStateWidth + 1];\n";
file << "	char	stackPuf[SSLR_maxElemWidth + 1];\n";
file << "	char	actionPuf[SSLR_maxAltRightSideWidth + 1];\n";
file << "	char	nextPuf[SSLR_maxElemWidth + 1];\n";
file << "	int		stackIndex, i;\n";
file << "\n";
file << "	//curent state in string\n";
file << "	sprintf( statePuf, \"%d\", SSLR_state );\n";
file << "\n";
file << "	//print first element\n";
file << "	stackIndex = SSLR_dbgStack[0].index;\n";
file << "\n";
file << "	//terminal?\n";
file << "	if( SSLR_dbgStack[0].elem == true )\n";
file << "		//terminal\n";
file << "		sprintf( stackPuf, \"%s\", SSLR_termName[stackIndex] );\n";
file << "\n";
file << "	else\n";
file << "		//is nonterminal\n";
file << "		sprintf( stackPuf, \"%s\", SSLR_ntermStr[stackIndex].name );\n";
file << "\n";
file << "	//action\n";
file << "	if( action == LR_SHIFT )\n";
file << "	{\n";
file << "		//shift state\n";
file << "		sprintf( actionPuf, \"push %s\", SSLR_termName[index] );\n";
file << "\n";
file << "\n";
file << "		//next is empty\n";
file << "		sprintf( nextPuf, \"%s\", \" \" );\n";
file << "	}\n";
file << "\n";
file << "	else\n";
file << "	{\n";
file << "		SSLR_NTERM_STR	*str = &SSLR_ntermStr[index];\n";
file << "		int				i;\n";
file << "\n";
file << "		//reduce with alternative\n";
file << "		sprintf( actionPuf, \"reduce with \" );\n";
file << "\n";
file << "		//print name of alternative\n";
file << "		strcat( actionPuf, str->name );\n";
file << "		strcat( actionPuf, \" -> \" );\n";
file << "\n";
file << "		//print all elements on the right side\n";
file << "		for( i = 0; i < str->elem; i++ )\n";
file << "		{\n";
file << "			//print element\n";
file << "			strcat( actionPuf, str->ri[i] );\n";
file << "\n";
file << "			//more elements?\n";
file << "			if( i < ( str->elem - 1 ) )\n";
file << "				//yes\n";
file << "				strcat( actionPuf, \" \" );\n";
file << "		}\n";
file << "\n";
file << "		//alternatives with zero elements have EPSILON on the right side\n";
file << "		if( !str->elem )\n";
file << "			//print EPSILON\n";
file << "			strcat( actionPuf, str->ri[0] );\n";
file << "\n";
file << "		//next is the current terminal\n";
file << "		sprintf( nextPuf, \"%s\", SSLR_termName[next] );\n";
file << "	}\n";
file << "\n";
file << "	//separator\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( '-' ) << \"|\"\n";
file << "	<< setw( SSLR_maxElemWidth ) << \"|\" << setw( SSLR_maxAltRightSideWidth )\n";
file << "	<< \"|\" << setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "\n";
file << "	//initialize\n";
file << "	cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )\n";
file << "	<< ( string( statePuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxAltRightSideWidth ) << ( string( actionPuf ) + \" |\" )\n";
file << "	<< setw( SSLR_maxElemWidth ) << ( string( nextPuf ) + \" |\" ) << endl;\n";
file << "\n";
file << "\n";
file << "\n";
file << "	//print all other debug stack entries\n";
file << "	for( i = 1; i < SSLR_dbgSp; i++ )\n";
file << "	{\n";
file << "		//print element\n";
file << "		stackIndex = SSLR_dbgStack[i].index;\n";
file << "\n";
file << "		//terminal?\n";
file << "		if( SSLR_dbgStack[i].elem == true )\n";
file << "			//terminal\n";
file << "			sprintf( stackPuf, \"%s\", SSLR_termName[stackIndex] );\n";
file << "\n";
file << "		else\n";
file << "			//is nonterminal\n";
file << "			sprintf( stackPuf, \"%s\", SSLR_ntermStr[stackIndex].name );\n";
file << "\n";
file << "		cout << setw( SSLR_maxStateWidth ) << setfill( ' ' )\n";
file << "		<< \"|\" << setw( SSLR_maxElemWidth ) << ( string( stackPuf ) + \" |\" )\n";
file << "		<< setw( SSLR_maxAltRightSideWidth ) << \"|\"\n";
file << "		<< setw( SSLR_maxElemWidth ) << \"|\" << endl;\n";
file << "	}\n";
file << "}\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "void SSLRParser::SSLR_shift( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until it is zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";
		file << "	//shift a new state onto the stack\n";
		file << "	SSLR_push( tab->value );\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void SSLRParser::SSLR_reduce( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//reduce with production\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "\n";
		file << "\t//reduce number of error messages to supress?\n";
		file << "\tif( SSLR_anzSuppressError )\n";
		file << "\t\t//yes, until ists zero\n";
		file << "\t\tSSLR_anzSuppressError--;\n";
		file << "\n";

		//semantische Aktionen?
		if( semActCnt )
		{
			//ja
			file << "	//perform a semantic action accociated with the reduced production\n";
			file << "	SSLR_doSemAct( tab );\n";
			file << "\n";
		}

		file << "	//get a pointer to the alternative\n";
		file << "	n = &SSLR_ntermStr[tab->value];\n";
		file << "\n";
		file << "	//remove states form stack\n";
		file << "	SSLR_state = SSLR_pop( n->elem );\n";
		file << "\n";
		file << "	//get new state\n";
		file << "	SSLR_state = SSLR_jumpTab[SSLR_state][n->jump_index];\n";
		file << "\n";
		file << "	//push new state on stack\n";
		file << "	SSLR_push( SSLR_state );\n";
		file << "}\n";
		file << "\n";
		file << "\n";
	}
}


void SSLRParser::outputCPPTerminal( ofstream &file )
{
	//Terminal-Defines als enum ausgeben
	char	*name;
	int		i, width;

	//Header ausgeben
	file << "//Terminals for debugging\n";
	file << "char *SSLR_scannerToken[] =\n{\n";

	for( i = 0; i < termArrCount; i++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//Define-Anweisung ausgeben
		file << "\t/*" << i << "*/ \"" << name << "\",\n";

		//Breite des Namens
		width = strlen( name );

		//länger?
		if( width > maxElemWidth )
			//ja, merken
			maxElemWidth = width;
	}

	//Abschluss
	file << "\t0L\n};\n\n\n";
}


void SSLRParser::outputLRTab( ofstream &file )
{
	//LR-Tabelle in Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	LR_TAB		*lrtab;
	char		puf1[256+1], puf2[256+1], *name;
	int			i, j, k, id;


	//Überschrift
	file << "//syntax analyze table\n";

	//Definition der LR-Tabelle
	file << "SSLRParser::SSLR_LR_TAB SSLRParser::SSLR_lrTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzTerm] = {\n";

	//alle Zustände
	for( i = 0; i < hulle_anz; i++ )
	{
		//öffnen
		file << "/* State " << i << " */\n{ ";

		//alle Terminale
		for( j = 0, k = 0; j < termArrCount; j++, k++ )
		{
			//Zeiger auf LR_TAB-Struktur
			lrtab = &lrTab[i][j];

			//Zustand ausgeben
			switch( lrtab->state )
			{
				//Fehler?
				case SSLR_ERROR:
				{
					//ja, Fehlerbehandlung
					sprintf( puf1, "%s", "LR_ERROR" );
					break;
				}

				//shift?
				case SSLR_SHIFT:
				{
					//ja, Zustand schieben
					sprintf( puf1, "%s", "LR_SHIFT" );
					break;
				}

				//reduce?
				case SSLR_REDUCE:
				{
					//ja, mit Produktion reduzieren
					sprintf( puf1, "%s", "LR_REDUCE" );

					//Produktion ausschreiben
					p2 = &prod2_str[lrtab->value];

					//Zeiger auf PROD_STR
					p1 = &prod_str[p2->prod_index];

					//Name der Produktion
					name = hash_tab->getName( p1->hash_index );

					//Nummer der Alternative
					id = lrtab->value - p1->prod2_index;

					//Namen generieren
					sprintf( puf2, "%s_%d", name, id );
					break;
				}

				//akzeptieren?
				case SSLR_ACCEPT:
				{
					//ja, akzeptieren
					sprintf( puf1, "%s", "LR_ACCEPT" );
					break;
				}

				default:
				{
					//anderer Wert
					sprintf( puf1, "%d", lrTab[i][j].state );
					break;
				}
			}

			//Werte-Paar ausgeben
			file << "{ " << puf1 << ", ";

			//reduce?
			if( lrtab->state == SSLR_REDUCE )
				//ja
				file << puf2 << " }";

			else
				//ausgeben
				file << lrtab->value << " }";

			//Kommt noch etwas?
			if( j < ( termArrCount - 1 ) )
				//ja
				file << ",";

			//neue Zeile?
			if( k == 8 )
			{
				//ja
				file << "\n";
				k = 0;
			}
		}

		//Nächster Zustand?
		if( i < ( hulle_anz - 1 ) )
			//ja
			file << " },\n";

		else
			//nein
			file << " }\n";
	}

	//abschliessen
	file << "};\n";
}


void SSLRParser::outputJumpTab( ofstream &file )
{
	//Sprung-Tabelle ausgeben
	PROD_STR	*p1;
	long		index, prod_index;
	char		*name, widthChar[128];
	int			i, j, k, width;

	//Breite des größten Zustands
	sprintf( widthChar, "%ld", hulle_anz );
	width = strlen( widthChar );

	//Definition der Sprung-Tabelle
	file << "\n\n//jump table\n";
	file << "long SSLRParser::SSLR_jumpTab[SSLRParser::SSLR_anzLRStates][SSLRParser::SSLR_anzNTerm] = {\n";

	//zuerst alle Produktionen ausgeben, dient der Orientierung
	file << "//";
	for( i = 0, k = 0; i < ntermArrCount; i++, k++ )
	{
		//neue Zeile?
		if( k == 10 )
			//ja
			file << "\n//";

		//Produktion ausgeben
		file << hash_tab->getName( ntermArr[i] ) << ", ";
	}

	//neue Zeile
	file << "\n\n";

	//alle Zustände
	for( i = 0; i < hulle_anz; i++ )
	{
		//öffnen
		file << "/* State " << i << " */\n{ ";

		//alle Produktionen
		for( j = 0, k = 0; j < ntermArrCount; j++, k++ )
		{
			//Name der Produktion
			name = hash_tab->getName( ntermArr[j] );

			//prod_index holen
			prod_index = hash_tab->getProdStr( ntermArr[j] );

			//Zeiger auf PROD_STR
			p1 = &prod_str[prod_index];

			//Index in Jump-Tabelle
			index = hash_tab->getLRTabIndex( p1->hash_index );

			//Wert ausgeben
			file.width( width );
			file << jumpTab[i][index];

			//Folgt noch etwas?
			if( j < ( prod_anz - 1 ) )
				//ja
				file << ", ";

			//neue Zeile?
			if( k == 15 )
			{
				//ja
				file << "\n";
				k = 0;
			}
		}

		//Nächster Zustand?
		if( i < ( hulle_anz - 1 ) )
			//ja
			file << " },\n";

		else
			//nein
			file << " }\n";
	}

	//abschliessen
	file << "};\n\n";
}


void SSLRParser::outputAlternatives( ofstream &file )
{
	//die Alternativen in die cpp-Datei ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, puf1[256+1];
	int			i, j, id, type, rs, ns;

	//nur bei Debug-Version
	if( argv_str->debug == true )
	{
		//Header
		file << "\n//all alternatives\n";

		//alle Alternativen
		for( i = 0; i < prod2_anz; i++ )
		{
			//Länge der rechten Seite dieser Alternative
			rs = ns = 0;

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//den Namen der Alternative holen
			name = hash_tab->getName( p1->hash_index );

			//Nummer der Alternative
			id = i - p1->prod2_index;

			//Namen generieren
			sprintf( puf1, "%s%d", name, id );

			//Länge des Namens der Alternative
			ns = strlen( puf1 );

			//addieren zur Länge der rechten Seite dieser Alternative
			rs += ns;

			//länger?
			if( ns > maxElemWidth )
				//ja, merken
				maxElemWidth = ns;

			//initialisieren
			file << "char *SSLRParser::SSLR_" << puf1 << "Ri[" << p2->riAnz << "] = { ";

			//alle Elemente auf der rechten Seite ausgeben
			for( j = 0; j < p2->riAnz; j++ )
			{
				//Namen holen
				name = hash_tab->getName( p2->right[j] );

				//addieren
				rs += strlen( name );

				//Typ holen
				type = hash_tab->getType( p2->right[j] );

				//Terminal?
				if( type == SSLR_TERM )
				{
					//ja
					file << "\"\\\'" << name << "\\\'\"";

					//Terminale werden in ' ausgegeben
					rs += 2;
				}

				else
					//Nichtterminal
					file << "\"" << name << "\"";

				//folgt noch ein Eintrag?
				if( j < ( p2->riAnz - 1 ) )
				{
					//ja
					file << ", ";

					//Space zwischen zwei Elementen auf der rechten Seite
					rs++;
				}
			}

			//abschließen
			file << " };\n";

			//rechte Seite größer?
			if( rs > maxAltRightSideWidth )
				//ja, merken
				maxAltRightSideWidth = rs;
		}
	}
}


void SSLRParser::outputNtermStr( ofstream &file )
{
	//die NTERM_STR ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, puf1[256+1];
	long		followAnz;
	int			i, id, riAnz;

	//Header
	file << "\n\n//all alternatives\n";
	file << "SSLRParser::SSLR_NTERM_STR SSLRParser::SSLR_ntermStr[SSLRParser::SSLR_anzProd] = {\n";

	//alle Alternativen
	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf PROD2_STR
		p2 = &prod2_str[i];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//den Namen der Alternative holen
		name = hash_tab->getName( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Nummer der Alternative
		id = i - p1->prod2_index;

		//Namen generieren
		sprintf( puf1, "%s%d", name, id );

		//ist es eine EPSILON-Produktion?
		if( p2->right[0] == epsHashIndex )
			//ja
			riAnz = 0;

		else
			//nein, ganz normal
			riAnz = p2->riAnz;

		//Debug-Version?
		if( argv_str->debug == true )
			//nein, entsprechende SSLR_NTERM_STR ausgeben
			file << "{ \"" << name << "\", SSLRParser::SSLR_" << puf1 << "Ri, " << name << ", " << riAnz << ", SSLRParser::SSLR_" << name << "Follow, " << followAnz << " }";

		else
			//ja, entsprechende SSLR_NTERM_STR ausgeben
			file << "{ " << name << ", " << riAnz << ", SSLRParser::SSLR_" << name << "Follow, " << followAnz << " }";

		//folgt noch ein Eintrag?
		if( i < ( prod2_anz - 1 ) )
			//ja
			file << ",\n";
	}

	//abschließen
	file << "};\n\n";
}


void SSLRParser::outputFollow( ofstream &file )
{
	//Die Alternativen in die cpp-Datei ausgeben.
	PROD_STR	*p1;
	Terminal	*followSet;
	char		*name;
	long		followAnz, *followTerm;
	int			i, j;

	//Header
	file << "\n//follow sets for the error recovery\n";

	//alle Produktionen
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//Den Namen der Produktion holen
		name = hash_tab->getName( p1->hash_index );

		//Zeiger auf die Follow-Elemente
		followSet = hash_tab->getFollow( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//Initialisieren
		file << "long SSLRParser::SSLR_" << name << "Follow[" << followAnz << "] = { ";

		//alle Follow-Elemente ausgeben
		for( j = 0; j < followAnz; j++ )
		{
			//Namen holen
			name = hash_tab->getName( (*followSet)[j] );

			//Terminal ausgeben
			file << name;

			//folgt noch ein Eintrag?
			if( j < ( followAnz - 1 ) )
				//ja
				file << ", ";
		}

		//abschließen
		file << " };\n";
	}
}


void SSLRParser::outputTermName( ofstream &file )
{
	//Die Namen der Terminale ausgeben, nur im debug-mode
	char	*name;
	int		i, k;

	//Debug-Makro ausgeben
	file << "\n#ifdef SSLR_DEBUG\n";

	//Header
	file << "\n//names of the terminals\n";
	file << "char *SSLRParser::SSLR_termName[SSLRParser::SSLR_anzTerm] =\n{ ";

	//alle Terminale
	for( i = k = 0; i < termArrCount; i++, k++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//neue Zeile?
		if( k == 16 )
		{
			//ja
			file << "\n";
			k = 0;
		}

		//Define-Anweisung ausgeben
		file << "\"" << name << "\"";

		//Folgt noch ein Terminal?
		if( i < ( termArrCount - 1 ) )
			//ja
			file << ", ";
	}

	//abschliessen
	file << " };\n\n";
	file << "#endif\n\n";
}


void SSLRParser::outputSemAct( ofstream &file )
{
	//semantische Aktionen ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char		*name, *pos, *tmp, *semTypeName;
	long		_line, LRTabIndex;
	bool		semTypeOK = false;
	int			i, state, depth, semIndex, semTypeIndex, id;
	int			*nArr, *tArr, type, sign, err;

	//gibt es überhaupt welche?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//dient der Vermeidung von Fehlerlawinen
		nArr = new( int[ntermArrCount] );
		tArr = new( int[termArrCount] );

		//initialisieren
		memset( nArr, 0, sizeof( int ) * ntermArrCount );
		memset( tArr, 0, sizeof( int ) * termArrCount );

		//Funktions-Header ausgeben
		file << "void SSLRParser::SSLR_doSemAct( SSLR_LR_TAB *tab )\n";
		file << "{\n";
		file << "	//do semantic actions before reduction\n";
		file << "	SSLR_NTERM_STR	*n;\n";
		file << "	SSLR_TYPE		tmp;\n";
		file << "\n";
		file << "	//semantic actions allowed?\n";
		file << "	if( SSLR_semAct == true )\n";
		file << "	{\n";
		file << "		//get a pointer to the alternative\n";
		file << "		n = &SSLR_ntermStr[tab->value];\n";
		file << "\n";
		file << "		//Alternative to reduce with\n";
		file << "		switch( tab->value )\n";
		file << "		{\n";

		//alle Alternativen
		for( i = 0; i < prod2_anz; i++ )
		{
			//Fehlerflag zurücksetzen
			err = 0;

			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//gibt es semantische Aktionen?
			if( p2->semAct )
			{
				//ja, ausgeben
				name = hash_tab->getName( p1->hash_index );

				//das entsprechende Item ausgeben
				file << "\t\t\t//";
				outputItem( i, p2->riAnz, file );
				file << "\n";

				//case ausgeben
				file << "\t\t\tcase " << name << "_" << i - p1->prod2_index << ":\n";
				file << "\t\t\t{\n\t\t\t\t";

				//Zustand setzen
				state = 0;
				_line = p2->semActLine;

				//Verschachtelung von Kommentaren
				depth = 0;

				//Zeiger auf den text
				pos = p2->semAct;

				//den Text analysieren
				while( *pos && !err )
				{
					//Blancs löschen
					switch( state )
					{
						case 0:
						{
							//Leerzeichen löschen
							while( isspace( *pos ) && ( *pos != '\n' ) )
								//nächstes Zeichen
								file << *pos++;

							break;
						}
					}

					//neue Zeile?
					if( *pos == '\n' )
					{
						//neue Zeile
						_line++;

						//Status: 2?
						if( state != 2 )
						{
							//Status 2 ist Kommentar //
							file << *pos++;
							continue;
						}
					}

					//semantischer Typ?
					if( !state && ( *pos == '$' ) )
					{
						//ja
						state = 10;
						pos++;
					}

					switch( state )
					{
						//Default-Zustand
						case 10:
						{
							//semantischer Typ?
							if( *pos == '$' )
							{
								//den semantischen Typ der Produktion holen
								semIndex = hash_tab->getUnionType( p1->hash_index );

								//gibt es einen semantischen Typ?
								if( semIndex )
								{
									//ja, mit semantischem Typ ausgeben
									file << "tmp." << unionStr->id[semIndex];

									//ist überflüssigerweise ein semantischer Typ in Form von <typ>
									//angegeben worden?
									if( semTypeOK )
									{
										//sind die Typen gleich?
										if( semIndex == semTypeIndex )
											//ja, Angabe ist überflüssig
											cerr << "sslr: line " << _line << ": Explicit semantic type statement not necessary!" << endl;

										else
											//nein, sind verschieden!
											cerr << "sslr: line " << _line << ": Explicit semantic type statement does not coincide with %union statement!" << endl;

										//Speicher für Namen freigeben
										delete( semTypeName );

										//Flag zurücksetzen
										semTypeOK = false;
									}
								}

								else
								{
									//nein, ohne semantischen Typ ausgeben
									file << "tmp";

									//ist ein semantischer Typ in Form von <typ> angegeben worden?
									if( semTypeOK )
									{
										//Typ ausgeben
										file << "." << unionStr->id[semTypeIndex];

										//Speicher für Namen freigeben
										delete( semTypeName );

										//Flag zurücksetzen
										semTypeOK = false;
									}

									else
									{
										//nein, Fehler

										//den Namen der Produktion
										name = hash_tab->getName( p1->hash_index );

										//den Index in der LR-Tabelle holen
										LRTabIndex = hash_tab->getLRTabIndex( p1->hash_index );

										//Warnung ausgeben?
										if( !nArr[LRTabIndex] )
											//ja, Warnung ausgeben
											cerr << "sslr: line " << _line << ": No semantic type defined for production " << name << "!" << endl;

										//Vermeidung von Fehlerlawinen
										nArr[LRTabIndex]++;
									}
								}

								//überspringen
								pos++;

								//Zustand zurücksetzen
								state = 0;
							}

							else if( *pos == '<' )
							{
								//ist vom Typ $<...>
								pos++;

								//Position merken
								tmp = pos;

								//solange kein >
								while( ( *pos != '>' ) && *pos )
									//übertragen
									pos++;

								//genügend Speicher anfordern
								semTypeName = new( char[pos - tmp + 1] );

								//kopieren
								strncpy( semTypeName, tmp, pos - tmp );
								semTypeName[pos - tmp] = 0;

								//den Index in unionStr finden
								if( ( semTypeIndex = getSemIndex( semTypeName ) ) < 0 )
								{
									//Typ nicht in %union definiert
									cerr << "sslr: ERROR: line " << _line << ": Type " << semTypeName << " for semantic action not defined in %union!" << endl;

									//Speicher gleich wieder freigeben
									delete( semTypeName );

									//Fehler
									semTypeOK = false;
								}

								else
									//Flag setzen
									semTypeOK = true;

								//> löschen
								pos++;
							}

							else if( isdigit( *pos ) || ( *pos == '-' ) )
							{
								//bezieht sich auf ein Element auf der rechten Seite
								//semStack[semStackCnt-1] ist das letzte Element

								//negativer Index?
								if( *pos == '-' )
								{
									//ja, negativ
									sign = -1;
									pos++;
								}

								else
									//ist positiv
									sign = 1;

								//Zahl einlesen
								id = strtol( pos, 0L, 10 );

								//Vorzeichen
								id *= sign;

								//Ziffern löschen
								while( isdigit( *pos ) )
									pos++;

								//gibt es überhaupt so viele Elemente auf der rechten Seite wie angegeben?
								if( ( id - 1 ) < p2->riAnz )
								{
									//ist es der Form prod -> 'EPSILON'`?
									if( ( p2->riAnz == 1 ) && ( p2->right[0] == epsHashIndex ) )
									{
										//Warnung ausgeben
										cerr << "sslr: line " <<  _line << ": $" << id << " not allowed inside 'EPSILON'-alternative!" << endl;

										//nächste semantische Aktion behandelt
										err++;
										break;
									}

									else
									{
										//den semantischen Typ des Elements holen
										semIndex = hash_tab->getUnionType( p2->right[id - 1] );

										//gibt es einen semantischen Typ?
										if( semIndex )
										{
											//ja, Stack-Zugriff
											file << "SSLR_semStack[SSLR_semStackCnt - 1 - " << p2->riAnz << " + (" << id << ")]." << unionStr->id[semIndex];

											//ist überflüssigerweise ein semantischer Typ in Form von <typ>
											//angegeben worden?
											if( semTypeOK )
											{
												//sind die Typen gleich?
												if( semIndex == semTypeIndex )
													//ja, Angabe ist überflüssig
													cerr << "sslr: line " << _line << ": Explicit semantic type statement not necessary!" << endl;

												else
													//nein, sind verschieden!
													cerr << "sslr: line " << _line << ": Explicit semantic type statement does not coincide with %union-Statement!" << endl;

												//Speicher für Namen freigeben
												delete( semTypeName );

												//Flag zurücksetzen
												semTypeOK = false;
											}
										}

										else
										{
											//nein, Stack-Zugriff
											file << "SSLR_semStack[SSLR_semStackCnt - 1 - " << p2->riAnz << " + (" << id << ")]";

											//ist ein semantischer Typ in Form von <typ> angegeben worden?
											if( semTypeOK )
											{
												//Typ ausgeben
												file << "." << unionStr->id[semTypeIndex];

												//Speicher für Namen freigeben
												delete( semTypeName );

												//Flag zurücksetzen
												semTypeOK = false;

												//überspringen
												pos++;
											}

											else
											{
												//den Namen des Elements
												name = hash_tab->getName( p2->right[id - 1] );

												//den Index in der LR-Tabelle holen
												LRTabIndex = hash_tab->getLRTabIndex( p2->right[id - 1] );

												//Typ holen
												type = hash_tab->getType( p2->right[id - 1] );

												//Terminal?
												if( type == SSLR_TERM )
												{
													//ja

													//Warnung ausgeben?
													if( !tArr[LRTabIndex] )
														//Warnung ausgeben
														cerr << "sslr: line " << _line << ": No semantic type defined for terminal " << name << "!" << endl;

													//Vermeidung von Fehlerlawinen
													tArr[LRTabIndex]++;
												}

												else
												{
													//ist ein Nicht-Terminal

													//Warnung ausgeben?
													if( !nArr[LRTabIndex] )
														//Warnung ausgeben
														cerr << "sslr: line " << _line << ": No semantic type defined for nonterminal " << name << "!" << endl;

													//Vermeidung von Fehlerlawinen
													nArr[LRTabIndex]++;
												}
											}
										}
									}
								}

								else
								{
									//Indiziertes Element zu groß!
									cerr << "sslr: line " << _line << ": Number in semantic type statement too big!" << endl;

									//abbrechen
									err++;
									break;
								}

								//Zustand zurücksetzen
								state = 0;
							}

							break;
						}

						case 0:
						{
							//Kommentar?
							if( ( pos[0] == '/' ) && ( pos[1] == '*' ) )
							{
								//ja, Kommentar
								state = 1;

								//Verschachtelung
								depth++;
								pos += 2;

								//ausgeben
								file << "/*";
							}

							else if( ( pos[0] == '/' ) && ( pos[1] == '/' ) )
							{
								//Kommentar
								pos += 2;
								file << "//";
								state = 2;
							}

							else if( *pos )
								//einfach übertragen
								file << *pos++;

							break;
						}

						case 1:
						{
							//Kommentar /*
							if( ( pos[0] == '*' ) && ( pos[1] == '/' ) )
							{
								//Kommentar schliessen
								file << "*/";
								pos += 2;

								//Verschachtelungstiefe
								depth--;

								//Default-Zustand?
								if( !depth )
									//ja
									state = 0;
							}

							else if( ( pos[0] == '/' ) && ( pos[1] == '*' ) )
							{
								//ja, Kommentar

								//Verschachtelung
								depth++;
								pos += 2;

								//ausgeben
								file << "/*";
							}

							else
								//einfach übertragen
								file << *pos++;

							break;
						}

						case 2:
						{
							//Kommentar //
							file << *pos;

							//Newline?
							if( *pos++ == '\n' )
								//ja
								state = 0;

							break;
						}

						default:
							//einfach kopieren
							file << *pos++;
					}
				}

				//case abschliessen
				file << "\t\t\t\tbreak;\n";
				file << "\t\t\t}\n";
				file << "\n";
			}
		}

		file << "//\t\t\tdefault:\n";
		file << "\t\t\t\t//error\n";
		file << "//\t\t\t\tcerr << \"SSLRParser::SSLR_doSemAct: Unknown alternative \" << tab->value << \"!\" << endl;\n";
		file << "\t\t}\n";
		file << "\n\t\t//correct stack pointer\n";
		file << "\t\tSSLR_semStackCnt -= n->elem;\n";
		file << "\n";
		file << "		//semantic stack overflow?\n";
		file << "		if( SSLR_semStackCnt >= SSLR_maxStackSize )\n";
		file << "		{\n";
		file << "			//yes, print an error message\n";
		file << "			cerr << \"SSLRParser::SSLR_doSemAct: Semantic stack overflow!\" << endl;\n";
		file << "\n";
		file << "			//no more semantic actions allowed\n";
		file << "			SSLR_semAct = false;\n";
		file << "		}\n";
		file << "\n";
		file << "		else\n";
		file << "			//push last value on stack\n";
		file << "			SSLR_semStack[SSLR_semStackCnt++] = tmp;\n";
		file << "\t}\n";
		file << "}\n";
		file << "\n";

		//Speicher freigeben
		delete[] ( nArr );
		delete[] ( tArr );
	}
}


void SSLRParser::outputErrorRecovery( ofstream &file )
{
	//Hier wird die komplette Fehlerbehandlung ausgegeben
	LR_TAB	*lrtab;
	char	*name;

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		file << "\n";
		file << "\n";
file << "void SSLRParser::SSLR_printErrorMsg( bool print, char *errMsg  )\n";
file << "{\n";
file << "	//print an error message, but only when it is allowed\n";
file << "	if( ( print == true ) && !SSLR_anzSuppressError )\n";
file << "		//allowed\n";
file << "		cerr << \"sslr: ERROR: line \" << SSLR_line << \": \" << errMsg << endl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errPop( long termi )\n";
file << "{\n";
file << "\t//get current state\n";
file << "\tlong state = SSLR_state;\n";
file << "\n";
file << "\t//pop states from the parse stack untill termi may be shifted\n";
file << "\twhile( SSLR_lrTab[state][termi].state != LR_SHIFT )\n";
file << "\t{\n";
file << "\t\t//pop one element\n";
file << "\t\tstate = SSLR_pop( 1 );\n";
file << "\n";
file << "\t\t//are we in state 1, that is could'n termi be shifted?\n";
file << "\t\tif( state == 1 )\n";
file << "\t\t{\n";
file << "\t\t\t//all states poped from parse stack, exit\n";
file << "\t\t\tSSLR_state = state;\n";
file << "\n";
file << "\t\t\t//set current terminal to ACCEPT to simulate successful parsing\n";
file << "\t\t\tSSLR_terminal = ACCEPT;\n";
file << "\t\t\treturn;\n";
file << "\t\t}\n";
file << "\t}\n";
file << "\n";
file << "\t//set new state\n";
file << "\tSSLR_state = state;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errShift( long termi )\n";
file << "{\n";
file << "\t//can we reduce here?\n";
file << "\twhile( SSLR_lrTab[SSLR_state][termi].state == LR_REDUCE )\n";
file << "\t\t//yes, that might allow recovery\n";
file << "\t\tSSLR_reduce( &SSLR_lrTab[SSLR_state][termi] );\n";
file << "\n";
file << "	//shift a new state\n";
file << "	if( SSLR_lrTab[SSLR_state][termi].state == LR_SHIFT )\n";
file << "		//push new state onto the parse stack\n";
file << "		SSLR_push( SSLR_lrTab[SSLR_state][termi].value );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errDelete( void )\n";
file << "{\n";
file << "	//delete current terminal\n";
file << "	SSLR_terminal = SSLR_getTerminal();\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_errOverRead( long termi )\n";
file << "{\n";
file << "	//delete all terminals untill termi is found\n";
file << "	do\n";
file << "	{\n";
file << "		//get next terminal\n";
file << "		SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "		//equal?\n";
file << "		if( SSLR_terminal == termi )\n";
file << "			//yes, return\n";
file << "			return;\n";
file << "\n";
file << "		else if( SSLR_terminal == ACCEPT )\n";
file << "		{\n";
file << "			//abort parsing\n";
file << "			SSLR_state = 1;\n";
file << "			return;\n";
file << "		}\n";
file << "\n";
file << "	}while( 1 );\n";
file << "}\n";
	}

	//Fehler-Routine ausgeben
file << "\n";
file << "\n";
file << "void SSLRParser::SSLR_error( void )\n";
file << "{\n";
file << "	//error handling\n";
file << "	long	tmpState, tmpSp;\n";
file << "	int		rec = 0;\n";
file << "\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Flag ausgeben
		file << "	//no more semantic actions allowed\n";
		file << "	SSLR_semAct = false;\n";
		file << "\n";
	}

file << "	//count error\n";
file << "	SSLR_anzError++;\n";
file << "\n";
file << "\n";



	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		unsigned long	i, j, k, m;
		ERROR_STR		*errorStr;
		bool			outputCase;
		long			LRTabIndex;
		int				pass, autoErr;

		//ja, Header ausgeben
		file << "	switch( SSLR_state )\n";
		file << "	{\n";

		//alle Hüllen-Indices prüfen
		for( i = 0; i < hulle_anz; i++ )
		{
			/*
				vor Verarbeitung der ersten Hülle muss ein case-Statement
				ausgegeben werden
			*/
			outputCase = true;

			//einen neuen Zustand prüfen, dazu zwei Pässe
			for( pass = 0; pass < 2; pass++ )
			{
				/*
					Für alle ERROR_STR prüfen, ob sie eine Fehleranweisung
					für den Zustand i haben.
				*/
				for( j = 0; j < error_anz; j++ )
				{
					//Zeiger auf ERROR_STR
					errorStr = &error_str[j];

					//hat diese Hülle eine Fehleraktion für Zustand i?
					for( k = 0; k < errorStr->hInd.anzArr; k++ )
					{
						//gesuchter Zustand?
						if( errorStr->hInd.arr[k] == i )
						{
							//Fehleraktion ausgeben

							//case-Statement ausgeben?
							if( outputCase == true )
							{
								//Einleitung
								file << "\t\tcase " << i << ":\n";
								file << "\t\t{\n";
								file << "\t\t\tswitch( SSLR_terminal )\n";
								file << "\t\t\t{\n";

								//nicht noch einmal ausgeben
								outputCase = false;
							}

							/*
								Im ersten Pass werden nur Terminal-gebundene
								Fehleraktionen bearbeitet, also der Art
								1:ADD,SUB:AKTION:		"Fehlermeldung!" oder
								1:!(ADD,SUB):AKTION:	"Fehlermeldung!"
							*/
							if( !pass & errorStr->errTermStrAnz )
							{
								//das Fehler-Item ausgeben
								file << "\t\t\t\t//line " << errorStr->line << ", ";

								//entsprechende Alternative ausgeben
								outputItem( errorStr->prod2_index, errorStr->dot, file );
								file << "\n";

								//hat die ERROR_STR überhaupt Terminal-gebundenen Fehleraktionen?
								if( errorStr->errTermStr )
								{
									//alle Terminale durchgehen
									for( m = 0; m < termArrCount; m++ )
									{
										//Terminal gesetzt?
										if( errorStr->errTermArr[m] )
										{
											//den Namen des Terminals holen
											name = hash_tab->getName( termArr[m] );

											//case-Statement ausgeben
											file << "\t\t\t\tcase " << name << ":\n";
										}
									}
								}

								//neue Zeile
								file << "\t\t\t\t{\n";

								//interne Fehlerbehandlung standardmässig ausgeben
								autoErr = 1;

								//Fehlermeldung ausgeben?
								if( errorStr->msg )
								{
									/*
										Die Fehlermeldung MUSS vor den Fehler-Aktionen ausgegeben werden, da,
										wenn z.B. EXIT verwendet wird, die Fehlermeldung nicht gezeigt
										würde!
									*/
									file << "\t\t\t\t\t//show user defined error message\n";
									file << "\t\t\t\t\tSSLR_printErrorMsg( true, \"" << errorStr->msg << "\" );\n\n";
								}


								//Zustände vom Parse-Stack poppen?
								if( errorStr->pop )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->pop );

									//Zustände vom Parse-Stack poppen
									file << "\t\t\t\t\t//pop states from parse stack\n";
									file << "\t\t\t\t\tSSLR_ERROR_POP( " << name << " );\n\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//Terminal auf den Parse-Stack schieben?
								if( errorStr->shift )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->shift );

									//neuen Zustand schieben
									file << "\t\t\t\t\t//shift terminal " << name << "\n";
									file << "\t\t\t\t\tSSLR_ERROR_SHIFT( " << name << " );\n\n";

									//Index des Terminals in der LR-Tabelle holen
									LRTabIndex = hash_tab->getLRTabIndex( errorStr->shift );
//LRTabIndex = getTermArrIndex( errorStr->shift );

									//prüfen, ob das Terminal tatsächlich in diesem Zustand i geschoben werden kann

									//Zeiger auf LR_TAB-Struktur
									lrtab = &lrTab[errorStr->hInd.arr[k]][LRTabIndex];

									//kann das Terminal geschoben werden?
									if( lrtab->state != LR_SHIFT )
										//nein, Warnung ausgeben
										cerr << "sslr: line " << errorStr->line << ": Terminal " << name << " cannot be shifted in state " << i << "!" << endl;

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//Terminale überlesen?
								if( errorStr->overread )
								{
									//den Namen des Terminals holen
									name = hash_tab->getName( errorStr->overread );

									//Terminale überlesen
									file << "\t\t\t\t\t//delete terminals until " << name << " ist the current terminal\n";
									file << "\t\t\t\t\tSSLR_ERROR_OVERREAD( " << name << " );\n\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//aktuelles Terminal aus der Eingabe löschen?
								if( errorStr->del )
								{
									//ein Terminal löschen
									file << "\t\t\t\t\t//delete current terminal\n";

									//mehrfaches Auftreten von DELETE ist erlaubt
									for( m = 0; m < errorStr->del; m++ )
										file << "\t\t\t\t\tSSLR_ERROR_DELETE();\n";

									//neue Zeile
									file << "\n";

									//automatische Fehlerbehandlung einschalten
									autoErr++;
								}


								//den Parse-Prozess beenden?
								if( errorStr->exit )
								{
									//Parsen abbrechen
									file << "\t\t\t\t\t//stop parsing\n";
									file << "\t\t\t\t\tSSLR_ERROR_EXIT;\n";
								}


								//semantische Aktionen trotz Fehlers weiterführen?
								if( errorStr->sem )
								{
									//semantische Aktionen trotz Fehler zulassen

									//gibt es überhaupt semantische Aktionen?
									if( semActCnt && ( unionStr->anz > 1 ) )
									{
										//ja
										file << "\t\t\t\t\t//allow semantic actions despite the error\n";
										file << "\t\t\t\t\tSSLR_ERROR_SEM;\n\n";
									}

									else
										//nein
										cerr << "sslr: line " << errorStr->line << ": There are no semantic actions not to allow!" << endl;
								}


								//automatische Fehlerbehandlung überspringen, wenn keine Aktion gewählt wurde oder nur SEM
								if( autoErr )
								{
									//nein, automatische Fehlerbehandlung trotz eigener Fehler-Angaben ausführen
									file << "\t\t\t\t\t//skip automatic error recovery\n";
									file << "\t\t\t\t\trec++;\n";
								}

								//case für diese ERROR_STR abschliessen
								file << "\n";
								file << "\t\t\t\t\t//leave\n";
								file << "\t\t\t\t\tbreak;\n";
								file << "\t\t\t\t}\n";

								//nächste ERROR_STR prüfen
								break;
							}

							//zweiter Pass?
							else if( pass )
							{
								/*
									zweiter Pass, hier nun die Fehleraktionen ausgeben, die
									nicht mit einem Terminal verbunden sind, also der Art
									1:AKTION:	"Fehlermeldung!
								*/
								if( !errorStr->errTermStr )
								{
									//das Fehler-Item ausgeben
									file << "\t\t\t\t//line " << errorStr->line << ", ";

									//entsprechende Alternative ausgeben
									outputItem( errorStr->prod2_index, errorStr->dot, file );
									file << "\n";

									//alle nicht-Terminal-gebundenen Fehleranweisung unter default subsummieren
									file << "\t\t\t\tdefault:\n";

									//neue Zeile
									file << "\t\t\t\t{\n";

									//interne Fehlerbehandlung standardmässig ausgeben
									autoErr = 1;

									//Fehlermeldung ausgeben?
									if( errorStr->msg )
									{
										/*
											Die Fehlermeldung MUSS vor den Fehler-Aktionen ausgegeben werden, da,
											wenn z.B. EXIT verwendet wird, die Fehlermeldung nicht gezeigt
											würde!
										*/
										file << "\t\t\t\t\t//show user defined error message\n";
										file << "\t\t\t\t\tSSLR_printErrorMsg( true, \"" << errorStr->msg << "\" );\n\n";
									}


									//Zustände vom Parse-Stack poppen?
									if( errorStr->pop )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->pop );

										//Zustände vom Parse-Stack poppen
										file << "\t\t\t\t\t//pop states from parse stack\n";
										file << "\t\t\t\t\tSSLR_ERROR_POP( " << name << " );\n\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//Terminal auf den Parse-Stack schieben?
									if( errorStr->shift )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->shift );

										//neuen Zustand schieben
										file << "\t\t\t\t\t//shift terminal " << name << "\n";
										file << "\t\t\t\t\tSSLR_ERROR_SHIFT( " << name << " );\n\n";

										//Index des Terminals in der LR-Tabelle holen
										LRTabIndex = hash_tab->getLRTabIndex( errorStr->shift );
//LRTabIndex = getTermArrIndex( errorStr->shift );

										//prüfen, ob das Terminal tatsächlich in diesem Zustand i geschoben werden kann

										//Zeiger auf LR_TAB-Struktur
										lrtab = &lrTab[errorStr->hInd.arr[k]][LRTabIndex];

										//kann das Terminal geschoben werden?
										if( lrtab->state != LR_SHIFT )
											//nein, Warnung ausgeben
											cerr << "sslr: line " << errorStr->line << ": Terminal " << name << " cannot be shifted in state " << i << "!" << endl;

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//Terminale überlesen?
									if( errorStr->overread )
									{
										//den Namen des Terminals holen
										name = hash_tab->getName( errorStr->overread );

										//Terminale überlesen
										file << "\t\t\t\t\t//delete terminals until " << name << " ist the current terminal\n";
										file << "\t\t\t\t\tSSLR_ERROR_OVERREAD( " << name << " );\n\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//aktuelles Terminal aus der Eingabe löschen?
									if( errorStr->del )
									{
										//ein Terminal löschen
										file << "\t\t\t\t\t//delete current terminal\n";

										//mehrfaches Auftreten von DELETE ist erlaubt
										for( m = 0; m < errorStr->del; m++ )
											file << "\t\t\t\t\tSSLR_ERROR_DELETE();\n";

										//neue Zeile
										file << "\n";

										//automatische Fehlerbehandlung einschalten
										autoErr++;
									}


									//den Parse-Prozess beenden?
									if( errorStr->exit )
									{
										//Parsen abbrechen
										file << "\t\t\t\t\t//stop parsing\n";
										file << "\t\t\t\t\tSSLR_ERROR_EXIT;\n";
									}


									//semantische Aktionen trotz Fehlers weiterführen?
									if( errorStr->sem )
									{
										//semantische Aktionen trotz Fehler zulassen

										//gibt es überhaupt semantische Aktionen?
										if( semActCnt && ( unionStr->anz > 1 ) )
										{
											//ja
											file << "\t\t\t\t\t//allow semantic actions despite the error\n";
											file << "\t\t\t\t\tSSLR_ERROR_SEM;\n\n";
										}

										else
											//nein
											cerr << "sslr: line " << errorStr->line << ": There are no semantic actions not to allow!" << endl;
									}


									//automatische Fehlerbehandlung überspringen, wenn keine Aktion gewählt wurde oder nur SEM
									if( autoErr )
									{
										//nein, automatische Fehlerbehandlung trotz eigener Fehler-Angaben ausführen
										file << "\t\t\t\t\t//skip automatic error recovery\n";
										file << "\t\t\t\t\trec++;\n";
									}

									//default für diese ERROR_STR abschliessen
									file << "\n";
									file << "\t\t\t\t\t//leave\n";
									file << "\t\t\t\t\tbreak;\n";
									file << "\t\t\t\t}\n";

									//pro Zustand ist nur eine nicht-Terminal-gebundene Fehleranweisung zulässig
//									j = error_anz;
//									break;
								}

								//case-Anweisung abschliessen
								file << "\t\t\t}\n";

								//pro Zustand ist nur eine nicht-Terminal-gebundene Fehleranweisung zulässig
								j = error_anz;
								break;
							}
						}
					}
				}
			}

			//Zustand abschliessen?
			if( outputCase == false )
			{
				//ja, es gab für die Hülle i Fehleranweisungen
				file << "\n";
				file << "\t\t\t//leave\n";
				file << "\t\t\tbreak;\n";
				file << "\t\t}\n\n";
			}
		}


		//default ausgeben
		file << "		default:\n";
		file << "		{\n";
		file << "			//default error message\n";
		file << "			SSLR_printErrorMsg( true, \"Syntax error!\" );\n";
		file << "			break;\n";
		file << "		}\n";

		//switch-Statement abschliessen
		file << "\t}\n\n";
	}

	else
	{
		//es gibt keine benutzter-definierten Fehleranweisungen, nun default-Fehlermeldung ausgeben
		file << "	//default error message\n";
		file << "	cerr << \"line: \" << SSLR_line << \": Syntax error!\" << endl;\n";
	}

	//nun die Standard-Fehlerbehandlung

file << "\n";
file << "	//supress further error messages\n";
file << "	SSLR_anzSuppressError = SSLR_anzSuppressErrorMsg;\n";
file << "\n";
file << "	//skip intern error recovery?\n";
file << "	if( rec )\n";
file << "		//yes, return\n";
file << "		return;\n";
file << "\n";
file << "	//save current stack position\n";
file << "	tmpSp = SSLR_sp;\n";
file << "\n";
file << "	//pop states from the parse stack until a valid transition is found\n";
file << "	do\n";
file << "	{\n";
file << "		//pop one state from the parse stack\n";
file << "		tmpState = SSLR_pop( 1 );\n";
file << "\n";
file << "		//is there a transition?\n";
file << "		if( ( SSLR_sp > 0 ) && ( SSLR_lrTab[tmpState][SSLR_terminal].state == LR_SHIFT ) )\n";
file << "		{\n";
file << "			//we found a valid transition, consider recovered\n";
file << "			SSLR_state = tmpState;\n";
file << "			return;\n";
file << "		}\n";
file << "\n";
file << "		//did we check the whole stack?\n";
file << "		else if( SSLR_sp < 1 )\n";
file << "		{\n";
file << "			//the whole stack has been visited without success\n";
file << "			SSLR_terminal = SSLR_getTerminal();\n";
file << "\n";
file << "			//end of input, that is ACCEPT?\n";
file << "			if( SSLR_terminal == ACCEPT )\n";
file << "			{\n";
file << "				//yes, stop parsing\n";
file << "				SSLR_state = 1;\n";
file << "				return;\n";
file << "			}\n";
file << "\n";
file << "			//set stack pointer\n";
file << "			SSLR_sp = tmpSp;\n";
file << "		}\n";
file << "\n";
file << "	}while( 1 );\n";
file << "}\n";
}


void SSLRParser::outputIncl( ofstream &file )
{
	//Include-Anweisungen in das cpp-File ausgeben
	char	*incl = SSLR_scanner->getInclude(), *beg;
	ulong	len;

	//gibt es include-Anweisungen?
	if( incl )
	{
		//am Anfang das \{ löschen
		while( !( ( incl[0] == '\\' ) && ( incl[1] == '{' ) ) )
			incl++;

		//löschen
		incl = &incl[2];

		//die Länge der Include-Anweisungen
		len = strlen( incl );

		//merken
		beg = &incl[len - 2];

		//am Ende das \{ löschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << incl;
	}
}


void SSLRParser::outputExt( ofstream &file )
{
	//eigene Erweiterungen in das cpp-File ausgeben
	char	*ext = SSLR_scanner->getExtension(), *beg;
	ulong	len;

	//gibt es Extensionen?
	if( ext )
	{
		//am Anfang das \{ löschen
		while( !( ( ext[0] == '\\' ) && ( ext[1] == '{' ) ) )
			ext++;

		//löschen
		ext = &ext[2];

		//die Länge der eigenen Erweiterungen
		len = strlen( ext );

		//merken
		beg = &ext[len - 2];

		//am Ende das \{ löschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << ext;
	}
}


void SSLRParser::outputTermDefHFile( ofstream &file )
{
	/*
		Der Scanner liefert ja Tokens zum Parser zurück, die im Prinzip
		für die Auswahl der nächsten Aktion (schieben/reduzieren) benötigt
		werden. In diesem File werden die #defines der Terminale geschrieben,
		sowie die Definition der %union-Angabe, auf die im Aktionsteil einer
		Regel in SSLEX zugegriffen werden kann/muss.
	*/
	char *name;
	int	i;

	//Kopf ausgeben
file << "/***************************************************************************\n";
file << "                          sslrtermdef.h  -  description\n";
file << "                             -------------------\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLRTERMDEF_H\n";
file << "#define SSLRTERMDEF_H\n";
file << "\n";
file << "\n";
file << "/**\n";
file << "\t@author SSLR V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";

	//Terminale, die der Scanner zurückliefert
	file << "//Terminals returned by the scanner\n";

	for( i = 0; i < termArrCount; i++ )
	{
		//Name des Terminals
		name = hash_tab->getName( termArr[i] );

		//Define-Anweisung ausgeben
		file << "#define " << name << "\t" << i << "\n";
	}


	//wurde eine %union-Angabe vorgenommen?
	if( unionStr->anz > 1 )
	{
		//ja, ausgeben
		file << "\n\n\n//Type for semantic actions\n";
		file << "typedef union\n{\n";

		//Text ausgeben
		file << unionStr->text;

		//abschliessen
		file << "\n}SSLR_TYPE;\n\n\n";
	}

	//Ende des Header-Files
	file << "#endif\n\n";
}


void SSLRParser::outputHFile( ofstream &file )
{
	//Header-File ausgeben
	PROD2_STR	*p2;
	PROD_STR	*p1;
	char 		*name, puf1[256+1];
	char 		**userDefHeader;
	long		followAnz;
	int			i, j, id, userDefHeaderCnt;

	//Kopf ausgeben
file << "/***************************************************************************\n";
file << "                          sslrparser.h  -  description\n";
file << "                             -------------------\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLRPARSER_H\n";
file << "#define SSLRPARSER_H\n";
file << "\n";
file << "\n";
file << "/**\n";
file << "\t@author SSLR V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";


	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug version *\n";
		file << "****************************/\n\n\n";

		//Debug-Makro
		file << "//define debug macro\n";
		file << "#define SSLR_DEBUG\n";
		file << "//#undef SSLR_DEBUG\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug version *\n";
		file << "********************************/\n\n\n";
	}

	//Include-Files
	file << "//Include-Files\n";
	file << "#include <iostream>\n";
	file << "#include <iomanip>\n";
	file << "#include \"sslexscanner.h\"\n\n";

	//allgemeine Definitionen

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		//ja, die Fehlerroutinen als Defines ausgeben
		file << "\n//error routines\n";
		file << "#define SSLR_ERROR_POP\t\t\tSSLR_errPop\n";
		file << "#define SSLR_ERROR_DELETE\t\tSSLR_errDelete\n";
		file << "#define SSLR_ERROR_SHIFT\t\tSSLR_errShift\n";
		file << "#define SSLR_ERROR_OVERREAD\t\tSSLR_errOverRead\n";
		file << "#define SSLR_ERROR_SEM\t\t\tSSLR_semAct = true\n";
		file << "#define SSLR_ERROR_EXIT\t\t\texit( 1 )\n";
		file << "\n";
	}



	//Nicht-Terminal-Defines für Sprung-Tabelle
	file << "\n//Nonterminal defines for the jump table\n";

	for( i = 0; i < ntermArrCount; i++ )
	{
		//Name des Nicht-Terminals
		name = hash_tab->getName( ntermArr[i] );

		//Define-Anweisung ausgeben
		file << "#define " << name << "\t" << i << "\n";
	}



	//Nicht-Terminale für die LR-Tabelle
	file << "\n\n//Nontermials for the LR table\n";

	for( i = 0; i < prod2_anz; i++ )
	{
		//Zeiger auf PROD2_STR
		p2 = &prod2_str[i];

		//Zeiger auf PROD_STR
		p1 = &prod_str[p2->prod_index];

		//Name der Produktion
		name = hash_tab->getName( p1->hash_index );

		//Nummer der Alternative
		id = i - p1->prod2_index;

		//Namen generieren
		sprintf( puf1, "%s_%d", name, id );

		//Define-Anweisung ausgeben
		file << "#define " << puf1 << "\t" << i << "\n";
	}



	//Klassen-Deklaration
	file << "\n\nclass SSLRParser\n";
	file << "{\n";
	file << "private:\n";


	//Struktur für die LR-Tabelle
	file << "\n\t//LR table\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";
	file << "\t\tint\t\t\tstate;\n";
	file << "\t\tlong\t\tvalue;\n";
	file << "\n\t}SSLR_LR_TAB;\n\n";


	//Struktur für alle Alternativen
	file << "\n";
	file << "\t//all productions\n";
	file << "\ttypedef struct\n";
	file << "\t{\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		file << "\t\t//name of alternative\n";
		file << "\t\tchar\t*name;\n";
		file << "\n";
		file << "\t\t//pointer to right side of alternative\n";
		file << "\t\tchar\t**ri;\n";
		file << "\n";
	}

	//Zeiger auf die Follow-Terminale
	file << "\t\t//index in jumpTab\n";
	file << "\t\tint\t\tjump_index;\n";
	file << "\n";
	file << "\t\t//number of elements on the right side\n";
	file << "\t\tint\t\telem;\n";
	file << "\n";
	file << "\t\t//pointer to follow sets\n";
	file << "\t\tlong\t*follow;\n";
	file << "\n";
	file << "\t\t//number of follow terminals\n";
	file << "\t\tlong\tfollowCnt;\n";
	file << "\n";
	file << "\t}SSLR_NTERM_STR;\n";
	file << "\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLR_DEBUG\n";

		//Debug-Stack-Struktur ausgeben
		file << "\t//stack for debugging\n";
		file << "\ttypedef struct\n";
		file << "\t{\n";
		file << "\t\t//true: terminal, false: nonterminal\n";
		file << "\t\tbool\telem;\n";
		file << "\n";
		file << "\t\t//terminal: index in SSLR_termName, nonterminal: index in SSLR_NTERM_STR\n";
		file << "\t\tint\t\tindex;\n";
		file << "\n";
		file << "\t}SSLR_debugStack;\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	file << "\n\n\n\t//private class variables\n\n\n\n";

	//Anzahl der Zustände
	file << "\t//Number of lr states\n";
	file << "\tstatic const unsigned long\tSSLR_anzLRStates = " << hulle_anz << ";\n\n";

	//Anzahl der Terminale
	file << "\t//Number of terminals = number of columns in lrTab\n";
	file << "\tstatic const unsigned long\tSSLR_anzTerm = " << termArrCount << ";\n\n";

	//Anzahl der Produktionen
	file << "\t//Number of productions = number of rows in jumpTab\n";
	file << "\tstatic const unsigned long\tSSLR_anzNTerm = " << prod_anz << ";\n\n";

	//Anzahl der Alternativen
	file << "\t//Number of alternatives\n";
	file << "\tstatic const unsigned long\tSSLR_anzProd = " << prod2_anz << ";\n\n";

	//Zustände in der LR-Tabelle
	file << "\n\t//Actions in lrTab\n";
	file << "\tstatic const int\t\t\tLR_ERROR = 1;\n";
	file << "\tstatic const int\t\t\tLR_SHIFT = 2;\n";
	file << "\tstatic const int\t\t\tLR_REDUCE = 3;\n";
	file << "\tstatic const int\t\t\tLR_ACCEPT = 4;\n\n";

	//Stack-Größe
	file << "\n\t//maximum stack size\n";
	file << "\tstatic const int\t\t\tSSLR_maxStackSize = 100;\n\n";


	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Breite der längsten rechten Seite aller Alternativen
		file << "\t//longest right side of all alternatives\n";
		file << "\tstatic const int\t\t\tSSLR_maxAltRightSideWidth = " << maxAltRightSideWidth << ";\n\n";

		//Breite des längsten Elements (Terminal/Nicht-Terminal)
		file << "\t//longest terminal or nonterminal\n";
		file << "\tstatic const int\t\t\tSSLR_maxElemWidth = " << maxElemWidth << ";\n\n";

		//Breite des größten Zustands
		file << "\t//longest state\n";
		file << "\tstatic const int\t\t\tSSLR_maxStateWidth = " << maxStateWidth << ";\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	/*
		Anzahl der erfolgreichen Reduktionen bzw. Shifts nach einem Fehler,
		um wieder Fehlermeldungen zu zeigen.
	*/
	file << "	//number of seccessful reduce - and shift actions\n";
	file << "	//neccassary after an error occured\n";
	file << "	static const int\t\t\tSSLR_anzSuppressErrorMsg = 3;\n";
	file << "\n";

	//Anzahl der erfolgreichen Reduktionen bzw. Shifts nach einem Fehler
	file << "	//number of seccessful reduce - and shift actions after an error occured\n";
	file << "	int\t\t\t\t\t\t\tSSLR_anzSuppressError;\n";
	file << "\n";


	//Stack für Zustände
	file << "\n";
	file << "	//parse stack\n";
	file << "	long\t\t\t\t\t\tSSLR_stack[SSLR_maxStackSize];\n";
	file << "\n";


	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Stack fürs Debugging
		file << "\t//debug stack\n";
		file << "\tSSLR_debugStack\t\t\t\tSSLR_dbgStack[SSLR_maxStackSize];\n\n";

		//Stack-Pointer fürs Debugging
		file << "\t//debug stack pointer\n";
		file << "\tlong\t\t\t\t\t\tSSLR_dbgSp;\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	file << "	//stack counter\n";
	file << "	long\t\t\t\t\t\tSSLR_sp;\n";
	file << "\n";
	file << "\n";

	//LR-Tabelle
	file << "\t//LR table\n";
	file << "\tstatic SSLR_LR_TAB\t\t\tSSLR_lrTab[SSLR_anzLRStates][SSLR_anzTerm];\n\n";

	//Sprung-Tabelle
	file << "\t//jump table\n";
	file << "\tstatic long\t\t\t\t\tSSLR_jumpTab[SSLR_anzLRStates][SSLR_anzNTerm];\n\n";

	//Scanner-Klasse
	file << "\t//scanner class\n";
	file << "\tSSLEXScanner *\t\t\t\tSSLR_scanner;\n\n";

	//array with all alternatives
	file << "\t//array with all alternatives\n";
	file << "\tstatic SSLR_NTERM_STR\t\tSSLR_ntermStr[SSLR_anzProd];\n\n";

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Array mit den Namen der Terminale
		file << "\t//array with the names of the terminals\n";
		file << "\tstatic char *\t\t\t\tSSLR_termName[SSLR_anzTerm];\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}


	//Typ des Terminals, dass der Scanner zurückliefert
	file << "	//current terminal\n";
	file << "	int\t\t\t\t\t\t\tSSLR_terminal;\n";
	file << "\n";

	//Atrribut des Terminals wie z.B. Zahlenwert
	file << "	//attributes returned form scanner\n";
	file << "	SSLR_TYPE\t\t\t\t\tSSLR_attributeStr;\n";
	file << "\n";

	//Zeile, in der ein Fehler auftrat
	file << "	//line number\n";
	file << "	unsigned long\t\t\t\tSSLR_line;\n";
	file << "\n";

	//aktueller Zustand des Parsers
	file << "	//current state\n";
	file << "	int\t\t\t\t\t\t\tSSLR_state;\n";
	file << "\n";

	//Anzahl der aufgetretenen Fehler
	file << "	//number of errors\n";
	file << "	int\t\t\t\t\t\t\tSSLR_anzError;\n";
	file << "\n";

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//semantische Aktionen, für Fehlerbehandlung
		file << "	//allow/deny semantic actions\n";
		file << "	bool\t\t\t\t\t\tSSLR_semAct;\n";
		file << "\n";
		file << "	//stack for semantic actions\n";
		file << "	SSLR_TYPE\t\t\t\t\tSSLR_semStack[SSLR_maxStackSize];\n";
		file << "\n";
		file << "	//stack counter for semantic action stack\n";
		file << "	unsigned int\t\t\t\tSSLR_semStackCnt;\n";
		file << "\n";
	}

	//Debug-Mode?
	if( argv_str->debug == true )
	{
		//die rechten Seiten
		file << "\t//Alternatives\n";

		//alle rechten Seiten (nur Debug)
		for( i = 0; i < prod2_anz; i++ )
		{
			//Zeiger auf PROD2_STR
			p2 = &prod2_str[i];

			//Zeiger auf PROD_STR
			p1 = &prod_str[p2->prod_index];

			//den Namen der Alternative holen
			name = hash_tab->getName( p1->hash_index );

			//Nummer der Alternative
			id = i - p1->prod2_index;

			//Namen generieren
			sprintf( puf1, "%s%d", name, id );

			//initialisieren
			file << "\tstatic char *\t\t\t\tSSLR_" << puf1 << "Ri[" << p2->riAnz << "];\n";
		}
	}

	//alle Follow-Mengen ausgeben
	file << "\n	//all follow sets for the error recovery\n";

	//alle Follow-Mengen ausgeben
	for( i = 0; i < prod_anz; i++ )
	{
		//Zeiger auf PROD_STR
		p1 = &prod_str[i];

		//den Namen der Alternative holen
		name = hash_tab->getName( p1->hash_index );

		//Anzahl der Follow-Elemente
		followAnz = hash_tab->getFollowAnz( p1->hash_index );

		//initialisieren
		file << "\tstatic long\t\t\t\t\tSSLR_" << name << "Follow[" << followAnz << "];\n";
	}

	//private Methoden
	file << "\n\n\t//private methods\n\n";


	//Methoden der Klasse
file << "\n";
file << "	//push a new state on parse stack\n";
file << "	void SSLR_push( long );\n";
file << "\n";
file << "	//pop elements from parse stack\n";
file << "	long SSLR_pop( int );\n";
file << "\n";
file << "	//begin parsing\n";
file << "	int SSLR_parse( void );\n";
file << "\n";
file << "	//shift a new state onto the parse stack\n";
file << "	void SSLR_shift( SSLR_LR_TAB * );\n";
file << "\n";
file << "	//reduce with a production\n";
file << "	void SSLR_reduce( SSLR_LR_TAB * );\n";
file << "\n";
file << "	//error handling\n";
file << "	void SSLR_error( void );\n";
file << "\n";
file << "	//print an error message, but only when it is allowed\n";
file << "	void SSLR_printErrorMsg( bool, char * );\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLR_DEBUG\n";

		//Ausgaberoutine für den Debug-Stack
		file << "	//print the debug stack SSLR_dbgStack\n";
		file << "	void SSLR_outputDbgStack( int, int, int, int );\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}

	//gibt es überhaupt Fehlerangaben?
	if( error_anz )
	{
		//ja, Hilfsroutinen ausgeben
		file << "	//shift a new state onto the parse stack\n";
		file << "	void SSLR_errShift( long );\n";
		file << "\n";
		file << "	//pop elements from the parse stack untill term may be shifted\n";
		file << "	void SSLR_errPop( long );\n";
		file << "\n";
		file << "	//delete next terminal\n";
		file << "	void SSLR_errDelete( void );\n";
		file << "\n";
		file << "	//delete all terminals untill term is found\n";
		file << "	void SSLR_errOverRead( long );\n";
		file << "\n";
	}

	//semantische Aktionen?
	if( semActCnt && ( unionStr->anz > 1 ) )
	{
		//ja, Prototypen ausgeben
		file << "\t//perform semantic actions associated with the production\n";
		file << "\t//to be reduced\n";
		file << "\tvoid SSLR_doSemAct( SSLR_LR_TAB * );\n";
		file << "\n";
	}

file << "	//get next terminal\n";
file << "	int SSLR_getTerminal( void );\n";
file << "\n";
file << "public:\n";
file << "\n";
file << "	//public methods \n";
file << "	SSLRParser( SSLEXScanner * );\n";
file << "	~SSLRParser();\n";
file << "\n";
file << "	//resets the whole parser\n";
file << "	void reset( void );\n";
file << "\n";
file << "	//start parsing\n";
file << "	int yyParse( void );\n";
file << "\n";
file << "\n";

	//benutzerdefinierte Daten holen
	userDefHeader = SSLR_scanner->getUserDefHeader( userDefHeaderCnt );

	//alle Zeilen
	for( j = 0; j < userDefHeaderCnt; j++ )
		//ausgeben
		file << userDefHeader[j];

file << "};\n";
file << "\n";
file << "\n";

	//Ende des Header-Files
	file << "#endif\n\n";
}

\}


