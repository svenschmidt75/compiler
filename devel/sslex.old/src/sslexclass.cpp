/***************************************************************************
                          sslexclass.cpp  -  description
                             -------------------
    begin                : Mon Feb 3 2003
    copyright            : (C) 2003 by Sven Schmidt
    email                : s.schmidt@lboro.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "sslexclass.h"
#include "sslex.h"




//mit Zustandsminimierung
#undef MINDEA
#define MINDEA


//gebe erweiterte Debug-Meldungen aus
#define DEBUG_LEVEL2
#undef DEBUG_LEVEL2





//Terminals for debugging
char *scannerToken[] =
{
	/*0*/ "CCE_GRAPH",
	/*1*/ "PLUS",
	/*2*/ "DEF",
	/*3*/ "SOPEN",
	/*4*/ "LA",
	/*5*/ "OR",
	/*6*/ "NAME",
	/*7*/ "KLCLOSE",
	/*8*/ "SPEC",
	/*9*/ "CCE_CNTRL",
	/*10*/ "XSCDECL",
	/*11*/ "SCALL",
	/*12*/ "CCE_UPPER",
	/*13*/ "COPEN",
	/*14*/ "CCE_XDIGIT",
	/*15*/ "CCLOSE",
	/*16*/ "BOPEN",
	/*17*/ "MINUS",
	/*18*/ "ENDLINE",
	/*19*/ "NUMBER",
	/*20*/ "MUL",
	/*21*/ "EOF_OP",
	/*22*/ "CCE_DIGIT",
	/*23*/ "CCE_ALPHA",
	/*24*/ "NEGATE",
	/*25*/ "KOMMA",
	/*26*/ "BCLOSE",
	/*27*/ "SCOPEN",
	/*28*/ "SCDECL",
	/*29*/ "CCE_ALNUM",
	/*30*/ "CCE_PUNCT",
	/*31*/ "NEWLINE",
	/*32*/ "CCE_PRINT",
	/*33*/ "CCE_SPACE",
	/*34*/ "CCE_LOWER",
	/*35*/ "BEGLINE",
	/*36*/ "CCE_BLANK",
	/*37*/ "KLOPEN",
	/*38*/ "EPSILON",
	/*39*/ "QUEST",
	/*40*/ "PREVCCL",
	/*41*/ "ANY",
	/*42*/ "CHAR",
	/*43*/ "SCCLOSE",
	/*44*/ "ACCEPT",
	0L
};


//syntax analyze table
LR_TAB ssLexClass::lr_tab[SSLR_STATE][TERM] = {
/* State 0 */
{ { 0, 0 },{ 0, 0 },{ LR_REDUCE, initlex_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initlex_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initlex_0 } },
/* State 1 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, start_0 } },
/* State 2 */
{ { 0, 0 },{ 0, 0 },{ LR_SHIFT, 4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_1 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_1 } },
/* State 3 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 6 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect2_1 } },
/* State 4 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_1 },
{ 0, 0 },{ LR_REDUCE, scsect1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_1 } },
/* State 5 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 } },
/* State 6 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },
{ LR_REDUCE, sc2_2 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ LR_REDUCE, sc2_2 } },
/* State 7 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_0 },
{ 0, 0 },{ LR_SHIFT, 12 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 11 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_0 } },
/* State 8 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, goal_0 } },
/* State 9 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 14 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },
{ LR_REDUCE, scon_2 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ LR_REDUCE, sect2_0 } },
/* State 10 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 16 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 11 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, startconddecl_0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 12 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, startconddecl_1 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 13 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 18 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },
{ LR_REDUCE, initforrule_0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 } },
/* State 14 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_stk_ptr_0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 20 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 15 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 21 },{ 0, 0 },{ LR_REDUCE, scsect1_0 },
{ 0, 0 },{ LR_REDUCE, scsect1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_0 } },
/* State 16 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },
{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 } },
/* State 17 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 25 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 23 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 18 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, sc2_2 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },
{ LR_REDUCE, sc2_2 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 } },
/* State 19 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 40 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 20 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 41 },{ 0, 0 } },
/* State 21 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },
{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 } },
/* State 22 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 42 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 23 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 24 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, flexrule_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 25 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, flexrule_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 26 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 27 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 46 },{ LR_SHIFT, 47 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 45 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rule_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 28 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ LR_REDUCE, re_1 },{ LR_REDUCE, re_1 },{ 0, 0 },{ LR_REDUCE, re_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, re_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 29 */
{ { 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, series_1 },{ LR_REDUCE, series_1 },{ LR_REDUCE, series_1 },{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 52 },
{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },{ LR_SHIFT, 49 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },{ LR_SHIFT, 51 },{ LR_REDUCE, series_1 },
{ LR_REDUCE, series_1 },{ LR_REDUCE, series_1 },{ 0, 0 },{ 0, 0 } },
/* State 30 */
{ { 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ LR_REDUCE, singleton_6 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_6 },
{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ LR_REDUCE, singleton_6 },
{ LR_REDUCE, singleton_6 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ 0, 0 } },
/* State 31 */
{ { 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ LR_REDUCE, singleton_7 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_7 },
{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ LR_REDUCE, singleton_7 },
{ LR_REDUCE, singleton_7 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ 0, 0 } },
/* State 32 */
{ { 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ LR_REDUCE, singleton_8 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_8 },
{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ LR_REDUCE, singleton_8 },
{ LR_REDUCE, singleton_8 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ 0, 0 } },
/* State 33 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, string_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, string_1 },{ 0, 0 },{ 0, 0 } },
/* State 34 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 35 */
{ { 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ LR_REDUCE, singleton_11 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_11 },
{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ LR_REDUCE, singleton_11 },
{ LR_REDUCE, singleton_11 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ 0, 0 } },
/* State 36 */
{ { LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ LR_SHIFT, 56 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },
{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 } },
/* State 37 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 57 },{ LR_SHIFT, 14 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },
{ LR_REDUCE, scon_2 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 } },
/* State 38 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 59 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 58 },{ 0, 0 } },
/* State 39 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ 0, 0 } },
/* State 40 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, sconname_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sconname_0 },{ 0, 0 } },
/* State 41 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },
{ LR_REDUCE, scon_1 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 } },
/* State 42 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, sc2_0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },
{ LR_REDUCE, sc2_0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ LR_REDUCE, sc2_0 } },
/* State 43 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, flexrule_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 44 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 60 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rule_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 45 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rule_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 46 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re2_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re2_0 },
{ LR_REDUCE, re2_0 },{ LR_REDUCE, re2_0 },{ 0, 0 },{ 0, 0 } },
/* State 47 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 48 */
{ { 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, series_0 },{ LR_REDUCE, series_0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 52 },
{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ LR_SHIFT, 49 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ LR_SHIFT, 51 },{ LR_REDUCE, series_0 },
{ LR_REDUCE, series_0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ 0, 0 } },
/* State 49 */
{ { 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ LR_REDUCE, singleton_0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },
{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ LR_REDUCE, singleton_0 },
{ LR_REDUCE, singleton_0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ 0, 0 } },
/* State 50 */
{ { 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ LR_REDUCE, singleton_1 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_1 },
{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ LR_REDUCE, singleton_1 },
{ LR_REDUCE, singleton_1 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ 0, 0 } },
/* State 51 */
{ { 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ LR_REDUCE, singleton_2 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_2 },
{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ LR_REDUCE, singleton_2 },
{ LR_REDUCE, singleton_2 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ 0, 0 } },
/* State 52 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 62 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 53 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 63 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 64 },{ 0, 0 },{ 0, 0 } },
/* State 54 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 65 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 55 */
{ { LR_SHIFT, 74 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 72 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 79 },{ 0, 0 },{ LR_SHIFT, 80 },{ LR_SHIFT, 66 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 73 },{ LR_SHIFT, 70 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 69 },{ LR_SHIFT, 77 },{ 0, 0 },{ LR_SHIFT, 76 },
{ LR_SHIFT, 78 },{ LR_SHIFT, 75 },{ 0, 0 },{ LR_SHIFT, 71 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 67 },{ 0, 0 },{ 0, 0 } },
/* State 56 */
{ { LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },
{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 } },
/* State 57 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, sc2_1 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },
{ LR_REDUCE, sc2_1 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ LR_REDUCE, sc2_1 } },
/* State 58 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },
{ LR_REDUCE, scon_0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 } },
/* State 59 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 40 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 60 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rule_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 61 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ LR_REDUCE, re_0 },{ LR_REDUCE, re_0 },{ 0, 0 },{ LR_REDUCE, re_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, re_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 62 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 83 },{ LR_SHIFT, 84 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 63 */
{ { 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ LR_REDUCE, singleton_9 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_9 },
{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ LR_REDUCE, singleton_9 },
{ LR_REDUCE, singleton_9 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ 0, 0 } },
/* State 64 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, string_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, string_0 },{ 0, 0 },{ 0, 0 } },
/* State 65 */
{ { 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ LR_REDUCE, singleton_10 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_10 },
{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ LR_REDUCE, singleton_10 },
{ LR_REDUCE, singleton_10 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ 0, 0 } },
/* State 66 */
{ { 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ LR_REDUCE, fullccl_0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },
{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ LR_REDUCE, fullccl_0 },
{ LR_REDUCE, fullccl_0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ 0, 0 } },
/* State 67 */
{ { LR_REDUCE, ccl_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ LR_REDUCE, ccl_1 },{ 0, 0 },
{ LR_SHIFT, 85 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ LR_REDUCE, ccl_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ LR_REDUCE, ccl_1 },
{ LR_REDUCE, ccl_1 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ 0, 0 } },
/* State 68 */
{ { LR_REDUCE, ccl_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ LR_REDUCE, ccl_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ LR_REDUCE, ccl_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ LR_REDUCE, ccl_2 },
{ LR_REDUCE, ccl_2 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ 0, 0 } },
/* State 69 */
{ { LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },
{ LR_REDUCE, ccl_expr_0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ 0, 0 } },
/* State 70 */
{ { LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },
{ LR_REDUCE, ccl_expr_1 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ 0, 0 } },
/* State 71 */
{ { LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },
{ LR_REDUCE, ccl_expr_2 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ 0, 0 } },
/* State 72 */
{ { LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },
{ LR_REDUCE, ccl_expr_3 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ 0, 0 } },
/* State 73 */
{ { LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },
{ LR_REDUCE, ccl_expr_4 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ 0, 0 } },
/* State 74 */
{ { LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },
{ LR_REDUCE, ccl_expr_5 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ 0, 0 } },
/* State 75 */
{ { LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },
{ LR_REDUCE, ccl_expr_6 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ 0, 0 } },
/* State 76 */
{ { LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },
{ LR_REDUCE, ccl_expr_7 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ 0, 0 } },
/* State 77 */
{ { LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },
{ LR_REDUCE, ccl_expr_8 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ 0, 0 } },
/* State 78 */
{ { LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },
{ LR_REDUCE, ccl_expr_9 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ 0, 0 } },
/* State 79 */
{ { LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },
{ LR_REDUCE, ccl_expr_10 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ 0, 0 } },
/* State 80 */
{ { LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },
{ LR_REDUCE, ccl_expr_11 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ 0, 0 } },
/* State 81 */
{ { LR_SHIFT, 74 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 72 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 79 },{ 0, 0 },{ LR_SHIFT, 80 },{ LR_SHIFT, 86 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 73 },{ LR_SHIFT, 70 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 69 },{ LR_SHIFT, 77 },{ 0, 0 },{ LR_SHIFT, 76 },
{ LR_SHIFT, 78 },{ LR_SHIFT, 75 },{ 0, 0 },{ LR_SHIFT, 71 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 67 },{ 0, 0 },{ 0, 0 } },
/* State 82 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ 0, 0 } },
/* State 83 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 87 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 88 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 84 */
{ { 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ LR_REDUCE, singleton_5 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_5 },
{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ LR_REDUCE, singleton_5 },
{ LR_REDUCE, singleton_5 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ 0, 0 } },
/* State 85 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 89 },{ 0, 0 },{ 0, 0 } },
/* State 86 */
{ { 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ LR_REDUCE, fullccl_1 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },
{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ LR_REDUCE, fullccl_1 },
{ LR_REDUCE, fullccl_1 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ 0, 0 } },
/* State 87 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 90 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 88 */
{ { 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ LR_REDUCE, singleton_4 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_4 },
{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ LR_REDUCE, singleton_4 },
{ LR_REDUCE, singleton_4 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ 0, 0 } },
/* State 89 */
{ { LR_REDUCE, ccl_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },
{ LR_REDUCE, ccl_0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ 0, 0 } },
/* State 90 */
{ { 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ LR_REDUCE, singleton_3 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_3 },
{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ LR_REDUCE, singleton_3 },
{ LR_REDUCE, singleton_3 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ 0, 0 } }
};


//Jump-Table
long ssLexClass::jump_tab[SSLR_STATE][NTERM] = {
//start, sconname, scon, rule, re2, sc2, flexrule, re, goal, fullccl,
//string, initforrule, initlex, series, ccl, startconddecl, sect1, sect2, scsect1, ccl_expr, singleton, namelist1, namelist2, scon_stk_ptr,

/* State 0 */
{  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  2,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 1 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 2 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 3,  0,  0,  0,  0,  0,  0,  0 },
/* State 3 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  5,  0,  0,  0,  0,  0,  0 },
/* State 4 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  7,  0,  0,  0,  0,  0 },
/* State 5 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 6 */
{  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 7 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 8 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 9 */
{  0,  0, 13,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 10 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0, 15,  0,  0 },
/* State 11 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 12 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 13 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 14 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0, 19 },
/* State 15 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 16 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 17 */
{  0,  0,  0, 24, 26,  0, 22, 27,  0, 31,  0,  0,  0, 28,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 18 */
{  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 19 */
{  0, 39,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0, 38,  0 },
/* State 20 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 21 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 22 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 23 */
{  0,  0,  0, 43, 26,  0,  0, 27,  0, 31,  0,  0,  0, 28,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 24 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 25 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 26 */
{  0,  0,  0,  0,  0,  0,  0, 44,  0, 31,  0,  0,  0, 28,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 27 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 28 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0, 31,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0, 48,  0,  0,  0 },
/* State 29 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 30 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 31 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 32 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 33 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 53,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 34 */
{  0,  0,  0,  0,  0,  0,  0, 54,  0, 31,  0,  0,  0, 28,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 35 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 36 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 55,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 37 */
{  0,  0, 13,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 38 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 39 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 40 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 41 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 42 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 43 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 44 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 45 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 46 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 47 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0, 31,  0,  0,  0, 61,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 48 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 49 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 50 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 51 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 52 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 53 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 54 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 55 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0, 68,  0,  0,  0,  0 },
/* State 56 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 81,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 57 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 58 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 59 */
{  0, 82,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 60 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 61 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0, 31,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0, 48,  0,  0,  0 },
/* State 62 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 63 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 64 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 65 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 66 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 67 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 68 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 69 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 70 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 71 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 72 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 73 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 74 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 75 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 76 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 77 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 78 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 79 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 80 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 81 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0, 68,  0,  0,  0,  0 },
/* State 82 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 83 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 84 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 85 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 86 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 87 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 88 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 89 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 90 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 }
};

//Follow-Sets for Error-Recovery

long ssLexClass::startFollow[1] = { ACCEPT };
long ssLexClass::goalFollow[1] = { ACCEPT };
long ssLexClass::initlexFollow[3] = { DEF, SPEC, ACCEPT };
long ssLexClass::sect1Follow[2] = { SPEC, ACCEPT };
long ssLexClass::scsect1Follow[4] = { SPEC, XSCDECL, ACCEPT, SCDECL };
long ssLexClass::startconddeclFollow[1] = { NAME };
long ssLexClass::namelist1Follow[5] = { NAME, SPEC, XSCDECL, ACCEPT, SCDECL };
long ssLexClass::sect2Follow[1] = { ACCEPT };
long ssLexClass::sc2Follow[12] = { SOPEN, ACCEPT, COPEN, BOPEN, EOF_OP, BCLOSE, SCOPEN, BEGLINE, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::initforruleFollow[9] = { SOPEN, ACCEPT, COPEN, EOF_OP, BEGLINE, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::flexruleFollow[1] = { NEWLINE };
long ssLexClass::scon_stk_ptrFollow[1] = { NAME };
long ssLexClass::sconFollow[9] = { SOPEN, COPEN, BOPEN, EOF_OP, BEGLINE, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::namelist2Follow[2] = { KOMMA, SCCLOSE };
long ssLexClass::sconnameFollow[2] = { KOMMA, SCCLOSE };
long ssLexClass::ruleFollow[1] = { NEWLINE };
long ssLexClass::reFollow[5] = { LA, OR, KLCLOSE, ENDLINE, NEWLINE };
long ssLexClass::re2Follow[6] = { SOPEN, COPEN, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::seriesFollow[11] = { SOPEN, LA, OR, KLCLOSE, COPEN, ENDLINE, NEWLINE, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::singletonFollow[15] = { PLUS, SOPEN, LA, OR, KLCLOSE, COPEN, BOPEN, ENDLINE, MUL, NEWLINE, KLOPEN, QUEST, PREVCCL, ANY, CHAR };
long ssLexClass::fullcclFollow[15] = { PLUS, SOPEN, LA, OR, KLCLOSE, COPEN, BOPEN, ENDLINE, MUL, NEWLINE, KLOPEN, QUEST, PREVCCL, ANY, CHAR };
long ssLexClass::cclFollow[14] = { CCE_GRAPH, CCE_CNTRL, CCE_UPPER, CCE_XDIGIT, CCLOSE, CCE_DIGIT, CCE_ALPHA, CCE_ALNUM, CCE_PUNCT, CCE_PRINT, CCE_SPACE, CCE_LOWER, CCE_BLANK, CHAR };
long ssLexClass::ccl_exprFollow[14] = { CCE_GRAPH, CCE_CNTRL, CCE_UPPER, CCE_XDIGIT, CCLOSE, CCE_DIGIT, CCE_ALPHA, CCE_ALNUM, CCE_PUNCT, CCE_PRINT, CCE_SPACE, CCE_LOWER, CCE_BLANK, CHAR };
long ssLexClass::stringFollow[2] = { SOPEN, CHAR };

//All Alternatives
char *ssLexClass::start0Ri[1] = { "goal" };
char *ssLexClass::goal0Ri[4] = { "initlex", "sect1", "sect2", "initforrule" };
char *ssLexClass::initlex0Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::sect10Ri[2] = { "\'DEF\'", "scsect1" };
char *ssLexClass::sect11Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::scsect10Ri[3] = { "scsect1", "startconddecl", "namelist1" };
char *ssLexClass::scsect11Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::startconddecl0Ri[1] = { "\'SCDECL\'" };
char *ssLexClass::startconddecl1Ri[1] = { "\'XSCDECL\'" };
char *ssLexClass::namelist10Ri[2] = { "namelist1", "\'NAME\'" };
char *ssLexClass::namelist11Ri[1] = { "\'NAME\'" };
char *ssLexClass::sect20Ri[2] = { "\'SPEC\'", "sc2" };
char *ssLexClass::sect21Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::sc20Ri[5] = { "sc2", "scon", "initforrule", "flexrule", "\'NEWLINE\'" };
char *ssLexClass::sc21Ri[5] = { "sc2", "scon", "\'BOPEN\'", "sc2", "\'BCLOSE\'" };
char *ssLexClass::sc22Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::initforrule0Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::flexrule0Ri[2] = { "\'BEGLINE\'", "rule" };
char *ssLexClass::flexrule1Ri[1] = { "rule" };
char *ssLexClass::flexrule2Ri[1] = { "\'EOF_OP\'" };
char *ssLexClass::scon_stk_ptr0Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::scon0Ri[4] = { "\'SCOPEN\'", "scon_stk_ptr", "namelist2", "\'SCCLOSE\'" };
char *ssLexClass::scon1Ri[3] = { "\'SCOPEN\'", "\'SCALL\'", "\'SCCLOSE\'" };
char *ssLexClass::scon2Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::namelist20Ri[3] = { "namelist2", "\'KOMMA\'", "sconname" };
char *ssLexClass::namelist21Ri[1] = { "sconname" };
char *ssLexClass::sconname0Ri[1] = { "\'NAME\'" };
char *ssLexClass::rule0Ri[2] = { "re2", "re" };
char *ssLexClass::rule1Ri[3] = { "re2", "re", "\'ENDLINE\'" };
char *ssLexClass::rule2Ri[2] = { "re", "\'ENDLINE\'" };
char *ssLexClass::rule3Ri[1] = { "re" };
char *ssLexClass::re0Ri[3] = { "re", "\'OR\'", "series" };
char *ssLexClass::re1Ri[1] = { "series" };
char *ssLexClass::re20Ri[2] = { "re", "\'LA\'" };
char *ssLexClass::series0Ri[2] = { "series", "singleton" };
char *ssLexClass::series1Ri[1] = { "singleton" };
char *ssLexClass::singleton0Ri[2] = { "singleton", "\'MUL\'" };
char *ssLexClass::singleton1Ri[2] = { "singleton", "\'PLUS\'" };
char *ssLexClass::singleton2Ri[2] = { "singleton", "\'QUEST\'" };
char *ssLexClass::singleton3Ri[6] = { "singleton", "\'BOPEN\'", "\'NUMBER\'", "\'KOMMA\'", "\'NUMBER\'", "\'BCLOSE\'" };
char *ssLexClass::singleton4Ri[5] = { "singleton", "\'BOPEN\'", "\'NUMBER\'", "\'KOMMA\'", "\'BCLOSE\'" };
char *ssLexClass::singleton5Ri[4] = { "singleton", "\'BOPEN\'", "\'NUMBER\'", "\'BCLOSE\'" };
char *ssLexClass::singleton6Ri[1] = { "\'ANY\'" };
char *ssLexClass::singleton7Ri[1] = { "fullccl" };
char *ssLexClass::singleton8Ri[1] = { "\'PREVCCL\'" };
char *ssLexClass::singleton9Ri[3] = { "\'SOPEN\'", "string", "\'SOPEN\'" };
char *ssLexClass::singleton10Ri[3] = { "\'KLOPEN\'", "re", "\'KLCLOSE\'" };
char *ssLexClass::singleton11Ri[1] = { "\'CHAR\'" };
char *ssLexClass::fullccl0Ri[3] = { "\'COPEN\'", "ccl", "\'CCLOSE\'" };
char *ssLexClass::fullccl1Ri[4] = { "\'COPEN\'", "\'NEGATE\'", "ccl", "\'CCLOSE\'" };
char *ssLexClass::ccl0Ri[4] = { "ccl", "\'CHAR\'", "\'MINUS\'", "\'CHAR\'" };
char *ssLexClass::ccl1Ri[2] = { "ccl", "\'CHAR\'" };
char *ssLexClass::ccl2Ri[2] = { "ccl", "ccl_expr" };
char *ssLexClass::ccl3Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::ccl_expr0Ri[1] = { "\'CCE_ALNUM\'" };
char *ssLexClass::ccl_expr1Ri[1] = { "\'CCE_ALPHA\'" };
char *ssLexClass::ccl_expr2Ri[1] = { "\'CCE_BLANK\'" };
char *ssLexClass::ccl_expr3Ri[1] = { "\'CCE_CNTRL\'" };
char *ssLexClass::ccl_expr4Ri[1] = { "\'CCE_DIGIT\'" };
char *ssLexClass::ccl_expr5Ri[1] = { "\'CCE_GRAPH\'" };
char *ssLexClass::ccl_expr6Ri[1] = { "\'CCE_LOWER\'" };
char *ssLexClass::ccl_expr7Ri[1] = { "\'CCE_PRINT\'" };
char *ssLexClass::ccl_expr8Ri[1] = { "\'CCE_PUNCT\'" };
char *ssLexClass::ccl_expr9Ri[1] = { "\'CCE_SPACE\'" };
char *ssLexClass::ccl_expr10Ri[1] = { "\'CCE_UPPER\'" };
char *ssLexClass::ccl_expr11Ri[1] = { "\'CCE_XDIGIT\'" };
char *ssLexClass::string0Ri[2] = { "string", "\'CHAR\'" };
char *ssLexClass::string1Ri[1] = { "\'EPSILON\'" };


//all alternatives
NTERM_STR ssLexClass::nterm_str[PROD] = {
{ "start", start0Ri, start, 1, startFollow, 1 },
{ "goal", goal0Ri, goal, 4, goalFollow, 1 },
{ "initlex", initlex0Ri, initlex, 0, initlexFollow, 3 },
{ "sect1", sect10Ri, sect1, 2, sect1Follow, 2 },
{ "sect1", sect11Ri, sect1, 0, sect1Follow, 2 },
{ "scsect1", scsect10Ri, scsect1, 3, scsect1Follow, 4 },
{ "scsect1", scsect11Ri, scsect1, 0, scsect1Follow, 4 },
{ "startconddecl", startconddecl0Ri, startconddecl, 1, startconddeclFollow, 1 },
{ "startconddecl", startconddecl1Ri, startconddecl, 1, startconddeclFollow, 1 },
{ "namelist1", namelist10Ri, namelist1, 2, namelist1Follow, 5 },
{ "namelist1", namelist11Ri, namelist1, 1, namelist1Follow, 5 },
{ "sect2", sect20Ri, sect2, 2, sect2Follow, 1 },
{ "sect2", sect21Ri, sect2, 0, sect2Follow, 1 },
{ "sc2", sc20Ri, sc2, 5, sc2Follow, 12 },
{ "sc2", sc21Ri, sc2, 5, sc2Follow, 12 },
{ "sc2", sc22Ri, sc2, 0, sc2Follow, 12 },
{ "initforrule", initforrule0Ri, initforrule, 0, initforruleFollow, 9 },
{ "flexrule", flexrule0Ri, flexrule, 2, flexruleFollow, 1 },
{ "flexrule", flexrule1Ri, flexrule, 1, flexruleFollow, 1 },
{ "flexrule", flexrule2Ri, flexrule, 1, flexruleFollow, 1 },
{ "scon_stk_ptr", scon_stk_ptr0Ri, scon_stk_ptr, 0, scon_stk_ptrFollow, 1 },
{ "scon", scon0Ri, scon, 4, sconFollow, 9 },
{ "scon", scon1Ri, scon, 3, sconFollow, 9 },
{ "scon", scon2Ri, scon, 0, sconFollow, 9 },
{ "namelist2", namelist20Ri, namelist2, 3, namelist2Follow, 2 },
{ "namelist2", namelist21Ri, namelist2, 1, namelist2Follow, 2 },
{ "sconname", sconname0Ri, sconname, 1, sconnameFollow, 2 },
{ "rule", rule0Ri, rule, 2, ruleFollow, 1 },
{ "rule", rule1Ri, rule, 3, ruleFollow, 1 },
{ "rule", rule2Ri, rule, 2, ruleFollow, 1 },
{ "rule", rule3Ri, rule, 1, ruleFollow, 1 },
{ "re", re0Ri, re, 3, reFollow, 5 },
{ "re", re1Ri, re, 1, reFollow, 5 },
{ "re2", re20Ri, re2, 2, re2Follow, 6 },
{ "series", series0Ri, series, 2, seriesFollow, 11 },
{ "series", series1Ri, series, 1, seriesFollow, 11 },
{ "singleton", singleton0Ri, singleton, 2, singletonFollow, 15 },
{ "singleton", singleton1Ri, singleton, 2, singletonFollow, 15 },
{ "singleton", singleton2Ri, singleton, 2, singletonFollow, 15 },
{ "singleton", singleton3Ri, singleton, 6, singletonFollow, 15 },
{ "singleton", singleton4Ri, singleton, 5, singletonFollow, 15 },
{ "singleton", singleton5Ri, singleton, 4, singletonFollow, 15 },
{ "singleton", singleton6Ri, singleton, 1, singletonFollow, 15 },
{ "singleton", singleton7Ri, singleton, 1, singletonFollow, 15 },
{ "singleton", singleton8Ri, singleton, 1, singletonFollow, 15 },
{ "singleton", singleton9Ri, singleton, 3, singletonFollow, 15 },
{ "singleton", singleton10Ri, singleton, 3, singletonFollow, 15 },
{ "singleton", singleton11Ri, singleton, 1, singletonFollow, 15 },
{ "fullccl", fullccl0Ri, fullccl, 3, fullcclFollow, 15 },
{ "fullccl", fullccl1Ri, fullccl, 4, fullcclFollow, 15 },
{ "ccl", ccl0Ri, ccl, 4, cclFollow, 14 },
{ "ccl", ccl1Ri, ccl, 2, cclFollow, 14 },
{ "ccl", ccl2Ri, ccl, 2, cclFollow, 14 },
{ "ccl", ccl3Ri, ccl, 0, cclFollow, 14 },
{ "ccl_expr", ccl_expr0Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr1Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr2Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr3Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr4Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr5Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr6Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr7Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr8Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr9Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr10Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr11Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "string", string0Ri, string, 2, stringFollow, 2 },
{ "string", string1Ri, string, 0, stringFollow, 2 }};



#ifdef SSLR_DEBUG

//Names of the Terminals
char *ssLexClass::term_name[TERM] =
{ "CCE_GRAPH", "PLUS", "DEF", "SOPEN", "LA", "OR", "NAME", "KLCLOSE", "SPEC", "CCE_CNTRL", "XSCDECL", "SCALL", "CCE_UPPER", "COPEN", "CCE_XDIGIT", "CCLOSE",
"BOPEN", "MINUS", "ENDLINE", "NUMBER", "MUL", "EOF_OP", "CCE_DIGIT", "CCE_ALPHA", "NEGATE", "KOMMA", "BCLOSE", "SCOPEN", "SCDECL", "CCE_ALNUM", "CCE_PUNCT", "NEWLINE",
"CCE_PRINT", "CCE_SPACE", "CCE_LOWER", "BEGLINE", "CCE_BLANK", "KLOPEN", "EPSILON", "QUEST", "PREVCCL", "ANY", "CHAR", "SCCLOSE", "ACCEPT" };

#endif




void ssLexClass::errShift( long termi )
{
	//shift a new state
	if( lr_tab[state][termi].state == LR_SHIFT )
		//Push new state
		Push( lr_tab[state][termi].value );
}


void ssLexClass::errDelete( void )
{
	//delete current terminal
	terminal = getTerminal();
}


void ssLexClass::errOverRead( long termi )
{
	//delete all terminals till term is found
	do
	{
		//get next terminal
		terminal = getTerminal();

		//equal?
		if( terminal == termi )
			//yes, return
			return;

		else if( terminal == ACCEPT )
		{
			//abort parsing
			state = 1;
			return;
		}

	}while( 1 );
}


void ssLexClass::error( void )
{
	//error-handling
	NTERM_STR	*n;
	long		*f, tmpState;
	int			fCnt = 0, i, rec = 0;

	//delete all terminals till one that follows the last nonterminal
	//the reduction was done with
	anzError++;

	//no semantic actions are allowed after errors
	semAct++;

	//state after reduction
	tmpState = errStr.state;

	//get a pointer to the NTERM_STR of the nonterminal
	n = &nterm_str[errStr.alt];

	//get the follow-terminals
	f = n->follow;

	//number of follow-terminals
	fCnt = n->followCnt;


	switch( state )
	{
		// sc2 ->  sc2  scon  'BOPEN' . sc2  'BCLOSE'
		case 18:
		{
			if( ( terminal == LA ) )
			{
				//show user-defined error message
				cerr << "line: " << line << ": Lookahead-Operator not allowed!";

				//delete terminals till NEWLINE ist the current Terminal
				OVERREAD( NEWLINE );

				//delete current Terminal
				DELETE();

				//skip automatic error recovery
				rec++;

			}

			break;
		}

		// namelist2 ->  namelist2 . 'KOMMA'  sconname
		case 38:
		{
				//show user-defined error message
				cerr << "line: " << line << ": Comma expected in start condition!";

			break;
		}

		// namelist2 ->  namelist2  'KOMMA' . sconname
		case 59:
		{
				//show user-defined error message
				cerr << "line: " << line << ": Name expected in start condition list!";

				//shift Terminal NAME
				SHIFT( NAME );

				//skip automatic error recovery
				rec++;

			break;
		}

		// sconname ->  'NAME' .
		case 40:
		{
				//show user-defined error message
				cerr << "line: " << line << ": Start conditions must be separated by a comma!";

				//delete terminals till SCCLOSE ist the current Terminal
				OVERREAD( SCCLOSE );

				//skip automatic error recovery
				rec++;

			break;
		}

		default:
		{
			//default error message
			cerr << "line: " << line << ": Syntax error!\n";
			break;
		}
	}


	//do the common error-recovery?
	if( !rec )
	{
		//yes, no user defined error-routines were made

		do
		{
			//is the current terminal ACCEPT?
			if( terminal == ACCEPT )
			{
				//abort parsing
				state = 1;
				return;
			}

			//equal?
			if( lr_tab[tmpState][terminal].state == LR_SHIFT )
			{
				//set state
				state = errStr.state;

				//set stack-position
				sp = errStr.sp;

				return;
			}

			//get next terminal
			terminal = getTerminal();

		}while( 1 );
	}

	return;
}


ssLexClass::ssLexClass( SSLEXScanner *scan, ARGV_STR *argv )
{
	//call reset to initialize the parser
	reset();

	//scanner-class
	s = scan;


	//Argumente
	argv_str = argv;
}


ssLexClass::~ssLexClass()
{
	//Speicher freigeben
	_temp();
}


void ssLexClass::_temp( void )
{
	//Speicher freigeben
	DEA_STATES	*dea;
	STATE_STR	*_s;
	NEA_STR		*nea;
	SC_STR		*sc, *_sc2;
	ulong		i, j, k, l;
	char		*tmp, **tmp2;

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//den Namen freigeben, INITIAL berspringen, da static
		if( i )
			delete[] ( sc->name );

		//Alle NEAen dieser SC
		for( j = 0; j < sc->neaArrCnt; j++ )
		{
			//Zeiger auf NEA
			nea = sc->neaArr[j];

			//Speicher freigeben?
			if( nea )
			{
				//Aktion
				if( nea->action )
				{
					//Adresse merken
					tmp2 = nea->action;

					//auch in anderen NEA_STR lschen
					for( k = i; k < scStrAnz; k++ )
					{
						//Zeiger auf SC
						_sc2 = &scStr[k];

						//Alle NEAen
						for( l = 0; l < _sc2->neaArrCnt; l++ )
						{
							//gleich?
							if( _sc2->neaArr[l] && ( _sc2->neaArr[l] != nea ) && ( _sc2->neaArr[l]->action == nea->action ) )
								//Ja, zurcksetzen
								_sc2->neaArr[l]->action = 0L;
						}
					}

					//Speicher freigeben
					deleteAction( nea );
				}

				//reg. Ausdruck als Text
				if( nea->regText )
				{
					//Adresse merken
					tmp = nea->regText;

					//auch in anderen NEA_STR lschen
					for( k = i; k < scStrAnz; k++ )
					{
						//Zeiger auf SC
						_sc2 = &scStr[k];

						//Alle NEAen
						for( l = 0; l < _sc2->neaArrCnt; l++ )
						{
							//gleich?
							if( _sc2->neaArr[l] && ( _sc2->neaArr[l]->regText == nea->regText ) )
								//Ja, zurcksetzen
								_sc2->neaArr[l]->regText = 0L;
						}
					}

					//Speicher freigeben
					delete[] ( tmp );

					//zurcksetzen
					nea->regText = 0L;
				}

				//NEA_STR auch in anderen SC
				for( k = i; k < scStrAnz; k++ )
				{
					//Zeiger auf SC
					_sc2 = &scStr[k];

					//Alle NEAen
					for( l = 0; l < _sc2->neaArrCnt; l++ )
					{
						//gleich?
						if( _sc2->neaArr[l] && ( _sc2->neaArr[l] == nea ) )
							//Ja, zurcksetzen
							_sc2->neaArr[l] = 0L;
					}
				}

				//NEA_STR freigeben
				delete( nea );
			}
		}

		//Array mit den NEAen freigeben
		if( sc->neaArr )
			delete[] ( sc->neaArr );

		//bergangstabellen mit den NEAen freigeben, die berall stehen drfen
		if( sc->DTran1 )
		{
			//Alle Zustnde
			for( j = 0; j < sc->DTran1Cnt; j++ )
			{
				delete[] ( sc->DTran1[j]->to );
				delete( sc->DTran1[j] );
			}

			//freigeben
			delete[] ( sc->DTran1 );
		}

		//bergangstabellen mit den NEAen freigeben, die ausschlielich am Zeilenanfang stehen drfen
		if( sc->DTran2 )
		{
			//Alle Zustnde
			for( j = 0; j < sc->DTran2Cnt; j++ )
			{
				delete[] ( sc->DTran2[j]->to );
				delete( sc->DTran2[j] );
			}

			//freigeben
			delete[] ( sc->DTran2 );
		}

		//Gruppe mit den NEAen freigeben, die berall stehen drfen
		if( sc->grp )
		{
			//Alle Zustnde
			for( j = 0; j < sc->grpCnt; j++ )
			{
				delete[] ( sc->grp[j]->DEAIndex );
				delete( sc->grp[j] );
			}

			//freigeben
			delete[] ( sc->grp );
		}
	}

	//Speicher der SC freigeben
	delete[] ( scStr );

	//Stack mit den SC?
	if( scStack )
		delete[] ( scStack );


	//die NEA-Zustnde freigeben?
	if( stateStr )
	{
		//alle NEA-Zustnde
		for( i = 0; i < stateStrCnt; i++ )
		{
			//Zeiger auf Zustand
			_s = stateStr[i];

			//gibt es berhaupt bergnge?
			if( _s->braStr )
			{
				//Zustandsbergnge freigeben
				for( j = 0; j < _s->braStrCnt; j++ )
				{
					//Zeichenklasse freigeben
					if( _s->braStr[j]->cclClass )
						//Zeichenklasse freigeben
						delete[] ( _s->braStr[j]->cclClass );

					//freigeben
					delete( _s->braStr[j] );
				}

				//Array mit den Zustandsbergngen freigeben
				delete[] ( _s->braStr );
			}

			//freigeben
			delete( _s );
		}

		//freigeben
		delete[] ( stateStr );
	}

	//die DEA-Zustnde freigeben?
	if( DEAStates )
	{
		//alle DEA-Zustnde
		for( i = 0; i < DEAStatesCnt; i++ )
		{
			//Zeiger auf DEA
			dea = DEAStates[i];

			//Zeiger mit den NEA-Zustnden freigeben
			delete[] ( dea->neaIndex );
			delete( dea );
		}

		//Speicher freigeben
		delete[] ( DEAStates );
	}

	//NEA-Stack freigeben?
	if( neaStack )
		delete[] ( neaStack );
}


void ssLexClass::reset( void )
{
	//resets the whole parser

	//Stack-Counter
	sp = 0;

	//start with state 0
	Push( 0 );
	state = 0;

	//no errors yet
	anzError = 0;

	/*
		Nach jedem regulrem Shift wird der aktuelle Zustand gespeichert, da zwar von einem LR-Parser
		niemals ein fehlerhaftes Terminal geschoben werden wird, wohl aber die eine oder andere
		Reduktion.
	*/
	errStr.alt = start_0;
	errStr.sp = sp;
	errStr.state = 0;

	//wenn semAct = 0, dann werden semantische Aktionen ausgefhrt
	semAct = 0;

	//counter for semantic-action-stack
	semStackCnt = 0;

	/*
		Nach einem Fehler mssen mind. ERR_SHIFT Terminale geschoben werden, damit keine
		Fehlerlawinen auftreten.
	*/
	regShift = true;
}


int ssLexClass::getTerminal( void )
{
	//semantic actions allowed?
	if( !semAct )
		//push attribute on Stack for semantic actions
		semStack[semStackCnt++] = attributeStr;

	//get next Terminal
	terminal = s->yyLex( &attributeStr );

	//get line
	line = s->getYYLineno();

	//Terminal zurckliefern
	return( terminal );
}


int ssLexClass::yyParse( void )
{
	//start parsing
	int			error;

	//get first terminal
	terminal = getTerminal();

	//start parsing
	error = Parse();

	//Fehler?
	if( !error )
	{
		//prfen, ob alle name definitions auch benutzt wurden
		s->checkRegExp();

		//Nein, aus den NEAen DEAen machen
		NEA2DEA();

		//finde Regeln, die nie ausgefhrt werden
		findNoRules();

#ifdef MINDEA
		//Zustandsmenge minimieren
		minDEA();
#endif

		//die bergangstabelle als C++-Code ausgeben
		generateFiles();

		//Informationen ausgeben?
		if( argv_str->verbose == true )
			//Ja
			outputInfo();
	}

	else
		//Meldung
		cout << "sslex: Terminate with " << error << " error(s)!\n";

	//Alles OK
	return( 0 );
}


void ssLexClass::Push( long ast )
{
	//Push a new state on stack
	stack[sp++] = ast;

	//stack-overflow?
	if( sp > MAX_STACK )
	{
		//stack-overflow
		cerr << "ssLexClass::push: Stack-overflow!\nExiting...\n";
		exit( 1 );
	}

	//new state
	state = ast;
}


long ssLexClass::Pop( int anz )
{
	//pop anz elements from stack
	sp -= anz;

	//Stack underflow?
	if( sp < 0 )
	{
		//stack underflow
		cerr << "ssLexClass::pop: Stack-underflow!\nExiting...\n";
		exit( 1 );
	}

	//return new state
	return( stack[sp - 1] );
}


int ssLexClass::Parse( void )
{
	//begin parsing

	while( 1 )
	{
		//end parsing?
		if( state == 1 )
		{
			//yes, is terminal ACCEPT
			if( terminal == ACCEPT )
				//yes
				return( anzError );

			else
			{
				//error
				cerr << "parser: bailing out...\n";
				return( anzError );
			}
		}

		//shift?
		else if( lr_tab[state][terminal].state == LR_SHIFT )
		{
			//yes
			Shift( &lr_tab[state][terminal] );

			//get new terminal
			terminal = getTerminal();
		}

		//reduce?
		else if( lr_tab[state][terminal].state == LR_REDUCE )
			//reduce
			Reduce( &lr_tab[state][terminal] );

		//must be an error
		else
			//Fehlerbehandlungs-Routine starten
			//error-recovery
			error();
	}
}


void ssLexClass::Shift( LR_TAB *tab )
{
	//Shift

#ifdef SSLR_DEBUG
	//output
	cout << "Shift\n";
	cout << "current state: " << state << "\n";
	cout << "current terminal: " << term_name[terminal] << "\n";
#endif

	//shift new state in stack
	Push( tab->value );


#ifdef SSLR_DEBUG
	//output
	cout << "shift new state " << state << "\n\n";
#endif
}


void ssLexClass::Reduce( LR_TAB *tab )
{
	//Reduce
	NTERM_STR	*n;

	//do semantic action
	doSemAct( tab );

	//get a pointer to the alternative
	n = &nterm_str[tab->value];

#ifdef SSLR_DEBUG
	//output
	cout << "Reduce\n";
	cout << "current state: " << state << "\n";
	cout << "current terminal: " << term_name[terminal] << "\n";
	cout << "reduce with ";

	//output alternative
	outputAlt( n );

	//output
	cout << "\n";
#endif

	//remove states form stack
	state = Pop( n->elem );

	//get new state
	state = jump_tab[state][n->jump_index];

	//push new state on stack
	Push( state );

#ifdef SSLR_DEBUG
	//output
	cout << "new state " << state << "\n\n";
#endif

	//for error-recovery
	errStr.alt = tab->value;
	errStr.sp = sp;
	errStr.state = state;
}


#ifdef SSLR_DEBUG
void ssLexClass::outputAlt( NTERM_STR *n )
{
	//output an alternative
	int	i;

	//name of alternative
	cout << n->name << " -> ";

	//output right side
	for( i = 0; i < n->elem; i++ )
		cout << n->ri[i] << " ";

	//EPSILON alternative?
	if( !n->elem )
		//yes
		cout << "'EPSILON'";
}
#endif




void ssLexClass::doSemAct( LR_TAB *tab )
{
	//do semantic actions before reduction
	NTERM_STR	*n;
	SSLR_TYPE	tmp;

	//semantic actions allowed?
	if( !semAct )
	{
		//get a pointer to the alternative
		n = &nterm_str[tab->value];

		//Alternative to reduce with
		switch( tab->value )
		{
			// goal ->  initlex  sect1  sect2  initforrule .
			case goal_0:
			{

	//Ende
				break;
			}

			// initlex ->  'EPSILON' .
			case initlex_0:
			{

	//SSLEX initialisieren

	//7- oder 8-Bit-Scanner
	cclWidth = argv_str->cclWidth;

	//noch keine NEA-Zustnde
	stateStrCnt = 0;
	stateStr = 0L;

	//noch keine NEA_STR auf Stack
	neaStackCnt = 0;
	neaStackMax = 0;
	neaStack = 0L;

	//SC-Stack
	scStack = 0L;

	//noch keine SC
	scStrAnz = 0;
	scStr = 0L;

	//keine Lookahead-Rules
	laUsed = false;

	//keine begin-of-line-Rules
	begLineUsed = false;

	//Regeln zhlen
	ruleCnt = 0;


	//Speicher fr NEA-Stack anfordern
	extendNEAStack();

	//SC INITIAL eintragen
	insertSC( "INITIAL", false );
				break;
			}

			// sect1 ->  'DEF'  scsect1 .
			case sect1_0:
			{

	//ab hier mssen alle SC definiert sein, nun Speicher fr den SC-Stack anfordern
	scStack = new( SC_STR *[scStrAnz] );
	scStackPos = 0;
				break;
			}

			// startconddecl ->  'SCDECL' .
			case startconddecl_0:
			{

	//ist eine inclusive SC
	xcluSC = false;
				break;
			}

			// startconddecl ->  'XSCDECL' .
			case startconddecl_1:
			{

	//ist eine exclusive SC
	xcluSC = true;
				break;
			}

			// namelist1 ->  namelist1  'NAME' .
			case namelist1_0:
			{

	//den Namen einer SC eintragen
	insertSC( semStack[semStackCnt - 1 - 2 + (2)].name, xcluSC );
				break;
			}

			// namelist1 ->  'NAME' .
			case namelist1_1:
			{

	//den Namen einer SC eintragen
	insertSC( semStack[semStackCnt - 1 - 1 + (1)].name, xcluSC );
				break;
			}

			// sc2 ->  sc2  scon  initforrule  flexrule  'NEWLINE' .
			case sc2_0:
			{

	//Position auf dem SC-Stack zurckgeben
	scStackPos = semStack[semStackCnt - 1 - 5 + (2)].i;
				break;
			}

			// sc2 ->  sc2  scon  'BOPEN'  sc2  'BCLOSE' .
			case sc2_1:
			{

	//Position auf dem SC-Stack zurckgeben
	scStackPos = semStack[semStackCnt - 1 - 5 + (2)].i;
				break;
			}

			// initforrule ->  'EPSILON' .
			case initforrule_0:
			{

	//es folgt ein reg. Ausdruck

	//erst einmal kein Lookahead-NEA
	trailingContext = false;
				break;
			}

			// flexrule ->  'BEGLINE'  rule .
			case flexrule_0:
			{

	NEA_STR	*nea = semStack[semStackCnt - 1 - 2 + (2)].neaStr;
	int		i;

	//Regeln zhlen
	ruleCnt++;

	//begin-of-line-Rules benutzt
	begLineUsed = true;

	//NEA darf nur am Anfang einer Zeile stehen
	nea->begLine = true;

	//die auszufhrende Aktion holen
	nea->action = s->getAction( nea->actionAnz );

	//den reg. Ausdruck als Text holen
	nea->regText = s->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

	//reg. Ausdruck ausgeben
	cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


	//Nun den NEA in die SC eintragen
	if( scStackPos )
	{
		//alle SC auf dem Stack
		for( i = 0; i < scStackPos; i++ )
			//eintragen
			insertSC( scStack[i], nea );
	}

	else
		//es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
		insertInclSC( nea );


	//Aktion |, d.h. die auszufhrende Aktion folgt spter?
	if( nea->action && ( nea->action[0][0] == '|' ) )
		//Ja, NEA auf Stack
		insertNEAStack( nea );

	else
	{
		//Aktion auch an andere NEAen weitergeben?
		if( neaStackCnt )
		{
			//Ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
			for( i = 0; i < neaStackCnt; i++ )
			{
				//den Speicher der alten Aktion freigeben
				deleteAction( neaStack[i] );

				//Aktionen anhngen
				neaStack[i]->action = nea->action;
				neaStack[i]->actionAnz = nea->actionAnz;
			}

			//Stack lschen
			neaStackCnt = 0;
		}
	}

	//auf Stack
	tmp.neaStr = nea;
				break;
			}

			// flexrule ->  rule .
			case flexrule_1:
			{

	NEA_STR	*nea = semStack[semStackCnt - 1 - 1 + (1)].neaStr;
	int		i;

	//Regeln zhlen
	ruleCnt++;

	//die auszufhrende Aktion holen
	nea->action = s->getAction( nea->actionAnz );

	//den reg. Ausdruck als Text holen
	nea->regText = s->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

	//reg. Ausdruck ausgeben
	cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


	//Nun den NEA in die SC eintragen
	if( scStackPos )
	{
		//alle SC auf dem Stack
		for( i = 0; i < scStackPos; i++ )
			//eintragen
			insertSC( scStack[i], nea );
	}

	else
		//es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
		insertInclSC( nea );


	//Aktion |, d.h. die auszufhrende Aktion folgt spter?
	if( nea->action && ( nea->action[0][0] == '|' ) )
		//Ja, NEA auf Stack
		insertNEAStack( nea );

	else
	{
		//Aktion auch an andere NEAen weitergeben?
		if( neaStackCnt )
		{
			//Ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
			for( i = 0; i < neaStackCnt; i++ )
			{
				//den Speicher der alten Aktion freigeben
				deleteAction( neaStack[i] );

				//Aktionen anhngen
				neaStack[i]->action = nea->action;
				neaStack[i]->actionAnz = nea->actionAnz;
			}

			//Stack lschen
			neaStackCnt = 0;
		}
	}

	//auf Stack
	tmp.neaStr = nea;
				break;
			}

			// flexrule ->  'EOF_OP' .
			case flexrule_2:
			{

	//ist eine Regel, die am Ende der gesamten Eingabe ausgefhrt wird
	NEA_STR	*nea;
	int		i;

	//Regeln zhlen
	ruleCnt++;

	//einen NEA erzeugen
	nea = getNewNEA();

	//ein EOF-NEA
	nea->eof = true;

	//die auszufhrende Aktion holen
	nea->action = s->getAction( nea->actionAnz );

	//den reg. Ausdruck als Text holen
	nea->regText = s->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

	//reg. Ausdruck ausgeben
	cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


	//Nun den NEA in die SC eintragen
	if( scStackPos )
	{
		//alle SC auf dem Stack
		for( i = 0; i < scStackPos; i++ )
			//eintragen
			insertSC( scStack[i], nea );
	}

	else
		//es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
		insertInclSC( nea );


	//Aktion |, d.h. die auszufhrende Aktion folgt spter?
	if( nea->action && ( nea->action[0][0] == '|' ) )
		//Ja, NEA auf Stack
		insertNEAStack( nea );

	else
	{
		//Aktion auch an andere NEAen weitergeben?
		if( neaStackCnt )
		{
			//Ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
			for( i = 0; i < neaStackCnt; i++ )
			{
				//den Speicher der alten Aktion freigeben
				deleteAction( neaStack[i] );

				//Aktionen anhngen
				neaStack[i]->action = nea->action;
				neaStack[i]->actionAnz = nea->actionAnz;
			}

			//Stack lschen
			neaStackCnt = 0;
		}
	}

	//auf Stack
	tmp.neaStr = nea;
				break;
			}

			// scon_stk_ptr ->  'EPSILON' .
			case scon_stk_ptr_0:
			{

	//Position auf dem SC-Stack zurckgeben
	tmp.i = scStackPos;
				break;
			}

			// scon ->  'SCOPEN'  scon_stk_ptr  namelist2  'SCCLOSE' .
			case scon_0:
			{

	//Position auf dem SC-Stack zurckgeben
	tmp.i = semStack[semStackCnt - 1 - 4 + (2)].i;
				break;
			}

			// scon ->  'SCOPEN'  'SCALL'  'SCCLOSE' .
			case scon_1:
			{

	//regulren Ausdruck in alle SC eintragen
	SC_STR	*sc;
	int		i, j;

	//Position merken
	tmp.i = scStackPos;

	//Ja, wurde sie schon auf dem Stack gepackt?
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger
		sc = &scStr[i];

		//nur die eintragen, die nicht schon auf dem Stack sind
		for( j = 0; j < scStackPos; j++ )
		{
			//gleich?
			if( sc == scStack[j] )
				//Ja
				break;
		}

		//war die SC schon auf dem Stack?
		if( j == scStackPos )
			//Zeiger auf SC auf Stack
			scStack[scStackPos++] = &scStr[i];
	}
				break;
			}

			// scon ->  'EPSILON' .
			case scon_2:
			{

	//Position auf dem SC-Stack zurckgeben
	tmp.i = scStackPos;
				break;
			}

			// sconname ->  'NAME' .
			case sconname_0:
			{

	//den Namen einer SC auf den SC-Stack packen, zu der der folgende reg. Ausdruck gehren soll
	int	scIndex, i;

	//Wurde die SC berhaupt definiert?
	if( ( scIndex = lookupSC( semStack[semStackCnt - 1 - 1 + (1)].name ) ) >= 0 )
	{
		//Ja, wurde sie schon auf dem Stack gepackt?
		for( i = 0; i < scStackPos; i++ )
		{
			//gleich?
			if( !strcmp( scStack[i]->name, semStack[semStackCnt - 1 - 1 + (1)].name ) )
			{
				//Ja, Meldung
				cerr << "sslex: line " << line << ": Start condition " << semStack[semStackCnt - 1 - 1 + (1)].name << " already on Stack!\n";

				//raus hier
				break;
			}
		}

		//War sie schon auf dem Stack?
		if( i == scStackPos )
			//Nein
			scStack[scStackPos++] = &scStr[scIndex];
	}

	else
	{
		//Nein, Fehler
		cerr << "sslex: line " << line << ": Start condition " << semStack[semStackCnt - 1 - 1 + (1)].name << " not definied!\n";

		//Fehler
		err++;
	}

	//Speicher freigeben
	delete[] ( semStack[semStackCnt - 1 - 1 + (1)].name );
				break;
			}

			// rule ->  re2  re .
			case rule_0:
			{

	//Lookahead-NEA
	NEA_STR	*nea;
	ulong	index = semStack[semStackCnt - 1 - 2 + (1)].neaStr->endState;

	//Lookahead-Rule benutzt
	laUsed = true;

	//NEAen verlinken
	nea = mkLink( semStack[semStackCnt - 1 - 2 + (1)].neaStr, semStack[semStackCnt - 1 - 2 + (2)].neaStr );

	//den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ndern
	setState( nea, index, MARK_AS_LA );

	//ist ein Lookahead-NEA
	nea->laState = true;

	//NEAen auf Stack
	tmp.neaStr = nea;
				break;
			}

			// rule ->  re2  re  'ENDLINE' .
			case rule_1:
			{

	/*
		reg. Ausdruck nur am Zeilenende, aber zweimal trailing context
	*/
	NEA_STR	*nea;
	ulong	index = semStack[semStackCnt - 1 - 3 + (2)].neaStr->endState;
	int		*cclStr;

	//Lookahead-Rule benutzt
	laUsed = true;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//newline
	cclAdd( cclStr, '\n' );

	//beide NEAen verlinken
	nea = mkLink( semStack[semStackCnt - 1 - 3 + (1)].neaStr, semStack[semStackCnt - 1 - 3 + (2)].neaStr );

	//nun einen Zustandsbergang erzeugen
	mkBranch( nea, cclStr, false );

	//den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ndern
	setState( nea, index, MARK_AS_LA );

	//ist ein Lookahead-NEA
	nea->laState = true;

	//NEAen auf Stack
	tmp.neaStr = nea;

	//Fehler-Meldung ausgeben
	cerr << "sslex: line " << line << ": Trailing context used twice!\n";

	//Fehler
	err++;
				break;
			}

			// rule ->  re  'ENDLINE' .
			case rule_2:
			{

	//reg. Ausdruck nur am Zeilenende
	ulong	index = semStack[semStackCnt - 1 - 2 + (1)].neaStr->endState;
	int		*cclStr;

	//Lookahead-Rule benutzt
	laUsed = true;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//newline
	cclAdd( cclStr, '\n' );

	//nun einen Zustandsbergang erzeugen
	mkBranch( semStack[semStackCnt - 1 - 2 + (1)].neaStr, cclStr, false );

	//den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ndern
	setState( semStack[semStackCnt - 1 - 2 + (1)].neaStr, index, MARK_AS_LA );

	//ist ein Lookahead-NEA
	semStack[semStackCnt - 1 - 2 + (1)].neaStr->laState = true;

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 2 + (1)].neaStr;
				break;
			}

			// rule ->  re .
			case rule_3:
			{

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 1 + (1)].neaStr;
				break;
			}

			// re ->  re  'OR'  series .
			case re_0:
			{

	//NEAen verodern
	tmp.neaStr = mkor( semStack[semStackCnt - 1 - 3 + (1)].neaStr, semStack[semStackCnt - 1 - 3 + (3)].neaStr );
				break;
			}

			// re ->  series .
			case re_1:
			{

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 1 + (1)].neaStr;
				break;
			}

			// re2 ->  re  'LA' .
			case re2_0:
			{

	//Lookahead-NEA

	//ist ein Lookahead-NEA
	semStack[semStackCnt - 1 - 2 + (1)].neaStr->laState = true;

	//NEA auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 2 + (1)].neaStr;
				break;
			}

			// series ->  series  singleton .
			case series_0:
			{

	//NEAen auf Stack
	tmp.neaStr = mkLink( semStack[semStackCnt - 1 - 2 + (1)].neaStr, semStack[semStackCnt - 1 - 2 + (2)].neaStr );
				break;
			}

			// series ->  singleton .
			case series_1:
			{

	//NEA auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 1 + (1)].neaStr;
				break;
			}

			// singleton ->  singleton  'MUL' .
			case singleton_0:
			{

	//NEA beliebig oft
	tmp.neaStr = mkClos( semStack[semStackCnt - 1 - 2 + (1)].neaStr );
				break;
			}

			// singleton ->  singleton  'PLUS' .
			case singleton_1:
			{

	//NEA hchstens einmal ausfhren
	tmp.neaStr = mkPosClos( semStack[semStackCnt - 1 - 2 + (1)].neaStr );
				break;
			}

			// singleton ->  singleton  'QUEST' .
			case singleton_2:
			{

	//NEA ist optional
	tmp.neaStr = mkOpt( semStack[semStackCnt - 1 - 2 + (1)].neaStr );
				break;
			}

			// singleton ->  singleton  'BOPEN'  'NUMBER'  'KOMMA'  'NUMBER'  'BCLOSE' .
			case singleton_3:
			{

	//NEA vervielfachen

	//Wert OK?
	if( ( semStack[semStackCnt - 1 - 6 + (3)].l > semStack[semStackCnt - 1 - 6 + (5)].l ) || ( semStack[semStackCnt - 1 - 6 + (3)].l <= 0 ) )
	{
		//Fehler
		cerr << "sslex: line " << line << ": Bad iteration values!\n";

		//Fehler
		err++;

		//auf Stack
		tmp.neaStr = semStack[semStackCnt - 1 - 6 + (1)].neaStr;
	}

	else
	{
		//optional?
		if( semStack[semStackCnt - 1 - 6 + (3)].l == 0 )
		{
			//negativ?
			if( semStack[semStackCnt - 1 - 6 + (5)].l <= 0 )
			{
				//Fehler
				cerr << "sslex: line " << line << ": Bad iteration values!\n";

				//Fehler
				err++;

				//auf Stack
				tmp.neaStr = semStack[semStackCnt - 1 - 6 + (1)].neaStr;
			}

			else
				//NEA vervielfachen
				tmp.neaStr = mkRepeat( semStack[semStackCnt - 1 - 6 + (1)].neaStr, semStack[semStackCnt - 1 - 6 + (3)].l, semStack[semStackCnt - 1 - 6 + (5)].l );
		}

		else
			//NEA vervielfachen
			tmp.neaStr = mkRepeat( semStack[semStackCnt - 1 - 6 + (1)].neaStr, semStack[semStackCnt - 1 - 6 + (3)].l, semStack[semStackCnt - 1 - 6 + (5)].l );
	}
				break;
			}

			// singleton ->  singleton  'BOPEN'  'NUMBER'  'KOMMA'  'BCLOSE' .
			case singleton_4:
			{

	//NEA vervielfachen

	//Wert OK?
	if( semStack[semStackCnt - 1 - 5 + (3)].l <= 0 )
	{
		//Fehler
		cerr << "sslex: line " << line << ": Iteration value must be positive!\n";

		//Fehler
		err++;

		//auf Stack
		tmp.neaStr = semStack[semStackCnt - 1 - 5 + (1)].neaStr;
	}

	else
		//NEA vervielfachen
		tmp.neaStr = mkRepeat( semStack[semStackCnt - 1 - 5 + (1)].neaStr, semStack[semStackCnt - 1 - 5 + (3)].l, _INFINITY );
				break;
			}

			// singleton ->  singleton  'BOPEN'  'NUMBER'  'BCLOSE' .
			case singleton_5:
			{

	//NEA vervielfachen

	//Wert OK?
	if( semStack[semStackCnt - 1 - 4 + (3)].l <= 0 )
	{
		//Fehler
		cerr << "sslex: line " << line << ": Iteration value must be positive!\n";

		//Fehler
		err++;

		//auf Stack
		tmp.neaStr = semStack[semStackCnt - 1 - 4 + (1)].neaStr;
	}

	else
		//NEA vervielfachen
		tmp.neaStr = mkRepeat( semStack[semStackCnt - 1 - 4 + (1)].neaStr, semStack[semStackCnt - 1 - 4 + (3)].l );
				break;
			}

			// singleton ->  'ANY' .
			case singleton_6:
			{

	NEA_STR		*nea;
	int			*cclClass;

	//einen NEA erzeugen
	nea = getNewNEA();

	//eine Zeichenklasse anlegen
	cclClass = cclAny();

	//Zustands-bergang erzeugen
	mkBranch( nea, cclClass, false );

	//NEAen auf Stack
	tmp.neaStr = nea;
				break;
			}

			// singleton ->  fullccl .
			case singleton_7:
			{

	NEA_STR		*nea;

	//einen NEA erzeugen
	nea = getNewNEA();

	//Zustands-bergang erzeugen
	mkBranch( nea, semStack[semStackCnt - 1 - 1 + (1)].cclClass, false );

	//NEAen auf Stack
	tmp.neaStr = nea;
				break;
			}

			// singleton ->  'SOPEN'  string  'SOPEN' .
			case singleton_9:
			{

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 3 + (2)].neaStr;
				break;
			}

			// singleton ->  'KLOPEN'  re  'KLCLOSE' .
			case singleton_10:
			{

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 3 + (2)].neaStr;
				break;
			}

			// singleton ->  'CHAR' .
			case singleton_11:
			{

	NEA_STR		*nea;
	int			*cclClass;

	//einen NEA erzeugen
	nea = getNewNEA();

	//eine Zeichenklasse anlegen
	cclClass = cclInit();

	//Zeichen hinzufgen
	cclAdd( cclClass, semStack[semStackCnt - 1 - 1 + (1)].character );

	//Zustands-bergang erzeugen
	mkBranch( nea, cclClass, false );

	//NEAen auf Stack
	tmp.neaStr = nea;
				break;
			}

			// fullccl ->  'COPEN'  ccl  'CCLOSE' .
			case fullccl_0:
			{

	//Zeichenklasse bernehmen
	tmp.cclClass = semStack[semStackCnt - 1 - 3 + (2)].cclClass;
				break;
			}

			// fullccl ->  'COPEN'  'NEGATE'  ccl  'CCLOSE' .
			case fullccl_1:
			{

	//Zeichenklasse negieren
	tmp.cclClass = cclNegate( semStack[semStackCnt - 1 - 4 + (3)].cclClass );
				break;
			}

			// ccl ->  ccl  'CHAR'  'MINUS'  'CHAR' .
			case ccl_0:
			{

	char	upper, lower;

	//Grenzen OK?
	if( semStack[semStackCnt - 1 - 4 + (2)].character > semStack[semStackCnt - 1 - 4 + (4)].character )
	{
		//Fehler
		cerr << "sslex: line " << line << ": Wrong limits in character class!\n";

		//umdrehen
		lower = semStack[semStackCnt - 1 - 4 + (4)].character;
		upper = semStack[semStackCnt - 1 - 4 + (2)].character;

		//Fehler
		err++;
	}

	else
	{
		//Limits OK
		upper = semStack[semStackCnt - 1 - 4 + (4)].character;
		lower = semStack[semStackCnt - 1 - 4 + (2)].character;
	}

	//einen Zeichenbereich erzeugen
	tmp.cclClass = cclAddRange( semStack[semStackCnt - 1 - 4 + (1)].cclClass, lower, upper );
				break;
			}

			// ccl ->  ccl  'CHAR' .
			case ccl_1:
			{

	//ein Zeichen zu einer Zeichenklasse hinzufgen
	tmp.cclClass = cclAdd( semStack[semStackCnt - 1 - 2 + (1)].cclClass, semStack[semStackCnt - 1 - 2 + (2)].character );
				break;
			}

			// ccl ->  ccl  ccl_expr .
			case ccl_2:
			{

	//bernehmen
	tmp.cclClass = cclAdd( semStack[semStackCnt - 1 - 2 + (1)].cclClass, semStack[semStackCnt - 1 - 2 + (2)].cclClass );

	//zweite Zeichenklasse freigeben
	delete[] ( semStack[semStackCnt - 1 - 2 + (2)].cclClass );
				break;
			}

			// ccl ->  'EPSILON' .
			case ccl_3:
			{

	//Zeichenklasse anfordern
	tmp.cclClass = cclInit();
				break;
			}

			// ccl_expr ->  'CCE_ALNUM' .
			case ccl_expr_0:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isalnum
	cclClass( cclStr, CCE_ALNUM );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_ALPHA' .
			case ccl_expr_1:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isalpha
	cclClass( cclStr, CCE_ALPHA );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_BLANK' .
			case ccl_expr_2:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isblank
	cclClass( cclStr, CCE_BLANK );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_CNTRL' .
			case ccl_expr_3:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//iscntrl
	cclClass( cclStr, CCE_CNTRL );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_DIGIT' .
			case ccl_expr_4:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isdigit
	cclClass( cclStr, CCE_DIGIT );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_GRAPH' .
			case ccl_expr_5:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isgraph
	cclClass( cclStr, CCE_GRAPH );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_LOWER' .
			case ccl_expr_6:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//islower
	cclClass( cclStr, CCE_LOWER );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_PRINT' .
			case ccl_expr_7:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isprint
	cclClass( cclStr, CCE_PRINT );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_PUNCT' .
			case ccl_expr_8:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//ispunct
	cclClass( cclStr, CCE_PUNCT );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_SPACE' .
			case ccl_expr_9:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isspace
	cclClass( cclStr, CCE_SPACE );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_UPPER' .
			case ccl_expr_10:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isupper
	cclClass( cclStr, CCE_UPPER );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_XDIGIT' .
			case ccl_expr_11:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isxdigit
	cclClass( cclStr, CCE_XDIGIT );

	//bergeben
	tmp.cclClass = cclStr;
				break;
			}

			// string ->  string  'CHAR' .
			case string_0:
			{

	//zwei NEAen verlinken
	NEA_STR		*nea;
	int			*cclClass;

	//einen NEA erzeugen
	nea = getNewNEA();

	//eine Zeichenklasse anlegen
	cclClass = cclInit();

	//Zeichen hinzufgen
	cclAdd( cclClass, semStack[semStackCnt - 1 - 2 + (2)].character );

	//Zustands-bergang erzeugen
	mkBranch( nea, cclClass, false );

	//beide NEAen verknpfen
	tmp.neaStr = mkLink( semStack[semStackCnt - 1 - 2 + (1)].neaStr, nea );
				break;
			}

			// string ->  'EPSILON' .
			case string_1:
			{

	//einen NEA erzeugen
	tmp.neaStr = getNewNEA();
				break;
			}

//			default:
				//error
//				cerr << "ssLexClass::doSemAct: Unknown Alternative " << tab->value << "!\n";
		}

		//correct stack-pointer
		semStackCnt -= n->elem;

		//push last value on stack
		semStack[semStackCnt++] = tmp;
	}
}


void ssLexClass::deleteAction( NEA_STR *nea )
{
	//den Speicher der Aktionen eines NEA freigeben
	int	i;

	//gibt es berhaupt welche?
	if( nea->actionAnz )
	{
		//Alle Eintrge
		for( i = 0; i < nea->actionAnz; i++ )
			//Speicher freigeben
			delete[] ( nea->action[i] );

		//Speicher freigeben
		delete[] ( nea->action );

		//initialisieren
		nea->action = 0L;
		nea->actionAnz = 0;
	}
}


NEA_STR *ssLexClass::getNewNEA( void )
{
	//einen neuen NEA anfordern
	NEA_STR	*nea;
	ulong	state;

	//Speicher anfordern
	nea = new( NEA_STR );

	//initialisieren
	nea->regText = 0L;
	nea->action = 0L;
	nea->laState = false;
	nea->eof = false;
	nea->begLine = false;
	nea->line = 0;

	//mit einen epsilon-Zustand initialisieren
	state = getNewState( nea );

	//ist erster Zustand dieses NEA
	nea->startState = state;
	nea->endState = state;

	//Zustand ist Finit-Zustand
	setState( nea, state, MARK_AS_FINIT );

	//zurckliefern
	return( nea );
}


ulong ssLexClass::getNewState( NEA_STR *nea )
{
	//einen neuen Zustand anfordern
	STATE_STR	**tmp, *s;
	ulong		index;

	//genug Speicher anfordern
	tmp = new( STATE_STR *[stateStrCnt + 1] );

	//kopieren
	memcpy( tmp, stateStr, sizeof( STATE_STR * ) * stateStrCnt );

	//alten Speicherbereich freigeben
	if( stateStr )
		delete[] ( stateStr );

	//neue Adresse
	stateStr = tmp;

	//Speicher fr die eigentliche STATE_STR anfordern
	s = new( STATE_STR );

	//Zeiger
	stateStr[stateStrCnt] = s;

	//Index merken
	index = stateStrCnt++;

	//Index merken
	s->state = index;

	//initialisieren
	s->braStrCnt = 0;
	s->braStr = 0L;
	s->eps = false;
	s->finit = false;
	s->la = false;
	s->isUseful = false;

	//den zugehrigen NEA eintragen
	s->nea = nea;

	//Index in stateStr zurckliefern
	return( index );
}


int *ssLexClass::cclInit( void )
{
	//neue Zeichenklasse anfordern
	int	*tmp;

	//Speicher fr Zeichenklasse
	tmp = new( int[cclWidth] );

	//initialisieren
	memset( tmp, 0, sizeof( int ) * cclWidth );

	//zurckliefern
	return( tmp );
}


int *ssLexClass::cclAny( void )
{
	//eine Zeichenklasse gem. . (any-char) erzeugen
	int		*tmp;

	//Zeichenklasse initialisieren
	tmp = cclInit();

	//alle bis auf \n
	cclAdd( tmp, '\n' );

	//negieren
	cclNegate( tmp );

	//zurckliefern
	return( tmp );
}


int *ssLexClass::cclAddRange( int *cclStr, uchar from, uchar to )
{
	//einen Bereich wie [a-z] eintragen
	uchar	i;

	//alle Zeichen eintragen
	for( i = from; i <= to; i++ )
		//hinzufgen
		cclAdd( cclStr, i );

	//zurckliefern
	return( cclStr );
}


int *ssLexClass::cclAdd( int *cclStr, uchar c )
{
	//ein Zeichen zu einer Zeichenklasse hinzufgen

	//Zeichen zu gro?
	if( ( c > 127 ) && ( cclWidth == _7BIT ) )
		//Fehlermeldung
		cerr << "ssLexClass::cclAdd: Line " << line << ": Character " << c << " needs an 8 bit scanner!\n";

	else
		//eintragen
		cclStr[c] = 1;

	//zurckliefern
	return( cclStr );
}


int *ssLexClass::cclAdd( int *cclStr1, int *cclStr2 )
{
	//eine Zeichenklasse an eine andere anfgen
	int	i;

	//alle Zeichen eintragen
	for( i = 0; i < cclWidth; i++ )
	{
		//Zeichen in zweiter Zeichenklasse gesetzt?
		if( cclStr2[i] )
			//ja, zur ersten hinzufgen
			cclAdd( cclStr1, i );
	}

	//zurckliefern
	return( cclStr1 );
}


int *ssLexClass::cclNegate( int *cclStr )
{
	//eine Zeichenklasse negieren
	int	i;

	//Alle Positionen
	for( i = 0; i < cclWidth; i++ )
		//gesetzt?
		cclStr[i] = !cclStr[i];

	//zurckliefern
	return( cclStr );
}


int *ssLexClass::cclCopy( int *cclClass )
{
	//eine Zeichenklasse kopieren
	int	*tmp;

	//ist berhuapt etwas zu kopieren?
	if( cclClass )
	{
		//Speicher fr Zeichenklasse
		tmp = new( int[cclWidth] );

		//kopieren
		memcpy( tmp, cclClass, sizeof( int ) * cclWidth );
	}

	else
		//nein
		tmp = 0L;

	//zurckliefern
	return( tmp );
}


int *ssLexClass::cclClass( int *cclStr, int type )
{
	//eine vordefinierte Zeichenklasse installieren
	int ( *isArr[12] )( int ) = { isgraph, isupper, isxdigit, isdigit, isalpha, isalnum, ispunct, isprint, isspace, islower, isblank, iscntrl };
	int	isIndex, i;

	//Welche vordef. Zeichenklasse?
	switch( type )
	{
		case CCE_GRAPH:
		{
			//isgrapgh
			isIndex = 0;
			break;
		}

		case CCE_UPPER:
		{
			//isupper
			isIndex = 1;
			break;
		}

		case CCE_XDIGIT:
		{
			//isxdigit
			isIndex = 2;
			break;
		}

		case CCE_DIGIT:
		{
			//isdigit
			isIndex = 3;
			break;
		}

		case CCE_ALPHA:
		{
			//isalpha
			isIndex = 4;
			break;
		}

		case CCE_ALNUM:
		{
			//isalnum
			isIndex = 5;
			break;
		}

		case CCE_PUNCT:
		{
			//ispunkt
			isIndex = 6;
			break;
		}

		case CCE_PRINT:
		{
			//isprint
			isIndex = 7;
			break;
		}

		case CCE_SPACE:
		{
			//isspace
			isIndex = 8;
			break;
		}

		case CCE_LOWER:
		{
			//islower
			isIndex = 9;
			break;
		}

		case CCE_BLANK:
		{
			//isblank
			isIndex = 10;
			break;
		}

		case CCE_CNTRL:
		{
			//iscntrl
			isIndex = 11;
			break;
		}

		default:
		{
			//unbekannte Zeichenklasse
//			cerr << "sslex: line " << line << ": Illegal character class!\n";
			cerr << "sslex: Illegal character!\n";

			//Fehler
//			err++;
		}
	}

	//Zeichenklasse erzeugen
	for( i = 0; i < cclWidth; i++ )
	{
		//Zeichen eintragen?
		if( isascii( i ) && isArr[isIndex]( i ) )
			//Ja
			cclStr[i] = 1;
	}

	//zurckliefern
	return( cclStr );
}


void ssLexClass::mkBranch( ulong from, ulong to, int *cclStr, bool eps )
{
	//einen Zustandsbergang mit cclStr erzeugen
	BRA_STR		**braStr, *bra;
	STATE_STR	*s1, *s2;

	//Zeiger holen
	s1 = stateStr[from];
	s2 = stateStr[to];

	//genug Speicher anfordern
	braStr = new( BRA_STR *[s1->braStrCnt + 1] );

	//kopieren
	memcpy( braStr, s1->braStr, sizeof( BRA_STR * ) * s1->braStrCnt );

	//alten Speicherbereich freigeben
	if( s1->braStr )
		delete[] ( s1->braStr );

	//neue Adresse
	s1->braStr = braStr;

	//Speicher fr die eigentliche BRA_STR anfordern
	bra = new( BRA_STR );

	//Zeiger
	s1->braStr[s1->braStrCnt++] = bra;



	//nun bra initialisieren
	if( cclStr )
		//Zeichenklasse eintragen
		bra->cclClass = cclStr;

	else
		//keine Zeichen-bergnge
		bra->cclClass = 0L;

	//epsilon-bergang?
	if( eps == true )
		//Ja, ein epsilon-bergang von from nach to
		s1->eps = true;

	//bertragen
	bra->eps = eps;

	//Ziel-Zustand eintragen
	bra->bra = to;
}


void ssLexClass::mkBranch( NEA_STR *nea, int *cclStr, bool eps )
{
	//einen Zustand an einen NEA anhngen
	STATE_STR	*s1, *s2;
	ulong		index;

	//Zustand erzeugen
	index = getNewState( nea );

	//Zeiger holen
	s1 = stateStr[nea->endState];
	s2 = stateStr[index];

	//Zustandsbergang erzeugen
	mkBranch( nea->endState, index, cclStr, eps );

	//ist kein Finit-Zustand mehr
	setState( nea, nea->endState, MARK_AS_NORMAL );

	//Zustand index ist neuer End-Zustand des NEA
	nea->endState = index;

	//ist ein Finit-Zustand
	setState( nea, index, MARK_AS_FINIT );
}


NEA_STR *ssLexClass::mkor( NEA_STR *nea1, NEA_STR *nea2 )
{
	//zwei NEAen verodern
	ulong		startIndex, endIndex;

	//neuen Start-Zustand anfordern
	startIndex = getNewState( nea1 );

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea1 );

	//eps-bergang von startIndex zu den beiden Start-Zustnden des beiden NEAen
	mkBranch( startIndex, nea1->startState, 0L, true );
	mkBranch( startIndex, nea2->startState, 0L, true );

	//eps-bergang von den End-Zustnden beider NEAen zum neuen End-Zustand
	mkBranch( nea1->endState, endIndex, 0L, true );
	mkBranch( nea2->endState, endIndex, 0L, true );


	//endIndex ist neuer End-Zustand des veroderten NEA
	setState( nea1, endIndex, MARK_AS_FINIT );

	//alte Finit-Zustnde sind keine mehr
	setState( nea1, nea1->endState, MARK_AS_NORMAL );
	setState( nea1, nea2->endState, MARK_AS_NORMAL );

	//startIndex ist neuer Start-Zustand des veroderten NEA
	nea1->startState = startIndex;

	//neuen End-Zustand setzen
	nea1->endState = endIndex;

	//ist der zweite NEA ein NEA mit Lookahead?
	if( nea2->laState == true )
		//Ja, so auch der neue
		nea1->laState = true;

	//zweite NEA-Struktur freigeben
	delete( nea2 );

	//veroderten NEA zurckliefern
	return( nea1 );
}


NEA_STR *ssLexClass::mkLink( NEA_STR *nea1, NEA_STR *nea2 )
{
	//zwei NEAen verketten
	STATE_STR	*indexStr;
	BRA_STR		*bra;
	long		*stack, *marked, stackPos = 0;
	long		index, neaDest;
	int			i;

	//eps-bergang von End-Zustand des ersten NEA zum Start-Zustand des zweiten
	mkBranch( nea1->endState, nea2->startState, 0L, true );

	//alter Finit-Zustand des ersten NEA ist keiner mehr
	setState( nea1, nea1->endState, MARK_AS_NORMAL );

	//Finit-Zustand des zweiten NEA setzen, damit NEA_STR bergeben wird
	setState( nea1, nea2->endState, MARK_AS_FINIT );

	//neuen End-Zustand des NEA eintragen
	nea1->endState = nea2->endState;

	//ist der zweite NEA ein NEA mit Lookahead?
	if( nea2->laState == true )
		//Ja, so auch der neue
		nea1->laState = true;

	//zweite NEA-Struktur freigeben
	delete( nea2 );


	//Nun an alle NEA-Zustnde, insbesondere an die von nea2, den Zeiger auf nea1 vererben


	//Speicher fr den Zustands-Stack holen
	stack = new( long[stateStrCnt] );

	//Speicher um die bereits bearbeiteten Zustnde zu markieren
	marked = new( long[stateStrCnt] );

	//initialisieren
	memset( marked, 0, sizeof( ulong ) * stateStrCnt );

	//diesen Zustand auf den Stack schieben
	stack[stackPos++] = nea1->startState;

	while( stackPos )
	{
		//Zustand vom Stack holen
		index = stack[--stackPos];

		//bereits markiert?
		if( !marked[index] )
		{
			//markieren
			marked[index]++;

			//Zeiger auf STATE_STR
			indexStr = stateStr[index];

			//nea eintragen
			indexStr->nea = nea1;

			//nun alle Zustandsbergnge des Zustands index
			for( i = 0; i < indexStr->braStrCnt; i++ )
			{
				//Zeiger auf BRA_STR
				bra = indexStr->braStr[i];

				//Ziel-Zustand
				neaDest = bra->bra;

				//Ziel-Zustand bereits markiert?
				if( !marked[neaDest] )
					//Nein, auf Stack
					stack[stackPos++] = neaDest;
			}
		}
	}

	//Speicher wieder freigeben
	delete[] ( stack );
	delete[] ( marked );


	//veroderten NEA zurckliefern
	return( nea1 );
}


NEA_STR *ssLexClass::mkClos( NEA_STR *nea )
{
	//einen NEA beliebig oft ausfhrbar machen
	ulong		startIndex, endIndex;

	//neuen Start-Zustand anfordern
	startIndex = getNewState( nea );

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea );

	//eps-bergang von startIndex zum Start-Index des NEA
	mkBranch( startIndex, nea->startState, 0L, true );

	//eps-bergang vom neuen Start-Zustand zum neuen End-Zustand
	mkBranch( startIndex, endIndex, 0L, true );

	//eps-bergang vom alten End-Zustand zum neuen End-Zustand
	mkBranch( nea->endState, endIndex, 0L, true );

	//eps-bergang vom alten End-Zustand zum alten Start-Zustand
	mkBranch( nea->endState, nea->startState, 0L, true );


	//ist ein Finit-Zustand
	setState( nea, endIndex, MARK_AS_FINIT );

	//alter Finit-Zustand ist keiner mehr
	setState( nea, nea->endState, MARK_AS_NORMAL );

	//neuen Start-Zustand setzen
	nea->startState = startIndex;

	//neuen End-Zustand setzen
	nea->endState = endIndex;

	//NEA zurckliefern
	return( nea );
}


NEA_STR *ssLexClass::mkPosClos( NEA_STR *nea )
{
	//einen NEA mind. einmal ausfhrbar machen
	ulong		startIndex, endIndex;

	//neuen Start-Zustand anfordern
	startIndex = getNewState( nea );

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea );

	//eps-bergang von startIndex zum Start-Index des NEA
	mkBranch( startIndex, nea->startState, 0L, true );

	//eps-bergang vom alten End-Zustand zum neuen End-Zustand
	mkBranch( nea->endState, endIndex, 0L, true );

	//eps-bergang vom alten End-Zustand zum alten Start-Zustand
	mkBranch( nea->endState, nea->startState, 0L, true );


	//ist ein Finit-Zustand
	setState( nea, endIndex, MARK_AS_FINIT );

	//alter Finit-Zustand ist keiner mehr
	setState( nea, nea->endState, MARK_AS_NORMAL );

	//neuen Start-Zustand setzen
	nea->startState = startIndex;

	//neuen End-Zustand setzen
	nea->endState = endIndex;

	//NEA zurckliefern
	return( nea );
}


NEA_STR *ssLexClass::mkOpt( NEA_STR *nea )
{
	//einen NEA optional machen
	ulong		startIndex, endIndex;

	//neuen Start-Zustand anfordern
	startIndex = getNewState( nea );

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea );

	//eps-bergang von startIndex zum Start-Index des NEA
	mkBranch( startIndex, nea->startState, 0L, true );

	//eps-bergang vom neuen Start-Zustand zum neuen End-Zustand
	mkBranch( startIndex, endIndex, 0L, true );

	//eps-bergang vom alten End-Zustand zum neuen End-Zustand
	mkBranch( nea->endState, endIndex, 0L, true );


	//ist ein Finit-Zustand
	setState( nea, endIndex, MARK_AS_FINIT );

	//alter Finit-Zustand ist keiner mehr
	setState( nea, nea->endState, MARK_AS_NORMAL );

	//neuen Start-Zustand setzen
	nea->startState = startIndex;

	//neuen End-Zustand setzen
	nea->endState = endIndex;

	//NEA zurckliefern
	return( nea );
}


NEA_STR *ssLexClass::mkRepeat( NEA_STR *nea, int value )
{
	//einen NEA genau value Mal ausfhren
	NEA_STR		*cpyNEA, *base = mkCopy( nea );
	int			i;

	//mind. einmal?
	if( value > 1 )
	{
		//value mal
		for( i = 0; i < value - 1; i++ )
		{
			//NEA kopieren
			cpyNEA = mkCopy( base );

			//NEAen verbinden
			nea = mkLink( nea, cpyNEA );
		}
	}

	//Speicher freigeben
	mkDelete( base );

	//NEA zurckliefern
	return( nea );
}


NEA_STR *ssLexClass::mkRepeat( NEA_STR *nea, int min, int max )
{
	//einen NEA mindestens min-mal ausfhren, maximal max-mal
	NEA_STR		*cpyNEA, *base = mkCopy( nea );
	ulong		endIndex, index;
	int			i;

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea );

	//mind. einmal?
	if( max > min )
	{
		//min mal
		for( i = 1; i < max; i++ )
		{
			//NEA kopieren
			cpyNEA = mkCopy( base );

			//den End-Zustand merken
			index = nea->endState;

			//NEAen verbinden
			nea = mkLink( nea, cpyNEA );

			//i > min, d.h. optional?
			if( i >= min )
				//Ja
				mkBranch( index, endIndex, 0L, true );
		}

		//min=0, d.h. auch kein mal erlaubt?
		if( !min )
			//Ja, eps-bergang vom Start-Zustand zum End-Zustand
			mkBranch( nea->startState, endIndex, 0L, true );

		//neuen End-Zustand
		mkBranch( nea->endState, endIndex, 0L, true );

		//alter Finit-Zustand ist keiner mehr
		setState( nea, nea->endState, MARK_AS_NORMAL );

		//neuen Finit-Zustand setzen
		setState( nea, endIndex, MARK_AS_FINIT );

		//neuen Finit-Zustand eintragen
		nea->endState = endIndex;
	}

	else if( max == _INFINITY )
	{
		//NEA min. min-mal, dann beliebig oft
		for( i = 1; i < min; i++ )
		{
			//NEA kopieren
			cpyNEA = mkCopy( base );

			//NEAen verbinden
			nea = mkLink( nea, cpyNEA );
		}

		//nun noch einen anfgen, diesen aber beliebig oft ausfhrbar machen
		cpyNEA = mkCopy( base );

		//beliebig oft ausfhrbar machen
		cpyNEA = mkClos( cpyNEA );

		//beide verbinden
		nea = mkLink( nea, cpyNEA );
	}

	//Speicher freigeben
	mkDelete( base );

	//NEA zurckliefern
	return( nea );
}


NEA_STR *ssLexClass::mkCopy( NEA_STR *nea )
{
	//eine Kopie eines NEA erzeugen
	STATE_STR	*indexStr, *toCopyStr;
	NEA_STR		*cpyNEA;
	BRA_STR		*bra;
	long		*stack, stackPos = 0;
	long		*transStates, index, toCopy, neaDest, dest;
	int			*cclClass, i;

	//neuen NEA anfordern
	cpyNEA = getNewNEA();

	//Speicher fr den Zustands-Stack holen
	stack = new( long[stateStrCnt] );

	//in diesem Array steht die Nummer des Zustandes, den ein Zustand in nea hat, in cpyNEA
	transStates = new( long[stateStrCnt] );

	//initialisieren
	memset( transStates, -1, sizeof( long ) * stateStrCnt );

	//den Startzustand eintragen
	transStates[nea->startState] = cpyNEA->startState;

	//diesen Zustand auf den Stack schieben
	stack[stackPos++] = nea->startState;

	while( stackPos )
	{
		//Zustand vom Stack holen
		index = stack[--stackPos];

		//Gibt es diesen Zustand in cpyNEA schon?
		if( transStates[index] >= 0 )
			//Ja, holen
			toCopy = transStates[index];

		else
		{
			//Nein, erzeugen
			toCopy = getNewState( cpyNEA );

			//eintragen
			transStates[index] = toCopy;
		}

		//Zeiger auf STATE_STR
		indexStr = stateStr[index];
		toCopyStr = stateStr[toCopy];

		//nun alle Zustandsbergnge des Zustands index in cpyNEA erzeugen
		for( i = 0; i < indexStr->braStrCnt; i++ )
		{
			//Zeiger auf BRA_STR
			bra = indexStr->braStr[i];

			//Ziel-Zustand
			neaDest = bra->bra;

			//Ziel-Zustand erzeugen?
			if( transStates[neaDest] < 0 )
			{
				//Ja, erzeugen
				dest = getNewState( cpyNEA );

				//eintragen
				transStates[neaDest] = dest;

				//Zeichenklasse kopieren
				cclClass = cclCopy( bra->cclClass );

				//Zustandsbergang erzeugen
				mkBranch( toCopy, dest, cclClass, bra->eps );

				//Zustand auf dem Stack schieben
				stack[stackPos++] = neaDest;
			}
		}

		//alle anderen Dinge kopieren
		toCopyStr->eps = indexStr->eps;
		toCopyStr->finit = indexStr->finit;
		toCopyStr->la = indexStr->la;
	}

	//NEA-Infos kopieren
	cpyNEA->action = nea->action;
	cpyNEA->endState = transStates[nea->endState];
	cpyNEA->laState = nea->laState;
	cpyNEA->regText = nea->regText;
	cpyNEA->startState = transStates[nea->startState];

	//Speicher wieder freigeben
	delete[] ( stack );
	delete[] ( transStates );

	//NEA zurckliefern
	return( cpyNEA );
}


void ssLexClass::mkDelete( NEA_STR *nea )
{
	//einen NEa mitsamt seinen Zustnden lschen
	STATE_STR	*indexStr;
	BRA_STR		*bra;
	long		*stack, stackPos = 0;
	long		index, neaDest;
	int			i, *marked;

	//Speicher fr den Zustands-Stack holen
	stack = new( long[stateStrCnt] );

	//in diesem Array stehen die Zustnde, die bereits gelscht wurden
	marked = new( int[stateStrCnt] );

	//initialisieren
	memset( marked, 0, sizeof( int ) * stateStrCnt );

	//diesen Zustand auf den Stack schieben
	stack[stackPos++] = nea->startState;

	while( stackPos )
	{
		//Zustand vom Stack holen
		index = stack[--stackPos];

		//markiert?
		if( !marked[index] )
		{
			//markieren
			marked[index]++;

			//Zeiger auf STATE_STR
			indexStr = stateStr[index];

			//nun alle Zustandsbergnge des Zustands index in nea lschen
			for( i = 0; i < indexStr->braStrCnt; i++ )
			{
				//Zeiger auf BRA_STR
				bra = indexStr->braStr[i];

				//Ziel-Zustand
				neaDest = bra->bra;

				//schon markiert?
				if( !marked[neaDest] )
					//nein, auf den Stack legen
					stack[stackPos++] = neaDest;

				//Zeichenklasse lschen
				if( bra->cclClass )
				{
					//Speicher freigeben
					delete[] ( bra->cclClass );

					//zurcksetzen
					bra->cclClass = 0L;
				}

				//Zustandsbergangs-Struktur lschen
				delete( bra );

				//zurcksetzen
				bra = 0L;
			}

			//Array mit den Zustandsbergangs-Strukturen lschen
			if( indexStr->braStr )
			{
				//Speicher freigeben
				delete[] ( indexStr->braStr );

				//zurcksetzen
				indexStr->braStr = 0L;
			}

			/*
				STATE-STR dieses Zustands nicht lschnen, da sonst alle Zustandsbergnge angepasst
				werden mssten.
			*/
			indexStr->nea = 0L;
		}
	}

	//Speicher wieder freigeben
	delete[] ( stack );
	delete[] ( marked );

	//NEA freigeben
	delete( nea );
}


void ssLexClass::setState( NEA_STR *nea, ulong state, int type )
{
	//einen Zustand setzen
	//MARK_AS_NORMAL: normaler Zustand
	//MARK_AS_FINIT: End-Zustand
	//MARK_AS_LA: Lookahead-Zustand
	STATE_STR	*s1;

	//Teuger
	s1 = stateStr[state];

	//Welcher ist es denn?
	switch( type )
	{
		case MARK_AS_NORMAL:
		{
			//normaler Zustand
			s1->finit = false;
			s1->la = false;
			s1->nea = nea;
			break;
		}

		case MARK_AS_FINIT:
		{
			//End-Zustand
			s1->finit = true;
			s1->la = false;
			s1->nea = nea;
			break;
		}

		case MARK_AS_LA:
		{
			//Lookahead-Zustand
			s1->finit = false;
			s1->la = true;
			s1->nea = nea;
			break;
		}

		default:
		{
			//Fehler
			cerr << "sslex: Illegal state in setState!\n";

			//Fehler
//			err++;
		}
	}
}


void ssLexClass::outputNEA( NEA_STR *nea )
{
	//einen NEA ausgeben
	STATE_STR	*indexStr;
	BRA_STR		*bra;
	long		*stack, stackPos = 0;
	long		*doub, index;
	int			i, j;

	//den entsprechenden reg. Ausdruck ausgeben?
	if( nea->regText )
		//Ja
		cout << "\n" << nea->regText << "\n";

	//Speicher fr den Zustands-Stack holen
	stack = new( long[stateStrCnt] );

	//Zustnde nicht doppelt ausgeben
	doub = new( long[stateStrCnt] );

	//initialisieren
	memset( doub, 0, sizeof( long ) * stateStrCnt );

	//Start-Zustand auf den Stack
	stack[stackPos++] = nea->startState;

	//Ist es ein Lookahead-NEA?
	if( nea->laState == true )
		//Ja
		cout << "Lookahead-NEA\n";

	while( stackPos )
	{
		//Zustand holen
		index = stack[--stackPos];

		//Zeiger auf STATE_STR
		indexStr = stateStr[index];

		//ausgeben?
		if( !doub[index] )
		{
			//Ja, Zustandsnummer ausgeben
			cout << "\n\nZustand: " << index;

			//Start-Zustand?
			if( index == nea->startState )
				//Ja
				cout << "\tStartzustand\n";

			else if( indexStr->la == true )
				//ist ein Lookahead-Zustand
				cout << "\tLookahead-Zustand\n";

			else if( index == nea->endState )
				//Ja
				cout << "\tEnd-Zustand\n";

			else
				//normaler Zustand
				cout << "\n";

			//Zustndsbergnge ausgeben
			for( i = 0; i < indexStr->braStrCnt; i++ )
			{
				//Zeiger auf BRA_STR
				bra = indexStr->braStr[i];

				//ausgeben
				cout << "bergang zu " << bra->bra << "\n";

				//gibt es eine?
				if( bra->cclClass )
				{
					//Zeichenklasse ausgeben
					cout << "Zeichenklasse\n";

					//Zeichen ausgeben
					for( j = 0; j < cclWidth; j++ )
					{
						//Zeichen gesetzt?
						if( bra->cclClass[j] )
						{
							//druckbar?
							if( isprint( j ) )
								//Ja, normal ausgeben
								fprintf( stdout, "%c", j );

							else
							{
								//ist ein nicht-druckbares Zeichen
								cout << "," << j << ",";
							}
						}
					}

					//nchste Zeile
					cout << "\n";
				}

				//Epsilon?
				if( bra->eps )
					//Ja
					cout << "Epsilon\n";

				//aus Stack schieben
				stack[stackPos++] = bra->bra;
			}

			//markieren
			doub[index] = 1;
		}
	}

	//Speicher wieder freigeben
	delete[] ( stack );
	delete[] ( doub );
}


void ssLexClass::insertSC( char *name, bool type )
{
	//eine in %definition definierte SC eintragen
	SC_STR	*tmp, *sc;

	//schon definiert?
	if( lookupSC( name ) < 0 )
	{
		//Speicher anfordern
		tmp = new( SC_STR[scStrAnz + 1] );

		//alte Daten kopieren
		memcpy( tmp, scStr, sizeof( SC_STR ) * scStrAnz );

		//alten Speicherbereich freigeben
		if( scStr )
			delete[] ( scStr );

		//neue Adresse
		scStr = tmp;

		//Zeiger auf Struktur holen
		sc = &scStr[scStrAnz++];

		//initialisieren
		memset( sc, 0, sizeof( SC_STR ) );

		//eintragen
		sc->name = name;

		//Typ eintragen
		sc->type = type;
	}

	else
	{
		//Fehler
		cerr << "sslex: line " << line << ": SC " << name << " already definied!\n";

		//Fehler
		err++;
	}
}


int ssLexClass::lookupSC( char *name )
{
	//eine in %definition definierte SC suchen
	int	i;

	//Alle Eintrge
	for( i = 0; i < scStrAnz; i++ )
	{
		//Namen gleich
		if( !strcmp( scStr[i].name, name ) )
			//Ja
			return( i );
	}

	//war nicht dabei
	return( -1 );
}


void ssLexClass::insertSC( SC_STR *scStr, NEA_STR *nea )
{
	//einen NEA an eine SC einfgen
	NEA_STR	**tmp;
	bool	eof = nea->eof;

	//eof-NEA?
	if( ( eof == false ) || ( ( eof == true ) && ( ( insertEOFSC( scStr ) ) == false ) ) )
	{
		//genug Speicher anfordern
		tmp = new( NEA_STR *[scStr->neaArrCnt + 1] );

		//kopieren
		memcpy( tmp, scStr->neaArr, sizeof( NEA_STR * ) * scStr->neaArrCnt );

		//alten Speicher freigeben
		if( scStr->neaArr )
			delete[] ( scStr->neaArr );

		//Adressen
		scStr->neaArr = tmp;

		//NEA_STR eintragen
		scStr->neaArr[scStr->neaArrCnt++] = nea;

		//ist es ein NEA, der nur am Zeilenanfang stehen darf?
		if( nea->begLine == true )
			//Ja
			scStr->nea2Anz++;

		else
			//Nein, darf berall stehen
			scStr->nea1Anz++;
	}
}


void ssLexClass::insertInclSC( NEA_STR *nea )
{
	//einen NEA an alle inclusive SC einfgen
	SC_STR	*sc;
	long	i;
	bool	eof = nea->eof;

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger
		sc = &scStr[i];

		//inclusive?
		if( sc->type == false )
		{
			//eof-NEA?
			if( ( eof == false ) || ( ( eof == true ) && ( ( insertEOFSC( sc ) ) == false ) ) )
				//genug Speicher anfordern
				insertSC( sc, nea );
		}
	}
}


bool ssLexClass::insertEOFSC( SC_STR *scStr )
{
	//prfen, ob mit der SC bereits ein EOF-NEA verbunden ist
	bool	ex = false;
	int		j;

	//alle NEAen dieser SC
	for( j = 0; j < scStr->neaArrCnt; j++ )
	{
		//Hat diese SC schon einen NEA mit <<EOF>>-Regel?
		if( scStr->neaArr[j]->eof == true )
			//Ja
			ex = true;
	}

	//gab es bereits einen NEA mit <<EOF>>?
	if( ex == true )
	{
		//Fehler
		cerr << "sslex: line " << line << ": SC " << scStr->name << " already has an <<EOF>>-Rule!\n";

		//Fehler
		err++;
	}

	//Alles OK
	return( ex );
}


void ssLexClass::extendNEAStack( void )
{
	/*
		den NEA-Stack vergrern, wird bentig, falls mehrere NEAen diegleiche
		Aktion ausfhren sollen (erstes Zeichen |).
	*/
	NEA_STR	**tmp;

	//Speicher anfordern
	tmp = new( NEA_STR *[neaStackCnt + 100] );

	//kopieren
	memcpy( tmp, neaStack, sizeof( NEA_STR * ) * neaStackCnt );

	//Speicher freigeben
	if( neaStack )
		delete[] ( neaStack );

	//Adresse
	neaStack = tmp;

	//neue Gre
	neaStackMax += 100;
}


void ssLexClass::insertNEAStack( NEA_STR *nea )
{
	//einen NEA auf den NEA-Stack packen
	if( neaStackCnt >= neaStackMax )
		//vergrern
		extendNEAStack();

	//nun auf dem Stack packen
	neaStack[neaStackCnt++] = nea;
}


ECLOS_STR *ssLexClass::createEClos( void )
{
	//eine ECLOS_STR-Struktur vorbereiten
	ECLOS_STR	*tmp;

	//Speicher anfordern
	tmp = new( ECLOS_STR );

	//initialisieren
	memset( tmp, 0, sizeof( ECLOS_STR ) );

	//zurckliefern
	return( tmp );
}


void ssLexClass::removeEClos( ECLOS_STR *eclosStr )
{
	//ECLOS_STR freigeben

	//Zustnde?
	if( eclosStr->from )
		delete[] ( eclosStr->from );

	//Zustnde?
	if( eclosStr->to )
		delete[] ( eclosStr->to );

	delete( eclosStr );
}


void ssLexClass::insertFromEClos( ECLOS_STR *eclosStr, ulong index )
{
	/*
		einen Zustand in eine ECLOS_STR-Struktur eintragen, von dem aus die Epsilon-bergnge berechnet
		werden sollen.
	*/
	ulong	*tmp, i;

	//gengend Speicher anfordern
	tmp = new( ulong[eclosStr->fromCnt + 1] );

	//kopieren
	memcpy( tmp, eclosStr->from, sizeof( ulong ) * eclosStr->fromCnt );

	//alten Speicher lschen
	if( eclosStr->from )
		delete[] ( eclosStr->from );

	//Zeiger
	eclosStr->from = tmp;


	//sortiert eintragen
	for( i = 0; i < eclosStr->fromCnt; i++ )
	{
		//vergleichen
		if( eclosStr->from[i] > index )
		{
			//an dieser Stelle eintragen
			memmove( &eclosStr->from[i + 1], &eclosStr->from[i], sizeof( ulong ) * ( eclosStr->fromCnt - i ) );

			//eintragen
			eclosStr->from[i] = index;

			//Ende
			break;
		}
	}

	//an letzter Stelle eintragen?
	if( i == eclosStr->fromCnt )
		//Ja
		eclosStr->from[i] = index;

	//ein Zustand weiter
	eclosStr->fromCnt++;
}


void ssLexClass::insertFromEClos( ECLOS_STR *eclosStr, ulong *index, ulong anz )
{
	/*
		mehrere Zustnde in eine ECLOS_STR-Struktur eintragen, von denen aus die Epsilon-bergnge
		berechnet werden sollen.
	*/
	ulong	i;

	//Alle Zustnde eintragen
	for( i = 0; i < anz; i++ )
		//eintragen
		insertFromEClos( eclosStr, index[i] );
}


void ssLexClass::insertToEClos( ECLOS_STR *eclosStr, ulong index )
{
	/*
		einen Zustand in eine ECLOS_STR-Struktur eintragen, der von from aus ber einen Epsilon-bergnge
		erreicht wird.
	*/
	ulong	*tmp, i;

	//gengend Speicher anfordern
	tmp = new( ulong[eclosStr->toCnt + 1] );

	//kopieren
	memcpy( tmp, eclosStr->to, sizeof( ulong ) * eclosStr->toCnt );

	//alten Speicher lschen
	if( eclosStr->to )
		delete[] ( eclosStr->to );

	//Zeiger
	eclosStr->to = tmp;


	//sortiert eintragen
	for( i = 0; i < eclosStr->toCnt; i++ )
	{
		//vergleichen
		if( eclosStr->to[i] > index )
		{
			//an dieser Stelle eintragen
			memmove( &eclosStr->to[i + 1], &eclosStr->to[i], sizeof( ulong ) * ( eclosStr->toCnt - i ) );

			//eintragen
			eclosStr->to[i] = index;

			//Ende
			break;
		}
	}

	//an letzter Stelle eintragen?
	if( i == eclosStr->toCnt )
		//Ja
		eclosStr->to[i] = index;

	//ein Zustand weiter
	eclosStr->toCnt++;
}


bool ssLexClass::findToEClos( ECLOS_STR *eclosStr, ulong index )
{
	//sucht einen Index in to
	ulong	i;
	bool	er = false;

	//Alle Zustnde in to
	for( i = 0; i < eclosStr->toCnt; i++ )
	{
		//Zustnde gleich?
		if( eclosStr->to[i] == index )
		{
			//Ja
			er = true;
			break;
		}
	}

	//zurckliefern
	return( er );
}


void ssLexClass::generateEClos( ECLOS_STR *eclosStr )
{
	/*
		Nun die Zustnde bestimmen, die ber Epsilon-bergnge von from aus erreichbar sind und
		in to eintragen.
	*/
	STATE_STR	*sc;
	BRA_STR		*braStr;
	ulong		*stack, stackPos = 0, i, index;

	//Speicher fr den Stack anfordern
	stack = new( ulong[stateStrCnt] );

	//zuerst alle Zustnde from selbst auf den Stack legen
	for( i = 0; i < eclosStr->fromCnt; i++ )
	{
		//auf Stack
		stack[stackPos++] = eclosStr->from[i];

		//initialisieren
		insertToEClos( eclosStr, eclosStr->from[i] );
	}

	//solange Zustnde auf dem Stack sind
	while( stackPos )
	{
		//einen Index vom Stack holen
		index = stack[--stackPos];

		//Zeiger auf STATE_STR
		sc = stateStr[index];

		//Alle Zustandsbergnge von index
		for( i = 0; i < sc->braStrCnt; i++ )
		{
			//Zeiger auf BRA_STR
			braStr = sc->braStr[i];

			//Ist es ein epsilon-bergang?
			if( braStr->eps == true )
			{
				//Ja, schon enthalten?
				if( findToEClos( eclosStr, braStr->bra ) == false )
				{
					//Nein, eintragen
					insertToEClos( eclosStr, braStr->bra );

					//auf den Stack legen
					stack[stackPos++] = braStr->bra;
				}
			}
		}
	}

	//Stack freigeben
	delete[] ( stack );
}


MOVE_STR *ssLexClass::createMove( uchar c )
{
	//eine MOVE_STR-Struktur vorbereiten
	MOVE_STR	*tmp;

	//Speicher anfordern
	tmp = new( MOVE_STR );

	//initialisieren
	memset( tmp, 0, sizeof( MOVE_STR ) );

	//Zeichen eintragen
	tmp->jump = c;

	//zurckliefern
	return( tmp );
}


void ssLexClass::removeMove( MOVE_STR *moveStr )
{
	//Speicher fr moevStr freigeben
	if( moveStr->to )
		delete[] ( moveStr->to );

	if( moveStr->from )
		delete[] ( moveStr->from );

	delete( moveStr );
}


void ssLexClass::insertFromMove( MOVE_STR *moveStr, ulong index )
{
	/*
		einen Zustand in eine MOVE_STR-Struktur eintragen, von dem aus die bergnge berechnet
		werden sollen.
	*/
	ulong	*tmp, i;

	//gengend Speicher anfordern
	tmp = new( ulong[moveStr->fromCnt + 1] );

	//kopieren
	memcpy( tmp, moveStr->from, sizeof( ulong ) * moveStr->fromCnt );

	//alten Speicher lschen
	if( moveStr->from )
		delete[] ( moveStr->from );

	//Zeiger
	moveStr->from = tmp;


	//sortiert eintragen
	for( i = 0; i < moveStr->fromCnt; i++ )
	{
		//vergleichen
		if( moveStr->from[i] > index )
		{
			//an dieser Stelle eintragen
			memmove( &moveStr->from[i + 1], &moveStr->from[i], sizeof( ulong ) * ( moveStr->fromCnt - i ) );

			//eintragen
			moveStr->from[i] = index;

			//Ende
			break;
		}
	}

	//an letzter Stelle eintragen?
	if( i == moveStr->fromCnt )
		//Ja
		moveStr->from[i] = index;

	//ein Zustand weiter
	moveStr->fromCnt++;
}


void ssLexClass::insertFromMove( MOVE_STR *moveStr, ulong *index, ulong anz )
{
	/*
		mehrere Zustnde in eine MOVE_STR-Struktur eintragen, von denen aus die bergnge
		berechnet werden sollen.
	*/
	ulong	i;

	//Alle Zustnde eintragen
	for( i = 0; i < anz; i++ )
		//eintragen
		insertFromMove( moveStr, index[i] );
}


void ssLexClass::insertToMove( MOVE_STR *moveStr, ulong index )
{
	/*
		einen Zustand in eine MOVE_STR-Struktur eintragen, der von from aus ber einen bergnge
		erreicht wird.
	*/
	ulong	*tmp, i;

	//gengend Speicher anfordern
	tmp = new( ulong[moveStr->toCnt + 1] );

	//kopieren
	memcpy( tmp, moveStr->to, sizeof( ulong ) * moveStr->toCnt );

	//alten Speicher lschen
	if( moveStr->to )
		delete[] ( moveStr->to );

	//Zeiger
	moveStr->to = tmp;


	//sortiert eintragen
	for( i = 0; i < moveStr->toCnt; i++ )
	{
		//vergleichen
		if( moveStr->to[i] > index )
		{
			//an dieser Stelle eintragen
			memmove( &moveStr->to[i + 1], &moveStr->to[i], sizeof( ulong ) * ( moveStr->toCnt - i ) );

			//eintragen
			moveStr->to[i] = index;

			//Ende
			break;
		}
	}

	//an letzter Stelle eintragen?
	if( i == moveStr->toCnt )
		//Ja
		moveStr->to[i] = index;

	//ein Zustand weiter
	moveStr->toCnt++;
}


bool ssLexClass::findToMove( MOVE_STR *moveStr, ulong index )
{
	//sucht einen Index in to
	ulong	i;
	bool	er = false;

	//Alle Zustnde in to
	for( i = 0; i < moveStr->toCnt; i++ )
	{
		//Zustnde gleich?
		if( moveStr->to[i] == index )
		{
			//Ja
			er = true;
			break;
		}
	}

	//zurckliefern
	return( er );
}


void ssLexClass::generateMove( MOVE_STR *moveStr )
{
	/*
		Nun die Zustnde bestimmen, die ber moveStr->jump-bergnge von from aus erreichbar sind und
		in to eintragen.
	*/
	STATE_STR	*sc;
	BRA_STR		*braStr;
	ulong		i, j, index;
	uchar		c = moveStr->jump;

	//solange Zustnde auf dem Stack sind
	for( j = 0; j < moveStr->fromCnt; j++ )
	{
		//einen Index vom Stack holen
		index = moveStr->from[j];

		//Zeiger auf STATE_STR
		sc = stateStr[index];

		//Alle Zustandsbergnge von index
		for( i = 0; i < sc->braStrCnt; i++ )
		{
			//Zeiger auf BRA_STR
			braStr = sc->braStr[i];

			//Ist es ein epsilon-bergang?
			if( braStr->cclClass && braStr->cclClass[c] )
			{
				//Ja, schon enthalten?
				if( findToMove( moveStr, braStr->bra ) == false )
					//Nein, eintragen
					insertToMove( moveStr, braStr->bra );
			}
		}
	}
}


void ssLexClass::initDStatesStack( void )
{
	//DSTATES wird als Stack implementiert.

	//initalisieren
	dstatesStack = 0L;
	dstatesStackPos = 0;
}


void ssLexClass::removeDStatesStack( void )
{
	//DSTATES deinitialisieren
	ulong	i;

	//Speicher belegt?
	if( dstatesStack )
	{
		//Alle Elemente auf dem Stack entfernen
		for( i = 0; i < dstatesStackPos; i++ )
			//freigeben
			delete( dstatesStack[i] );

		//freigeben
		delete[] ( dstatesStack );
	}

	//keine Elemente auf dem Stack
	dstatesStackPos = 0;
	dstatesStack = 0L;
}


long ssLexClass::insertDStates( ulong *index, ulong anz )
{
	//eine neue NEA-Zustandsmenge in DSTATES eintragen, d.h. einen neuen DEA-Zustand erzeugen
	DSTATES		*tmp, **tmp2;
	long		deaIndex;

	//gibt es den DEA-Zustand schon?
	if( ( deaIndex = lookupDStates( index, anz ) ) < 0 )
	{
		//den DEA-Zustand erzeugen
		deaIndex = insertDEAState( index, anz, false );

		//ist noch nicht enthalten
		tmp2 = new( DSTATES *[dstatesStackPos + 1] );

		//schon auf dem Stack enthaltende Zeiger kopieren
		memcpy( tmp2, dstatesStack, sizeof( DSTATES * ) * dstatesStackPos );

		//alten Speicher freigeben
		if( dstatesStack )
			delete[] ( dstatesStack );

		//Zeiger
		dstatesStack = tmp2;

		//neue DSTATES-Struktur anlegen
		tmp = new( DSTATES );

		//unmarkiert
		tmp->marked = false;

		//Index des DEA-Zustandes
		tmp->deaIndex = deaIndex;

		//auf dem Stack
		dstatesStack[dstatesStackPos++] = tmp;
	}

	//DEA-Zustands-Index zurckliefern
	return( deaIndex );
}


ulong ssLexClass::insertDEAState( ulong *index, ulong anz, bool dummy )
{
	//einen neuen DEA-Zustand
	DEA_STATES	**tmp1, *tmp2;
	STATE_STR	*s;
	ulong		i;

	//genug Speicher
	tmp1 = new( DEA_STATES *[DEAStatesCnt + 1] );

	//kopieren
	memcpy( tmp1, DEAStates, sizeof( DEA_STATES * ) * DEAStatesCnt );

	//alten Speicher freigeben
	if( DEAStates )
		delete[] ( DEAStates );

	//Zeiger
	DEAStates = tmp1;

	//Speicher fr eine DEA_STATES-Struktur
	tmp2 = new( DEA_STATES );

	//Speicher fr die NEA-Zustnde
	tmp2->neaIndex = new( ulong[anz] );

	//kopieren
	memcpy( tmp2->neaIndex, index, sizeof( ulong ) * anz );

	//Anzahl der NEA-Zustnde
	tmp2->neaIndexCnt = anz;

	//Index dieses DEA-Zustandes
	tmp2->index = DEAStatesCnt;

	//kein NEA
	tmp2->finitNEA = 0L;
	tmp2->laNEA = 0L;

	//Default
	tmp2->la = false;
	tmp2->finit = false;

	//ist es ein toter Zustand, der fr die Zustandsminimierung bentigt wird?
	if( dummy == true )
		//Ja
		tmp2->dummy = true;

	else
		//Nein
		tmp2->dummy = false;

	//prfen, ob es ein Finit-Zustand ist
	for( i = 0; i < anz; i++ )
	{
		//Zeiger auf NEA-Zustand
		s = stateStr[index[i]];

		//Finit-Zustand?
		if( s->finit == true )
		{
			//Ja
			tmp2->finit = true;

			//NEA_STR eintragen?
			if( !tmp2->finitNEA )
				//Ja, immer nur den ersten!
				tmp2->finitNEA = s->nea;
		}

		//Lookahead-Zustand?
		if( s->la == true )
		{
			//Ja
			tmp2->la = true;

			//NEA_STR eintragen?
			if( !tmp2->laNEA )
				//Ja, immer nur den ersten!
				tmp2->laNEA = s->nea;
		}
	}

	//eintragen
	DEAStates[DEAStatesCnt] = tmp2;

	//Index des Zustands zurckliefern
	return( DEAStatesCnt++ );
}


long ssLexClass::lookupDStates( ulong *index, ulong anz )
{
	//eine Menge von NEA-Zustnden, d.h. einen DEA-Zustand suchen
	DEA_STATES	*dea;
	DSTATES		*d;
	ulong		i;

	//Alle bisherigen DEA-Zustnde
	for( i = 0; i < dstatesStackPos; i++)
	{
		//Zeiger
		d = dstatesStack[i];

		//Zeiger auf DEA-Zustand
		dea = DEAStates[d->deaIndex];

		//Anzahl der Eintrge gleich?
		if( anz == dea->neaIndexCnt )
		{
			//Ja, vergleichen
			if( !memcmp( index, dea->neaIndex, sizeof( ulong ) * anz ) )
				//Ja, den DEA-Zustand gibt es bereits
				return( d->deaIndex );
		}
	}

	//den DEA-Zustand gibt es noch nicht
	return( -1 );
}


long ssLexClass::getUnmarkedDStates( void )
{
	//einen unmarkierten DEA-Zustand holen
	DSTATES		*d;
	ulong		i;

	//Alle bisherigen DEA-Zustnde
	for( i = 0; i < dstatesStackPos; i++)
	{
		//Zeiger
		d = dstatesStack[i];

		//unmarkiert?
		if( d->marked == false )
			//Ja
			return( i );
	}

	//es gibt keine unmarkierten DEA-Zustnde mehr
	return( -1 );
}


void ssLexClass::markDStates( ulong index )
{
	//einen unmarkierten DEA-Zustand markieren
	DSTATES		*d = dstatesStack[index];

	//markieren
	d->marked = true;
}


void ssLexClass::insertDTran( SC_STR *sc, int type, long from, long to, uchar c )
{
	//einen Zustandsbergang in die DEA-bergangstabelle eintragen
	DTRAN	**tmp1, *tmp2, **myDTran;
	ulong	i, *myDTranCnt, index;

	//NEA darf nur am Zeilenanfang stehen?
	if( type == BEGLINE_NEA )
	{
		//Ja
		myDTran = sc->DTran2;

		//Anzahl der bisherigen Zustnde
		myDTranCnt = &sc->DTran2Cnt;

		//Index des Zustands in der Tabelle
		index = from - sc->begLineDEAIndex;
	}

	else
	{
		//NEA darf berall stehen
		myDTran = sc->DTran1;

		//Anzahl der bisherigen Zustnde
		myDTranCnt = &sc->DTran1Cnt;

		//Index des Zustands in der Tabelle
		index = from - sc->DEAIndex;
	}



	//neue Zeile erzeugen?
	if( !myDTran || ( ( *myDTranCnt - 1 ) < index ) )
	{
		//genug Speicher fr alle Zeilen
		tmp1 = new( DTRAN *[index + 1] );

		//initialisieren
		memset( tmp1, 0, sizeof( DTRAN * ) * ( index + 1 ) );

		//umkopieren
		memcpy( tmp1, myDTran, sizeof( DTRAN * ) * *myDTranCnt );

		//Speicher fr alle leeren Zeilen anfordern
		for( i = 0; i < ( index + 1 ); i++ )
		{
			//leer?
			if( !tmp1[i] )
			{
				//Ja, Speicher anfordern
				tmp2 = new( DTRAN );

				//initialisieren
				memset( tmp2, 0, sizeof( DTRAN ) );

				//Speicher fr die bergnge
				tmp2->to = new( ulong[cclWidth] );
#warning	tmp2->to = new( ulong[cclWidth] );

				//lschen
				memset( tmp2->to, 0, sizeof( int ) * cclWidth );

				//DEA-Index
				tmp2->index = from;

				//eintragen
				tmp1[i] = tmp2;

				//zhlen
				(*myDTranCnt)++;
			}
		}

		//alten Speicher freigeben
		if( myDTran )
			delete[] ( myDTran );

		//Adresse
		myDTran = tmp1;
	}

	//bergang eintragen
	myDTran[index]->index = from;
	myDTran[index]->to[c] = to;

	//NEA darf nur am Zeilenanfang stehen?
	if( type == BEGLINE_NEA )
		//Ja
		sc->DTran2 = myDTran;

	else
		//NEA darf berall stehen
		sc->DTran1 = myDTran;
}


void ssLexClass::NEA2DEA( void )
{
	//die NEAen in DEAen wandeln
	DEA_STATES	*dea;
	ECLOS_STR	*eclosStr;
	MOVE_STR	*moveStr;
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		i, j, k;
	ulong		dDEAIndex;
	uchar		c;
	long		dstatesIndex, newDEAIndex;
	char		hexChar[10];

	//Meldung?
	if( argv_str->verbose == true )
		//Meldung
		cout << "sslex: Generating dea states...\n";

	//alle DEA-Zustnde werden fortlaufend nummeriert
	DEAStatesCnt = 0;
	DEAStates = 0L;

	//die DEA-bergangstabelle aller SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

#ifdef DEBUG
		//Debug-Meldung
		cout << "SC: " << sc->name << "\n";
#endif

		//gibt es berhaupt NEAen, die berall stehen drfen?
		if( sc->nea1Anz )
		{
			//den Start-Index des DEA merken, bei dem die NEA auch am Zeilenanfang stehen drfen
			sc->DEAIndex = DEAStatesCnt;

			//WICHTIG: DSTATES initialisieren
			initDStatesStack();

			//e-clos fr den ersten Zustand des DEA initialisieren
			eclosStr = createEClos();

			//der erste DEA-Zustand ist e-closure (Start-Zustnde aller NEAen dieser SC)
			//keine <<EOF>>-NEAen!
			for( j = 0; j < sc->neaArrCnt; j++ )
			{
				//Zeiger auf NEA
				nea = sc->neaArr[j];

				//<<EOF>>-NEA?
				if( nea->eof == false )
				{
					//zuerst ohne NEAen, die nur am Zeilenanfang stehen drfen
					if( nea->begLine == false )
					{
						//Zustand eintragen
						insertFromEClos( eclosStr, nea->startState );
#ifdef DEBUG
						//NEA ausgeben
						outputNEA( sc->neaArr[j] );
#endif
					}
				}
			}

			//e-clos generieren
			generateEClos( eclosStr );

			//diese Zustandsmenge in DSTATES eintragen
			insertDStates( eclosStr->to, eclosStr->toCnt );

			//Speicher fr eclos freigeben
			removeEClos( eclosStr );

			//solange unmarkierte DEA-Zustnde auf dem Stack sind
			while( ( dstatesIndex = getUnmarkedDStates() ) >= 0 )
			{
				//markieren
				markDStates( dstatesIndex );

				//Zeiger auf DSTATES
				dea = DEAStates[dstatesStack[dstatesIndex]->deaIndex];

				//alle Zeichen
				for( k = 0; k < cclWidth; k++ )
				{
					//fr Debug-Zwecke
					c = k;

					//move( deaIndex, k ) bilden
					moveStr = createMove( k );

					//die NEA-Zustnde des DEA-Zustandes deaIndex eintragen
					insertFromMove( moveStr, dea->neaIndex, dea->neaIndexCnt );

					//bergnge generieren
					generateMove( moveStr );

					//nun e-closure( move( deaIndex, k ) ) bilden
					eclosStr = createEClos();

					//Zustnde eintragen
					insertFromEClos( eclosStr, moveStr->to, moveStr->toCnt );

					//generieren
					generateEClos( eclosStr );

					//Wurden Zustnde erzeugt?
					if( eclosStr->toCnt )
					{
						//diese neue NEA-Zustandsmenge ist ein DEA-Zustand, eintragen
						newDEAIndex = insertDStates( eclosStr->to, eclosStr->toCnt );
#ifdef DEBUG
						//Zeichen ausgeben
						outputChar( k, hexChar );

						//Debug-Meldung
						cout << "DTran[" << dea->index << "][" << hexChar << "] = " << newDEAIndex << "\n";
#endif
						//in DEA-Zustandsbergangstabelle eintragen
						insertDTran( sc, NORM_NEA, dea->index, newDEAIndex, k );
					}

					else
						//dieser Zustand hat fr das Eingabesymbol k keinen bergang
						//in DEA-Zustandsbergangstabelle eintragen
						insertDTran( sc, NORM_NEA, dea->index, -1, k );

					//Speicher fr eclos freigeben
					removeEClos( eclosStr );

					//Speicher fr moevStr freigeben
					removeMove( moveStr );
				}
			}

#ifdef DEBUG
			//die DEA-Zustnde ausgeben
			outputDEAStates();
#endif
			//DSTATES deinitialisieren
			removeDStatesStack();
		}

		/*
			An diese Stelle wird auch gesprungen, wenn sc->nea1Anz = 0, d.h. wenn die SC keine
			NEAen hat, die berall stehen drfen. In diesem Falle hat die SC fr diese NEAen nur
			den "tote" Zustand. Dies wird bei der Zustandsminimierung in der Routine minDEA
			bentigt.
			Fr die NEAen, die nur am Zeilenanfang stehen drfen, ist dies nicht notwendig, da dann
			die NEAen aktiv sein werden, die berall stehen drfen.
		*/

		//nun einen toten Zustand d erzeugen, s. Drache S. 172, fr die Zustandsminimierung
		dDEAIndex = insertDEAState( 0L, 0, true );

		//hat die SC keine NEAen, die berall stehen drfen?
		if( !sc->nea1Anz )
			//nein, toter Zustand d ist zugleich Startzustand der NEAen, die berall stehen drfen
			sc->DEAIndex = dDEAIndex;

		//alle Zeichen
		for( k = 0; k < cclWidth; k++ )
			//in DEA-Zustandsbergangstabelle eintragen
			insertDTran( sc, NORM_NEA, dDEAIndex, dDEAIndex, k );




		//hat die SC NEAen, die ausschlielich am Zeilenanfang stehen drfen?
		if( sc->nea1Anz || sc->nea2Anz )
		{
			//Nun die NEAen betrachten, die ausschlielich am Zeilenanfang stehen drfen!

			//den Start-Index des DEA merken, bei dem die NEA auch am Zeilenanfang stehen drfen
			sc->begLineDEAIndex = DEAStatesCnt;


			//WICHTIG: DSTATES initialisieren
			initDStatesStack();

			//e-clos fr den ersten Zustand des DEA initialisieren
			eclosStr = createEClos();

			//der erste DEA-Zustand ist e-closure(Start-Zustnde aller NEAen dieser SC)
			//keine <<EOF>>-NEAen!
			for( j = 0; j < sc->neaArrCnt; j++ )
			{
				//Zeiger auf NEA
				nea = sc->neaArr[j];

				//<<EOF>>-NEA?
				if( nea->eof == false )
				{
					//Zustand eintragen
					insertFromEClos( eclosStr, sc->neaArr[j]->startState );
#ifdef DEBUG
					//NEA ausgeben
					outputNEA( sc->neaArr[j] );
#endif
				}
			}

			//e-clos generieren
			generateEClos( eclosStr );

			//diese Zustandsmenge in DSTATES eintragen
			insertDStates( eclosStr->to, eclosStr->toCnt );

			//Speicher fr eclos freigeben
			removeEClos( eclosStr );

			//solange unmarkierte DEA-Zustnde auf dem Stack sind
			while( ( dstatesIndex = getUnmarkedDStates() ) >= 0 )
			{
				//markieren
				markDStates( dstatesIndex );

				//Zeiger auf DSTATES
				dea = DEAStates[dstatesStack[dstatesIndex]->deaIndex];

				//alle Zeichen
				for( k = 0; k < cclWidth; k++ )
				{
					//move( deaIndex, k ) bilden
					moveStr = createMove( k );

					//die NEA-Zustnde des DEA-Zustandes deaIndex eintragen
					insertFromMove( moveStr, dea->neaIndex, dea->neaIndexCnt );

					//bergnge generieren
					generateMove( moveStr );

					//nun e-closure( move( deaIndex, k ) ) bilden
					eclosStr = createEClos();

					//Zustnde eintragen
					insertFromEClos( eclosStr, moveStr->to, moveStr->toCnt );

					//generieren
					generateEClos( eclosStr );

					//Wurden Zustnde erzeugt?
					if( eclosStr->toCnt )
					{
						//diese neue NEA-Zustandsmenge ist ein DEA-Zustand, eintragen
						newDEAIndex = insertDStates( eclosStr->to, eclosStr->toCnt );
#ifdef DEBUG
						//Zeichen ausgeben
						outputChar( k, hexChar );

						//Debug-Meldung
						cout << "DTran[" << dea->index << "][" << hexChar << "] = " << newDEAIndex << "\n";
#endif
						//in DEA-Zustandsbergangstabelle eintragen
						insertDTran( sc, BEGLINE_NEA, dea->index, newDEAIndex, k );
					}

					else
						//dieser Zustand hat fr das Eingabesymbol k keinen bergang
						//in DEA-Zustandsbergangstabelle eintragen
						insertDTran( sc, BEGLINE_NEA, dea->index, -1, k );

					//Speicher fr eclos freigeben
					removeEClos( eclosStr );

					//Speicher fr moevStr freigeben
					removeMove( moveStr );
				}
			}

#ifdef DEBUG
			//die DEA-Zustnde ausgeben
			outputDEAStates();
#endif
			//DSTATES deinitialisieren
			removeDStatesStack();
		}

		/*
			An diese Stelle wird auch gesprungen, wenn sc->nea1Anz = 0, d.h. wenn die SC keine
			NEAen hat, die berall stehen drfen. In diesem Falle hat die SC fr diese NEAen nur
			den "tote" Zustand. Dies wird bei der Zustandsminimierung in der Routine minDEA
			bentigt.
			Fr die NEAen, die nur am Zeilenanfang stehen drfen, ist dies nicht notwendig, da dann
			die NEAen aktiv sein werden, die berall stehen drfen.
		*/

		//nun einen toten Zustand d erzeugen, s. Drache S. 172, fr die Zustandsminimierung
		dDEAIndex = insertDEAState( 0L, 0, true );

		//hat die SC keine NEAen?
		if( !sc->nea1Anz && !sc->nea2Anz )
			//nein, toter Zustand d ist zugleich Startzustand der NEAen, die nur am Zeilenanfang
			//stehen drfen
			sc->begLineDEAIndex = dDEAIndex;

		//alle Zeichen
		for( k = 0; k < cclWidth; k++ )
			//in DEA-Zustandsbergangstabelle eintragen
			insertDTran( sc, BEGLINE_NEA, dDEAIndex, dDEAIndex, k );
	}
}


void ssLexClass::findNoRules( void )
{
	/*	Finde Regeln, die nie ausgefhrt werden. Hat ein DEA-Finit-Zustand mehrere NEA-Finit-Zustnde, die
		zu verschiedenen NEAen gehren (und damit zu verschiedenen Aktionen), so wird der zuerst eingetragene
		bevorzugt.
	*/
	DEA_STATES	*dea;
	STATE_STR	*ffinits, *s;
	NEA_STR		*ffinitNea, *nea;
	SC_STR		*sc;
	ulong		*stack, stackPos = 0, state, ffinit, baseState, endIndex;
	ulong		*marked;
	ulong		i = 0, k, l, j;
	long		dest;

	//Meldung?
	if( argv_str->verbose == true )
		//Ja
		cout << "sslex: Searching never matching rules...\n";

	//Speicher fr den Stack
	stack = new( ulong[DEAStatesCnt * cclWidth] );

	//Wenn ein Zustand geprft wurde, wird er markiert, um Endelos-Schleifen zu vermeiden
	marked = new( ulong[DEAStatesCnt] );

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf Start-Condition
		sc = &scStr[i];

		//Hat die SC berhaupt NEAen?
		if( sc->neaArrCnt )
		{
			//Array fr die Markierungen initialisieren
			memset( marked, 0, sizeof( ulong ) * DEAStatesCnt );

			//Hat die SC NEAen, die berall stehen drfen?
			if( sc->DTran1Cnt )
			{
				//Start-Zustand der NEAen, die berall stehen drfen, auf den Stack
				stack[stackPos++] = baseState = sc->DEAIndex;

				//solange Zustnde auf dem Stack sind
				while( stackPos )
				{
					//Zustand holen
					state = stack[--stackPos];

					//schon markiert?
					if( !marked[state] )
					{
						//markieren
						marked[state]++;

						//prfen, ob dieser DEA-Zustand mehrere NEA-Finit-Zustnde besitzt
						dea = DEAStates[state];

						//hat er Finit-Zustnde?
						if( dea->finit == true )
						{
							//Alle NEA-Zustnde
							for( j = 0, ffinit = 0; j < dea->neaIndexCnt; j++ )
							{
								//Zeiger auf STATE_STR
								s = stateStr[dea->neaIndex[j]];

								//ist es ein NEA-Finit-Zustand?
								if( s->finit == true )
								{
									//der erste Finit-Zustand?
									if( !ffinit )
									{
										//Ja, merken
										ffinit = 1;

										//Regel wird ausgefhrt
										s->isUseful = true;

										//STATE_STR merken
										ffinits = s;

										//die NEA-Strukur merken
										ffinitNea = s->nea;
									}

									else
									{
										//DEA-Zustand beinhaltet mehrere NEA-Finit-Zustnde
										nea = s->nea;

										//Zeige Konflikte zwischen reg. Ausdrcken?
										if( argv_str->showConflicts == true )
											//Meldung
											cerr << "sslex: WARNING: Conflict between reg. Expession " << ffinitNea->regText << ", line " << ffinitNea->line << ", and reg. Expression " << nea->regText << ", line " << nea->line << "!\n";
									}
								}
							}
						}


						//Ziel-Zustnde auf dem Stack
						for( k = 0; k < cclWidth; k++ )
						{
							//Zustand holen
							dest = sc->DTran1[state - baseState]->to[k];

							//Hat dieser DEA-Zustand einen bergang fr k?
							if( dest >= 0 )
							{
								//Ja, Zustand bereits markiert?
								if( !marked[dest] )
								{
									//Nein, ist dieser Zustand bereits auf dem Stack?
									for( l = 0; l < stackPos; l++ )
									{
										//Zustand dest?
										if( stack[l] == dest )
											//Ja, nicht schieben
											break;
									}

									//Zustand schon auf dem Stack?
									if( l == stackPos )
										//Nein
										stack[stackPos++] = dest;
								}
							}
						}
					}
				}
			}


			//Nun die NEAen, die ausschlielich am Zeilenanfang stehen drfen
			if( sc->DTran2Cnt )
			{
				//Array fr die Markierungen initialisieren
//				memset( marked, 0, sizeof( ulong ) * DEAStatesCnt );

				//Start-Zustand der NEAen, die ausschlielich am Zeilenanfang stehen drfen, auf den Stack
				stack[stackPos++] = baseState = sc->begLineDEAIndex;

				//solange Zustnde auf dem Stack sind
				while( stackPos )
				{
					//Zustand holen
					state = stack[--stackPos];

					//schon markiert?
					if( !marked[state] )
					{
						//markieren
						marked[state]++;

						//prfen, ob dieser DEA-Zustand mehrere NEA-Finit-Zustnde besitzt
						dea = DEAStates[state];

						//hat er Finit-Zustnde?
						if( dea->finit == true )
						{
							//Alle NEA-Zustnde
							for( j = 0, ffinit = 0; j < dea->neaIndexCnt; j++ )
							{
								//Zeiger auf STATE_STR
								s = stateStr[dea->neaIndex[j]];

								//ist es ein NEA-Finit-Zustand?
								if( s->finit == true )
								{
									//der erste Finit-Zustand?
									if( !ffinit )
									{
										//Ja, merken
										ffinit = 1;

										//Regel wird ausgefhrt
										s->isUseful = true;

										//STATE_STR merken
										ffinits = s;

										//die NEA-Strukur merken
										ffinitNea = s->nea;
									}

									else
									{
										//DEA-Zustand beinhaltet mehrere NEA-Finit-Zustnde
										nea = s->nea;

										//Zeige Konflikte zwischen reg. Ausdrcken?
										if( argv_str->showConflicts == true )
											//Meldung
											cerr << "sslex: WARNING: Conflict between reg. Expession " << ffinitNea->regText << ", line " << ffinitNea->line << ", and reg. Expression " << nea->regText << ", line " << nea->line << "!\n";
									}
								}
							}
						}


						//Ziel-Zustnde auf dem Stack
						for( k = 0; k < cclWidth; k++ )
						{
							//Zustand holen
							dest = sc->DTran2[state - baseState]->to[k];

							//Hat dieser DEA-Zustand einen bergang fr k?
							if( dest >= 0 )
							{
								//Ja, Zustand bereits markiert?
								if( !marked[dest] )
								{
									//Nein, ist dieser Zustand bereits auf dem Stack?
									for( l = 0; l < stackPos; l++ )
									{
										//Zustand dest?
										if( stack[l] == dest )
											//Ja, nicht schieben
											break;
									}

									//Zustand schon auf dem Stack?
									if( l == stackPos )
										//Nein
										stack[stackPos++] = dest;
								}
							}
						}
					}
				}
			}


			//den End-Zustand berechnen
			if( sc->begLineDEAIndex >= 0 )
				//Ja
				endIndex = sc->begLineDEAIndex + sc->DTran2Cnt - 1;

			else
				//hat keine NEAen, die ausschlielich am Zeilenanfang stehen mssen
				endIndex = sc->DEAIndex + sc->DTran1Cnt - 1;

			//nach nicht erreichbaren Zustnden suchen
			for( k = sc->DEAIndex; k <= endIndex; k++ )
			{
				//Zeiger auf DEA-Struktur
				dea = DEAStates[k];

				//unmarkierter Zustand?
				if( !marked[k] && ( dea->dummy == false ) )
					//Ja, Meldung
					cerr << "sslex: DEA-State " << k << " in start condition " << sc->name << " will never be reached!\n";
			}
		}
	}

	//Speicher freigeben
	delete[] ( stack );
	delete[] ( marked );


	//prfen, ob es Regeln gibt, die niemals ausgefhrt werden
	for( i = 0; i < stateStrCnt; i++ )
	{
		//Zeiger auf NEA-Zustand
		s = stateStr[i];

		//Finit-Zustand?
		if( ( s->finit == true ) && ( s->isUseful == false ) && ( s->nea ) && ( s->nea->eof == false ) )
			//Regel wird nie ausgefhrt
			cerr << "sslex: WARNING: line " << s->nea->line << ": Rule " << s->nea->regText << " will never be matched!\n";
	}
}


void ssLexClass::outputDEAStates( void )
{
	//die DEA-Zustnde ausgeben mit den zugehrigen NEA-Zustnden
	DEA_STATES	*dea;
	DSTATES		*d;
	ulong		i, j;

	//die DEA-Zustnde befinden sich in dstatesStack
	for( i = 0; i < dstatesStackPos; i++ )
	{
		//Zeiger auf DSTATES
		d = dstatesStack[i];

		//Zeiger auf DEA-Zustand
		dea = DEAStates[d->deaIndex];

		//ausgeben
		cout << "DEA(" << d->deaIndex << ") = { ";

		//Alle NEA-Zustnde
		for( j = 0; j < dea->neaIndexCnt; j++ )
			cout << " " << dea->neaIndex[j] << " ";

		//abschlieen
		cout << "}\n";
	}
}


void ssLexClass::outputCPPMinDEA( ofstream &file )
{
	/*
		Die bergangstabelle ausgeben, mit Minimierung der DEA-Zustandsmenge. Jede Gruppe entspricht
		einem neuen DEA-Zustand (sofern sie nicht disabled ist).
	*/
	DEA_STATES	*dea;
	GROUP_STR	**grp, *tmp, *destGrp;
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		*transTable, *transState, baseDEAState = 0, index, state, dest;
	ulong		baseState, base1State, end1State, base2State, end2State;
	char		widthPuffer[10], *regText;
	int			i, j, k, l, width;


	//die Breite eines Zustandes bestimmen
	sprintf( widthPuffer, "%ld", numberOfGroups );
	width = strlen( widthPuffer );

	//Mindestbreite: 4
	if( width < 4 )
		width = 4;


	//bersetzt Gruppen-Indices in DEA-Zustnde
	transState = new( ulong[maxGroupIndex] );

	//bersetzt die Gruppen-Indices in laufende Nummern
	transTable = new( ulong[maxGroupIndex] );

	//fr die Erzeugung der Accept-Tabelle
	finitNEA = new( NEA_STR *[numberOfGroups] );

	//initialisieren
	memset( finitNEA, 0, sizeof( NEA_STR * ) * numberOfGroups );

	//fr die Erzeugung der Lookahead-Tabelle
	laNEA = new( NEA_STR *[numberOfGroups] );

	//initialisieren
	memset( laNEA, 0, sizeof( NEA_STR * ) * numberOfGroups );


	//Header ausgeben
	file << "\n//Transition-Table\n";
	file << "long SSLEXScanner::ssLexTable[SSLEX_STATE][CCLWIDTH] = \n{\n";

	//alle Zeichen ausgeben
	file << "/*\n";

	//alle Zeichen ausgeben
	for( i = j = k = 0; i < cclWidth; i++, j++, k++ )
	{
		//Alle 32 Zeichen einen Zeilenwechsel
		if( k == 32 )
		{
			//Ja
			file << "\n";
			k = 0;
		}

		//Breite setzen
		file.width( width );

		//Zeichen schreiben
		outputChar( i, widthPuffer );

		//Zeichen ist druckbar
		file << widthPuffer;

		//letztes Element?
		if( j < 127 )
			//Komma ausgeben
			file << ",";
	}

	//abschlieen
	file << "\n*/\n";



	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger
		sc = &scStr[i];


		//Anfangs- und Endzustand der NEAen, die berall stehen drfen
		base1State = sc->DEAIndex;
		end1State = base1State + sc->DTran1Cnt - 1;

		//Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen drfen
		base2State = sc->begLineDEAIndex;
		end2State = base2State + sc->DTran2Cnt - 1;


		//transTable initialisieren
		memset( transTable, 0, sizeof( ulong ) * maxGroupIndex );


		/*
			Die erste Gruppe ist der neue Startzustand der NEAen, die berall stehen drfen.
			Die zweite Gruppe ist der neue Startzustand der NEAen, die nur am Zeilenanfang stehen drfen.
		*/

		//Zeiger auf Gruppen-Strukturen
		grp = sc->grp;

		//Start-Zustand merken
		baseState = baseDEAState;


		//die neuen DEA-Zustnde in die SC eintragen
		sc->firstStart = baseState;
		sc->secondStart = baseState + 1;


		//transTable aufbereiten
		for( j = 0; j < sc->grpCnt; j++ )
		{
			//Zeiger auf Gruppe
			tmp = grp[j];

			//laufende Nummer
			transTable[tmp->index] = j;

			//Gruppe valid?
			if( tmp->valid == true )
				//Da jede Gruppe einer Menge von quivalenten DEA-Zustnden entspricht, wird jeder
				//Gruppe ein neuer "DEA-Zustand" zugewiesen.
				transState[tmp->index] = baseDEAState++;
		}

		//SC ausgeben
		file << "\n//Startcondition: " << sc->name << "\n";

		//Alle Gruppen
		for( l = 0; l < sc->grpCnt; l++ )
		{
			//ist die Gruppe disabled?
			if( grp[l]->valid == true )
			{
				//Nein, aus der Gruppe einen reprsentativen Zustand nehmen
				index = grp[l]->DEAIndex[0];

				//Zeiger auf DEA-Struktur
				dea = DEAStates[index];

				//aktueller Zustand
				state = transState[grp[l]->index];

				//state darf nicht >= max sein
				assert( state < numberOfGroups );

				//ist dieser Zustand ein akzeptierender Zustand?
				if( dea->finit == true )
					//Ja, Zeiger auf NEA merken
					finitNEA[state] = dea->finitNEA;

				//ist dieser Zustand ein Lookahead-Zustand?
				if( dea->la == true )
					//Ja, markieren
					laNEA[state] = dea->laNEA;

				//aktuellen Zustand ausgeben
				file << "/* " << state << " */\n{\n";

				//Alle Zeichen
				for( j = k = 0; j < cclWidth; j++, k++ )
				{
					//Alle 32 Zeichen einen Zeilenwechsel
					if( k == 32 )
					{
						//Ja
						file << "\n";
						k = 0;
					}

					//ausgeben
					file.width( width );

					//Index des Zielzustands
					if( index <= end1State )
						dest = sc->DTran1[index - base1State]->to[j];

					else
						dest = sc->DTran2[index - base2State]->to[j];

					//DEA-Struktur des Ziel-Zustands
					dea = DEAStates[dest];

					//Gruppe des Zielzustands
					destGrp = grp[transTable[dea->groupIndex]];

					//ist die Gruppe valid?
					if( ( destGrp->valid == true ) && ( dea->dummy == false ) )
						//ausgeben
						file << transState[destGrp->index];

					else
						//kein bergang
						file << "-1";

					//letztes Element?
					if( j < ( cclWidth - 1 ) )
						//Komma ausgeben
						file << ",";
				}

				//letztes Element?
				if( state < ( numberOfGroups - 1 ) )
					//Komma ausgeben
					file << "\n},\n";

				else
					//Ohne Komma ausgeben
					file << "\n}\n";
			}
		}
	}


	//abschlieen
	file << "\n};\n";

	//Nun das Array fr die Accept-Zustnde erzeugen
	file << "\n//Accept-Array\n";
	file << "ulong SSLEXScanner::ssLexAccept[SSLEX_STATE] = \n{\n";

	//Alle DEA-Zustnde
	for( i = 0; i < numberOfGroups; i++ )
	{
		//Zustand ausgeben
		file << "/* " << i << " */\n";

		//Zeiger auf den entsprechenden NEA
		nea = finitNEA[i];

		//Finit-Zustand?
		if( nea )
		{
			//Ja, reg. Text des zugehrigen NEA ausgeben

			//reg. Ausdruck in Textform anpassen
			regText = toString( nea->regText );

			//ausgeben
			file << "\n//Line " << nea->line << ": " << regText << "\n";
			file << i;

			//Speicher freigeben
			delete[] ( regText );
		}

		else
			//nein
			file << "0";

		//letzter Zustand?
		if( i < ( numberOfGroups - 1 ) )
			//Nein, Komma
			file << ",\n";
	}

	//abschliessen
	file << "\n};\n\n";


	//Gibt es Lookahead-NEAs?
	if( laUsed == true )
	{
		//Nun das Array fr die Lookahead-Zustnde erzeugen
		file << "\n//Lookahead-Array\n";
		file << "ulong SSLEXScanner::ssLexLA[SSLEX_STATE] = \n{\n";

		//Alle DEA-Zustnde
		for( i = 0; i < numberOfGroups; i++ )
		{
			//Zustand ausgeben
			file << "/* " << i << " */\n";

			//Zeiger auf den entsprechenden NEA
			nea = laNEA[i];

			//Lookahead-Zustand?
			if( nea )
			{
				//reg. Ausdruck in Textform anpassen
				regText = toString( nea->regText );

				//Ja, reg. Text des zugehrigen NEA ausgeben
				file << "\n//Line " << nea->line << ": " << regText << "\n";
				file << "1";

				//Speicher freigeben
				delete[] ( regText );
			}

			else
				//nein
				file << "0";

			//letzter Zustand?
			if( i < ( numberOfGroups - 1 ) )
				//Nein, Komma
				file << ",\n";
		}

		//abschliessen
		file << "\n};\n\n";
	}


	//Speicher freigeben
	delete[] ( transTable );
	delete[] ( transState );
}


void ssLexClass::outputCPPDebug( ofstream &file )
{
	//die Debug-Strukturen ausgeben
	DEA_STATES	*dea;
	STATE_STR	*s;
	GROUP_STR	**grp;
	DEBUG_STR	*debugStr, *d;
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		k, l, index, anzNEA = 0, cnt, DEACnt;
	ulong		*marked, *anzRegExp;
	long		i, j;
	char		*regText;

	//Debug-Makro ausgeben
	file << "\n#ifdef SSLEX_DEBUG\n";

	//initialisieren
	debugStrPos = 0;

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Anzahl der NEAen dieser SC
		anzNEA += sc->neaArrCnt;
	}

	//Speicher fr die DEBUG_STR anfordern
	debugStr = new( DEBUG_STR[anzNEA] );

	//Nun die DEBUG_STR fllen
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Alle NEAen
		for( j = 0; j < sc->neaArrCnt; j++ )
		{
			//Zeiger auf NEA
			nea = sc->neaArr[j];

			//ist die NEA-Struktur bereits eingetragen?
			for( k = 0; k < debugStrPos; k++ )
			{
				//schon da?
				if( debugStr[k].nea == nea )
					//Ja
					break;
			}

			//war sie schon eingetragen?
			if( k ==debugStrPos )
			{
				//nein, eintragen
				debugStr[debugStrPos].index = debugStrPos;
				debugStr[debugStrPos++].nea = nea;
			}
		}
	}


	//die Debug-Struktur ausgeben
	file << "\n//Structure with regular expressions in text form\n";
	file << "char *SSLEXScanner::regText[regTextSize] = {\n";

	//Alle Eintrge
	for( i = 0; i < debugStrPos; i++ )
	{
		//Zeiger
		d = &debugStr[i];

		//reg. Ausdruck in Textform anpassen
		regText = toString( d->nea->regText );

		//ausgeben
		file << "\"" << regText << "\"";

		//letzter Eintrag?
		if( i < ( debugStrPos - 1 ) )
			//nein
			file << ",";

		//ausgeben
		file << "\t// " << d->nea->regText << ", line " << d->nea->line << "\n";

		//Speicher freigeben
		delete[] ( regText );
	}

	//abschlieen
	file << "};\n\n";



	//markierte Indices nicht ausgeben
	marked = new( ulong[debugStrPos] );

	//Anzahl der assoziierten regulren Ausdrcke eines Zustands merken
	anzRegExp = new( ulong[numberOfGroups] );

	//Nun die Arrays mit den Indices in regText ausgeben
	file << "\n//Array with indices in regText\n";

	//Alle SC
	for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Zeiger auf Gruppen-Array
		grp = sc->grp;

		//Alle Gruppen ( = reduzierte DEA-Zustnde ) einer SC
		for( j = 0; j < sc->grpCnt; j++ )
		{
			//ist die Gruppe disabled?
			if( grp[j]->valid == true )
			{
				//ausgeben
				file << "ulong SSLEXScanner::regTextIndex" << DEACnt << "[] = { ";

				//inizialisieren
				memset( marked, 0, sizeof( ulong ) * debugStrPos );

				//aus der Gruppe einen reprsentativen Zustand nehmen
				index = grp[j]->DEAIndex[0];

				//Zeiger auf DEA-Struktur
				dea = DEAStates[index];

				//Alle NEA-Zustnde dieses NEA-Zustands
				for( k = cnt = 0; k < dea->neaIndexCnt; k++ )
				{
					//Zeiger auf NEA-Zustand
					s = stateStr[dea->neaIndex[k]];

					//den NEA dieses Zustands in DEBUG_STR suchen
					for( l = 0; l < debugStrPos; l++ )
					{
						//gleich?
						if( ( debugStr[l].nea == s->nea ) && !marked[l] )
						{
							//Ja, ausgeben
							if( cnt )
								file << ", ";

							//Index ausgeben
							file << l;

							//markieren
							marked[l]++;

							//Zhler
							cnt++;
						}
					}
				}

				//Anzahl der regulren Ausdrcke merken
				anzRegExp[DEACnt++] = cnt;

				//abschliessen
				file << " };\n";
			}
		}
	}




	//Nun die DEBUG_STR ausgeben
	file << "\n\n//Structure with debugging information\n";
	file << "SSLEXDebugStr SSLEXScanner::debugStr[SSLEX_STATE] = {\n";

	//Alle SC
	for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Zeiger auf Gruppen-Array
		grp = sc->grp;

		//Alle Gruppen ( = reduzierte DEA-Zustnde ) einer SC
		for( j = 0; j < sc->grpCnt; j++ )
		{
			//ist die Gruppe disabled?
			if( grp[j]->valid == true )
			{
				//ausgeben
				file << "{ " << DEACnt << ", regTextIndex" << DEACnt << ", " << anzRegExp[DEACnt] << " }";

				//nchster DEA-Zustand
				DEACnt++;

				//mit Komma abschliessen?
				if( DEACnt < numberOfGroups )
					//Ja
					file << ",\n";

				else
					//ist letzter Eintrag
					file << "\n";
			}
		}
	}

	//abschlieen
	file << "};\n\n";



	//Nun das Array mit den reg. Ausdrcken bei Akzeptieren
	file << "\n//Array with regular expression at accepting\n";
	file << "char *SSLEXScanner::acceptRegText[SSLEX_STATE] = { ";

	//Alle SC
	for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Zeiger auf Gruppen-Array
		grp = sc->grp;

		//Alle Gruppen ( = reduzierte DEA-Zustnde ) einer SC
		for( j = 0; j < sc->grpCnt; j++ )
		{
			//ist die Gruppe disabled?
			if( grp[j]->valid == true )
			{
				//aus der Gruppe einen reprsentativen Zustand nehmen
				index = grp[j]->DEAIndex[0];

				//Zeiger auf DEA-Struktur
				dea = DEAStates[index];

				//akzepierend?
				if( dea->finit == true )
				{
					//Ja, reg. Ausdruck in Textform anpassen
					regText = toString( dea->finitNEA->regText );

					//ausgeben
					file << "\"" << regText << "\"";

					//Speicher freigeben
					delete[] ( regText );
				}

				else
					//ist kein akzeptierender Zustand
					file << "0L";

				//folgen noch welche?
				if( DEACnt < ( numberOfGroups - 1 ) )
					//Komma ausgeben
					file << ",\n";

				else
					//nein
					file << "\n";

				//DEA-Zustnde zhlen
				DEACnt++;
			}
		}
	}

	//abschlieen
	file << "\n};\n";


	//Debug-Makro ausgeben
	file << "#endif\n";


	//Start-Conditionen ausgeben
	file << "\n";
	file << "//name of the start conditions\n";
	file << "char *SSLEXScanner::scName[] = {\n";

	//die Namen der Start-Conditionen ausgeben
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//ausgeben
		file << "\t\"" << sc->name << "\", " << "\"NL_" << sc->name << "\"";

		//folgen noch welche?
		if( i < ( scStrAnz - 1 ) )
			//Komma ausgeben
			file << ",\n";
	}

	//abschlieen
	file << "\n};\n";





	//Speicher freigeben
	delete[] ( debugStr );
	delete[] ( marked );
	delete[] ( anzRegExp );
}


char *ssLexClass::toString( char *text )
{
	//wandelt die Steuerzeichen in druckbare Zeichen
	ulong	len = strlen( text ), cnt = 0;
	char	*tmp, *pos;

	//doppelt soviel Speicher gengt
	tmp = new( char[2 * len + 1] );

	//Null-Byte
	tmp[0] = 0;

	//Anfang merken
	pos = tmp;

	while( text[cnt] )
	{
		//Steuerzeichen?
		switch( text[cnt] )
		{
			case '\"':
			{
				//Anfhrungszeichen
				*pos++ = '\\';
				*pos++ = '"';
				*pos = 0;
				break;
			}

			case '\\':
			{
				//druckbar machen
				*pos++ = '\\';
				*pos++ = '\\';

				//Null-Byte
				*pos = 0;
				break;
			}

			default:
				//Zeichen kopieren
				*pos++ = text[cnt];
		}

		//nchstes Zeichen
		cnt++;
	}

	//Null-Byte
	*pos = 0;

	//String zurckliefern
	return( tmp );
}


void ssLexClass::outputAction( ofstream &file )
{
	//Aktionen ausgeben
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		i, j, k, *fArr;

	//fr Fehlerbehandlung
	file << "\n";
	file << "//Table for error handling\n";
	file << "int SSLEXScanner::err[scSize][CCLWIDTH] = { 0 };\n";
	file << "\n";
	file << "\n";




	//die Zustnde ausgeben, an denen ein Wechsel der Start-Conditionen stattfindet, ausgeben
	file << "\n";
	file << "//state of start conditions\n";
	file << "ulong SSLEXScanner::scIndex[] = {\n";

	//die Namen der Start-Conditionen ausgeben
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//ausgeben
		file << "\t" << sc->firstStart << ",";

		//SC als Namen im Kommentar ausgeben
		file << " //" << sc->name << "\n";

		//ausgeben
		file << "\t" << sc->secondStart;

		//folgen noch welche?
		if( i < ( scStrAnz - 1 ) )
			//Komma ausgeben
			file << ",";

		//ausgeben
		file << " //NL_" << sc->name << "\n";
	}

	//abschlieen
	file << "};\n";


	//Speicher fr das Array, das angibt, welche Finit-Zustnde bereits bearbeitet wurden
	fArr = new( ulong[numberOfGroups] );

	//initialisieren
	memset( fArr, 0, sizeof( ulong ) * numberOfGroups );


file << "\n";
file << "\n";
file << "SSLEXScanner::SSLEXScanner( char *data, ulong size )\n";
file << "{\n";
file << "	//initialize SSLEX\n";
file << "\n";
file << "	//no data?\n";
file << "	if( !data )\n";
file << "	{\n";
file << "		//error\n";
file << "		cerr << \"SSLEXScanner: No data!\\n\";\n";
file << "\n";
file << "		//exit\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//save length of text\n";
file << "	basePosLength = size;\n";
file << "\n";
file << "	//copy text to analyze due to unput\n";
file << "	pos = basePos = new( char[basePosLength + 1] );\n";
file << "\n";
file << "	//copy to analyze string. This is nesessary as there are zero-bytes allowed in scanning\n";
file << "	//text. But this would couse strlen to return only the length till the next zero-byte!\n";
file << "	memcpy( pos, data, sizeof( char ) * basePosLength );\n";
file << "	pos[basePosLength] = 0;\n";
file << "\n";
file << "	//end of scanning\n";
file << "	end = pos + basePosLength;\n";
file << "\n";
file << "	//start-condition INITIAL\n";
file << "	state = baseState = INITIAL;\n";
file << "\n";
file << "	//init with 8KB\n";
file << "	yyTextLen = 8*1024;\n";
file << "	yyText = new( char[yyTextLen + 1] );\n";
file << "	yyLeng = 0;\n";
file << "\n";
file << "	//SSLEX automatically counts line numbers\n";
file << "	yyLineno = 1;\n";
file << "\n";
file << "	//last accepting state\n";
file << "	lastAcceptingState = -1;\n";
file << "\n";
file << "	//do not concatenate token\n";
file << "	concatenate = false;\n";
file << "\n";
file << "	//no start conditions on stack\n";
file << "	scStackSize = 0;\n";
file << "	scStackPos = 0;\n";
file << "	scStack = 0L;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "SSLEXScanner::~SSLEXScanner()\n";
file << "{\n";
file << "	//free memory\n";
file << "	if( yyText )\n";
file << "		delete[] ( yyText );\n";
file << "\n";
file << "	if( scStack )\n";
file << "		delete[] ( scStack );\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "	//deinizialize user defined variables\n";
file << "	deinit();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::reset( void )\n";
file << "{\n";
file << "	//reset the whole scanner\n";
file << "\n";
file << "	//start position\n";
file << "	pos = basePos;\n";
file << "\n";
file << "	//end of scanning\n";
file << "	end = pos + basePosLength;\n";
file << "\n";
file << "	//need memory for yyText?\n";
file << "	if( !yyText )\n";
file << "	{\n";
file << "		//init with 8KB\n";
file << "		yyTextLen = 8*1024;\n";
file << "		yyText = new( char[yyTextLen + 1] );\n";
file << "	}\n";
file << "\n";
file << "	//start-condition INITIAL\n";
file << "	state = baseState = INITIAL;\n";
file << "\n";
file << "	//no token\n";
file << "	yyLeng = 0;\n";
file << "\n";
file << "	//SSLEX automatically counts line numbers\n";
file << "	yyLineno = 1;\n";
file << "\n";
file << "	//last accepting state\n";
file << "	lastAcceptingState = -1;\n";
file << "\n";
file << "	//do not concatenate token\n";
file << "	concatenate = false;\n";
file << "\n";
file << "	//no start conditions on stack\n";
file << "	scStackPos = 0;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::reset( char *data, ulong size )\n";
file << "{\n";
file << "	//reset the whole scanner and give him new input\n";
file << "\n";
file << "	//no data?\n";
file << "	if( !data )\n";
file << "	{\n";
file << "		//error\n";
file << "		cerr << \"SSLEXScanner: No data!\\n\";\n";
file << "\n";
file << "		//exit\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//save length of text\n";
file << "	basePosLength = size;\n";
file << "\n";
file << "	//copy text to analyze due to unput\n";
file << "	pos = basePos = new( char[basePosLength + 1] );\n";
file << "\n";
file << "	//copy to analyze string. This is nesessary as there are zero-bytes allowed in scanning\n";
file << "	//text. But this would couse strlen to return only the length till the next zero-byte!\n";
file << "	memcpy( pos, data, sizeof( char ) * basePosLength );\n";
file << "	pos[basePosLength] = 0;\n";
file << "\n";
file << "	//end of scanning\n";
file << "	end = pos + basePosLength;\n";
file << "\n";
file << "	//start-condition INITIAL\n";
file << "	state = baseState = INITIAL;\n";
file << "\n";
file << "	//need memory for yyText?\n";
file << "	if( !yyText )\n";
file << "	{\n";
file << "		//init with 8KB\n";
file << "		yyTextLen = 8*1024;\n";
file << "		yyText = new( char[yyTextLen + 1] );\n";
file << "	}\n";
file << "\n";
file << "	//no token\n";
file << "	yyLeng = 0;\n";
file << "\n";
file << "	//SSLEX automatically counts line numbers\n";
file << "	yyLineno = 1;\n";
file << "\n";
file << "	//last accepting state\n";
file << "	lastAcceptingState = -1;\n";
file << "\n";
file << "	//do not concatenate token\n";
file << "	concatenate = false;\n";
file << "\n";
file << "	//no start conditions on stack\n";
file << "	scStackPos = 0;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLEXScanner::yyLex( SSLR_TYPE *attributeStr )\n";
file << "{\n";
file << "	//start scanning\n";
file << "	unsigned char	c;\n";
file << "\n";
file << "	//Basis-Position fr das Lexem\n";
file << "	startPos = pos;\n";
file << "\n";
file << "	//setup some stuff\n";
file << "	yyDoBeforeRule();\n";
file << "\n";
file << "	while( pos <= end )\n";
file << "	{\n";
file << "		//Zeichen\n";
file << "		c = *pos;\n";

	//7-Bit-Scanner?
	if( argv_str->cclWidth == _7BIT )
	{
		//Fehler abfangen
file << "\n";
file << "		//when we use a 7 bit scanner\n";
file << "		if( c > 127 )\n";
file << "		{\n";
file << "			//we need a 8 bit scanner\n";
file << "			cerr << \"SSLEXScanner::yyLex: Line \" << yyLineno << \": You need a 8 bit scanner to match the character \" << c << \"!\\n\";\n";
file << "\n";
file << "			//skip character\n";
file << "			pos++;\n";
file << "			continue;\n";
file << "		}\n";
	}

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro
		file << "\n#ifdef SSLEX_DEBUG";

		//Ja
		file << "\n";
		file << "		//print debugging information\n";
		file << "		mainDebug( c );\n";

		//Debug-Makro
		file << "#endif\n";
	}


file << "\n";
file << "		//schieben?\n";
file << "		if( ssLexTable[state][c] >= 0 )\n";
file << "		{\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro
		file << "\n#ifdef SSLEX_DEBUG\n";

		//Ja
		file << "			//print debugging information\n";
		file << "			shiftDebug( c );\n";

		//Debug-Makro
		file << "#endif\n\n";
	}

file << "			//akzeptieren?\n";
file << "			if( ssLexAccept[state] )\n";
file << "			{\n";
file << "				//Ja, merken\n";
file << "				lastAcceptingState = state;\n";
file << "				lastAcceptingPos = pos;\n";
file << "			}\n";
file << "\n";

	//wurden Lookahead-Regeln benutzt?
	if( laUsed == true )
	{
		//Ja
		file << "			//Lookahead-Zustand?\n";
		file << "			if( ssLexLA[state] )\n";
		file << "				//Ja, merken\n";
		file << "				lastLAPos = pos;\n";
		file << "\n";
	}

file << "			//shift new state\n";
file << "			state = ssLexTable[state][c];\n";
file << "\n";
file << "			//nchstes Zeichen\n";
file << "			pos++;\n";
file << "		}\n";
file << "\n";
file << "		else\n";
file << "		{\n";
file << "			//akzeptieren\n";
file << "			do\n";
file << "			{\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro
		file << "\n#ifdef SSLEX_DEBUG\n";

		//Ja
		file << "				//print debugging information\n";
		file << "				acceptDebug();\n";

		//Debug-Makro
		file << "#endif\n\n";
	}

file << "				switch( ssLexAccept[state] )\n";
file << "				{\n";

	//Nun alle Aktionen ausgeben
	for( i = 0; i < numberOfGroups; i++ )
	{
		//den ersten Eintrag finden
		if( finitNEA[i] && !fArr[i] )
		{
			//Ja, Zeiger auf NEA_STR
			nea = finitNEA[i];

			//markieren
			fArr[i] = 1;

			//entsprechenden reg. Ausdruck ausgeben
			file << "\t\t\t\t\t//" << nea->regText << "\n";

			//ausgeben
			file << "\t\t\t\t\tcase " << i << ":\n";

			//alle Zustnde mit gleicher Aktion ausgeben
			for( j = i + 1; j < numberOfGroups; j++ )
			{
				//gleich?
				if( finitNEA[j] == nea )
				{
					//Ja, markieren
					fArr[j] = 1;

					//case ausgeben
					file << "\t\t\t\t\tcase " << j << ":\n";
				}
			}

			//in einem Block
			file << "\t\t\t\t\t{\n";

			//Ist es ein Lookahead-NEA?
			if( nea->laState == true )
				//erst die Position zurcksetzen, bevor yyText geschrieben wird
				file << "\t\t\t\t\t\t//set position back\n\t\t\t\t\t\tpos = lastLAPos;\n\n";

			//yyText setzen
			file << "\t\t\t\t\t\t//setup yyText\n\t\t\t\t\t\tsetupyyText();\n\n";

			//Alle Aktionen
			for( k = 0; k < nea->actionAnz; k++ )
				//ausgeben
				file << nea->action[k];

			//break
			file << "\t\t\t\t\t\tbreak;\n";

			//Block schlieen
			file << "\t\t\t\t\t}\n\n";
		}
	}

file << "\n";
file << "					default:\n";
file << "					{\n";
file << "						//unable to accept, backtracking or error\n";
file << "						if( lastAcceptingState >= 0 )\n";
file << "						{\n";
file << "							//set back to last accept position\n";
file << "							state = lastAcceptingState;\n";
file << "							pos = lastAcceptingPos;\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLEX_DEBUG";

		//Meldung ausgeben
		file << "\n";
		file << "							//backtracking\n";
		file << "							cout << \"Backtracking, set new state \" << state << \"\\n\";\n";

		//Debug-Makro ausgeben
		file << "#endif";
	}

file << "\n";
file << "							//now accept with last accept position\n";
file << "							continue;\n";
file << "						}\n";
file << "\n";
file << "						else\n";
file << "						{\n";
file << "							//error\n";
file << "							error( *startPos );\n";
file << "\n";
file << "							//remove character\n";
file << "							pos++;\n";
file << "						}\n";
file << "\n";
file << "						break;\n";
file << "					}\n";
file << "				}\n";
file << "\n";
file << "				//setup some stuff\n";
file << "				yyDoBeforeRule();\n";
file << "\n";
file << "				//exit while-loop\n";
file << "				break;\n";
file << "\n";
file << "			}while( 1 );\n";
file << "\n";
file << "			//Ende der Eingabe erreicht?\n";
file << "			if( pos == end )\n";
file << "				//Ja\n";
file << "				break;\n";
file << "		}\n";
file << "	}\n";
file << "\n";
file << "	//call eof-rules\n";
file << "	return( endOfLine() );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyDoBeforeRule( void )\n";
file << "{\n";
file << "	//set some stuff before a new rule is scanned\n";
file << "\n";
file << "	//reset\n";
file << "	lastAcceptingState = -1;\n";
file << "\n";
file << "	//base position for lexem\n";
file << "	startPos = pos;\n";
file << "\n";
file << "	//are we at the beginning of a line?\n";
file << "	if( ( pos == basePos ) || ( pos[-1] == '\\n' ) )\n";
file << "		//setup state\n";
file << "		state = setupState( baseState );\n";
file << "\n";
file << "	else\n";
file << "		//base-State\n";
file << "		state = baseState;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::error( uchar c )\n";
file << "{\n";
file << "	//simple error handling routine\n";
file << "	ulong		i;\n";
file << "	char		*transChar[] = {\n";
file << "	  \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "	 \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "	\"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "	   \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "	   \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "	   \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "	   \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "	   \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "	   \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "	   \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "	   \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "	   \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "	   \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "	   \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "	   \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "	   \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "	   \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "	   \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "	   \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "	   \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "	   \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "	   \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "	   \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "	   \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "	//get current sc\n";
file << "	for( i = 0; i < scSize; i++ )\n";
file << "	{\n";
file << "		//equal?\n";
file << "		if( scIndex[i] == baseState )\n";
file << "			break;\n";
file << "	}\n";
file << "\n";
file << "	//did already an error occur in that sc?\n";
file << "	if( !err[i][c] )\n";
file << "	{\n";
file << "		//No, print an error message\n";


	//Debug-Version?
	if( argv_str->debug == true )
		//Ja, auch den Namen der SC ausgeben
		file << "		cerr << \"line \" << yyLineno << \": SC \" << scName[i] << \": Illegal character \" << transChar[c] << \"!\\n\";\n";

	else
		//Nein, nur Fehlermeldung
		file << "		cerr << \"line \" << yyLineno << \": Illegal character \" << transChar[c] << \"!\\n\";\n";


file << "\n";
file << "		//mark to avoid ever lasting loops\n";
file << "		err[i][c]++;\n";
file << "	}\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setupYYLineno( char *beg, char *end )\n";
file << "{\n";
file << "	//setup yyLineno\n";
file << "	ulong	len = end - beg, i;\n";
file << "	int		nl = 0;\n";
file << "\n";
file << "	//count newlines\n";
file << "	for( i = 0; i < len; i++ )\n";
file << "	{\n";
file << "		//newline?\n";
file << "		if( beg[i] == '\\n' )\n";
file << "			nl++;\n";
file << "	}\n";
file << "\n";
file << "	//add to yyLineno\n";
file << "	yyLineno += nl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setupyyText( void )\n";
file << "{\n";
file << "	//insert text in yytext\n";
file << "	ulong	len;\n";
file << "	char	*tmp;\n";
file << "\n";
file << "	//reg. expression one-character?\n";
file << "	if( pos == startPos )\n";
file << "		//yes, move to next character\n";
file << "		pos++;\n";
file << "\n";
file << "	//get length of lexem\n";
file << "	yyLeng = pos - startPos;\n";
file << "\n";
file << "	//concatenate token? (yyMore)\n";
file << "	if( concatenate == true )\n";
file << "	{\n";
file << "		//yes, append\n";
file << "		len = strlen( yyText );\n";
file << "\n";
file << "		//enough space?\n";
file << "		if( yyTextLen <= ( yyLeng + len ) )\n";
file << "		{\n";
file << "			//extend memory\n";
file << "\n";
file << "			//fix yyTextLen\n";
file << "			yyTextLen = yyLeng + len;\n";
file << "\n";
file << "			//get enough memory fr lexem\n";
file << "			tmp = new( char[yyTextLen + 1] );\n";
file << "\n";
file << "			//copy string\n";
file << "			strcpy( tmp, yyText );\n";
file << "\n";
file << "			//release memory\n";
file << "			if( yyText )\n";
file << "				delete[] ( yyText );\n";
file << "\n";
file << "			//copy adress\n";
file << "			yyText = tmp;\n";
file << "		}\n";
file << "\n";
file << "		//append\n";
file << "		strncat( yyText, startPos, len );\n";
file << "\n";
file << "		//zero\n";
file << "		yyText[yyLeng + len] = 0;\n";
file << "\n";
file << "		//set up yyLeng\n";
file << "		yyLeng += len;\n";
file << "\n";
file << "		//next time we want to set up yyText as usual\n";
file << "		concatenate = false;\n";
file << "	}\n";
file << "\n";
file << "	else\n";
file << "	{\n";
file << "		//enough space?\n";
file << "		if( yyTextLen <= yyLeng )\n";
file << "		{\n";
file << "			//extend memory\n";
file << "			if( yyText )\n";
file << "				delete[] ( yyText );\n";
file << "\n";
file << "			//fix yyTextLen\n";
file << "			yyTextLen = yyLeng;\n";
file << "\n";
file << "			//get enough memory fr lexem\n";
file << "			yyText = new( char[yyTextLen + 1] );\n";
file << "		}\n";
file << "\n";
file << "		//insert\n";
file << "		strncpy( yyText, startPos, yyLeng );\n";
file << "\n";
file << "		//end with zere\n";
file << "		yyText[yyLeng] = 0;\n";
file << "	}\n";
file << "\n";
file << "	//setup yyLineno\n";
file << "	setupYYLineno( startPos, pos );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::setupState( ulong baseState )\n";
file << "{\n";
file << "	//setup state for begin-of-line-rules\n";
file << "	ulong	state = baseState, i;\n";
file << "\n";
file << "	//test if the current state is valid\n";
file << "	switch( baseState )\n";
file << "	{\n";


	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Namen der SC ausgeben
		file << "\t\tcase " << sc->name << ":\n";
	}

	/*
		Wenn der Scanner auf ein Newline-Zeichen trifft, soll er den Startzustand nehmen, in dem auch die
		NEAen aktiviert sind, die ausschlielich am Zeilenanfang stehen drfen.
		Dies ist der Zustand, der nach dem Startzustand der NEAen steht, die berall stehen drfen.
		Ein schlichtes state++; gengt also.
		Hier wird trotzdem mit case gearbeitet, falls sich ein Zustand einschleicht, zu dem keine
		Startcondition gehrt.
	*/

	//den Basis-Zustand setzen
	file << "		{\n";
	file << "			//it is right the next state;\n";
	file << "			state++;\n";
	file << "			break;\n";
	file << "		}\n";


file << "\n";
file << "		default:\n";
file << "		{\n";
file << "			//ups, unknown start condition\n";
file << "			cerr << \"SSLEXScanner::setupState: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "			exit( 1 );\n";
file << "		}\n";
file << "	}\n";
file << "\n";

		//Debug-Version?
		if( argv_str->debug == true )
		{
			//Debug-Makro ausgeben
			file << "#ifdef SSLEX_DEBUG\n";

			//Ja
			file << "	//get current sc\n";
			file << "	for( i = 0; i < scSize; i++ )\n";
			file << "	{\n";
			file << "		//equal?\n";
			file << "		if( scIndex[i] == baseState )\n";
			file << "			break;\n";
			file << "	}\n";
			file << "\n";
			file << "	//print debugging information\n";
			file << "	cout << \"switch to \" << scName[i] << \"\\n\";\n";

			//Debug-Makro ausgeben
			file << "#endif\n\n";
		}

file << "	//return state\n";
file << "	return( state );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setStartCondition( ulong state )\n";
file << "{\n";
file << "	//set a new start condition\n";
file << "	switch( state )\n";
file << "	{\n";


	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Hat die SC berhaupt NEAen?
		if( sc->neaArrCnt )
		{
			//Index des Start-Zustandes ausgeben
			file << "\t\tcase " << sc->name << ":\n";

			//den Basis-Zustand setzen
			file << "		{\n";
			file << "			//set new start condition\n";
			file << "			baseState = " << sc->name << ";\n";
			file << "			break;\n";
			file << "		}\n\n";
		}
	}

file << "\n";
file << "		default:\n";
file << "		{\n";
file << "			//unknown start condition\n";
file << "			cerr << \"SSLEXScanner::setStartCondition: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "\n";
file << "			//ignore call\n";
file << "			break;\n";
file << "		}\n";
file << "	}\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::getYYLeng( void )\n";
file << "{\n";
file << "	//return length of yyText\n";
file << "	return( yyLeng );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::getYYLineno( void )\n";
file << "{\n";
file << "	//return line number\n";
file << "	return( yyLineno );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char *SSLEXScanner::getYYText( void )\n";
file << "{\n";
file << "	//return yyText\n";
file << "	return( yyText );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char *SSLEXScanner::yyStrCpy( char *txt )\n";
file << "{\n";
file << "	//return txt in it's own memory\n";
file << "	ulong	len;\n";
file << "	char	*tmp;\n";
file << "\n";
file << "	//length of txt\n";
file << "	len = strlen( txt );\n";
file << "\n";
file << "	//get memory for txt\n";
file << "	tmp = new( char[len + 1] );\n";
file << "\n";
file << "	//copy\n";
file << "	strcpy( tmp, txt );\n";
file << "\n";
file << "	//zero\n";
file << "	tmp[len] = 0;\n";
file << "\n";
file << "	//return\n";
file << "	return( tmp );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyLess( int n )\n";
file << "{\n";
file << "	//returns all but the first n characters of yyText back to the input\n";
file << "\n";
file << "	//check\n";
file << "	if( ( n < 0 ) || ( n > yyLeng ) )\n";
file << "	{\n";
file << "		//bad n\n";
file << "		cerr << \"SSLEXScanner::yyLess: Line \" << yyLineno << \": Bad argument!\\n\";\n";
file << "\n";
file << "		//ignore\n";
file << "		return;\n";
file << "	}\n";
file << "\n";
file << "	//zero\n";
file << "	yyText[n] = 0;\n";
file << "\n";
file << "	//return to input spring\n";
file << "	pos -= ( yyLeng - n );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyPushState( ulong newState )\n";
file << "{\n";
file << "	/*\n";
file << "		Pushes the current start condition onto the top of the start condition stack\n";
file << "		and switches to newState as though you have used BEGIN( newState ).\n";
file << "	*/\n";
file << "\n";
file << "	//enough memory\n";
file << "	if( scStackPos == scStackSize )\n";
file << "		//enlarge start condition stack\n";
file << "		enlargeSCStack();\n";
file << "\n";
file << "	//put on stack\n";
file << "	scStack[scStackPos++] = baseState;\n";
file << "\n";
file << "	//switch to new state\n";
file << "	BEGIN( newState );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyPopState( void )\n";
file << "{\n";
file << "	//pops the top of the start condition stack and switches to it\n";
file << "\n";
file << "	//underflow?\n";
file << "	if( scStackPos <= 0 )\n";
file << "		//error\n";
file << "		cerr << \"SSLEXScanner::yyPopState: Line \" << yyLineno << \": Start condition stack underflow!\\n\";\n";
file << "\n";
file << "	else\n";
file << "	{\n";
file << "		//get new SC state\n";
file << "		ulong	newState = scStack[--scStackPos];\n";
file << "\n";
file << "		//switch to it\n";
file << "		BEGIN( newState );\n";
file << "\n";
file << "		//set new state\n";
file << "		state = newState;\n";
file << "	}\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::yyTopState( void )\n";
file << "{\n";
file << "	//returns the top of the start condition stack without altering its contents\n";
file << "	return( scStack[scStackPos - 1] );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::enlargeSCStack( void )\n";
file << "{\n";
file << "	//enlarge start condition stack\n";
file << "	ulong	*tmp;\n";
file << "\n";
file << "	//get enough memory\n";
file << "	tmp = new( ulong[scStackSize + SCStackSize] );\n";
file << "\n";
file << "	//copy old content\n";
file << "	memcpy( tmp, scStack, sizeof( ulong ) * scStackSize );\n";
file << "\n";
file << "	//free old memory?\n";
file << "	if( scStack )\n";
file << "		//yes\n";
file << "		delete[] ( scStack );\n";
file << "\n";
file << "	//set new adress\n";
file << "	scStack = tmp;\n";
file << "\n";
file << "	//add size\n";
file << "	scStackSize += SCStackSize;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyUnput( unsigned char c )\n";
file << "{\n";
file << "	//puts the character c back to the input stream\n";
file << "	ulong	len = basePosLength++;\n";
file << "	int		diff = pos - basePos;\n";
file << "	char	*txt;\n";
file << "\n";
file << "	//get enough memory to push back character\n";
file << "	txt = new( char[len + 2] );\n";
file << "\n";
file << "	//copy to current position\n";
file << "	memcpy( txt, basePos, sizeof( char ) * diff );\n";
file << "\n";
file << "	//now insert c\n";
file << "	txt[diff] = c;\n";
file << "\n";
file << "	//append rest of the input\n";
file << "	memcpy( &txt[diff + 1], pos, sizeof( char ) * ( len - diff ) );\n";
file << "\n";
file << "	//zero\n";
file << "	txt[len + 1] = 0;\n";
file << "\n";
file << "	//free old memory\n";
file << "	delete[] ( basePos );\n";
file << "\n";
file << "	//set new position\n";
file << "	pos = startPos = &txt[diff];\n";
file << "\n";
file << "	//set new end\n";
file << "	end = &txt[len + 1];\n";
file << "\n";
file << "	//set new beginning\n";
file << "	basePos = txt;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyUnput( char *str )\n";
file << "{\n";
file << "	//puts the string str back to the input stream\n";
file << "	ulong	len = basePosLength, strLen = strlen( str );\n";
file << "	int		diff = pos - basePos;\n";
file << "	char	*txt;\n";
file << "\n";
file << "	//get enough memory to push back character\n";
file << "	txt = new( char[len + strLen + 1] );\n";
file << "\n";
file << "	//copy to current position\n";
file << "	memcpy( txt, basePos, sizeof( char ) * diff );\n";
file << "\n";
file << "	//now append str\n";
file << "	strcpy( &txt[diff], str );\n";
file << "\n";
file << "	//append rest of the input\n";
file << "	memcpy( &txt[strLen + diff], pos, sizeof( char ) * ( len - diff ) );\n";
file << "\n";
file << "	//zero\n";
file << "	txt[len + strLen] = 0;\n";
file << "\n";
file << "	//free old memory\n";
file << "	delete[] ( basePos );\n";
file << "\n";
file << "	//set new position\n";
file << "	pos = startPos = &txt[diff];\n";
file << "\n";
file << "	//set new end\n";
file << "	end = &txt[len + strLen + 1];\n";
file << "\n";
file << "	//set new beginning\n";
file << "	basePos = txt;\n";
file << "\n";
file << "	//correct basePosLength\n";
file << "	basePosLength += strLen;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char SSLEXScanner::yyInput( void )\n";
file << "{\n";
file << "	//return the next character to be scanned\n";
file << "	return( *pos++ );\n";
file << "}\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLEX_DEBUG\n";

file << "void SSLEXScanner::mainDebug( unsigned char c )\n";
file << "{\n";
file << "	//print debugging information\n";
file << "	SSLEXDebugStr	*d = &debugStr[state];\n";
file << "	ulong			i;\n";
file << "	char			tmp[200], *transChar[] = {\n";
file << "	  \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "	 \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "	\"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "	   \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "	   \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "	   \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "	   \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "	   \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "	   \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "	   \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "	   \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "	   \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "	   \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "	   \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "	   \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "	   \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "	   \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "	   \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "	   \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "	   \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "	   \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "	   \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "	   \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "	   \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "	//get current sc\n";
file << "	for( i = 0; i < scSize; i++ )\n";
file << "	{\n";
file << "		//equal?\n";
file << "		if( scIndex[i] == baseState )\n";
file << "			break;\n";
file << "	}\n";
file << "\n";
file << "	//current line\n";
file << "	cout << endl << \"current line: \" << getYYLineno() << endl;\n";
file << "\n";
file << "	//print the next 40 chars of the input\n";
file << "	txtFilter( pos, tmp, 40 );\n";
file << "	cout << \"current pos: \" << tmp << endl;\n";
file << "\n";
file << "	//current SC\n";
file << "	cout << \"current start condition: \" << scName[i] << endl;\n";
file << "\n";
file << "	//current state\n";
file << "	cout << \"current state: \" << state << endl;\n";
file << "\n";
file << "	//current character\n";
file << "	cout << \"current character: \" << transChar[c] << endl;\n";
file << "\n";
file << "	//print assocciated regular expression\n";
file << "	cout << \"associated regular expressions:\" << endl;\n";
file << "\n";
file << "	//all associated reg. expressions\n";
file << "	for( i = 0; i < d->indexCnt; i++ )\n";
file << "		//print\n";
file << "		cout << regText[d->index[i]] << endl;\n";
file << "\n";
file << "	//print ssLexTable\n";
file << "	cout << \"ssLexTable[\" << state << \"][\" << transChar[c] << \"] = \" << ssLexTable[state][c] << endl << endl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::shiftDebug( unsigned char c )\n";
file << "{\n";
file << "	//print debugging information\n";
file << "	SSLEXDebugStr	*d = &debugStr[state];\n";
file << "	ulong			i;\n";
file << "	char		*transChar[] = {\n";
file << "	  \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "	 \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "	\"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "	   \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "	   \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "	   \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "	   \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "	   \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "	   \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "	   \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "	   \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "	   \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "	   \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "	   \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "	   \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "	   \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "	   \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "	   \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "	   \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "	   \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "	   \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "	   \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "	   \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "	   \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "	//shift?\n";
file << "	cout << \"shift ssLexTable[\" << state << \"][\" << transChar[c] << \"] = \" << ssLexTable[state][c] << \"\\n\";\n";
file << "\n";
file << "	//accepting state?\n";
file << "	if( ssLexAccept[state] )\n";
file << "		//yes\n";
file << "		cout << \"ssLexAccept[\" << state << \"] = \" << ssLexAccept[state] << \" -> \" << acceptRegText[ssLexAccept[state]] << \"\\n\";\n";
file << "\n";

		//Lookahead-Rules benutzt?
		if( laUsed == true )
		{
			//Ja, ausgeben
			file << "	//lookahead state?\n";
			file << "	if( ssLexLA[state] )\n";
			file << "		//yes\n";
			file << "		cout << \"lookahead state\\n\";\n";
			file << "\n";
		}

file << "	//all associated reg. expressions\n";
file << "	for( i = 0; i < d->indexCnt; i++ )\n";
file << "		//print\n";
file << "		cout << regText[d->index[i]] << \"\\n\";\n";
file << "\n";
file << "	//newline\n";
file << "	cout << \"\\n\";\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::acceptDebug( void )\n";
file << "{\n";
file << "	//print debugging information\n";
file << "\n";
file << "	//accept?\n";
file << "	if( ssLexAccept[state] )\n";
file << "		//yes\n";
file << "		cout << \"accepting with \" << acceptRegText[ssLexAccept[state]] << \"\\n\";\n";
file << "\n";
file << "	else\n";
file << "		//backtrack\n";
file << "		cout << \"backtracking to state \" << lastAcceptingState << \"\\n\";\n";
file << "\n";
file << "	//newline\n";
file << "	cout << \"\\n\";\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::txtFilter( char *from, char *to, ulong cnt )\n";
file << "{\n";
file << "	//copy cnt bytes from from to to, but transform escape sequences into\n";
file << "	//readable text form\n";
file << "	ulong	i;\n";
file << "	char	c, tmp[10], *base = to;\n";
file << "\n";
file << "	//init\n";
file << "	*to = 0;\n";
file << "\n";
file << "	//as long as there is another char\n";
file << "	for( i = 0; i < cnt; i++ )\n";
file << "	{\n";
file << "		//get char\n";
file << "		c = *from++;\n";
file << "\n";
file << "		//is it printable?\n";
file << "		if( !isprint( c ) )\n";
file << "		{\n";
file << "			//transform into readable\n";
file << "			switch( c )\n";
file << "			{\n";
file << "				//newline?\n";
file << "				case '\\n':\n";
file << "				{\n";
file << "					//newline\n";
file << "					strcat( to, \"\\\\n\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//Backspace\n";
file << "				case '\\b':\n";
file << "				{\n";
file << "					//Backspace\n";
file << "					strcat( to, \"\\\\b\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//Linefeed\n";
file << "				case '\\f':\n";
file << "				{\n";
file << "					//Linefeed\n";
file << "					strcat( to, \"\\\\f\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//carriage return\n";
file << "				case '\\r':\n";
file << "				{\n";
file << "					//carriage return\n";
file << "					strcat( to, \"\\\\r\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//Tabulator\n";
file << "				case '\\t':\n";
file << "				{\n";
file << "					//Tabulator\n";
file << "					strcat( to, \"\\\\t\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "#if __STDC__\n";
file << "				//bing\n";
file << "				case '\\a':\n";
file << "				{\n";
file << "					//bing\n";
file << "					strcat( to, \"\\\\a\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//vertical tab\n";
file << "				case '\\v':\n";
file << "				{\n";
file << "					//vertical tab\n";
file << "					strcat( to, \"\\\\v\" );\n";
file << "					break;\n";
file << "				}\n";
file << "#else\n";
file << "				//bing\n";
file << "				case '\\a':\n";
file << "				{\n";
file << "					//bing\n";
file << "					strcat( to, \"\\\\007\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//vertical tab\n";
file << "				case '\\v':\n";
file << "				{\n";
file << "					//vertical tab\n";
file << "					strcat( to, \"\\\\013\" );\n";
file << "					break;\n";
file << "				}\n";
file << "#endif\n";
file << "\n";
file << "				default:\n";
file << "				{\n";
file << "					//neither of the above\n";
file << "					sprintf( tmp, \"%x\", c );\n";
file << "\n";
file << "					//append\n";
file << "					strcat( to, tmp );\n";
file << "				}\n";
file << "			}\n";
file << "		}\n";
file << "\n";
file << "		else\n";
file << "		{\n";
file << "			//yes, printable\n";
file << "			sprintf( tmp, \"%c\", c );\n";
file << "\n";
file << "			//append\n";
file << "			strcat( to, tmp );\n";
file << "		}\n";
file << "	}\n";
file << "}\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}

	//Speicher freigeben
	delete[] ( finitNEA );
	delete[] ( laNEA );
	delete[] ( fArr );
}


void ssLexClass::outputIncl( ofstream &file )
{
	//Include-Anweisungen in das cpp-File ausgeben
	char	*incl = s->getInclude(), *beg;
	ulong	len;

	//gibt es include-Anweisungen?
	if( incl )
	{
		//am Anfang das \{ lschen
		while( !( ( incl[0] == '\\' ) && ( incl[1] == '{' ) ) )
			incl++;

		//lschen
		incl = &incl[2];

		//die Lnge der Include-Anweisungen
		len = strlen( incl );

		//merken
		beg = &incl[len - 2];

		//am Ende das \{ lschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << incl;
	}
}


void ssLexClass::outputExt( ofstream &file )
{
	//eigene Erweiterungen in das cpp-File ausgeben
	char	*ext = s->getExtension(), *beg;
	ulong	len;

	//gibt es Extensionen?
	if( ext )
	{
		//am Anfang das \{ lschen
		while( !( ( ext[0] == '\\' ) && ( ext[1] == '{' ) ) )
			ext++;

		//lschen
		ext = &ext[2];

		//die Lnge der eigenen Erweiterungen
		len = strlen( ext );

		//merken
		beg = &ext[len - 2];

		//am Ende das \{ lschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << ext;
	}
}


void ssLexClass::outputCPPDTran( ofstream &file )
{
	//die bergangstabelle ausgeben, ohne Minimierung der DEA-Zustandsmenge
	DEA_STATES	*dea;
	SC_STR		*sc;
	ulong		state = 0, i;
	char		widthPuffer[512];
	int			j, k, l, width;

	//die Breite eines Zustandes bestimmen
	sprintf( widthPuffer, "%ld", DEAStatesCnt );
	width = strlen( widthPuffer );

	//Mindestbreite: 3
	if( width < 3 )
		width = 3;

	//Header ausgeben
	file << "\n//Transition-Table\n";
	file << "long SSLEXScanner::ssLexTable[SSLEX_STATE][CCLWIDTH] = \n{\n";

	//alle Zeichen ausgeben
	file << "/*\n";

	//alle Zeichen ausgeben
	for( i = j = k = 0; i < cclWidth; i++, j++, k++ )
	{
		//Alle 32 Zeichen einen Zeilenwechsel
		if( k == 32 )
		{
			//Ja
			file << "\n";
			k = 0;
		}

		//Breite setzen
		file.width( width );

		//Zeichen schreiben
		outputChar( i, widthPuffer );

		//Zeichen ist druckbar
		file << widthPuffer;

		//letztes Element?
		if( j < 127 )
			//Komma ausgeben
			file << ",";
	}

	//abschlieen
	file << "\n*/\n";

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger
		sc = &scStr[i];

		//hat die SC eine bergangstabelle fr NEAen, die berall stehen drfen?
		if( sc->DTran1 )
		{
			//Ja, ausgeben
			file << "\n//Startcondition: " << sc->name << "\n";

			//Alle Zustnde dieses DEA dieser SC fr NEAen, die berall stehen drfen
			for( l = 0; l < sc->DTran1Cnt; l++ )
			{
				//ausgeben
				file << "/* " << state++ << " */\n{\n";

				//Alle Zeichen
				for( j = k = 0; j < cclWidth; j++, k++ )
				{
					//Alle 32 Zeichen einen Zeilenwechsel
					if( k == 32 )
					{
						//Ja
						file << "\n";
						k = 0;
					}

					//ausgeben
					file.width( width );
					file << sc->DTran1[l]->to[j];

					//letztes Element?
					if( j < 127 )
						//Komma ausgeben
						file << ",";
				}

				//letztes Element?
				if( state < ( DEAStatesCnt - 1 ) )
					//Komma ausgeben
					file << "\n},\n";

				else
					//Ohne Komma ausgeben
					file << "\n}\n";

				//Zustnde zhlen
//				state++;
			}
		}

		//hat die SC eine bergangstabelle fr NEAen, die nur am Zeilenanfang stehen drfen?
		if( sc->DTran2 )
		{
			//Alle Zustnde dieses DEA dieser SC fr NEAen, die nur am Zeilenanfang stehen drfen
			for( l = 0; l < sc->DTran2Cnt; l++ )
			{
				//Start-Zustand der NEAen ausgeben, die nur am Zeilenanfang stehen drfen?
				if( state == sc->begLineDEAIndex )
					//Ja
					file << "/* " << "BOL-Startcondition: " << sc->name << " /*\n";

				//ausgeben
				file << "/* " << state++ << " */\n{\n";

				//Alle Zeichen
				for( j = k = 0; j < cclWidth; j++, k++ )
				{
					//Alle 32 Zeichen einen Zeilenwechsel
					if( k == 32 )
					{
						//Ja
						file << "\n";
						k = 0;
					}

					//ausgeben
					file.width( width );
					file << sc->DTran2[l]->to[j];

					//letztes Element?
					if( j < 127 )
						//Komma ausgeben
						file << ",";
				}

				//letztes Element?
				if( state < ( DEAStatesCnt - 1 ) )
					//Komma ausgeben
					file << "\n},\n";

				else
					//Ohne Komma ausgeben
					file << "\n}\n";

				//Zustnde zhlen
//				state++;
			}
		}
	}

	//abschlieen
	file << "\n};\n";





	//Nun das Array fr die Accept-Zustnde erzeugen
	file << "\n//Accept-Array\n";
	file << "ulong SSLEXScanner::ssLexAccept[SSLEX_STATE] = \n{\n";

	//Alle DEA-Zustnde
	for( i = 0; i < DEAStatesCnt; i++ )
	{
		//Zustand ausgeben
		file << "/* " << i << " */\n";

		//Zeiger auf Zustand
		dea = DEAStates[i];

		//Finit-Zustand?
		if( ( dea->finit == true ) && ( dea->finitNEA ) )
		{
			//Ja, reg. Text des zugehrigen NEA ausgeben
			file << "\n/* Line " << dea->finitNEA->line << ": " << dea->finitNEA->regText << " */\n";
			file << dea->index;
		}

		else
			//nein
			file << "0";

		//letzter Zustand?
		if( i < ( DEAStatesCnt - 1 ) )
			//Nein, Komma
			file << ",\n";
	}

	//abschliessen
	file << "\n};\n\n";




	//Nun das Array fr die Lookahead-Zustnde erzeugen
	file << "\n//Lookahead-Array\n";
	file << "ulong SSLEXScanner::ssLexLA[SSLEX_STATE] = \n{\n";

	//Alle DEA-Zustnde
	for( i = 0; i < DEAStatesCnt; i++ )
	{
		//Zustand ausgeben
		file << "/* " << i << " */\n";

		//Zeiger auf Zustand
		dea = DEAStates[i];

		//Finit-Zustand?
		if( ( dea->la == true ) && ( dea->laNEA ) )
		{
			//Ja, reg. Text des zugehrigen NEA ausgeben
			file << "\n/* Line " << dea->laNEA->line << ": " << dea->laNEA->regText << " */\n";
			file << dea->index;
		}

		else
			//nein
			file << "0";

		//letzter Zustand?
		if( i < ( DEAStatesCnt - 1 ) )
			//Nein, Komma
			file << ",\n";
	}

	//abschliessen
	file << "\n};\n\n";
}



void ssLexClass::outputHHeader( ofstream &file )
{
	//das Header-File ausgeben
	SC_STR	*sc;
	ulong	i, cnt;
	char	**userDefHeader;
	int		userDefHeaderCnt, j;


file << "/***************************************************************************\n";
file << "                          sslexscanner.h  -  description\n";
file << "                             -------------------\n";
file << "    begin                : Mon Feb 24 2003\n";
file << "    copyright            : (C) 2003 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLEXSCANNER_H\n";
file << "#define SSLEXSCANNER_H\n";
file << "\n";
file << "\n";

file << "/**\n";
file << "\t@author SSLEX V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug-version *\n";
		file << "****************************/\n\n\n";

		//Debug-Makro
		file << "//define debug-macro\n";
		file << "#define SSLEX_DEBUG\n";
		file << "//#undef SSLEX_DEBUG\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug-version *\n";
		file << "********************************/\n\n\n";
	}

file << "\n";
file << "using namespace std;\n";
file << "\n";
file << "#include <stdio.h>\n";
file << "#include <stdlib.h>\n";
file << "#include <iostream>\n";
file << "#include <string.h>\n";
file << "\n";
file << "\n";
file << "//type definition\n";
file << "typedef unsigned long	ulong;\n";
file << "typedef unsigned char	uchar;\n";
file << "\n";
file << "\n";


	//Header ausgeben
	file << "\n//Start-States of the different start conditions\n";

	//Alle SC
	for( i = cnt = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Index des Start-Zustandes ausgeben
		file << "#define " << sc->name << "\t" << sc->firstStart << "\n";

		//merken
		cnt++;
	}

	//abschliessen
	file << "\n\n";

	//Anzahl der Zustnde
	file << "//Number of DEA-States\n#define\tSSLEX_STATE\t" << numberOfGroups << "\n\n";

	//7- oder 8-Bit-Scanner
	file << "//7- or 8-bit scanner\n#define\tCCLWIDTH\t" << cclWidth << "\n\n";

	//erlaubt Zugriff auf die Start-Condition
	file << "//current start condition\n";
	file << "#define\tYY_START\tbaseState\n";
	file << "#define\tYYSTATE\t\tYY_START\n\n";

	//Anzahl der Start-Conditionen
	file << "\n";
	file << "//number of start conditions\n";
	file << "#define scSize\t" << ( 2 * cnt ) << "\n";
	file << "\n";

	/*
		Der Benutzer kann eigene Variablen im erzeugten Header-File deklarieren, die u.U. auch
		initialisiert werden mssen.
		Dazu definiert man im %include-Teil das Makro SSLEX_INIT. Es wird dann eine Routine
		void init( void ); aufgerufen, die der Benutzer im %extension-Teil definieren muss.
		Defaultmig wird dies deaktiviert.
	*/
	file << "//do not inizialize user defined variables per default\n";
	file << "#undef SSLEX_INIT\n";
	file << "\n\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLEX_DEBUG\n\n";

		//Ja
		file << "//size of array with regular expressions\n";
		file << "#define regTextSize\t" << debugStrPos << "\n\n";
		file << "//Structure with debugging information\n";
		file << "typedef struct\n";
		file << "{\n";
		file << "	//DEA-State\n";
		file << "	ulong	state;\n";
		file << "\n";
		file << "	//assocciated regular expressions in this state\n";
		file << "	ulong	*index;\n";
		file << "\n";
		file << "	//number of assocciated regular expressions\n";
		file << "	ulong	indexCnt;\n";
		file << "\n";
		file << "}SSLEXDebugStr;\n";

		//Debug-Makro
		file << "#endif\n";
	}



file << "\n";
file << "class SSLEXScanner\n";
file << "{\n";
file << "public: \n";
file << "\n";
file << "	//initialize SSLEX\n";
file << "	SSLEXScanner( char *, ulong );\n";
file << "	~SSLEXScanner();\n";
file << "\n";
file << "	//Methods for public access\n";
file << "\n";
file << "	//start scanning\n";
file << "	int yyLex( SSLR_TYPE *attributeStr = 0L );\n";
file << "\n";
file << "	//return line number\n";
file << "	ulong getYYLineno( void );\n";
file << "\n";
file << "	//return length of yyText\n";
file << "	ulong getYYLeng( void );\n";
file << "\n";
file << "	//return yyText\n";
file << "	char *getYYText( void );\n";
file << "\n";
file << "	//reset the whole scanner\n";
file << "	void reset( void );\n";
file << "\n";
file << "	//reset the whole scanner and give him new input\n";
file << "	void reset( char *, ulong );\n";
file << "\n";
file << "\n";
file << "private:\n";
file << "\n";
file << "	//Base state of SSLEX, i.e. beginning state of a start condition\n";
file << "	ulong					baseState;\n";
file << "\n";
file << "	//current state\n";
file << "	ulong					state;\n";
file << "\n";
file << "	//Begin of scanning text\n";
file << "	char					*basePos;\n";
file << "\n";
file << "	//length of scanning text\n";
file << "	ulong					basePosLength;\n";
file << "\n";
file << "	//current scanning position\n";
file << "	char					*pos;\n";
file << "\n";
file << "	//end of scanning text\n";
file << "	char					*end;\n";
file << "\n";
file << "	//Position of the beginning of a lexem\n";
file << "	char					*startPos;\n";
file << " \n";
file << "	//last accepting position in scanning text\n";
file << "	char					*lastAcceptingPos;\n";
file << "\n";
file << "	//last accepting state in scanning text\n";
file << "	long					lastAcceptingState;\n";
file << "\n";
file << "	//Table for error handling\n";
file << "	static int				err[scSize][CCLWIDTH];\n";
file << "\n";
file << "	//transition table\n";
file << "	static long				ssLexTable[SSLEX_STATE][CCLWIDTH];\n";
file << "\n";
file << "	//Accept-Array\n";
file << "	static ulong			ssLexAccept[SSLEX_STATE];\n";
file << "\n";

	//Gab es Lookahead-NEAen?
	if( laUsed == true )
	{
		//Ja, ausgeben
file << "	//Position of last occurence of a lookahead state\n";
file << "	char					*lastLAPos;\n";
file << "\n";
file << "	//Lookahead-Array\n";
file << "	static ulong 			ssLexLA[SSLEX_STATE];\n";
file << "\n";
	}

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLEX_DEBUG\n";

		//Ja
		file << "	//structure with debugging info\n";
		file << "	static SSLEXDebugStr	debugStr[SSLEX_STATE];\n";
		file << "\n";
		file << "	//array with the regular expressions in text form\n";
		file << "	static char				*regText[regTextSize];\n";
		file << "\n";
		file << "	//Array with indices in regText\n";
		file << "	static ulong			*regTextIndex[SSLEX_STATE];\n";
		file << "\n";

		//die Indices in regText ausgeben
		file << "	//Array with indices in regText\n";

		//Alle Gruppen
		for( i = 0; i < numberOfGroups; i++ )
		{
			//die Indices in regText ausgeben
			file << "	static ulong	regTextIndex" << i << "[];";
			file << "\n";
		}

		file << "\n";
		file << "	//Array with regular expression at accepting\n";
		file << "	static char				*acceptRegText[SSLEX_STATE];\n";

		//Debug-Makro
		file << "#endif\n\n";
	}


file << "	//name of the start conditions\n";
file << "	static char				*scName[SSLEX_STATE];\n";
file << "\n";
file << "	//state of start conditions\n";
file << "	static ulong			scIndex[];\n";
file << "\n";
file << "	//memory for yyText\n";
file << "	ulong					yyTextLen;\n";
file << "\n";
file << "	//yyText: holds the accepted lexem\n";
file << "	char					*yyText;\n";
file << "\n";
file << "	//length of yyText\n";
file << "	ulong					yyLeng;\n";
file << "\n";
file << "	//SSLEX automatically counts line numbers\n";
file << "	ulong					yyLineno;\n";
file << "\n";
file << "	//concatenate token\n";
file << "	bool					concatenate;\n";
file << "\n";
file << "	//size of start condition stack\n";
file << "	ulong					scStackSize;\n";
file << "\n";
file << "	//numer of start xonditions on stack\n";
file << "	long					scStackPos;\n";
file << "\n";
file << "	//start condition stack\n";
file << "	ulong					*scStack;\n";
file << "\n";
file << "\n";

	//benutzerdefinierte Daten holen
	userDefHeader = s->getUserDefHeader( userDefHeaderCnt );

	//alle Zeilen
	for( j = 0; j < userDefHeaderCnt; j++ )
		//ausgeben
		file << userDefHeader[j];


file << "\n";
file << "\n";
file << "private:\n";
file << "\n";
file << "	//insert text in yytext\n";
file << "	void setupyyText( void );\n";
file << "\n";
file << "	//setup yyLineno\n";
file << "	void setupYYLineno( char *, char * );\n";
file << "\n";
file << "	//setup state for begin-of-line-rules\n";
file << "	ulong setupState( ulong );\n";
file << "\n";
file << "	//set a new start condition\n";
file << "	void setStartCondition( ulong );\n";
file << "\n";
file << "	//return txt in it's own memory\n";
file << "	char *yyStrCpy( char *txt );\n";
file << "\n";
file << "	//returns all but the first n characters of yyText back to the input\n";
file << "	void yyLess( int );\n";
file << "\n";
file << "	//enlarge start condition stack\n";
file << "	void enlargeSCStack( void );\n";
file << "\n";
file << "	/*\n";
file << "		Pushes the current start condition onto the top of the start condition stack\n";
file << "		and switches to newState as though you have used BEGIN( newState ).\n";
file << "	*/\n";
file << "	void yyPushState( ulong );\n";
file << "\n";
file << "	//pops the top of the start condition stack and switches to it\n";
file << "	void yyPopState( void );\n";
file << "\n";
file << "	//returns the top of the start condition stack without altering its contents\n";
file << "	ulong yyTopState( void );\n";
file << "\n";
file << "	//puts the character c back to the input stream\n";
file << "	void yyUnput( unsigned char );\n";
file << "	void yyUnput( char * );\n";
file << "\n";
file << "	//return the next character to be scanned\n";
file << "	char yyInput( void );\n";
file << "\n";
file << "	//call eof-rules\n";
file << "	int endOfLine( void );\n";
file << "\n";
file << "	//handle simple errors\n";
file << "	void error( uchar c );\n";
file << "\n";
file << "	//set some stuff before a new rule is scanned\n";
file << "	void yyDoBeforeRule( void );\n";


	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLEX_DEBUG";

		//Ja
		file << "\n";
		file << "	//print debugging information\n";
		file << "	void mainDebug( unsigned char );\n";
		file << "\n";
		file << "	//print debugging information\n";
		file << "	void shiftDebug( unsigned char );\n";
		file << "\n";
		file << "	//print debugging information\n";
		file << "	void acceptDebug( void );\n";
		file << "\n";
		file << "	//copy cnt bytes from from to to, but transform escape sequences into\n";
		file << "	//readable text form\n";
		file << "	void txtFilter( char *, char *, ulong );\n";

		//Debug-Makro
		file << "#endif\n";
	}


file << "};\n";
file << "\n";
file << "#endif\n";
}


void ssLexClass::generateFiles( void )
{
	//Hier werden die Klassenfiles des Scanners erzeugt.
	ofstream	cppFile( "sslexscanner.cpp" );
	ofstream	hFile( "sslexscanner.h" );

	//Meldung?
	if( argv_str->verbose == true )
		//Meldung
		cout << "sslex: Generating output files...\n";

	//den Header fr das CPP-File ausgeben
	outputCPPHeader( cppFile );

	//etwaige Include-Anweisungen einfgen
	outputIncl( cppFile );

	//die bergangstabelle ausgeben
#ifdef MINDEA
	outputCPPMinDEA( cppFile );
#else
	outputCPPDTran( cppFile );
#endif

	//Debug-Informationen ausgeben?
	if( argv_str->debug == true )
		//die Debug-Strukturen ausgeben
		outputCPPDebug( cppFile );

	//Aktionen ausgeben
	outputAction( cppFile );

	//<<EOF>>-NEAen ausgeben
	outputEOF( cppFile );

	//etwaige eigene Erweiterungen einfgen
	outputExt( cppFile );

	//das Header-File ausgeben
	outputHHeader( hFile );
}


void ssLexClass::outputChar( uchar c, char *dest )
{
	//gibt ein Zeichen aus, insbesondere die nicht-druckbaren in lesbarer Form
	char	*transChar[] = {
	  "\\0",   "\\1",   "\\2",   "\\3",   "\\4",   "\\5",   "\\6",  "\\a",  "\\b",  "\\t",  "\\n",  "\\v",
	 "\\f",  "\\r", "0x0e", "0x0f", "0x10", "0x11", "0x12", "0x13", "0x14", "0x15", "0x16", "0x17",
	"0x18", "0x19", "0x1a", "0x1b", "0x1c", "0x1d", "0x1e", "0x1f",    " ",    "!",   "\"",    "#",
	   "$",    "%",    "&",    "'",    "(",    ")",    "*",    "+",    ",",    "-",    ".",    "/",
	   "0",    "1",    "2",    "3",    "4",    "5",    "6",    "7",    "8",    "9",    ":",    ";",
	   "<",    "=",    ">",    "?",    "@",    "A",    "B",    "C",    "D",    "E",    "F",    "G",
	   "H",    "I",    "J",    "K",    "L",    "M",    "N",    "O",    "P",    "Q",    "R",    "S",
	   "T",    "U",    "V",    "W",    "X",    "Y",    "Z",    "[",   "\\",    "]",    "^",    "_",
	   "`",    "a",    "b",    "c",    "d",    "e",    "f",    "g",    "h",    "i",    "j",    "k",
	   "l",    "m",    "n",    "o",    "p",    "q",    "r",    "s",    "t",    "u",    "v",    "w",
	   "x",    "y",    "z",    "{",    "|",    "}",    "~",   "DEL",
	   "128",  "129",  "130",  "131",  "132",  "133",  "134",  "135",  "136",  "137",   "138", "139",
	   "140",  "141",  "142",  "143",  "144",  "145",  "146",  "147",  "148",  "149",   "150", "151",
	   "152",  "153",  "154",  "155",  "156",  "157",  "158",  "159",  "160",  "161",   "162", "163",
	   "164",  "165",  "166",  "167",  "168",  "169",  "170",  "171",  "172",  "173",   "174", "175",
	   "176",  "177",  "178",  "179",  "180",  "181",  "182",  "183",  "184",  "185",   "186", "187",
	   "188",  "189",  "190",  "191",  "192",  "193",  "194",  "195",  "196",  "197",   "198", "199",
	   "200",  "201",  "202",  "203",  "204",  "205",  "206",  "207",  "208",  "209",   "210", "211",
	   "212",  "213",  "214",  "215",  "216",  "217",  "218",  "219",  "220",  "221",   "222", "223",
	   "224",  "225",  "226",  "227",  "228",  "229",  "230",  "231",  "232",  "233",   "234", "235",
	   "236",  "237",  "238",  "239",  "240",  "241",  "242",  "243",  "244",  "245",   "246", "247",
	   "248",  "249",  "250",  "251",  "252",  "253",  "254" };

	//Zeichen eintragen
	strcpy( dest, transChar[c] );
}


GROUP_STR *ssLexClass::createGROUP( void )
{
	//eine neue Gruppe fr die Zustandsminimierung erzeugen
	GROUP_STR	*tmp;

	//Speicher anfordern
	tmp = new( GROUP_STR );

	//initialisieren
	memset( tmp, 0, sizeof( GROUP_STR ) );

	//beinhaltet keinen Finit-Zustand
	tmp->finit = false;

	//beinhaltet keinen Lookahead-Zustand
	tmp->la = false;

	//Gruppe ist valid
	tmp->valid = true;

	//kein Start-Zustand
	tmp->startGroup = false;

	//zurckliefern
	return( tmp );
}


void ssLexClass::deleteGROUP( GROUP_STR *groupStr )
{
	//eine Gruppe lschen

	//sind DEA-Zustnde eingetragen?
	if( groupStr->DEAIndex )
		//ja, Speicher freigeben
		delete[] ( groupStr->DEAIndex );

	//Speicher freigeben
	delete( groupStr );
}


void ssLexClass::insertGROUP( GROUP_STR *groupStr, ulong index )
{
	//einen DEA-Index zu einer Gruppe hinzufgen
	DEA_STATES	*dea = DEAStates[index];
	ulong		*tmp;
	ulong		i;

	/*
		ACHTUNG: In insertGROUP wird in die DEA-Struktur des einzutragenden
		DEA-Zustand der Gruppen-Index eingetragen. So kann man leicht feststellen,
		in welcher Gruppe ein DEA-Zustand ist!
	*/


	//Ist dieser Zustand bereits in der Gruppe?
	for( i = 0; i < groupStr->DEAIndexCnt; i++ )
	{
		//Zustand?
		if( groupStr->DEAIndex[i] == index )
			//Ja
			break;
	}

	//gleich?
	if( i == groupStr->DEAIndexCnt )
	{
		//genug Speicher
		tmp = new( ulong[groupStr->DEAIndexCnt + 1] );

		//umkopieren
		memcpy( tmp, groupStr->DEAIndex, sizeof( ulong ) * groupStr->DEAIndexCnt );

		//alten Speicher lschen
		if( groupStr->DEAIndex )
			delete[] ( groupStr->DEAIndex );

		//eintragen
		groupStr->DEAIndex = tmp;

		//an letzter Stelle eintragen
		groupStr->DEAIndex[groupStr->DEAIndexCnt] = index;

		//Gruppen-Index eintragen
		dea->groupIndex = groupStr->index;

		//Ist es ein Finit-Zustand?
		if( dea->finit == true )
		{
			//setzen
			groupStr->finit = true;

			//NEA in Gruppe eintragen
			groupStr->finitNEA = dea->finitNEA;
		}

		//Ist es ein Lookahead-Zustand?
		if( dea->la == true )
		{
			//setzen
			groupStr->la = true;

			//DEA-Index merken
			groupStr->laIndex = index;
		}

		//ein Zustand weiter
		groupStr->DEAIndexCnt++;
	}
}

/*
void ssLexClass::moveGROUP( GROUP_STR *from, GROUP_STR *to )
{
	//eine Gruppe kopieren
	ulong	i;

	//Alle Zustnde
	for( i = 0; i < from->DEAIndexCnt; i++ )
		//eintragen
		insertGROUP( to, from->DEAIndex[i] );

	//Eigenschaften bertragen
	to->finit = from->finit;
	to->finitNEA = from->finitNEA;
	to->la = from->la;
	to->startGroup = from->startGroup;
	to->valid = from->valid;

	//eine invalide Gruppe darf hier nicht bearbeitet werden
	assert( from->valid == true );
}
*/

void ssLexClass::fixGROUP( GROUP_STR *from, GROUP_STR *to )
{
	//die speziellen Eigenschaften einer Gruppe bernehmen
	to->finit = from->finit;
	to->finitNEA = from->finitNEA;
	to->la = from->la;
	to->valid = from->valid;

	//eine invalide Gruppe darf hier nicht bearbeitet werden
	assert( from->valid == true );

	/*
		WICHTIG: Da nur eine Gruppe den Start-Zustand haben kann, darf diese Eigenschaft NICHT
		vererbt werden!
	*/
}


void ssLexClass::removeGROUP( GROUP_STR *groupStr, ulong index )
{
	//einen DEA-Index aus einer Gruppe lschen
	ulong	i;

	//Alle DEA-Zustnde
	for( i = 0; i < groupStr->DEAIndexCnt; i++ )
	{
		//vergleichen
		if( groupStr->DEAIndex[i] == index )
		{
			//Ja, lschen
			memmove( &groupStr->DEAIndex[i], &groupStr->DEAIndex[i+1], sizeof( ulong ) * ( groupStr->DEAIndexCnt - i - 1 ) );

			//Anzahl der Zustnde korrigieren
			groupStr->DEAIndexCnt--;

			//Ende
			break;
		}
	}
}


void ssLexClass::outputGROUP( GROUP_STR *groupStr )
{
	//eine Gruppe ausgeben
	ulong	j, l;
	char	widthPuffer[10];
	int		width;

	//Breite bestimmen
	sprintf( widthPuffer, "%ld", DEAStatesCnt );
	width = strlen( widthPuffer );

	//Gruppen-Index ausgeben
	cout << "\nGruppe: " << groupStr->index << ", ";

	//Gruppe mit Startzustand?
	if( groupStr->startGroup == true )
		//Ja
		cout << "Startgruppe, ";

	//eine Gruppe mit akzeptierenden Zustnden?
	if( groupStr->finit == true )
		//Ja
		cout << "akzeptierend, " << groupStr->finitNEA->regText << "\n";

	else
		//nein
		cout << "nicht-akzeptierend\n";

	//Meldung
	cout << "Zustnde dieser Gruppe:\n";

	//Alle Zustnde dieser Gruppe
	for( l = j = 0; l < groupStr->DEAIndexCnt; l++, j++ )
	{
		//neue Zeile?
		if( j == 20 )
		{
			//Ja
			cout << "\n";
			j = 0;
		}

		//Breite setzen
		cout.width( width + 1 );
		cout << groupStr->DEAIndex[l];
	}

	//Platz lassen
	cout << "\n\n";
}


void ssLexClass::checkGROUP( SC_STR *sc, GROUP_STR **grpStr, ulong grpStrCnt )
{
	//tote Zustnde finden
	DEA_STATES	*dea, *destDEA;
	GROUP_STR	*grp, *destGrp;
	DTRAN		*dt;
	ulong		*transTable, i, max;
	ulong		*stack, stackPos = 0, *marked, index;
	ulong		grpIndex, destGrpIndex, repState, destState;
	ulong		base1State, end1State, base2State, end2State;
	int			k, l, dead, invalid, changed;

	//Anfangs- und Endzustand der NEAen, die berall stehen drfen
	base1State = sc->DEAIndex;
	end1State = base1State + sc->DTran1Cnt - 1;

	//Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen drfen
	base2State = sc->begLineDEAIndex;
	end2State = base2State + sc->DTran2Cnt - 1;


	//Zeiger der letzten Gruppe
	grp = grpStr[grpStrCnt - 1];

	//maximalen Index merken
	max = grp->index + 1;

	//Speicher fr die Umwandlung der Gruppen-Indeces
	transTable = new( ulong[max] );

	//initialisieren
	memset( transTable, max, sizeof( ulong ) * max );

	//Alle Gruppen
	for( i = 0; i < grpStrCnt; i++ )
	{
		//Zeiger auf Gruppe
		grp = grpStr[i];

		//Gruppen-Index eintragen
		transTable[grp->index] = i;
	}


	//Speicher fr den Zustands-Stack
	stack = new( ulong[DEAStatesCnt] );

	//Speicher zum markieren der Grupppen
	marked = new( ulong[max] );

	//initialisieren
	memset( marked, 0, sizeof( ulong ) * max );

	do
	{
		//Reprsentativen Zustand aus der Gruppe mit dem Startzustand pushen.
		stack[stackPos++] = base1State;
		stack[stackPos++] = base2State;

		//zurcksetzen
		changed = 0;

		//solange Zustnde da sind
		while( stackPos )
		{
			//Zustand holen
			index = stack[--stackPos];

			//Zeiger auf DEA-Struktur
			dea = DEAStates[index];

			//Gruppen-Index von index
			grpIndex = dea->groupIndex;

			//grpIndex darf nicht > max sein
			assert( grpIndex < max );

			//ist die Gruppe bereits markiert?
			if( !marked[transTable[grpIndex]] )
			{
				//nein, markieren und prfen
				marked[transTable[grpIndex]]++;

				//Zeiger auf diese Gruppe
				grp = grpStr[transTable[grpIndex]];

				//reprsentativen Zustand aus dieser Gruppe holen
				repState = grp->DEAIndex[0];

				//Zeiger auf bergangs-Tabelle dieses Zustands
				if( repState <= end1State )
					dt = sc->DTran1[repState - base1State];

				else
					dt = sc->DTran2[repState - base2State];

				//fr bergnge zu toten Zustnden
				dead = 0;

				//fr bergnge zu invaliden Gruppen
				invalid = 0;

				//Alle Zeichen
				for( k =0; k < cclWidth; k++ )
				{
					//Ziel-Zustand holen
					destState = dt->to[k];

					//DEA-Struktur
					destDEA = DEAStates[destState];

					//Gruppen-Index dieses Zustands
					destGrpIndex = destDEA->groupIndex;

					//Zeiger auf Gruppe
					destGrp = grpStr[transTable[destGrpIndex]];

					//schon markiert?
					if( !marked[transTable[destGrpIndex]] )
					{
						//Nein, schon auf Stack?
						for( l = 0; l < stackPos; l++ )
						{
							//gleich?
							if( stack[l] == destState )
								//schon auf dem Stack
								break;
						}

						//War der Zustand schon auf dem Stack?
						if( l == stackPos )
							//Nein, eintragen
							stack[stackPos++] = destState;
					}

					//gleiche Gruppe?
					if( destGrpIndex == grpIndex )
						//ja
						dead++;

					//Ziel-Gruppe invalid?
					if( destGrp->valid == false )
						//Ja, merken
						invalid++;
				}

				//bergnge zur selben Gruppe fr alle Zeichen?
				if( ( dead == cclWidth ) && ( grp->finit == false ) && ( grp->startGroup == false ) )
				{
					//Ja, Gruppe ist invalid
					grp->valid = false;

					//invalide Gruppen werden bersprungen und zhlen daher nicht (Ausnahme sind Gruppen,
					//die Startzustnde beinhalten)
					numberOfGroups--;
				}

				//alle bergnge zu einer invaliden Gruppe?
				if( ( invalid == cclWidth ) && ( grp->finit == false ) )
				{
					//Ja, Gruppe ist invalid
					grp->valid = false;

					//invalide Gruppen werden bersprungen und zhlen daher nicht (Ausnahme sind Gruppen,
					//die Startzustnde beinhalten)
					numberOfGroups--;

					//nochmal, fr die Sprnge zu dieser Gruppe
					changed++;
				}
			}
		}

	}while( changed );

	//wurden alle Gruppen markiert?
	for( i = 0; i < grpStrCnt; i++ )
	{
		//Zeiger auf Gruppe
		grp = grpStr[i];

		//markiert und keine Gruppe, die einen Startzustand enthlt?
		if( !marked[transTable[grp->index]] )
		{
			//nein, Meldung ausgeben
			cout << "ssLexClass::checkGROUP: SC " << sc->name << ": Group " << grp->index << " not marked!\n";

			//invalide Gruppen werden nersprungen und zhlen daher nicht
			numberOfGroups--;

			//invalide Gruppe
			grp->valid = false;
		}
	}

	//Speicher freigeben
	delete[] ( transTable );
	delete[] ( stack );
	delete[] ( marked );
}


void ssLexClass::minDEA( void )
{
	/*
		Hier wird die DEA-Zustandsmenge minimiert, wie es im Drachen, S. 172 beschrieben ist.

		Die Startzustnde der NEAen, die berall stehen drfen, sowie die derer, die nur am Zeilenanfang
		stehen drfen, kommen auf JEDEN Fall in zwei unterschiedliche Gruppen. Somit knnen sie nicht in
		einem Zustand zu liegen kommen. Wichtig ist zu beachten, dass einer von beiden, oder gar beide,
		Finit-Zustnde sein knnen. Und trotzdem MSSEN sie in unterschiedliche Gruppe liegen.
	*/
	DEA_STATES	*dea;
	GROUP_STR	**stack, *acceptGroup, *aGrp, *nGrp, *stGrp;
	GROUP_STR	*firstGroup, *secondGroup, *nonAcceptGroup;
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		stackPos = 0, refDest, dest;
	ulong		base1State, end1State, base2State, end2State;
	ulong		groupCnt, state;
	ulong		*tmpStack, tmpStackCnt;
	DTRAN		**DTran1, **DTran2, *d, *dt, *refDTran;
	uchar		c;
	char		hexChar[10];
	int			i, j, k, l, changed;

	//Meldung?
	if( argv_str->verbose == true )
		//Meldung
		cout << "sslex: Minimizing dea states...\n";

	//den maximalen Gruppenindex merken
	maxGroupIndex = 0;

	//auf dem Stack werden die Gruppen abgelegt
	stack = new( GROUP_STR *[DEAStatesCnt + 1] );

	/*
		Problem: Seien die Zustnde 13, 24, 36 und 47 zusammen in einer Gruppe. Zustnde 24 und 47 seien
		quivalent. Es gilt (13,\n)=24 und (36,\n)=47. Wird nun Zustand 10 aus der Gruppe gelscht,
		dann sind 10 und 47 kurzzeitig in verschiedene Gruppen. Der Test (13,\n)=24 und (36,\n)=47
		fhrt dann dazu, dass die Zustnde 13 und 36 getrennt werden, obwohl sie zu Zustnden bergehen,
		die eigentlich in eine Gruppe gehren.

		Abhilfe: Die zu trennenden Zustnde werden erst auf einen extra Stack geschoben. Erst, nachdem
		alle anderen Zustnde der Gruppe getestet wurden, werden die zu lschenden Zustnde auch wirklich
		entfernt. So werden die Verhltnisse whrend des Tests nicht verflscht!
	*/
	tmpStack = new( ulong[DEAStatesCnt] );

	//noch keine Gruppe erzeugt
	numberOfGroups = 0;


	//Alle Start-Conditionen
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Gruppen-Zhler
		groupCnt = 0;

		//Stack-Position zurcksetzen
		stackPos = 0;

		//Anfangs- und Endzustand der NEAen, die berall stehen drfen
		base1State = sc->DEAIndex;
		end1State = base1State + sc->DTran1Cnt - 1;

		//Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen drfen
		base2State = sc->begLineDEAIndex;
		end2State = base2State + sc->DTran2Cnt - 1;


		//reduzierte bergangstabelle
		DTran1 = sc->DTran1;

		//Alle Zustnde, die fr k keinen bergang haben, bekommen ihn fr d
		for( l = 0; l < sc->DTran1Cnt; l++ )
		{
			//Zeiger auf DTran
			dt = DTran1[l];

			//Alle bergnge
			for( k = 0; k < cclWidth; k++ )
			{
				//kein bergang?
				if( dt->to[k] == -1 )
					//Ja, bergang zu toten Zustand d
					dt->to[k] = end1State;
			}
		}


		//reduzierte bergangstabelle
		DTran2 = sc->DTran2;


		//Alle Zustnde, die fr k keinen bergang haben, bekommen ihn fr d
		for( l = 0; l < sc->DTran2Cnt; l++ )
		{
			//Zeiger auf DTran
			dt = DTran2[l];

			//Alle bergnge
			for( k = 0; k < cclWidth; k++ )
			{
				//kein bergang?
				if( dt->to[k] == -1 )
					//Ja, bergang zu toten Zustand d
					dt->to[k] = end2State;
			}
		}


		/*
			An dieser Stelle werden die Gruppen fr die Zustandsminimierung erzeugt.
			Genauso wie es sich bei DEA-Zustnden um eine Menge von NEA-Zustnden handelt, handelt
			es sich bei einer Gruppe um eine Menge von DEA-Zustnden.

			In der ersten Gruppe befindet sich der Startzustand fr die NEAen, die berall stehen
			drfen. In der zweiten Gruppe befindet sich der Startzustand der NEAen, die nur
			am Zeilenanfang stehen drfen.
			Alle DEA-Finit-Zustnde, die zu ein und demselben NEA gehren, kommen zusammen in eine
			Gruppe. WICHTIG: die kann auch die erste oder zweite Gruppe sein, wenn der entsprechende
			Start-Zustand zugleich ein Finit-Zustand ist.

			Hat eine SC keine NEAen, werden nur die Dummy-DEA-Zustannde eingetragen. Sie haben fr
			alle Eingabezeichen KEINE bergnge, fhren also zu Fehlermeldungen whrend des
			Scannings und knnen so wertvolle Hilfe beim Debuggen liefern.
			Hat eine SC keine NEAen, die berall stehen drfen bzw. hat sie nur welche, die am
			Zeilenanfang stehen drfen, so hat die erste Gruppe nur einen Dummy-Zustand.
		*/

		//Gruppe mit den nicht-akzeptierenden Zustnden
		nonAcceptGroup = 0L;


		//erste Gruppe mit den Startzustand der NEAen, die berall stehen drfen
		firstGroup = createGROUP();

		//den Index der Gruppe setzen
		firstGroup->index = groupCnt++;

		//den Startzustand in die Gruppe eintragen
		insertGROUP( firstGroup, base1State );

		//Gruppe beinhaltet den Startzustand
		firstGroup->startGroup = true;

		//auf den Stack
		stack[stackPos++] = firstGroup;

		//ist der Startzustand ein Finit-Zustand?
		if( firstGroup->finit == false )
			//Ja, alle anderen nicht-akzeptierenden Zustnde in diese Gruppe eintragen
			nonAcceptGroup = firstGroup;


		//zweite Gruppe mit dem Startzustand der NEAen, die nur am Zeilenanfang stehen drfen
		secondGroup = createGROUP();

		//den Index der Gruppe setzen
		secondGroup->index = groupCnt++;

		//den Startzustand in die Gruppe eintragen
		insertGROUP( secondGroup, base2State );

		//Gruppe beinhaltet den Startzustand
		secondGroup->startGroup = true;

		//auf den Stack
		stack[stackPos++] = secondGroup;

		//ist der Startzustand ein Finit-Zustand?
		if( !nonAcceptGroup && ( secondGroup->finit == false ) )
			//Ja, alle anderen nicht-akzeptierenden Zustnde in diese Gruppe eintragen
			nonAcceptGroup = secondGroup;

		else if( !nonAcceptGroup )
		{
			//jeweils beide Startzustnde sind zugleich Finit-Zustnde
			nonAcceptGroup = createGROUP();

			//den Index der Gruppe setzen
			nonAcceptGroup->index = groupCnt++;

			//auf den Stack
			stack[stackPos++] = nonAcceptGroup;

			//Gruppen zhlen
			numberOfGroups++;
		}

		//Zahl der erzeugten Gruppen
		numberOfGroups += 2;





		/*
			Die Finit-Zustnde der NEAen, die berall stehen drfen, kommen in eine Gruppe, die alle
			zum selben NEA gehren.
			Jeder NEA hat genau einen Finit-Zustand!
		*/
		for( l = base1State; l <= end1State; l++ )
		{
			//DEA-Zustand
			dea = DEAStates[l];

			//akzeptierender Zustand?
			if( dea->finit == true )
			{
				//entsprechenden NEA holen
				nea = dea->finitNEA;

				//Ist die Gruppe auf dem Stack?
				for( j = 0; j < stackPos; j++ )
				{
					//Zeiger auf Gruppe
					acceptGroup = stack[j];

					//richtige Gruppe?
					if( acceptGroup->finitNEA == nea )
					{
						//Ja, hier eintragen
						insertGROUP( acceptGroup, l );

						//Schleife verlassen
						break;
					}
				}

				//war die Gruppe auf dem Stack?
				if( j == stackPos )
				{
					//Nein, Gruppe erzeugen
					acceptGroup = createGROUP();

					//Index setzen
					acceptGroup->index = groupCnt++;

					//Ja, hier eintragen
					insertGROUP( acceptGroup, l );

					//NEA eintragen
					acceptGroup->finitNEA = nea;

					//ist eine Gruppe mit akzeptierenden Zustnden
					acceptGroup->finit = true;

					//auf Stack
					stack[stackPos++] = acceptGroup;

					//Zahl der erzeugten Gruppen
					numberOfGroups++;
				}
			}

			else
				//nicht-akzeptierender Zustand
				insertGROUP( nonAcceptGroup, l );
		}




		/*
			Die Finit-Zustnde der NEAen, die nur am Zeilenanfang stehen drfen, kommen in eine Gruppe,
			die alle zum selben NEA gehren.
			Jeder NEA hat genau einen Finit-Zustand!
		*/
		for( l = base2State; l <= end2State; l++ )
		{
			//DEA-Zustand
			dea = DEAStates[l];

			//akzeptierender Zustand?
			if( dea->finit == true )
			{
				//entsprechenden NEA holen
				nea = dea->finitNEA;

				//Ist die Gruppe auf dem Stack?
				for( j = 0; j < stackPos; j++ )
				{
					//Zeiger auf Gruppe
					acceptGroup = stack[j];

					//richtige Gruppe?
					/*
						Der Startzustand der NEAen, die nur am Zeilenanfang stehen drfen, darf nicht
						in Gruppe j=0 eingetragen werden, denn dort steht der Startzustand der NEAen, die
						berall stehen drfen!
					*/
					if( ( acceptGroup->finitNEA == nea ) && j )
					{
						//Ja, hier eintragen
						insertGROUP( acceptGroup, l );

						//Schleife verlassen
						break;
					}
				}

				//war die Gruppe auf dem Stack?
				if( j == stackPos )
				{
					//Nein, Gruppe erzeugen
					acceptGroup = createGROUP();

					//Index setzen
					acceptGroup->index = groupCnt++;

					//Ja, hier eintragen
					insertGROUP( acceptGroup, l );

					//NEA eintragen
					acceptGroup->finitNEA = nea;

					//ist eine Gruppe mit akzeptierenden Zustnden
					acceptGroup->finit = true;

					//auf Stack
					stack[stackPos++] = acceptGroup;

					//Zahl der erzeugten Gruppen
					numberOfGroups++;
				}
			}

			else
			{
				//nicht-akzeptierender Zustand

				//Startzustand der NEAen, die nur am Zeilenanfang stehen drfen?
				//dieser ist ja bereits in der zweiten Gruppe enthalten und darf nicht in eine
				//andere Gruppe eingetragen werden.
				if( l != base2State )
					//Nein
					insertGROUP( nonAcceptGroup, l );
			}
		}




		//Zustandsgruppen trennen
		do
		{
			//keine nderungen
			changed = 0;
#ifdef DEBUG
			//Gruppen ausgeben
			for( j = 0; j < stackPos; j++ )
			{
				//Zeiger auf Gruppe
				stGrp = stack[j];

				//Meldung
				outputGROUP( stGrp );
			}
#endif

			//Alle Gruppen
			for( j = 0; j < stackPos; j++ )
			{
				/*
					Zustnde werden nicht unmittelbar aus einer Gruppe gelscht. Sie werden erst in tmpStack
					eingetragen und erst NACH dem kompletten Test aller Zustnde einer Gruppe aus dieser
					gelscht. S. oben!
				*/
				tmpStackCnt = 0;


				//neue Gruppe erzeugen fr akzeptierende Zustnde
				aGrp = createGROUP();
				aGrp->index = groupCnt++;

				//neue Gruppe erzeugen fr nicht-akzeptierende Zustnde
				nGrp = createGROUP();
				nGrp->index = groupCnt++;

				//Zeiger auf Gruppe
				stGrp = stack[j];


				//alle Zustnde dieser Gruppe mit dem ersten vergleichen
				//gehrt der Referenzzustand zu den NEAen, die berall stehen drfen?
				if( stGrp->DEAIndex[0] <= end1State )
					//Ja
					refDTran = DTran1[stGrp->DEAIndex[0] - base1State];

				else
					//Nein, gehrt zu den NEAen, die nur am Zeilenanfang stehen drfen
					refDTran = DTran2[stGrp->DEAIndex[0] - base2State];

				//die Zustandsbergnge des Referenzzustands mit allen anderen in seiner
				//Gruppe vergleichen
				for( l = 1; l < stGrp->DEAIndexCnt; l++ )
				{
					//Zeiger auf DTran
					if( stGrp->DEAIndex[l] <= end1State )
						//Zustand gehrt zu den NEAen, die berall stehen drfen
						d = DTran1[stGrp->DEAIndex[l] - base1State];

					else
						//Zustand gehrt zu den NEAen, die nur am Zeilenanfang stehen drfen
						d = DTran2[stGrp->DEAIndex[l] - base2State];

					//Alle Zustandsbergnge
					for( k = 0; k < cclWidth; k++ )
					{
						//fr Debug-Zwecke
						c = k;

						//Ziel-Gruppe von Zustand 1
						refDest = DEAStates[refDTran->to[k]]->groupIndex;

						//Ziel-Gruppe von Zustand l
						dest = DEAStates[d->to[k]]->groupIndex;

						//ungleich?
						if( refDest != dest )
						{
#ifdef DEBUG
							//Zeichen ausgeben
							outputChar( c, hexChar );

							//Debug-Meldung
							cout << "Gruppe " << stGrp->index << ":\n";
							cout << "(" << stGrp->DEAIndex[0] << "," << hexChar << ")=" << refDTran->to[k] << " in " << refDest << "\n";
							cout << "(" << stGrp->DEAIndex[l] << "," << hexChar << ")=" << d->to[k] << " in " << dest << "\n";

//							cout << c << ": insert Zustand " << stGrp->DEAIndex[l] << " in  Gruppe " << grp->index << "...\n";
							cout << c << ": delete Zustand " << stGrp->DEAIndex[l] << " aus Gruppe " << stGrp->index << "...\n\n";
#endif
							/*
								ACHTUNG: In insertGROUP wird in die DEA-Struktur des einzutragenden
								DEA-Zustands der Gruppen-Index eingetragen. So kann man leicht feststellen,
								in welcher Gruppe ein DEA-Zustand ist!
							*/
							tmpStack[tmpStackCnt++] = stGrp->DEAIndex[l];

							//raus aus der k Schleife
							break;
						}
					}
				}

				/*
					Jetzt sind alle Zustnde der Gruppe geprft. Nun die zu lschenden Zustnde
					auch wirklich aus der Gruppe entfernen.
				*/
				for( k = 0; k < tmpStackCnt; k++ )
				{
					//Zustand holen
					state = tmpStack[k];

					//Ist es ein akzeptierender Zustand?
					if( DEAStates[state]->finit == true )
						//in die Gruppe der akzeptierenden Zustnde eintragen
						insertGROUP( aGrp, state );

					else
						//in die Gruppe der nicht-akzeptierenden Zustnde eintragen
						insertGROUP( nGrp, state );

					//Zustand aus Gruppe lschen
					removeGROUP( stGrp, state );
				}


				//wurde eine Gruppe aufgespalten?
				if( !aGrp->DEAIndexCnt )
					//Nein, Speicher freigeben
					deleteGROUP( aGrp );

				else
				{
					//Ja, Gruppe auf Stack
					stack[stackPos++] = aGrp;

					//die speziellen Eigenschaften der Gruppe aktGrp bernehmen
					fixGROUP( stGrp, aGrp );

					//Zahl der erzeugten Gruppen
					numberOfGroups++;

					//markieren
					changed++;
				}

				//wurde eine Gruppe aufgespalten?
				if( !nGrp->DEAIndexCnt )
					//Nein, Speicher freigeben
					deleteGROUP( nGrp );

				else
				{
					//Ja, Gruppe auf Stack
					stack[stackPos++] = nGrp;

					//die speziellen Eigenschaften der Gruppe aktGrp bernehmen
					fixGROUP( stGrp, nGrp );

					//Zahl der erzeugten Gruppen
					numberOfGroups++;

					//markieren
					changed++;
				}
			}

		}while( changed );

		//grten Gruppenindex nehmen
		maxGroupIndex = ( groupCnt > maxGroupIndex ) ? groupCnt : maxGroupIndex;

#ifdef DEBUG
		//Gruppen ausgeben
		for( j = 0; j < stackPos; j++ )
		{
			//Zeiger auf Gruppe
			stGrp = stack[j];

			//Meldung
			outputGROUP( stGrp );
		}
#endif

		//Gruppe berprfen
		checkGROUP( sc, stack, stackPos );

		//Gruppen in die SC eintragen
		sc->grp = new( GROUP_STR *[stackPos] );

		//Zeiger auf die Gruppen-Strukturen
		for( j = 0; j < stackPos; j++ )
			//Zeiger auf Gruppe
			sc->grp[j] = stack[j];

		//Anzahl der Gruppen eintragen
		sc->grpCnt = stackPos;
	}

	//Speicher freigeben
	delete[] ( stack );
	delete[] ( tmpStack );
}


void ssLexClass::outputCPPHeader( ofstream &file )
{
	//den Header des CPP-Files ausgeben

	//Header des cpp-Files
file << "/***************************************************************************\n";
file << "                          sslrparser.cpp  -  description\n";
file << "                             -------------------\n";
file << "    copyright            : (C) 2002 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#include \"sslexscanner.h\"\n";
file << "#include <iostream>\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug-version *\n";
		file << "****************************/\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug-version *\n";
		file << "********************************/\n\n\n";
	}

file << "\n";
file << "\n";
file << "//Define macro ECHO\n";
file << "#define ECHO	cout << yyText\n";
file << "\n";
file << "//set a new start condition in user-defined action\n";
file << "#define BEGIN	setStartCondition\n";
file << "\n";
file << "//current start condition\n";
file << "#define YY_START	baseState\n";
file << "\n";
file << "//yyTerminate\n";
file << "#define yyTerminate()	return( ACCEPT )\n";
file << "\n";
file << "\n";
file << "//concatenate lexem\n";
file << "#define yyMore()	concatenate = true\n";
file << "\n";
file << "\n";
file << "//Size of start condition stack\n";
file << "#define SCStackSize	100\n";
file << "\n";
file << "\n";
}


void ssLexClass::outputEOF( ofstream &file )
{
	//<<EOF>>-NEAen ausgeben
	NEA_STR	*nea;
	SC_STR	*sc;
	ulong	i, j, k;

file << "int SSLEXScanner::endOfLine( void )\n";
file << "{\n";
file << "	//call eof-rules\n";
file << "\n";
file << "	//action depends on start condition\n";
file << "	switch( baseState )\n";
file << "	{\n";

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//den Namen der SC ausgeben
		file << "		case " << sc->name << ":\n";
		file << "		{\n";

		//Hat die SC einen EOF-NEA?
		for( j = 0; j < sc->neaArrCnt; j++ )
		{
			//Zeiger auf NEA
			nea = sc->neaArr[j];

			//<<EOF>>?
			if( nea->eof == true )
			{
				//Ja, ausgeben

				//Alle Aktionen
				for( k = 0; k < nea->actionAnz; k++ )
					//ausgeben
					file << nea->action[k];

				//abschlieen
				file << "\n\t\t}\n\n";

				//Schleife verlassen
				break;
			}
		}

		//hatte die SC <<EOF>>-NEAen?
		if( j == sc->neaArrCnt )
		{
			//Nein, die hatte keine
file << "			//default action\n";
file << "			yyTerminate();\n";
file << "\n";
file << "			break;\n";
file << "		}\n";
file << "\n";
		}
	}

file << "\n";
file << "		default:\n";
file << "		{\n";
file << "			//Unknown start condition\n";
file << "			cerr << \"SSLEXScanner::endOfLine: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "\n";
file << "			//ignore\n";
file << "			break;\n";
file << "		}\n";
file << "	}\n";
file << "\n";
file << "	//this should never be executed!\n";
file << "	return( 0 );\n";
file << "}\n";
file << "\n\n";

}


void ssLexClass::outputInfo( void )
{
	//Informationen ausgeben

	//Anzahl der Regeln
	cout << "sslex: Number of rules: " << ruleCnt << "\n";

	//Anzahl der NEA-Zustnde
	cout << "sslex: Number of nea states: " << stateStrCnt << "\n";

	//Anzahl der DEA-Zustnde
	cout << "sslex: Number of dea states before minDEA: " << DEAStatesCnt << ", after: " << numberOfGroups << "\n";

	//Zahl der SC
	cout << "sslex: Number of start conditions: " << scStrAnz << "\n\n";
}

