/***************************************************************************
                          sslexclass.cpp  -  description
                             -------------------
    begin                : Mon Feb 3 2003
    copyright            : (C) 2003 by Sven Schmidt
    email                : s.schmidt@lboro.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "sslexclass.h"
#include "sslex.h"




//mit Zustandsminimierung
#undef MINDEA
#define MINDEA


//gebe erweiterte Debug-Meldungen aus
#define DEBUG_LEVEL2
#undef DEBUG_LEVEL2





//Terminals for debugging
char *scannerToken[] =
{
	/*0*/ "CCE_GRAPH",
	/*1*/ "PLUS",
	/*2*/ "DEF",
	/*3*/ "SOPEN",
	/*4*/ "LA",
	/*5*/ "OR",
	/*6*/ "NAME",
	/*7*/ "KLCLOSE",
	/*8*/ "SPEC",
	/*9*/ "CCE_CNTRL",
	/*10*/ "XSCDECL",
	/*11*/ "SCALL",
	/*12*/ "CCE_UPPER",
	/*13*/ "COPEN",
	/*14*/ "CCE_XDIGIT",
	/*15*/ "CCLOSE",
	/*16*/ "BOPEN",
	/*17*/ "MINUS",
	/*18*/ "ENDLINE",
	/*19*/ "NUMBER",
	/*20*/ "MUL",
	/*21*/ "EOF_OP",
	/*22*/ "CCE_DIGIT",
	/*23*/ "CCE_ALPHA",
	/*24*/ "NEGATE",
	/*25*/ "KOMMA",
	/*26*/ "BCLOSE",
	/*27*/ "SCOPEN",
	/*28*/ "SCDECL",
	/*29*/ "CCE_ALNUM",
	/*30*/ "CCE_PUNCT",
	/*31*/ "NEWLINE",
	/*32*/ "CCE_PRINT",
	/*33*/ "CCE_SPACE",
	/*34*/ "CCE_LOWER",
	/*35*/ "BEGLINE",
	/*36*/ "CCE_BLANK",
	/*37*/ "KLOPEN",
	/*38*/ "EPSILON",
	/*39*/ "QUEST",
	/*40*/ "PREVCCL",
	/*41*/ "ANY",
	/*42*/ "CHAR",
	/*43*/ "SCCLOSE",
	/*44*/ "ACCEPT",
	0L
};


//syntax analyze table
LR_TAB ssLexClass::lr_tab[SSLR_STATE][TERM] = {
/* State 0 */
{ { 0, 0 },{ 0, 0 },{ LR_REDUCE, initlex_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initlex_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initlex_0 } },
/* State 1 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, start_0 } },
/* State 2 */
{ { 0, 0 },{ 0, 0 },{ LR_SHIFT, 4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_1 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_1 } },
/* State 3 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 6 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect2_1 } },
/* State 4 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_1 },
{ 0, 0 },{ LR_REDUCE, scsect1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_1 } },
/* State 5 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 } },
/* State 6 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },
{ LR_REDUCE, sc2_2 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ LR_REDUCE, sc2_2 } },
/* State 7 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_0 },
{ 0, 0 },{ LR_SHIFT, 12 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 11 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sect1_0 } },
/* State 8 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, goal_0 } },
/* State 9 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 14 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },
{ LR_REDUCE, scon_2 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ LR_REDUCE, sect2_0 } },
/* State 10 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 16 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 11 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, startconddecl_0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 12 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, startconddecl_1 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 13 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 18 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, initforrule_0 },
{ LR_REDUCE, initforrule_0 },{ LR_REDUCE, initforrule_0 },{ 0, 0 },{ 0, 0 } },
/* State 14 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_stk_ptr_0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 20 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 15 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 21 },{ 0, 0 },{ LR_REDUCE, scsect1_0 },
{ 0, 0 },{ LR_REDUCE, scsect1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scsect1_0 } },
/* State 16 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },
{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_1 } },
/* State 17 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 25 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 23 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 18 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, sc2_2 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_2 },
{ LR_REDUCE, sc2_2 },{ LR_REDUCE, sc2_2 },{ 0, 0 },{ 0, 0 } },
/* State 19 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 40 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 20 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 41 },{ 0, 0 } },
/* State 21 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },
{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist1_0 } },
/* State 22 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 42 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 23 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 24 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, flexrule_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 25 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, flexrule_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 26 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 27 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 46 },{ LR_SHIFT, 47 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 45 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rule_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 28 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ LR_REDUCE, re_1 },{ LR_REDUCE, re_1 },{ 0, 0 },{ LR_REDUCE, re_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, re_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 29 */
{ { 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, series_1 },{ LR_REDUCE, series_1 },{ LR_REDUCE, series_1 },{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 52 },
{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },{ LR_SHIFT, 49 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_1 },{ 0, 0 },{ LR_SHIFT, 51 },{ LR_REDUCE, series_1 },
{ LR_REDUCE, series_1 },{ LR_REDUCE, series_1 },{ 0, 0 },{ 0, 0 } },
/* State 30 */
{ { 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ LR_REDUCE, singleton_6 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_6 },
{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ LR_REDUCE, singleton_6 },{ LR_REDUCE, singleton_6 },
{ LR_REDUCE, singleton_6 },{ LR_REDUCE, singleton_6 },{ 0, 0 },{ 0, 0 } },
/* State 31 */
{ { 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ LR_REDUCE, singleton_7 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_7 },
{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ LR_REDUCE, singleton_7 },{ LR_REDUCE, singleton_7 },
{ LR_REDUCE, singleton_7 },{ LR_REDUCE, singleton_7 },{ 0, 0 },{ 0, 0 } },
/* State 32 */
{ { 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ LR_REDUCE, singleton_8 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_8 },
{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ LR_REDUCE, singleton_8 },{ LR_REDUCE, singleton_8 },
{ LR_REDUCE, singleton_8 },{ LR_REDUCE, singleton_8 },{ 0, 0 },{ 0, 0 } },
/* State 33 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, string_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, string_1 },{ 0, 0 },{ 0, 0 } },
/* State 34 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 35 */
{ { 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ LR_REDUCE, singleton_11 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_11 },
{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ LR_REDUCE, singleton_11 },{ LR_REDUCE, singleton_11 },
{ LR_REDUCE, singleton_11 },{ LR_REDUCE, singleton_11 },{ 0, 0 },{ 0, 0 } },
/* State 36 */
{ { LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ LR_SHIFT, 56 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },
{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 } },
/* State 37 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 57 },{ LR_SHIFT, 14 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_2 },
{ LR_REDUCE, scon_2 },{ LR_REDUCE, scon_2 },{ 0, 0 },{ 0, 0 } },
/* State 38 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 59 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 58 },{ 0, 0 } },
/* State 39 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_1 },{ 0, 0 } },
/* State 40 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, sconname_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sconname_0 },{ 0, 0 } },
/* State 41 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_1 },
{ LR_REDUCE, scon_1 },{ LR_REDUCE, scon_1 },{ 0, 0 },{ 0, 0 } },
/* State 42 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, sc2_0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_0 },
{ LR_REDUCE, sc2_0 },{ LR_REDUCE, sc2_0 },{ 0, 0 },{ LR_REDUCE, sc2_0 } },
/* State 43 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, flexrule_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 44 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 60 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rule_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 45 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rule_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 46 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re2_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re2_0 },
{ LR_REDUCE, re2_0 },{ LR_REDUCE, re2_0 },{ 0, 0 },{ 0, 0 } },
/* State 47 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 48 */
{ { 0, 0 },{ LR_SHIFT, 50 },{ 0, 0 },{ LR_REDUCE, series_0 },{ LR_REDUCE, series_0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 52 },
{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ LR_SHIFT, 49 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ LR_SHIFT, 51 },{ LR_REDUCE, series_0 },
{ LR_REDUCE, series_0 },{ LR_REDUCE, series_0 },{ 0, 0 },{ 0, 0 } },
/* State 49 */
{ { 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ LR_REDUCE, singleton_0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },
{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ LR_REDUCE, singleton_0 },{ LR_REDUCE, singleton_0 },
{ LR_REDUCE, singleton_0 },{ LR_REDUCE, singleton_0 },{ 0, 0 },{ 0, 0 } },
/* State 50 */
{ { 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ LR_REDUCE, singleton_1 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_1 },
{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ LR_REDUCE, singleton_1 },{ LR_REDUCE, singleton_1 },
{ LR_REDUCE, singleton_1 },{ LR_REDUCE, singleton_1 },{ 0, 0 },{ 0, 0 } },
/* State 51 */
{ { 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ LR_REDUCE, singleton_2 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_2 },
{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ LR_REDUCE, singleton_2 },{ LR_REDUCE, singleton_2 },
{ LR_REDUCE, singleton_2 },{ LR_REDUCE, singleton_2 },{ 0, 0 },{ 0, 0 } },
/* State 52 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 62 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 53 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 63 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 64 },{ 0, 0 },{ 0, 0 } },
/* State 54 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 47 },{ 0, 0 },{ LR_SHIFT, 65 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 55 */
{ { LR_SHIFT, 74 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 72 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 79 },{ 0, 0 },{ LR_SHIFT, 80 },{ LR_SHIFT, 66 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 73 },{ LR_SHIFT, 70 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 69 },{ LR_SHIFT, 77 },{ 0, 0 },{ LR_SHIFT, 76 },
{ LR_SHIFT, 78 },{ LR_SHIFT, 75 },{ 0, 0 },{ LR_SHIFT, 71 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 67 },{ 0, 0 },{ 0, 0 } },
/* State 56 */
{ { LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },
{ LR_REDUCE, ccl_3 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_3 },{ 0, 0 },{ 0, 0 } },
/* State 57 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, sc2_1 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, sc2_1 },
{ LR_REDUCE, sc2_1 },{ LR_REDUCE, sc2_1 },{ 0, 0 },{ LR_REDUCE, sc2_1 } },
/* State 58 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, scon_0 },
{ LR_REDUCE, scon_0 },{ LR_REDUCE, scon_0 },{ 0, 0 },{ 0, 0 } },
/* State 59 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 40 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 60 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, rule_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 61 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 33 },{ LR_REDUCE, re_0 },{ LR_REDUCE, re_0 },{ 0, 0 },{ LR_REDUCE, re_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 36 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, re_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, re_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 34 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 32 },
{ LR_SHIFT, 30 },{ LR_SHIFT, 35 },{ 0, 0 },{ 0, 0 } },
/* State 62 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 83 },{ LR_SHIFT, 84 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 63 */
{ { 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ LR_REDUCE, singleton_9 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_9 },
{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ LR_REDUCE, singleton_9 },{ LR_REDUCE, singleton_9 },
{ LR_REDUCE, singleton_9 },{ LR_REDUCE, singleton_9 },{ 0, 0 },{ 0, 0 } },
/* State 64 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, string_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, string_0 },{ 0, 0 },{ 0, 0 } },
/* State 65 */
{ { 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ LR_REDUCE, singleton_10 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_10 },
{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ LR_REDUCE, singleton_10 },{ LR_REDUCE, singleton_10 },
{ LR_REDUCE, singleton_10 },{ LR_REDUCE, singleton_10 },{ 0, 0 },{ 0, 0 } },
/* State 66 */
{ { 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ LR_REDUCE, fullccl_0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },
{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ LR_REDUCE, fullccl_0 },{ LR_REDUCE, fullccl_0 },
{ LR_REDUCE, fullccl_0 },{ LR_REDUCE, fullccl_0 },{ 0, 0 },{ 0, 0 } },
/* State 67 */
{ { LR_REDUCE, ccl_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ LR_REDUCE, ccl_1 },{ 0, 0 },
{ LR_SHIFT, 85 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ LR_REDUCE, ccl_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ LR_REDUCE, ccl_1 },
{ LR_REDUCE, ccl_1 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_1 },{ 0, 0 },{ 0, 0 } },
/* State 68 */
{ { LR_REDUCE, ccl_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ LR_REDUCE, ccl_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ LR_REDUCE, ccl_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ LR_REDUCE, ccl_2 },
{ LR_REDUCE, ccl_2 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_2 },{ 0, 0 },{ 0, 0 } },
/* State 69 */
{ { LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },
{ LR_REDUCE, ccl_expr_0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_0 },{ 0, 0 },{ 0, 0 } },
/* State 70 */
{ { LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },
{ LR_REDUCE, ccl_expr_1 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_1 },{ 0, 0 },{ 0, 0 } },
/* State 71 */
{ { LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },
{ LR_REDUCE, ccl_expr_2 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_2 },{ 0, 0 },{ 0, 0 } },
/* State 72 */
{ { LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },
{ LR_REDUCE, ccl_expr_3 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_3 },{ 0, 0 },{ 0, 0 } },
/* State 73 */
{ { LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },
{ LR_REDUCE, ccl_expr_4 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_4 },{ 0, 0 },{ 0, 0 } },
/* State 74 */
{ { LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },
{ LR_REDUCE, ccl_expr_5 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_5 },{ 0, 0 },{ 0, 0 } },
/* State 75 */
{ { LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },
{ LR_REDUCE, ccl_expr_6 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_6 },{ 0, 0 },{ 0, 0 } },
/* State 76 */
{ { LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },
{ LR_REDUCE, ccl_expr_7 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_7 },{ 0, 0 },{ 0, 0 } },
/* State 77 */
{ { LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },
{ LR_REDUCE, ccl_expr_8 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_8 },{ 0, 0 },{ 0, 0 } },
/* State 78 */
{ { LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },
{ LR_REDUCE, ccl_expr_9 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_9 },{ 0, 0 },{ 0, 0 } },
/* State 79 */
{ { LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },
{ LR_REDUCE, ccl_expr_10 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_10 },{ 0, 0 },{ 0, 0 } },
/* State 80 */
{ { LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },
{ LR_REDUCE, ccl_expr_11 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_expr_11 },{ 0, 0 },{ 0, 0 } },
/* State 81 */
{ { LR_SHIFT, 74 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_SHIFT, 72 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 79 },{ 0, 0 },{ LR_SHIFT, 80 },{ LR_SHIFT, 86 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 73 },{ LR_SHIFT, 70 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 69 },{ LR_SHIFT, 77 },{ 0, 0 },{ LR_SHIFT, 76 },
{ LR_SHIFT, 78 },{ LR_SHIFT, 75 },{ 0, 0 },{ LR_SHIFT, 71 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 67 },{ 0, 0 },{ 0, 0 } },
/* State 82 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, namelist2_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_REDUCE, namelist2_0 },{ 0, 0 } },
/* State 83 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ LR_SHIFT, 87 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 88 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 84 */
{ { 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ LR_REDUCE, singleton_5 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_5 },
{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ LR_REDUCE, singleton_5 },{ LR_REDUCE, singleton_5 },
{ LR_REDUCE, singleton_5 },{ LR_REDUCE, singleton_5 },{ 0, 0 },{ 0, 0 } },
/* State 85 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 89 },{ 0, 0 },{ 0, 0 } },
/* State 86 */
{ { 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ LR_REDUCE, fullccl_1 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },
{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ LR_REDUCE, fullccl_1 },{ LR_REDUCE, fullccl_1 },
{ LR_REDUCE, fullccl_1 },{ LR_REDUCE, fullccl_1 },{ 0, 0 },{ 0, 0 } },
/* State 87 */
{ { 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_SHIFT, 90 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 } },
/* State 88 */
{ { 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ LR_REDUCE, singleton_4 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_4 },
{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ LR_REDUCE, singleton_4 },{ LR_REDUCE, singleton_4 },
{ LR_REDUCE, singleton_4 },{ LR_REDUCE, singleton_4 },{ 0, 0 },{ 0, 0 } },
/* State 89 */
{ { LR_REDUCE, ccl_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ LR_REDUCE, ccl_0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },
{ LR_REDUCE, ccl_0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ LR_REDUCE, ccl_0 },{ 0, 0 },{ 0, 0 } },
/* State 90 */
{ { 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ LR_REDUCE, singleton_3 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_3 },
{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },
{ 0, 0 },{ 0, 0 },{ 0, 0 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ LR_REDUCE, singleton_3 },{ LR_REDUCE, singleton_3 },
{ LR_REDUCE, singleton_3 },{ LR_REDUCE, singleton_3 },{ 0, 0 },{ 0, 0 } }
};


//Jump-Table
long ssLexClass::jump_tab[SSLR_STATE][NTERM] = {
//start, sconname, scon, rule, re2, sc2, flexrule, re, goal, fullccl,
//string, initforrule, initlex, series, ccl, startconddecl, sect1, sect2, scsect1, ccl_expr, singleton, namelist1, namelist2, scon_stk_ptr,

/* State 0 */
{  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  2,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 1 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 2 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 3,  0,  0,  0,  0,  0,  0,  0 },
/* State 3 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  5,  0,  0,  0,  0,  0,  0 },
/* State 4 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  7,  0,  0,  0,  0,  0 },
/* State 5 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 6 */
{  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 7 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 8 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 9 */
{  0,  0, 13,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 10 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0, 15,  0,  0 },
/* State 11 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 12 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 13 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 14 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0, 19 },
/* State 15 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 16 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 17 */
{  0,  0,  0, 24, 26,  0, 22, 27,  0, 31,  0,  0,  0, 28,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 18 */
{  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 19 */
{  0, 39,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0, 38,  0 },
/* State 20 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 21 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 22 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 23 */
{  0,  0,  0, 43, 26,  0,  0, 27,  0, 31,  0,  0,  0, 28,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 24 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 25 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 26 */
{  0,  0,  0,  0,  0,  0,  0, 44,  0, 31,  0,  0,  0, 28,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 27 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 28 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0, 31,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0, 48,  0,  0,  0 },
/* State 29 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 30 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 31 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 32 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 33 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 53,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 34 */
{  0,  0,  0,  0,  0,  0,  0, 54,  0, 31,  0,  0,  0, 28,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 35 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 36 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 55,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 37 */
{  0,  0, 13,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 38 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 39 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 40 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 41 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 42 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 43 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 44 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 45 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 46 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 47 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0, 31,  0,  0,  0, 61,  0,  0,
 0,  0,  0,  0, 29,  0,  0,  0 },
/* State 48 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 49 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 50 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 51 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 52 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 53 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 54 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 55 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0, 68,  0,  0,  0,  0 },
/* State 56 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 81,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 57 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 58 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 59 */
{  0, 82,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 60 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 61 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0, 31,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0, 48,  0,  0,  0 },
/* State 62 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 63 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 64 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 65 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 66 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 67 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 68 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 69 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 70 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 71 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 72 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 73 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 74 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 75 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 76 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 77 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 78 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 79 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 80 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 81 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0, 68,  0,  0,  0,  0 },
/* State 82 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 83 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 84 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 85 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 86 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 87 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 88 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 89 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 },
/* State 90 */
{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 0,  0,  0,  0,  0,  0,  0,  0 }
};

//Follow-Sets for Error-Recovery

long ssLexClass::startFollow[1] = { ACCEPT };
long ssLexClass::goalFollow[1] = { ACCEPT };
long ssLexClass::initlexFollow[3] = { DEF, SPEC, ACCEPT };
long ssLexClass::sect1Follow[2] = { SPEC, ACCEPT };
long ssLexClass::scsect1Follow[4] = { SPEC, XSCDECL, ACCEPT, SCDECL };
long ssLexClass::startconddeclFollow[1] = { NAME };
long ssLexClass::namelist1Follow[5] = { NAME, SPEC, XSCDECL, ACCEPT, SCDECL };
long ssLexClass::sect2Follow[1] = { ACCEPT };
long ssLexClass::sc2Follow[12] = { SOPEN, ACCEPT, COPEN, BOPEN, EOF_OP, BCLOSE, SCOPEN, BEGLINE, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::initforruleFollow[9] = { SOPEN, ACCEPT, COPEN, EOF_OP, BEGLINE, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::flexruleFollow[1] = { NEWLINE };
long ssLexClass::scon_stk_ptrFollow[1] = { NAME };
long ssLexClass::sconFollow[9] = { SOPEN, COPEN, BOPEN, EOF_OP, BEGLINE, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::namelist2Follow[2] = { KOMMA, SCCLOSE };
long ssLexClass::sconnameFollow[2] = { KOMMA, SCCLOSE };
long ssLexClass::ruleFollow[1] = { NEWLINE };
long ssLexClass::reFollow[5] = { LA, OR, KLCLOSE, ENDLINE, NEWLINE };
long ssLexClass::re2Follow[6] = { SOPEN, COPEN, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::seriesFollow[11] = { SOPEN, LA, OR, KLCLOSE, COPEN, ENDLINE, NEWLINE, KLOPEN, PREVCCL, ANY, CHAR };
long ssLexClass::singletonFollow[15] = { PLUS, SOPEN, LA, OR, KLCLOSE, COPEN, BOPEN, ENDLINE, MUL, NEWLINE, KLOPEN, QUEST, PREVCCL, ANY, CHAR };
long ssLexClass::fullcclFollow[15] = { PLUS, SOPEN, LA, OR, KLCLOSE, COPEN, BOPEN, ENDLINE, MUL, NEWLINE, KLOPEN, QUEST, PREVCCL, ANY, CHAR };
long ssLexClass::cclFollow[14] = { CCE_GRAPH, CCE_CNTRL, CCE_UPPER, CCE_XDIGIT, CCLOSE, CCE_DIGIT, CCE_ALPHA, CCE_ALNUM, CCE_PUNCT, CCE_PRINT, CCE_SPACE, CCE_LOWER, CCE_BLANK, CHAR };
long ssLexClass::ccl_exprFollow[14] = { CCE_GRAPH, CCE_CNTRL, CCE_UPPER, CCE_XDIGIT, CCLOSE, CCE_DIGIT, CCE_ALPHA, CCE_ALNUM, CCE_PUNCT, CCE_PRINT, CCE_SPACE, CCE_LOWER, CCE_BLANK, CHAR };
long ssLexClass::stringFollow[2] = { SOPEN, CHAR };

//All Alternatives
char *ssLexClass::start0Ri[1] = { "goal" };
char *ssLexClass::goal0Ri[4] = { "initlex", "sect1", "sect2", "initforrule" };
char *ssLexClass::initlex0Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::sect10Ri[2] = { "\'DEF\'", "scsect1" };
char *ssLexClass::sect11Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::scsect10Ri[3] = { "scsect1", "startconddecl", "namelist1" };
char *ssLexClass::scsect11Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::startconddecl0Ri[1] = { "\'SCDECL\'" };
char *ssLexClass::startconddecl1Ri[1] = { "\'XSCDECL\'" };
char *ssLexClass::namelist10Ri[2] = { "namelist1", "\'NAME\'" };
char *ssLexClass::namelist11Ri[1] = { "\'NAME\'" };
char *ssLexClass::sect20Ri[2] = { "\'SPEC\'", "sc2" };
char *ssLexClass::sect21Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::sc20Ri[5] = { "sc2", "scon", "initforrule", "flexrule", "\'NEWLINE\'" };
char *ssLexClass::sc21Ri[5] = { "sc2", "scon", "\'BOPEN\'", "sc2", "\'BCLOSE\'" };
char *ssLexClass::sc22Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::initforrule0Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::flexrule0Ri[2] = { "\'BEGLINE\'", "rule" };
char *ssLexClass::flexrule1Ri[1] = { "rule" };
char *ssLexClass::flexrule2Ri[1] = { "\'EOF_OP\'" };
char *ssLexClass::scon_stk_ptr0Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::scon0Ri[4] = { "\'SCOPEN\'", "scon_stk_ptr", "namelist2", "\'SCCLOSE\'" };
char *ssLexClass::scon1Ri[3] = { "\'SCOPEN\'", "\'SCALL\'", "\'SCCLOSE\'" };
char *ssLexClass::scon2Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::namelist20Ri[3] = { "namelist2", "\'KOMMA\'", "sconname" };
char *ssLexClass::namelist21Ri[1] = { "sconname" };
char *ssLexClass::sconname0Ri[1] = { "\'NAME\'" };
char *ssLexClass::rule0Ri[2] = { "re2", "re" };
char *ssLexClass::rule1Ri[3] = { "re2", "re", "\'ENDLINE\'" };
char *ssLexClass::rule2Ri[2] = { "re", "\'ENDLINE\'" };
char *ssLexClass::rule3Ri[1] = { "re" };
char *ssLexClass::re0Ri[3] = { "re", "\'OR\'", "series" };
char *ssLexClass::re1Ri[1] = { "series" };
char *ssLexClass::re20Ri[2] = { "re", "\'LA\'" };
char *ssLexClass::series0Ri[2] = { "series", "singleton" };
char *ssLexClass::series1Ri[1] = { "singleton" };
char *ssLexClass::singleton0Ri[2] = { "singleton", "\'MUL\'" };
char *ssLexClass::singleton1Ri[2] = { "singleton", "\'PLUS\'" };
char *ssLexClass::singleton2Ri[2] = { "singleton", "\'QUEST\'" };
char *ssLexClass::singleton3Ri[6] = { "singleton", "\'BOPEN\'", "\'NUMBER\'", "\'KOMMA\'", "\'NUMBER\'", "\'BCLOSE\'" };
char *ssLexClass::singleton4Ri[5] = { "singleton", "\'BOPEN\'", "\'NUMBER\'", "\'KOMMA\'", "\'BCLOSE\'" };
char *ssLexClass::singleton5Ri[4] = { "singleton", "\'BOPEN\'", "\'NUMBER\'", "\'BCLOSE\'" };
char *ssLexClass::singleton6Ri[1] = { "\'ANY\'" };
char *ssLexClass::singleton7Ri[1] = { "fullccl" };
char *ssLexClass::singleton8Ri[1] = { "\'PREVCCL\'" };
char *ssLexClass::singleton9Ri[3] = { "\'SOPEN\'", "string", "\'SOPEN\'" };
char *ssLexClass::singleton10Ri[3] = { "\'KLOPEN\'", "re", "\'KLCLOSE\'" };
char *ssLexClass::singleton11Ri[1] = { "\'CHAR\'" };
char *ssLexClass::fullccl0Ri[3] = { "\'COPEN\'", "ccl", "\'CCLOSE\'" };
char *ssLexClass::fullccl1Ri[4] = { "\'COPEN\'", "\'NEGATE\'", "ccl", "\'CCLOSE\'" };
char *ssLexClass::ccl0Ri[4] = { "ccl", "\'CHAR\'", "\'MINUS\'", "\'CHAR\'" };
char *ssLexClass::ccl1Ri[2] = { "ccl", "\'CHAR\'" };
char *ssLexClass::ccl2Ri[2] = { "ccl", "ccl_expr" };
char *ssLexClass::ccl3Ri[1] = { "\'EPSILON\'" };
char *ssLexClass::ccl_expr0Ri[1] = { "\'CCE_ALNUM\'" };
char *ssLexClass::ccl_expr1Ri[1] = { "\'CCE_ALPHA\'" };
char *ssLexClass::ccl_expr2Ri[1] = { "\'CCE_BLANK\'" };
char *ssLexClass::ccl_expr3Ri[1] = { "\'CCE_CNTRL\'" };
char *ssLexClass::ccl_expr4Ri[1] = { "\'CCE_DIGIT\'" };
char *ssLexClass::ccl_expr5Ri[1] = { "\'CCE_GRAPH\'" };
char *ssLexClass::ccl_expr6Ri[1] = { "\'CCE_LOWER\'" };
char *ssLexClass::ccl_expr7Ri[1] = { "\'CCE_PRINT\'" };
char *ssLexClass::ccl_expr8Ri[1] = { "\'CCE_PUNCT\'" };
char *ssLexClass::ccl_expr9Ri[1] = { "\'CCE_SPACE\'" };
char *ssLexClass::ccl_expr10Ri[1] = { "\'CCE_UPPER\'" };
char *ssLexClass::ccl_expr11Ri[1] = { "\'CCE_XDIGIT\'" };
char *ssLexClass::string0Ri[2] = { "string", "\'CHAR\'" };
char *ssLexClass::string1Ri[1] = { "\'EPSILON\'" };


//all alternatives
NTERM_STR ssLexClass::nterm_str[PROD] = {
{ "start", start0Ri, start, 1, startFollow, 1 },
{ "goal", goal0Ri, goal, 4, goalFollow, 1 },
{ "initlex", initlex0Ri, initlex, 0, initlexFollow, 3 },
{ "sect1", sect10Ri, sect1, 2, sect1Follow, 2 },
{ "sect1", sect11Ri, sect1, 0, sect1Follow, 2 },
{ "scsect1", scsect10Ri, scsect1, 3, scsect1Follow, 4 },
{ "scsect1", scsect11Ri, scsect1, 0, scsect1Follow, 4 },
{ "startconddecl", startconddecl0Ri, startconddecl, 1, startconddeclFollow, 1 },
{ "startconddecl", startconddecl1Ri, startconddecl, 1, startconddeclFollow, 1 },
{ "namelist1", namelist10Ri, namelist1, 2, namelist1Follow, 5 },
{ "namelist1", namelist11Ri, namelist1, 1, namelist1Follow, 5 },
{ "sect2", sect20Ri, sect2, 2, sect2Follow, 1 },
{ "sect2", sect21Ri, sect2, 0, sect2Follow, 1 },
{ "sc2", sc20Ri, sc2, 5, sc2Follow, 12 },
{ "sc2", sc21Ri, sc2, 5, sc2Follow, 12 },
{ "sc2", sc22Ri, sc2, 0, sc2Follow, 12 },
{ "initforrule", initforrule0Ri, initforrule, 0, initforruleFollow, 9 },
{ "flexrule", flexrule0Ri, flexrule, 2, flexruleFollow, 1 },
{ "flexrule", flexrule1Ri, flexrule, 1, flexruleFollow, 1 },
{ "flexrule", flexrule2Ri, flexrule, 1, flexruleFollow, 1 },
{ "scon_stk_ptr", scon_stk_ptr0Ri, scon_stk_ptr, 0, scon_stk_ptrFollow, 1 },
{ "scon", scon0Ri, scon, 4, sconFollow, 9 },
{ "scon", scon1Ri, scon, 3, sconFollow, 9 },
{ "scon", scon2Ri, scon, 0, sconFollow, 9 },
{ "namelist2", namelist20Ri, namelist2, 3, namelist2Follow, 2 },
{ "namelist2", namelist21Ri, namelist2, 1, namelist2Follow, 2 },
{ "sconname", sconname0Ri, sconname, 1, sconnameFollow, 2 },
{ "rule", rule0Ri, rule, 2, ruleFollow, 1 },
{ "rule", rule1Ri, rule, 3, ruleFollow, 1 },
{ "rule", rule2Ri, rule, 2, ruleFollow, 1 },
{ "rule", rule3Ri, rule, 1, ruleFollow, 1 },
{ "re", re0Ri, re, 3, reFollow, 5 },
{ "re", re1Ri, re, 1, reFollow, 5 },
{ "re2", re20Ri, re2, 2, re2Follow, 6 },
{ "series", series0Ri, series, 2, seriesFollow, 11 },
{ "series", series1Ri, series, 1, seriesFollow, 11 },
{ "singleton", singleton0Ri, singleton, 2, singletonFollow, 15 },
{ "singleton", singleton1Ri, singleton, 2, singletonFollow, 15 },
{ "singleton", singleton2Ri, singleton, 2, singletonFollow, 15 },
{ "singleton", singleton3Ri, singleton, 6, singletonFollow, 15 },
{ "singleton", singleton4Ri, singleton, 5, singletonFollow, 15 },
{ "singleton", singleton5Ri, singleton, 4, singletonFollow, 15 },
{ "singleton", singleton6Ri, singleton, 1, singletonFollow, 15 },
{ "singleton", singleton7Ri, singleton, 1, singletonFollow, 15 },
{ "singleton", singleton8Ri, singleton, 1, singletonFollow, 15 },
{ "singleton", singleton9Ri, singleton, 3, singletonFollow, 15 },
{ "singleton", singleton10Ri, singleton, 3, singletonFollow, 15 },
{ "singleton", singleton11Ri, singleton, 1, singletonFollow, 15 },
{ "fullccl", fullccl0Ri, fullccl, 3, fullcclFollow, 15 },
{ "fullccl", fullccl1Ri, fullccl, 4, fullcclFollow, 15 },
{ "ccl", ccl0Ri, ccl, 4, cclFollow, 14 },
{ "ccl", ccl1Ri, ccl, 2, cclFollow, 14 },
{ "ccl", ccl2Ri, ccl, 2, cclFollow, 14 },
{ "ccl", ccl3Ri, ccl, 0, cclFollow, 14 },
{ "ccl_expr", ccl_expr0Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr1Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr2Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr3Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr4Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr5Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr6Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr7Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr8Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr9Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr10Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "ccl_expr", ccl_expr11Ri, ccl_expr, 1, ccl_exprFollow, 14 },
{ "string", string0Ri, string, 2, stringFollow, 2 },
{ "string", string1Ri, string, 0, stringFollow, 2 }};



#ifdef SSLR_DEBUG

//Names of the Terminals
char *ssLexClass::term_name[TERM] =
{ "CCE_GRAPH", "PLUS", "DEF", "SOPEN", "LA", "OR", "NAME", "KLCLOSE", "SPEC", "CCE_CNTRL", "XSCDECL", "SCALL", "CCE_UPPER", "COPEN", "CCE_XDIGIT", "CCLOSE",
"BOPEN", "MINUS", "ENDLINE", "NUMBER", "MUL", "EOF_OP", "CCE_DIGIT", "CCE_ALPHA", "NEGATE", "KOMMA", "BCLOSE", "SCOPEN", "SCDECL", "CCE_ALNUM", "CCE_PUNCT", "NEWLINE",
"CCE_PRINT", "CCE_SPACE", "CCE_LOWER", "BEGLINE", "CCE_BLANK", "KLOPEN", "EPSILON", "QUEST", "PREVCCL", "ANY", "CHAR", "SCCLOSE", "ACCEPT" };

#endif




void ssLexClass::errShift( long termi )
{
	//shift a new state
	if( lr_tab[state][termi].state == LR_SHIFT )
		//Push new state
		Push( lr_tab[state][termi].value );
}


void ssLexClass::errDelete( void )
{
	//delete current terminal
	terminal = getTerminal();
}


void ssLexClass::errOverRead( long termi )
{
	//delete all terminals till term is found
	do
	{
		//get next terminal
		terminal = getTerminal();

		//equal?
		if( terminal == termi )
			//yes, return
			return;

		else if( terminal == ACCEPT )
		{
			//abort parsing
			state = 1;
			return;
		}

	}while( 1 );
}


void ssLexClass::error( void )
{
	//error-handling
	NTERM_STR	*n;
	long		*f, tmpState;
	int			fCnt = 0, i, rec = 0;

	//delete all terminals till one that follows the last nonterminal
	//the reduction was done with
	anzError++;

	//no semantic actions are allowed after errors
	semAct++;

	//state after reduction
	tmpState = errStr.state;

	//get a pointer to the NTERM_STR of the nonterminal
	n = &nterm_str[errStr.alt];

	//get the follow-terminals
	f = n->follow;

	//number of follow-terminals
	fCnt = n->followCnt;


	switch( state )
	{
		// sc2 ->  sc2  scon  'BOPEN' . sc2  'BCLOSE'
		case 18:
		{
			if( ( terminal == LA ) )
			{
				//show user-defined error message
				cerr << "line: " << line << ": Lookahead-Operator not allowed!";

				//delete terminals till NEWLINE ist the current Terminal
				OVERREAD( NEWLINE );

				//delete current Terminal
				DELETE();

				//skip automatic error recovery
				rec++;

			}

			break;
		}

		// namelist2 ->  namelist2 . 'KOMMA'  sconname
		case 38:
		{
				//show user-defined error message
				cerr << "line: " << line << ": Comma expected in start condition!";

			break;
		}

		// namelist2 ->  namelist2  'KOMMA' . sconname
		case 59:
		{
				//show user-defined error message
				cerr << "line: " << line << ": Name expected in start condition list!";

				//shift Terminal NAME
				SHIFT( NAME );

				//skip automatic error recovery
				rec++;

			break;
		}

		// sconname ->  'NAME' .
		case 40:
		{
				//show user-defined error message
				cerr << "line: " << line << ": Start conditions must be separated by a comma!";

				//delete terminals till SCCLOSE ist the current Terminal
				OVERREAD( SCCLOSE );

				//skip automatic error recovery
				rec++;

			break;
		}

		default:
		{
			//default error message
			cerr << "line: " << line << ": Syntax error!\n";
			break;
		}
	}


	//do the common error-recovery?
	if( !rec )
	{
		//yes, no user defined error-routines were made

		do
		{
			//is the current terminal ACCEPT?
			if( terminal == ACCEPT )
			{
				//abort parsing
				state = 1;
				return;
			}

			//equal?
			if( lr_tab[tmpState][terminal].state == LR_SHIFT )
			{
				//set state
				state = errStr.state;

				//set stack-position
				sp = errStr.sp;

				return;
			}

			//get next terminal
			terminal = getTerminal();

		}while( 1 );
	}

	return;
}


ssLexClass::ssLexClass( SSLEXScanner *scan, ARGV_STR *argv )
{
	//call reset to initialize the parser
	reset();

	//scanner-class
	s = scan;


	//Argumente
	argv_str = argv;
}


ssLexClass::~ssLexClass()
{
	//Speicher freigeben
	_temp();
}


void ssLexClass::_temp( void )
{
	//Speicher freigeben
	DEA_STATES	*dea;
	STATE_STR	*_s;
	NEA_STR		*nea;
	SC_STR		*sc, *_sc2;
	ulong		i, j, k, l;
	char		*tmp, **tmp2;

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//den Namen freigeben, INITIAL überspringen, da static
		if( i )
			delete[] ( sc->name );

		//Alle NEAen dieser SC
		for( j = 0; j < sc->neaArrCnt; j++ )
		{
			//Zeiger auf NEA
			nea = sc->neaArr[j];

			//Speicher freigeben?
			if( nea )
			{
				//Aktion
				if( nea->action )
				{
					//Adresse merken
					tmp2 = nea->action;

					//auch in anderen NEA_STR löschen
					for( k = i; k < scStrAnz; k++ )
					{
						//Zeiger auf SC
						_sc2 = &scStr[k];

						//Alle NEAen
						for( l = 0; l < _sc2->neaArrCnt; l++ )
						{
							//gleich?
							if( _sc2->neaArr[l] && ( _sc2->neaArr[l] != nea ) && ( _sc2->neaArr[l]->action == nea->action ) )
								//Ja, zurücksetzen
								_sc2->neaArr[l]->action = 0L;
						}
					}

					//Speicher freigeben
					deleteAction( nea );
				}

				//reg. Ausdruck als Text
				if( nea->regText )
				{
					//Adresse merken
					tmp = nea->regText;

					//auch in anderen NEA_STR löschen
					for( k = i; k < scStrAnz; k++ )
					{
						//Zeiger auf SC
						_sc2 = &scStr[k];

						//Alle NEAen
						for( l = 0; l < _sc2->neaArrCnt; l++ )
						{
							//gleich?
							if( _sc2->neaArr[l] && ( _sc2->neaArr[l]->regText == nea->regText ) )
								//Ja, zurücksetzen
								_sc2->neaArr[l]->regText = 0L;
						}
					}

					//Speicher freigeben
					delete[] ( tmp );

					//zurücksetzen
					nea->regText = 0L;
				}

				//NEA_STR auch in anderen SC
				for( k = i; k < scStrAnz; k++ )
				{
					//Zeiger auf SC
					_sc2 = &scStr[k];

					//Alle NEAen
					for( l = 0; l < _sc2->neaArrCnt; l++ )
					{
						//gleich?
						if( _sc2->neaArr[l] && ( _sc2->neaArr[l] == nea ) )
							//Ja, zurücksetzen
							_sc2->neaArr[l] = 0L;
					}
				}

				//NEA_STR freigeben
				delete( nea );
			}
		}

		//Array mit den NEAen freigeben
		if( sc->neaArr )
			delete[] ( sc->neaArr );

		//Übergangstabellen mit den NEAen freigeben, die überall stehen dürfen
		if( sc->DTran1 )
		{
			//Alle Zustände
			for( j = 0; j < sc->DTran1Cnt; j++ )
			{
				delete[] ( sc->DTran1[j]->to );
				delete( sc->DTran1[j] );
			}

			//freigeben
			delete[] ( sc->DTran1 );
		}

		//Übergangstabellen mit den NEAen freigeben, die ausschließlich am Zeilenanfang stehen dürfen
		if( sc->DTran2 )
		{
			//Alle Zustände
			for( j = 0; j < sc->DTran2Cnt; j++ )
			{
				delete[] ( sc->DTran2[j]->to );
				delete( sc->DTran2[j] );
			}

			//freigeben
			delete[] ( sc->DTran2 );
		}

		//Gruppe mit den NEAen freigeben, die überall stehen dürfen
		if( sc->grp )
		{
			//Alle Zustände
			for( j = 0; j < sc->grpCnt; j++ )
			{
				delete[] ( sc->grp[j]->DEAIndex );
				delete( sc->grp[j] );
			}

			//freigeben
			delete[] ( sc->grp );
		}
	}

	//Speicher der SC freigeben
	delete[] ( scStr );

	//Stack mit den SC?
	if( scStack )
		delete[] ( scStack );


	//die NEA-Zustände freigeben?
	if( stateStr )
	{
		//alle NEA-Zustände
		for( i = 0; i < stateStrCnt; i++ )
		{
			//Zeiger auf Zustand
			_s = stateStr[i];

			//gibt es überhaupt Übergänge?
			if( _s->braStr )
			{
				//Zustandsübergänge freigeben
				for( j = 0; j < _s->braStrCnt; j++ )
				{
					//Zeichenklasse freigeben
					if( _s->braStr[j]->cclClass )
						//Zeichenklasse freigeben
						delete[] ( _s->braStr[j]->cclClass );

					//freigeben
					delete( _s->braStr[j] );
				}

				//Array mit den Zustandsübergängen freigeben
				delete[] ( _s->braStr );
			}

			//freigeben
			delete( _s );
		}

		//freigeben
		delete[] ( stateStr );
	}

	//die DEA-Zustände freigeben?
	if( DEAStates )
	{
		//alle DEA-Zustände
		for( i = 0; i < DEAStatesCnt; i++ )
		{
			//Zeiger auf DEA
			dea = DEAStates[i];

			//Zeiger mit den NEA-Zuständen freigeben
			delete[] ( dea->neaIndex );
			delete( dea );
		}

		//Speicher freigeben
		delete[] ( DEAStates );
	}

	//NEA-Stack freigeben?
	if( neaStack )
		delete[] ( neaStack );
}


void ssLexClass::reset( void )
{
	//resets the whole parser

	//Stack-Counter
	sp = 0;

	//start with state 0
	Push( 0 );
	state = 0;

	//no errors yet
	anzError = 0;

	/*
		Nach jedem regulärem Shift wird der aktuelle Zustand gespeichert, da zwar von einem LR-Parser
		niemals ein fehlerhaftes Terminal geschoben werden wird, wohl aber die eine oder andere
		Reduktion.
	*/
	errStr.alt = start_0;
	errStr.sp = sp;
	errStr.state = 0;

	//wenn semAct = 0, dann werden semantische Aktionen ausgeführt
	semAct = 0;

	//counter for semantic-action-stack
	semStackCnt = 0;

	/*
		Nach einem Fehler müssen mind. ERR_SHIFT Terminale geschoben werden, damit keine
		Fehlerlawinen auftreten.
	*/
	regShift = true;
}


int ssLexClass::getTerminal( void )
{
	//semantic actions allowed?
	if( !semAct )
		//push attribute on Stack for semantic actions
		semStack[semStackCnt++] = attributeStr;

	//get next Terminal
	terminal = s->yyLex( &attributeStr );

	//get line
	line = s->getYYLineno();

	//Terminal zurückliefern
	return( terminal );
}


int ssLexClass::yyParse( void )
{
	//start parsing
	int			error;

	//get first terminal
	terminal = getTerminal();

	//start parsing
	error = Parse();

	//Fehler?
	if( !error )
	{
		//prüfen, ob alle name definitions auch benutzt wurden
		s->checkRegExp();

		//Nein, aus den NEAen DEAen machen
		NEA2DEA();

		//finde Regeln, die nie ausgeführt werden
		findNoRules();

#ifdef MINDEA
		//Zustandsmenge minimieren
		minDEA();
#endif

		//die Übergangstabelle als C++-Code ausgeben
		generateFiles();

		//Informationen ausgeben?
		if( argv_str->verbose == true )
			//Ja
			outputInfo();
	}

	else
		//Meldung
		cout << "sslex: Terminate with " << error << " error(s)!\n";

	//Alles OK
	return( 0 );
}


void ssLexClass::Push( long ast )
{
	//Push a new state on stack
	stack[sp++] = ast;

	//stack-overflow?
	if( sp > MAX_STACK )
	{
		//stack-overflow
		cerr << "ssLexClass::push: Stack-overflow!\nExiting...\n";
		exit( 1 );
	}

	//new state
	state = ast;
}


long ssLexClass::Pop( int anz )
{
	//pop anz elements from stack
	sp -= anz;

	//Stack underflow?
	if( sp < 0 )
	{
		//stack underflow
		cerr << "ssLexClass::pop: Stack-underflow!\nExiting...\n";
		exit( 1 );
	}

	//return new state
	return( stack[sp - 1] );
}


int ssLexClass::Parse( void )
{
	//begin parsing

	while( 1 )
	{
		//end parsing?
		if( state == 1 )
		{
			//yes, is terminal ACCEPT
			if( terminal == ACCEPT )
				//yes
				return( anzError );

			else
			{
				//error
				cerr << "parser: bailing out...\n";
				return( anzError );
			}
		}

		//shift?
		else if( lr_tab[state][terminal].state == LR_SHIFT )
		{
			//yes
			Shift( &lr_tab[state][terminal] );

			//get new terminal
			terminal = getTerminal();
		}

		//reduce?
		else if( lr_tab[state][terminal].state == LR_REDUCE )
			//reduce
			Reduce( &lr_tab[state][terminal] );

		//must be an error
		else
			//Fehlerbehandlungs-Routine starten
			//error-recovery
			error();
	}
}


void ssLexClass::Shift( LR_TAB *tab )
{
	//Shift

#ifdef SSLR_DEBUG
	//output
	cout << "Shift\n";
	cout << "current state: " << state << "\n";
	cout << "current terminal: " << term_name[terminal] << "\n";
#endif

	//shift new state in stack
	Push( tab->value );


#ifdef SSLR_DEBUG
	//output
	cout << "shift new state " << state << "\n\n";
#endif
}


void ssLexClass::Reduce( LR_TAB *tab )
{
	//Reduce
	NTERM_STR	*n;

	//do semantic action
	doSemAct( tab );

	//get a pointer to the alternative
	n = &nterm_str[tab->value];

#ifdef SSLR_DEBUG
	//output
	cout << "Reduce\n";
	cout << "current state: " << state << "\n";
	cout << "current terminal: " << term_name[terminal] << "\n";
	cout << "reduce with ";

	//output alternative
	outputAlt( n );

	//output
	cout << "\n";
#endif

	//remove states form stack
	state = Pop( n->elem );

	//get new state
	state = jump_tab[state][n->jump_index];

	//push new state on stack
	Push( state );

#ifdef SSLR_DEBUG
	//output
	cout << "new state " << state << "\n\n";
#endif

	//for error-recovery
	errStr.alt = tab->value;
	errStr.sp = sp;
	errStr.state = state;
}


#ifdef SSLR_DEBUG
void ssLexClass::outputAlt( NTERM_STR *n )
{
	//output an alternative
	int	i;

	//name of alternative
	cout << n->name << " -> ";

	//output right side
	for( i = 0; i < n->elem; i++ )
		cout << n->ri[i] << " ";

	//EPSILON alternative?
	if( !n->elem )
		//yes
		cout << "'EPSILON'";
}
#endif




void ssLexClass::doSemAct( LR_TAB *tab )
{
	//do semantic actions before reduction
	NTERM_STR	*n;
	SSLR_TYPE	tmp;

	//semantic actions allowed?
	if( !semAct )
	{
		//get a pointer to the alternative
		n = &nterm_str[tab->value];

		//Alternative to reduce with
		switch( tab->value )
		{
			// goal ->  initlex  sect1  sect2  initforrule .
			case goal_0:
			{

	//Ende
				break;
			}

			// initlex ->  'EPSILON' .
			case initlex_0:
			{

	//SSLEX initialisieren

	//7- oder 8-Bit-Scanner
	cclWidth = argv_str->cclWidth;

	//noch keine NEA-Zustände
	stateStrCnt = 0;
	stateStr = 0L;

	//noch keine NEA_STR auf Stack
	neaStackCnt = 0;
	neaStackMax = 0;
	neaStack = 0L;

	//SC-Stack
	scStack = 0L;

	//noch keine SC
	scStrAnz = 0;
	scStr = 0L;

	//keine Lookahead-Rules
	laUsed = false;

	//keine begin-of-line-Rules
	begLineUsed = false;

	//Regeln zählen
	ruleCnt = 0;


	//Speicher für NEA-Stack anfordern
	extendNEAStack();

	//SC INITIAL eintragen
	insertSC( "INITIAL", false );
				break;
			}

			// sect1 ->  'DEF'  scsect1 .
			case sect1_0:
			{

	//ab hier müssen alle SC definiert sein, nun Speicher für den SC-Stack anfordern
	scStack = new( SC_STR *[scStrAnz] );
	scStackPos = 0;
				break;
			}

			// startconddecl ->  'SCDECL' .
			case startconddecl_0:
			{

	//ist eine inclusive SC
	xcluSC = false;
				break;
			}

			// startconddecl ->  'XSCDECL' .
			case startconddecl_1:
			{

	//ist eine exclusive SC
	xcluSC = true;
				break;
			}

			// namelist1 ->  namelist1  'NAME' .
			case namelist1_0:
			{

	//den Namen einer SC eintragen
	insertSC( semStack[semStackCnt - 1 - 2 + (2)].name, xcluSC );
				break;
			}

			// namelist1 ->  'NAME' .
			case namelist1_1:
			{

	//den Namen einer SC eintragen
	insertSC( semStack[semStackCnt - 1 - 1 + (1)].name, xcluSC );
				break;
			}

			// sc2 ->  sc2  scon  initforrule  flexrule  'NEWLINE' .
			case sc2_0:
			{

	//Position auf dem SC-Stack zurückgeben
	scStackPos = semStack[semStackCnt - 1 - 5 + (2)].i;
				break;
			}

			// sc2 ->  sc2  scon  'BOPEN'  sc2  'BCLOSE' .
			case sc2_1:
			{

	//Position auf dem SC-Stack zurückgeben
	scStackPos = semStack[semStackCnt - 1 - 5 + (2)].i;
				break;
			}

			// initforrule ->  'EPSILON' .
			case initforrule_0:
			{

	//es folgt ein reg. Ausdruck

	//erst einmal kein Lookahead-NEA
	trailingContext = false;
				break;
			}

			// flexrule ->  'BEGLINE'  rule .
			case flexrule_0:
			{

	NEA_STR	*nea = semStack[semStackCnt - 1 - 2 + (2)].neaStr;
	int		i;

	//Regeln zählen
	ruleCnt++;

	//begin-of-line-Rules benutzt
	begLineUsed = true;

	//NEA darf nur am Anfang einer Zeile stehen
	nea->begLine = true;

	//die auszuführende Aktion holen
	nea->action = s->getAction( nea->actionAnz );

	//den reg. Ausdruck als Text holen
	nea->regText = s->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

	//reg. Ausdruck ausgeben
	cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


	//Nun den NEA in die SC eintragen
	if( scStackPos )
	{
		//alle SC auf dem Stack
		for( i = 0; i < scStackPos; i++ )
			//eintragen
			insertSC( scStack[i], nea );
	}

	else
		//es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
		insertInclSC( nea );


	//Aktion |, d.h. die auszuführende Aktion folgt später?
	if( nea->action && ( nea->action[0][0] == '|' ) )
		//Ja, NEA auf Stack
		insertNEAStack( nea );

	else
	{
		//Aktion auch an andere NEAen weitergeben?
		if( neaStackCnt )
		{
			//Ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
			for( i = 0; i < neaStackCnt; i++ )
			{
				//den Speicher der alten Aktion freigeben
				deleteAction( neaStack[i] );

				//Aktionen anhängen
				neaStack[i]->action = nea->action;
				neaStack[i]->actionAnz = nea->actionAnz;
			}

			//Stack löschen
			neaStackCnt = 0;
		}
	}

	//auf Stack
	tmp.neaStr = nea;
				break;
			}

			// flexrule ->  rule .
			case flexrule_1:
			{

	NEA_STR	*nea = semStack[semStackCnt - 1 - 1 + (1)].neaStr;
	int		i;

	//Regeln zählen
	ruleCnt++;

	//die auszuführende Aktion holen
	nea->action = s->getAction( nea->actionAnz );

	//den reg. Ausdruck als Text holen
	nea->regText = s->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

	//reg. Ausdruck ausgeben
	cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


	//Nun den NEA in die SC eintragen
	if( scStackPos )
	{
		//alle SC auf dem Stack
		for( i = 0; i < scStackPos; i++ )
			//eintragen
			insertSC( scStack[i], nea );
	}

	else
		//es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
		insertInclSC( nea );


	//Aktion |, d.h. die auszuführende Aktion folgt später?
	if( nea->action && ( nea->action[0][0] == '|' ) )
		//Ja, NEA auf Stack
		insertNEAStack( nea );

	else
	{
		//Aktion auch an andere NEAen weitergeben?
		if( neaStackCnt )
		{
			//Ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
			for( i = 0; i < neaStackCnt; i++ )
			{
				//den Speicher der alten Aktion freigeben
				deleteAction( neaStack[i] );

				//Aktionen anhängen
				neaStack[i]->action = nea->action;
				neaStack[i]->actionAnz = nea->actionAnz;
			}

			//Stack löschen
			neaStackCnt = 0;
		}
	}

	//auf Stack
	tmp.neaStr = nea;
				break;
			}

			// flexrule ->  'EOF_OP' .
			case flexrule_2:
			{

	//ist eine Regel, die am Ende der gesamten Eingabe ausgeführt wird
	NEA_STR	*nea;
	int		i;

	//Regeln zählen
	ruleCnt++;

	//einen NEA erzeugen
	nea = getNewNEA();

	//ein EOF-NEA
	nea->eof = true;

	//die auszuführende Aktion holen
	nea->action = s->getAction( nea->actionAnz );

	//den reg. Ausdruck als Text holen
	nea->regText = s->getScanRegTxt( nea->line );

#ifdef DEBUG_LEVEL2

	//reg. Ausdruck ausgeben
	cerr << "Zeile " << nea->line << ": " << nea->regText << "\n";
#endif


	//Nun den NEA in die SC eintragen
	if( scStackPos )
	{
		//alle SC auf dem Stack
		for( i = 0; i < scStackPos; i++ )
			//eintragen
			insertSC( scStack[i], nea );
	}

	else
		//es wurden keine SC angegeben, d.h. in alle inclusive SC eintragen
		insertInclSC( nea );


	//Aktion |, d.h. die auszuführende Aktion folgt später?
	if( nea->action && ( nea->action[0][0] == '|' ) )
		//Ja, NEA auf Stack
		insertNEAStack( nea );

	else
	{
		//Aktion auch an andere NEAen weitergeben?
		if( neaStackCnt )
		{
			//Ja, Aktion an alle NEAen weitergeben, die auf dem NEA-Stack sind
			for( i = 0; i < neaStackCnt; i++ )
			{
				//den Speicher der alten Aktion freigeben
				deleteAction( neaStack[i] );

				//Aktionen anhängen
				neaStack[i]->action = nea->action;
				neaStack[i]->actionAnz = nea->actionAnz;
			}

			//Stack löschen
			neaStackCnt = 0;
		}
	}

	//auf Stack
	tmp.neaStr = nea;
				break;
			}

			// scon_stk_ptr ->  'EPSILON' .
			case scon_stk_ptr_0:
			{

	//Position auf dem SC-Stack zurückgeben
	tmp.i = scStackPos;
				break;
			}

			// scon ->  'SCOPEN'  scon_stk_ptr  namelist2  'SCCLOSE' .
			case scon_0:
			{

	//Position auf dem SC-Stack zurückgeben
	tmp.i = semStack[semStackCnt - 1 - 4 + (2)].i;
				break;
			}

			// scon ->  'SCOPEN'  'SCALL'  'SCCLOSE' .
			case scon_1:
			{

	//regulären Ausdruck in alle SC eintragen
	SC_STR	*sc;
	int		i, j;

	//Position merken
	tmp.i = scStackPos;

	//Ja, wurde sie schon auf dem Stack gepackt?
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger
		sc = &scStr[i];

		//nur die eintragen, die nicht schon auf dem Stack sind
		for( j = 0; j < scStackPos; j++ )
		{
			//gleich?
			if( sc == scStack[j] )
				//Ja
				break;
		}

		//war die SC schon auf dem Stack?
		if( j == scStackPos )
			//Zeiger auf SC auf Stack
			scStack[scStackPos++] = &scStr[i];
	}
				break;
			}

			// scon ->  'EPSILON' .
			case scon_2:
			{

	//Position auf dem SC-Stack zurückgeben
	tmp.i = scStackPos;
				break;
			}

			// sconname ->  'NAME' .
			case sconname_0:
			{

	//den Namen einer SC auf den SC-Stack packen, zu der der folgende reg. Ausdruck gehören soll
	int	scIndex, i;

	//Wurde die SC überhaupt definiert?
	if( ( scIndex = lookupSC( semStack[semStackCnt - 1 - 1 + (1)].name ) ) >= 0 )
	{
		//Ja, wurde sie schon auf dem Stack gepackt?
		for( i = 0; i < scStackPos; i++ )
		{
			//gleich?
			if( !strcmp( scStack[i]->name, semStack[semStackCnt - 1 - 1 + (1)].name ) )
			{
				//Ja, Meldung
				cerr << "sslex: line " << line << ": Start condition " << semStack[semStackCnt - 1 - 1 + (1)].name << " already on Stack!\n";

				//raus hier
				break;
			}
		}

		//War sie schon auf dem Stack?
		if( i == scStackPos )
			//Nein
			scStack[scStackPos++] = &scStr[scIndex];
	}

	else
	{
		//Nein, Fehler
		cerr << "sslex: line " << line << ": Start condition " << semStack[semStackCnt - 1 - 1 + (1)].name << " not definied!\n";

		//Fehler
		err++;
	}

	//Speicher freigeben
	delete[] ( semStack[semStackCnt - 1 - 1 + (1)].name );
				break;
			}

			// rule ->  re2  re .
			case rule_0:
			{

	//Lookahead-NEA
	NEA_STR	*nea;
	ulong	index = semStack[semStackCnt - 1 - 2 + (1)].neaStr->endState;

	//Lookahead-Rule benutzt
	laUsed = true;

	//NEAen verlinken
	nea = mkLink( semStack[semStackCnt - 1 - 2 + (1)].neaStr, semStack[semStackCnt - 1 - 2 + (2)].neaStr );

	//den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ändern
	setState( nea, index, MARK_AS_LA );

	//ist ein Lookahead-NEA
	nea->laState = true;

	//NEAen auf Stack
	tmp.neaStr = nea;
				break;
			}

			// rule ->  re2  re  'ENDLINE' .
			case rule_1:
			{

	/*
		reg. Ausdruck nur am Zeilenende, aber zweimal trailing context
	*/
	NEA_STR	*nea;
	ulong	index = semStack[semStackCnt - 1 - 3 + (2)].neaStr->endState;
	int		*cclStr;

	//Lookahead-Rule benutzt
	laUsed = true;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//newline
	cclAdd( cclStr, '\n' );

	//beide NEAen verlinken
	nea = mkLink( semStack[semStackCnt - 1 - 3 + (1)].neaStr, semStack[semStackCnt - 1 - 3 + (2)].neaStr );

	//nun einen Zustandsübergang erzeugen
	mkBranch( nea, cclStr, false );

	//den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ändern
	setState( nea, index, MARK_AS_LA );

	//ist ein Lookahead-NEA
	nea->laState = true;

	//NEAen auf Stack
	tmp.neaStr = nea;

	//Fehler-Meldung ausgeben
	cerr << "sslex: line " << line << ": Trailing context used twice!\n";

	//Fehler
	err++;
				break;
			}

			// rule ->  re  'ENDLINE' .
			case rule_2:
			{

	//reg. Ausdruck nur am Zeilenende
	ulong	index = semStack[semStackCnt - 1 - 2 + (1)].neaStr->endState;
	int		*cclStr;

	//Lookahead-Rule benutzt
	laUsed = true;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//newline
	cclAdd( cclStr, '\n' );

	//nun einen Zustandsübergang erzeugen
	mkBranch( semStack[semStackCnt - 1 - 2 + (1)].neaStr, cclStr, false );

	//den vorherigen Finit-Zustand des NEA in einen Lookahead-Zustand ändern
	setState( semStack[semStackCnt - 1 - 2 + (1)].neaStr, index, MARK_AS_LA );

	//ist ein Lookahead-NEA
	semStack[semStackCnt - 1 - 2 + (1)].neaStr->laState = true;

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 2 + (1)].neaStr;
				break;
			}

			// rule ->  re .
			case rule_3:
			{

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 1 + (1)].neaStr;
				break;
			}

			// re ->  re  'OR'  series .
			case re_0:
			{

	//NEAen verodern
	tmp.neaStr = mkor( semStack[semStackCnt - 1 - 3 + (1)].neaStr, semStack[semStackCnt - 1 - 3 + (3)].neaStr );
				break;
			}

			// re ->  series .
			case re_1:
			{

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 1 + (1)].neaStr;
				break;
			}

			// re2 ->  re  'LA' .
			case re2_0:
			{

	//Lookahead-NEA

	//ist ein Lookahead-NEA
	semStack[semStackCnt - 1 - 2 + (1)].neaStr->laState = true;

	//NEA auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 2 + (1)].neaStr;
				break;
			}

			// series ->  series  singleton .
			case series_0:
			{

	//NEAen auf Stack
	tmp.neaStr = mkLink( semStack[semStackCnt - 1 - 2 + (1)].neaStr, semStack[semStackCnt - 1 - 2 + (2)].neaStr );
				break;
			}

			// series ->  singleton .
			case series_1:
			{

	//NEA auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 1 + (1)].neaStr;
				break;
			}

			// singleton ->  singleton  'MUL' .
			case singleton_0:
			{

	//NEA beliebig oft
	tmp.neaStr = mkClos( semStack[semStackCnt - 1 - 2 + (1)].neaStr );
				break;
			}

			// singleton ->  singleton  'PLUS' .
			case singleton_1:
			{

	//NEA höchstens einmal ausführen
	tmp.neaStr = mkPosClos( semStack[semStackCnt - 1 - 2 + (1)].neaStr );
				break;
			}

			// singleton ->  singleton  'QUEST' .
			case singleton_2:
			{

	//NEA ist optional
	tmp.neaStr = mkOpt( semStack[semStackCnt - 1 - 2 + (1)].neaStr );
				break;
			}

			// singleton ->  singleton  'BOPEN'  'NUMBER'  'KOMMA'  'NUMBER'  'BCLOSE' .
			case singleton_3:
			{

	//NEA vervielfachen

	//Wert OK?
	if( ( semStack[semStackCnt - 1 - 6 + (3)].l > semStack[semStackCnt - 1 - 6 + (5)].l ) || ( semStack[semStackCnt - 1 - 6 + (3)].l <= 0 ) )
	{
		//Fehler
		cerr << "sslex: line " << line << ": Bad iteration values!\n";

		//Fehler
		err++;

		//auf Stack
		tmp.neaStr = semStack[semStackCnt - 1 - 6 + (1)].neaStr;
	}

	else
	{
		//optional?
		if( semStack[semStackCnt - 1 - 6 + (3)].l == 0 )
		{
			//negativ?
			if( semStack[semStackCnt - 1 - 6 + (5)].l <= 0 )
			{
				//Fehler
				cerr << "sslex: line " << line << ": Bad iteration values!\n";

				//Fehler
				err++;

				//auf Stack
				tmp.neaStr = semStack[semStackCnt - 1 - 6 + (1)].neaStr;
			}

			else
				//NEA vervielfachen
				tmp.neaStr = mkRepeat( semStack[semStackCnt - 1 - 6 + (1)].neaStr, semStack[semStackCnt - 1 - 6 + (3)].l, semStack[semStackCnt - 1 - 6 + (5)].l );
		}

		else
			//NEA vervielfachen
			tmp.neaStr = mkRepeat( semStack[semStackCnt - 1 - 6 + (1)].neaStr, semStack[semStackCnt - 1 - 6 + (3)].l, semStack[semStackCnt - 1 - 6 + (5)].l );
	}
				break;
			}

			// singleton ->  singleton  'BOPEN'  'NUMBER'  'KOMMA'  'BCLOSE' .
			case singleton_4:
			{

	//NEA vervielfachen

	//Wert OK?
	if( semStack[semStackCnt - 1 - 5 + (3)].l <= 0 )
	{
		//Fehler
		cerr << "sslex: line " << line << ": Iteration value must be positive!\n";

		//Fehler
		err++;

		//auf Stack
		tmp.neaStr = semStack[semStackCnt - 1 - 5 + (1)].neaStr;
	}

	else
		//NEA vervielfachen
		tmp.neaStr = mkRepeat( semStack[semStackCnt - 1 - 5 + (1)].neaStr, semStack[semStackCnt - 1 - 5 + (3)].l, _INFINITY );
				break;
			}

			// singleton ->  singleton  'BOPEN'  'NUMBER'  'BCLOSE' .
			case singleton_5:
			{

	//NEA vervielfachen

	//Wert OK?
	if( semStack[semStackCnt - 1 - 4 + (3)].l <= 0 )
	{
		//Fehler
		cerr << "sslex: line " << line << ": Iteration value must be positive!\n";

		//Fehler
		err++;

		//auf Stack
		tmp.neaStr = semStack[semStackCnt - 1 - 4 + (1)].neaStr;
	}

	else
		//NEA vervielfachen
		tmp.neaStr = mkRepeat( semStack[semStackCnt - 1 - 4 + (1)].neaStr, semStack[semStackCnt - 1 - 4 + (3)].l );
				break;
			}

			// singleton ->  'ANY' .
			case singleton_6:
			{

	NEA_STR		*nea;
	int			*cclClass;

	//einen NEA erzeugen
	nea = getNewNEA();

	//eine Zeichenklasse anlegen
	cclClass = cclAny();

	//Zustands-Übergang erzeugen
	mkBranch( nea, cclClass, false );

	//NEAen auf Stack
	tmp.neaStr = nea;
				break;
			}

			// singleton ->  fullccl .
			case singleton_7:
			{

	NEA_STR		*nea;

	//einen NEA erzeugen
	nea = getNewNEA();

	//Zustands-Übergang erzeugen
	mkBranch( nea, semStack[semStackCnt - 1 - 1 + (1)].cclClass, false );

	//NEAen auf Stack
	tmp.neaStr = nea;
				break;
			}

			// singleton ->  'SOPEN'  string  'SOPEN' .
			case singleton_9:
			{

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 3 + (2)].neaStr;
				break;
			}

			// singleton ->  'KLOPEN'  re  'KLCLOSE' .
			case singleton_10:
			{

	//NEAen auf Stack
	tmp.neaStr = semStack[semStackCnt - 1 - 3 + (2)].neaStr;
				break;
			}

			// singleton ->  'CHAR' .
			case singleton_11:
			{

	NEA_STR		*nea;
	int			*cclClass;

	//einen NEA erzeugen
	nea = getNewNEA();

	//eine Zeichenklasse anlegen
	cclClass = cclInit();

	//Zeichen hinzufügen
	cclAdd( cclClass, semStack[semStackCnt - 1 - 1 + (1)].character );

	//Zustands-Übergang erzeugen
	mkBranch( nea, cclClass, false );

	//NEAen auf Stack
	tmp.neaStr = nea;
				break;
			}

			// fullccl ->  'COPEN'  ccl  'CCLOSE' .
			case fullccl_0:
			{

	//Zeichenklasse übernehmen
	tmp.cclClass = semStack[semStackCnt - 1 - 3 + (2)].cclClass;
				break;
			}

			// fullccl ->  'COPEN'  'NEGATE'  ccl  'CCLOSE' .
			case fullccl_1:
			{

	//Zeichenklasse negieren
	tmp.cclClass = cclNegate( semStack[semStackCnt - 1 - 4 + (3)].cclClass );
				break;
			}

			// ccl ->  ccl  'CHAR'  'MINUS'  'CHAR' .
			case ccl_0:
			{

	char	upper, lower;

	//Grenzen OK?
	if( semStack[semStackCnt - 1 - 4 + (2)].character > semStack[semStackCnt - 1 - 4 + (4)].character )
	{
		//Fehler
		cerr << "sslex: line " << line << ": Wrong limits in character class!\n";

		//umdrehen
		lower = semStack[semStackCnt - 1 - 4 + (4)].character;
		upper = semStack[semStackCnt - 1 - 4 + (2)].character;

		//Fehler
		err++;
	}

	else
	{
		//Limits OK
		upper = semStack[semStackCnt - 1 - 4 + (4)].character;
		lower = semStack[semStackCnt - 1 - 4 + (2)].character;
	}

	//einen Zeichenbereich erzeugen
	tmp.cclClass = cclAddRange( semStack[semStackCnt - 1 - 4 + (1)].cclClass, lower, upper );
				break;
			}

			// ccl ->  ccl  'CHAR' .
			case ccl_1:
			{

	//ein Zeichen zu einer Zeichenklasse hinzufügen
	tmp.cclClass = cclAdd( semStack[semStackCnt - 1 - 2 + (1)].cclClass, semStack[semStackCnt - 1 - 2 + (2)].character );
				break;
			}

			// ccl ->  ccl  ccl_expr .
			case ccl_2:
			{

	//übernehmen
	tmp.cclClass = cclAdd( semStack[semStackCnt - 1 - 2 + (1)].cclClass, semStack[semStackCnt - 1 - 2 + (2)].cclClass );

	//zweite Zeichenklasse freigeben
	delete[] ( semStack[semStackCnt - 1 - 2 + (2)].cclClass );
				break;
			}

			// ccl ->  'EPSILON' .
			case ccl_3:
			{

	//Zeichenklasse anfordern
	tmp.cclClass = cclInit();
				break;
			}

			// ccl_expr ->  'CCE_ALNUM' .
			case ccl_expr_0:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isalnum
	cclClass( cclStr, CCE_ALNUM );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_ALPHA' .
			case ccl_expr_1:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isalpha
	cclClass( cclStr, CCE_ALPHA );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_BLANK' .
			case ccl_expr_2:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isblank
	cclClass( cclStr, CCE_BLANK );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_CNTRL' .
			case ccl_expr_3:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//iscntrl
	cclClass( cclStr, CCE_CNTRL );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_DIGIT' .
			case ccl_expr_4:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isdigit
	cclClass( cclStr, CCE_DIGIT );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_GRAPH' .
			case ccl_expr_5:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isgraph
	cclClass( cclStr, CCE_GRAPH );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_LOWER' .
			case ccl_expr_6:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//islower
	cclClass( cclStr, CCE_LOWER );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_PRINT' .
			case ccl_expr_7:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isprint
	cclClass( cclStr, CCE_PRINT );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_PUNCT' .
			case ccl_expr_8:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//ispunct
	cclClass( cclStr, CCE_PUNCT );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_SPACE' .
			case ccl_expr_9:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isspace
	cclClass( cclStr, CCE_SPACE );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_UPPER' .
			case ccl_expr_10:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isupper
	cclClass( cclStr, CCE_UPPER );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// ccl_expr ->  'CCE_XDIGIT' .
			case ccl_expr_11:
			{

	int	*cclStr;

	//eine Zeichenklasse erzeugen
	cclStr = cclInit();

	//isxdigit
	cclClass( cclStr, CCE_XDIGIT );

	//übergeben
	tmp.cclClass = cclStr;
				break;
			}

			// string ->  string  'CHAR' .
			case string_0:
			{

	//zwei NEAen verlinken
	NEA_STR		*nea;
	int			*cclClass;

	//einen NEA erzeugen
	nea = getNewNEA();

	//eine Zeichenklasse anlegen
	cclClass = cclInit();

	//Zeichen hinzufügen
	cclAdd( cclClass, semStack[semStackCnt - 1 - 2 + (2)].character );

	//Zustands-Übergang erzeugen
	mkBranch( nea, cclClass, false );

	//beide NEAen verknüpfen
	tmp.neaStr = mkLink( semStack[semStackCnt - 1 - 2 + (1)].neaStr, nea );
				break;
			}

			// string ->  'EPSILON' .
			case string_1:
			{

	//einen NEA erzeugen
	tmp.neaStr = getNewNEA();
				break;
			}

//			default:
				//error
//				cerr << "ssLexClass::doSemAct: Unknown Alternative " << tab->value << "!\n";
		}

		//correct stack-pointer
		semStackCnt -= n->elem;

		//push last value on stack
		semStack[semStackCnt++] = tmp;
	}
}


void ssLexClass::deleteAction( NEA_STR *nea )
{
	//den Speicher der Aktionen eines NEA freigeben
	int	i;

	//gibt es überhaupt welche?
	if( nea->actionAnz )
	{
		//Alle Einträge
		for( i = 0; i < nea->actionAnz; i++ )
			//Speicher freigeben
			delete[] ( nea->action[i] );

		//Speicher freigeben
		delete[] ( nea->action );

		//initialisieren
		nea->action = 0L;
		nea->actionAnz = 0;
	}
}


NEA_STR *ssLexClass::getNewNEA( void )
{
	//einen neuen NEA anfordern
	NEA_STR	*nea;
	ulong	state;

	//Speicher anfordern
	nea = new( NEA_STR );

	//initialisieren
	nea->regText = 0L;
	nea->action = 0L;
	nea->laState = false;
	nea->eof = false;
	nea->begLine = false;
	nea->line = 0;

	//mit einen epsilon-Zustand initialisieren
	state = getNewState( nea );

	//ist erster Zustand dieses NEA
	nea->startState = state;
	nea->endState = state;

	//Zustand ist Finit-Zustand
	setState( nea, state, MARK_AS_FINIT );

	//zurückliefern
	return( nea );
}


ulong ssLexClass::getNewState( NEA_STR *nea )
{
	//einen neuen Zustand anfordern
	STATE_STR	**tmp, *s;
	ulong		index;

	//genug Speicher anfordern
	tmp = new( STATE_STR *[stateStrCnt + 1] );

	//kopieren
	memcpy( tmp, stateStr, sizeof( STATE_STR * ) * stateStrCnt );

	//alten Speicherbereich freigeben
	if( stateStr )
		delete[] ( stateStr );

	//neue Adresse
	stateStr = tmp;

	//Speicher für die eigentliche STATE_STR anfordern
	s = new( STATE_STR );

	//Zeiger
	stateStr[stateStrCnt] = s;

	//Index merken
	index = stateStrCnt++;

	//Index merken
	s->state = index;

	//initialisieren
	s->braStrCnt = 0;
	s->braStr = 0L;
	s->eps = false;
	s->finit = false;
	s->la = false;
	s->isUseful = false;

	//den zugehörigen NEA eintragen
	s->nea = nea;

	//Index in stateStr zurückliefern
	return( index );
}


int *ssLexClass::cclInit( void )
{
	//neue Zeichenklasse anfordern
	int	*tmp;

	//Speicher für Zeichenklasse
	tmp = new( int[cclWidth] );

	//initialisieren
	memset( tmp, 0, sizeof( int ) * cclWidth );

	//zurückliefern
	return( tmp );
}


int *ssLexClass::cclAny( void )
{
	//eine Zeichenklasse gem. . (any-char) erzeugen
	int		*tmp;

	//Zeichenklasse initialisieren
	tmp = cclInit();

	//alle bis auf \n
	cclAdd( tmp, '\n' );

	//negieren
	cclNegate( tmp );

	//zurückliefern
	return( tmp );
}


int *ssLexClass::cclAddRange( int *cclStr, uchar from, uchar to )
{
	//einen Bereich wie [a-z] eintragen
	uchar	i;

	//alle Zeichen eintragen
	for( i = from; i <= to; i++ )
		//hinzufügen
		cclAdd( cclStr, i );

	//zurückliefern
	return( cclStr );
}


int *ssLexClass::cclAdd( int *cclStr, uchar c )
{
	//ein Zeichen zu einer Zeichenklasse hinzufügen

	//Zeichen zu groß?
	if( ( c > 127 ) && ( cclWidth == _7BIT ) )
		//Fehlermeldung
		cerr << "ssLexClass::cclAdd: Line " << line << ": Character " << c << " needs an 8 bit scanner!\n";

	else
		//eintragen
		cclStr[c] = 1;

	//zurückliefern
	return( cclStr );
}


int *ssLexClass::cclAdd( int *cclStr1, int *cclStr2 )
{
	//eine Zeichenklasse an eine andere anfügen
	int	i;

	//alle Zeichen eintragen
	for( i = 0; i < cclWidth; i++ )
	{
		//Zeichen in zweiter Zeichenklasse gesetzt?
		if( cclStr2[i] )
			//ja, zur ersten hinzufügen
			cclAdd( cclStr1, i );
	}

	//zurückliefern
	return( cclStr1 );
}


int *ssLexClass::cclNegate( int *cclStr )
{
	//eine Zeichenklasse negieren
	int	i;

	//Alle Positionen
	for( i = 0; i < cclWidth; i++ )
		//gesetzt?
		cclStr[i] = !cclStr[i];

	//zurückliefern
	return( cclStr );
}


int *ssLexClass::cclCopy( int *cclClass )
{
	//eine Zeichenklasse kopieren
	int	*tmp;

	//ist überhuapt etwas zu kopieren?
	if( cclClass )
	{
		//Speicher für Zeichenklasse
		tmp = new( int[cclWidth] );

		//kopieren
		memcpy( tmp, cclClass, sizeof( int ) * cclWidth );
	}

	else
		//nein
		tmp = 0L;

	//zurückliefern
	return( tmp );
}


int *ssLexClass::cclClass( int *cclStr, int type )
{
	//eine vordefinierte Zeichenklasse installieren
	int ( *isArr[12] )( int ) = { isgraph, isupper, isxdigit, isdigit, isalpha, isalnum, ispunct, isprint, isspace, islower, isblank, iscntrl };
	int	isIndex, i;

	//Welche vordef. Zeichenklasse?
	switch( type )
	{
		case CCE_GRAPH:
		{
			//isgrapgh
			isIndex = 0;
			break;
		}

		case CCE_UPPER:
		{
			//isupper
			isIndex = 1;
			break;
		}

		case CCE_XDIGIT:
		{
			//isxdigit
			isIndex = 2;
			break;
		}

		case CCE_DIGIT:
		{
			//isdigit
			isIndex = 3;
			break;
		}

		case CCE_ALPHA:
		{
			//isalpha
			isIndex = 4;
			break;
		}

		case CCE_ALNUM:
		{
			//isalnum
			isIndex = 5;
			break;
		}

		case CCE_PUNCT:
		{
			//ispunkt
			isIndex = 6;
			break;
		}

		case CCE_PRINT:
		{
			//isprint
			isIndex = 7;
			break;
		}

		case CCE_SPACE:
		{
			//isspace
			isIndex = 8;
			break;
		}

		case CCE_LOWER:
		{
			//islower
			isIndex = 9;
			break;
		}

		case CCE_BLANK:
		{
			//isblank
			isIndex = 10;
			break;
		}

		case CCE_CNTRL:
		{
			//iscntrl
			isIndex = 11;
			break;
		}

		default:
		{
			//unbekannte Zeichenklasse
//			cerr << "sslex: line " << line << ": Illegal character class!\n";
			cerr << "sslex: Illegal character!\n";

			//Fehler
//			err++;
		}
	}

	//Zeichenklasse erzeugen
	for( i = 0; i < cclWidth; i++ )
	{
		//Zeichen eintragen?
		if( isascii( i ) && isArr[isIndex]( i ) )
			//Ja
			cclStr[i] = 1;
	}

	//zurückliefern
	return( cclStr );
}


void ssLexClass::mkBranch( ulong from, ulong to, int *cclStr, bool eps )
{
	//einen Zustandsübergang mit cclStr erzeugen
	BRA_STR		**braStr, *bra;
	STATE_STR	*s1, *s2;

	//Zeiger holen
	s1 = stateStr[from];
	s2 = stateStr[to];

	//genug Speicher anfordern
	braStr = new( BRA_STR *[s1->braStrCnt + 1] );

	//kopieren
	memcpy( braStr, s1->braStr, sizeof( BRA_STR * ) * s1->braStrCnt );

	//alten Speicherbereich freigeben
	if( s1->braStr )
		delete[] ( s1->braStr );

	//neue Adresse
	s1->braStr = braStr;

	//Speicher für die eigentliche BRA_STR anfordern
	bra = new( BRA_STR );

	//Zeiger
	s1->braStr[s1->braStrCnt++] = bra;



	//nun bra initialisieren
	if( cclStr )
		//Zeichenklasse eintragen
		bra->cclClass = cclStr;

	else
		//keine Zeichen-Übergänge
		bra->cclClass = 0L;

	//epsilon-Übergang?
	if( eps == true )
		//Ja, ein epsilon-Übergang von from nach to
		s1->eps = true;

	//übertragen
	bra->eps = eps;

	//Ziel-Zustand eintragen
	bra->bra = to;
}


void ssLexClass::mkBranch( NEA_STR *nea, int *cclStr, bool eps )
{
	//einen Zustand an einen NEA anhängen
	STATE_STR	*s1, *s2;
	ulong		index;

	//Zustand erzeugen
	index = getNewState( nea );

	//Zeiger holen
	s1 = stateStr[nea->endState];
	s2 = stateStr[index];

	//Zustandsübergang erzeugen
	mkBranch( nea->endState, index, cclStr, eps );

	//ist kein Finit-Zustand mehr
	setState( nea, nea->endState, MARK_AS_NORMAL );

	//Zustand index ist neuer End-Zustand des NEA
	nea->endState = index;

	//ist ein Finit-Zustand
	setState( nea, index, MARK_AS_FINIT );
}


NEA_STR *ssLexClass::mkor( NEA_STR *nea1, NEA_STR *nea2 )
{
	//zwei NEAen verodern
	ulong		startIndex, endIndex;

	//neuen Start-Zustand anfordern
	startIndex = getNewState( nea1 );

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea1 );

	//eps-Übergang von startIndex zu den beiden Start-Zuständen des beiden NEAen
	mkBranch( startIndex, nea1->startState, 0L, true );
	mkBranch( startIndex, nea2->startState, 0L, true );

	//eps-Übergang von den End-Zuständen beider NEAen zum neuen End-Zustand
	mkBranch( nea1->endState, endIndex, 0L, true );
	mkBranch( nea2->endState, endIndex, 0L, true );


	//endIndex ist neuer End-Zustand des veroderten NEA
	setState( nea1, endIndex, MARK_AS_FINIT );

	//alte Finit-Zustände sind keine mehr
	setState( nea1, nea1->endState, MARK_AS_NORMAL );
	setState( nea1, nea2->endState, MARK_AS_NORMAL );

	//startIndex ist neuer Start-Zustand des veroderten NEA
	nea1->startState = startIndex;

	//neuen End-Zustand setzen
	nea1->endState = endIndex;

	//ist der zweite NEA ein NEA mit Lookahead?
	if( nea2->laState == true )
		//Ja, so auch der neue
		nea1->laState = true;

	//zweite NEA-Struktur freigeben
	delete( nea2 );

	//veroderten NEA zurückliefern
	return( nea1 );
}


NEA_STR *ssLexClass::mkLink( NEA_STR *nea1, NEA_STR *nea2 )
{
	//zwei NEAen verketten
	STATE_STR	*indexStr;
	BRA_STR		*bra;
	long		*stack, *marked, stackPos = 0;
	long		index, neaDest;
	int			i;

	//eps-Übergang von End-Zustand des ersten NEA zum Start-Zustand des zweiten
	mkBranch( nea1->endState, nea2->startState, 0L, true );

	//alter Finit-Zustand des ersten NEA ist keiner mehr
	setState( nea1, nea1->endState, MARK_AS_NORMAL );

	//Finit-Zustand des zweiten NEA setzen, damit NEA_STR übergeben wird
	setState( nea1, nea2->endState, MARK_AS_FINIT );

	//neuen End-Zustand des NEA eintragen
	nea1->endState = nea2->endState;

	//ist der zweite NEA ein NEA mit Lookahead?
	if( nea2->laState == true )
		//Ja, so auch der neue
		nea1->laState = true;

	//zweite NEA-Struktur freigeben
	delete( nea2 );


	//Nun an alle NEA-Zustände, insbesondere an die von nea2, den Zeiger auf nea1 vererben


	//Speicher für den Zustands-Stack holen
	stack = new( long[stateStrCnt] );

	//Speicher um die bereits bearbeiteten Zustände zu markieren
	marked = new( long[stateStrCnt] );

	//initialisieren
	memset( marked, 0, sizeof( ulong ) * stateStrCnt );

	//diesen Zustand auf den Stack schieben
	stack[stackPos++] = nea1->startState;

	while( stackPos )
	{
		//Zustand vom Stack holen
		index = stack[--stackPos];

		//bereits markiert?
		if( !marked[index] )
		{
			//markieren
			marked[index]++;

			//Zeiger auf STATE_STR
			indexStr = stateStr[index];

			//nea eintragen
			indexStr->nea = nea1;

			//nun alle Zustandsübergänge des Zustands index
			for( i = 0; i < indexStr->braStrCnt; i++ )
			{
				//Zeiger auf BRA_STR
				bra = indexStr->braStr[i];

				//Ziel-Zustand
				neaDest = bra->bra;

				//Ziel-Zustand bereits markiert?
				if( !marked[neaDest] )
					//Nein, auf Stack
					stack[stackPos++] = neaDest;
			}
		}
	}

	//Speicher wieder freigeben
	delete[] ( stack );
	delete[] ( marked );


	//veroderten NEA zurückliefern
	return( nea1 );
}


NEA_STR *ssLexClass::mkClos( NEA_STR *nea )
{
	//einen NEA beliebig oft ausführbar machen
	ulong		startIndex, endIndex;

	//neuen Start-Zustand anfordern
	startIndex = getNewState( nea );

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea );

	//eps-Übergang von startIndex zum Start-Index des NEA
	mkBranch( startIndex, nea->startState, 0L, true );

	//eps-Übergang vom neuen Start-Zustand zum neuen End-Zustand
	mkBranch( startIndex, endIndex, 0L, true );

	//eps-Übergang vom alten End-Zustand zum neuen End-Zustand
	mkBranch( nea->endState, endIndex, 0L, true );

	//eps-Übergang vom alten End-Zustand zum alten Start-Zustand
	mkBranch( nea->endState, nea->startState, 0L, true );


	//ist ein Finit-Zustand
	setState( nea, endIndex, MARK_AS_FINIT );

	//alter Finit-Zustand ist keiner mehr
	setState( nea, nea->endState, MARK_AS_NORMAL );

	//neuen Start-Zustand setzen
	nea->startState = startIndex;

	//neuen End-Zustand setzen
	nea->endState = endIndex;

	//NEA zurückliefern
	return( nea );
}


NEA_STR *ssLexClass::mkPosClos( NEA_STR *nea )
{
	//einen NEA mind. einmal ausführbar machen
	ulong		startIndex, endIndex;

	//neuen Start-Zustand anfordern
	startIndex = getNewState( nea );

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea );

	//eps-Übergang von startIndex zum Start-Index des NEA
	mkBranch( startIndex, nea->startState, 0L, true );

	//eps-Übergang vom alten End-Zustand zum neuen End-Zustand
	mkBranch( nea->endState, endIndex, 0L, true );

	//eps-Übergang vom alten End-Zustand zum alten Start-Zustand
	mkBranch( nea->endState, nea->startState, 0L, true );


	//ist ein Finit-Zustand
	setState( nea, endIndex, MARK_AS_FINIT );

	//alter Finit-Zustand ist keiner mehr
	setState( nea, nea->endState, MARK_AS_NORMAL );

	//neuen Start-Zustand setzen
	nea->startState = startIndex;

	//neuen End-Zustand setzen
	nea->endState = endIndex;

	//NEA zurückliefern
	return( nea );
}


NEA_STR *ssLexClass::mkOpt( NEA_STR *nea )
{
	//einen NEA optional machen
	ulong		startIndex, endIndex;

	//neuen Start-Zustand anfordern
	startIndex = getNewState( nea );

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea );

	//eps-Übergang von startIndex zum Start-Index des NEA
	mkBranch( startIndex, nea->startState, 0L, true );

	//eps-Übergang vom neuen Start-Zustand zum neuen End-Zustand
	mkBranch( startIndex, endIndex, 0L, true );

	//eps-Übergang vom alten End-Zustand zum neuen End-Zustand
	mkBranch( nea->endState, endIndex, 0L, true );


	//ist ein Finit-Zustand
	setState( nea, endIndex, MARK_AS_FINIT );

	//alter Finit-Zustand ist keiner mehr
	setState( nea, nea->endState, MARK_AS_NORMAL );

	//neuen Start-Zustand setzen
	nea->startState = startIndex;

	//neuen End-Zustand setzen
	nea->endState = endIndex;

	//NEA zurückliefern
	return( nea );
}


NEA_STR *ssLexClass::mkRepeat( NEA_STR *nea, int value )
{
	//einen NEA genau value Mal ausführen
	NEA_STR		*cpyNEA, *base = mkCopy( nea );
	int			i;

	//mind. einmal?
	if( value > 1 )
	{
		//value mal
		for( i = 0; i < value - 1; i++ )
		{
			//NEA kopieren
			cpyNEA = mkCopy( base );

			//NEAen verbinden
			nea = mkLink( nea, cpyNEA );
		}
	}

	//Speicher freigeben
	mkDelete( base );

	//NEA zurückliefern
	return( nea );
}


NEA_STR *ssLexClass::mkRepeat( NEA_STR *nea, int min, int max )
{
	//einen NEA mindestens min-mal ausführen, maximal max-mal
	NEA_STR		*cpyNEA, *base = mkCopy( nea );
	ulong		endIndex, index;
	int			i;

	//neuen End-Zustand anfordern
	endIndex = getNewState( nea );

	//mind. einmal?
	if( max > min )
	{
		//min mal
		for( i = 1; i < max; i++ )
		{
			//NEA kopieren
			cpyNEA = mkCopy( base );

			//den End-Zustand merken
			index = nea->endState;

			//NEAen verbinden
			nea = mkLink( nea, cpyNEA );

			//i > min, d.h. optional?
			if( i >= min )
				//Ja
				mkBranch( index, endIndex, 0L, true );
		}

		//min=0, d.h. auch kein mal erlaubt?
		if( !min )
			//Ja, eps-Übergang vom Start-Zustand zum End-Zustand
			mkBranch( nea->startState, endIndex, 0L, true );

		//neuen End-Zustand
		mkBranch( nea->endState, endIndex, 0L, true );

		//alter Finit-Zustand ist keiner mehr
		setState( nea, nea->endState, MARK_AS_NORMAL );

		//neuen Finit-Zustand setzen
		setState( nea, endIndex, MARK_AS_FINIT );

		//neuen Finit-Zustand eintragen
		nea->endState = endIndex;
	}

	else if( max == _INFINITY )
	{
		//NEA min. min-mal, dann beliebig oft
		for( i = 1; i < min; i++ )
		{
			//NEA kopieren
			cpyNEA = mkCopy( base );

			//NEAen verbinden
			nea = mkLink( nea, cpyNEA );
		}

		//nun noch einen anfügen, diesen aber beliebig oft ausführbar machen
		cpyNEA = mkCopy( base );

		//beliebig oft ausführbar machen
		cpyNEA = mkClos( cpyNEA );

		//beide verbinden
		nea = mkLink( nea, cpyNEA );
	}

	//Speicher freigeben
	mkDelete( base );

	//NEA zurückliefern
	return( nea );
}


NEA_STR *ssLexClass::mkCopy( NEA_STR *nea )
{
	//eine Kopie eines NEA erzeugen
	STATE_STR	*indexStr, *toCopyStr;
	NEA_STR		*cpyNEA;
	BRA_STR		*bra;
	long		*stack, stackPos = 0;
	long		*transStates, index, toCopy, neaDest, dest;
	int			*cclClass, i;

	//neuen NEA anfordern
	cpyNEA = getNewNEA();

	//Speicher für den Zustands-Stack holen
	stack = new( long[stateStrCnt] );

	//in diesem Array steht die Nummer des Zustandes, den ein Zustand in nea hat, in cpyNEA
	transStates = new( long[stateStrCnt] );

	//initialisieren
	memset( transStates, -1, sizeof( long ) * stateStrCnt );

	//den Startzustand eintragen
	transStates[nea->startState] = cpyNEA->startState;

	//diesen Zustand auf den Stack schieben
	stack[stackPos++] = nea->startState;

	while( stackPos )
	{
		//Zustand vom Stack holen
		index = stack[--stackPos];

		//Gibt es diesen Zustand in cpyNEA schon?
		if( transStates[index] >= 0 )
			//Ja, holen
			toCopy = transStates[index];

		else
		{
			//Nein, erzeugen
			toCopy = getNewState( cpyNEA );

			//eintragen
			transStates[index] = toCopy;
		}

		//Zeiger auf STATE_STR
		indexStr = stateStr[index];
		toCopyStr = stateStr[toCopy];

		//nun alle Zustandsübergänge des Zustands index in cpyNEA erzeugen
		for( i = 0; i < indexStr->braStrCnt; i++ )
		{
			//Zeiger auf BRA_STR
			bra = indexStr->braStr[i];

			//Ziel-Zustand
			neaDest = bra->bra;

			//Ziel-Zustand erzeugen?
			if( transStates[neaDest] < 0 )
			{
				//Ja, erzeugen
				dest = getNewState( cpyNEA );

				//eintragen
				transStates[neaDest] = dest;

				//Zeichenklasse kopieren
				cclClass = cclCopy( bra->cclClass );

				//Zustandsübergang erzeugen
				mkBranch( toCopy, dest, cclClass, bra->eps );

				//Zustand auf dem Stack schieben
				stack[stackPos++] = neaDest;
			}
		}

		//alle anderen Dinge kopieren
		toCopyStr->eps = indexStr->eps;
		toCopyStr->finit = indexStr->finit;
		toCopyStr->la = indexStr->la;
	}

	//NEA-Infos kopieren
	cpyNEA->action = nea->action;
	cpyNEA->endState = transStates[nea->endState];
	cpyNEA->laState = nea->laState;
	cpyNEA->regText = nea->regText;
	cpyNEA->startState = transStates[nea->startState];

	//Speicher wieder freigeben
	delete[] ( stack );
	delete[] ( transStates );

	//NEA zurückliefern
	return( cpyNEA );
}


void ssLexClass::mkDelete( NEA_STR *nea )
{
	//einen NEa mitsamt seinen Zuständen löschen
	STATE_STR	*indexStr;
	BRA_STR		*bra;
	long		*stack, stackPos = 0;
	long		index, neaDest;
	int			i, *marked;

	//Speicher für den Zustands-Stack holen
	stack = new( long[stateStrCnt] );

	//in diesem Array stehen die Zustände, die bereits gelöscht wurden
	marked = new( int[stateStrCnt] );

	//initialisieren
	memset( marked, 0, sizeof( int ) * stateStrCnt );

	//diesen Zustand auf den Stack schieben
	stack[stackPos++] = nea->startState;

	while( stackPos )
	{
		//Zustand vom Stack holen
		index = stack[--stackPos];

		//markiert?
		if( !marked[index] )
		{
			//markieren
			marked[index]++;

			//Zeiger auf STATE_STR
			indexStr = stateStr[index];

			//nun alle Zustandsübergänge des Zustands index in nea löschen
			for( i = 0; i < indexStr->braStrCnt; i++ )
			{
				//Zeiger auf BRA_STR
				bra = indexStr->braStr[i];

				//Ziel-Zustand
				neaDest = bra->bra;

				//schon markiert?
				if( !marked[neaDest] )
					//nein, auf den Stack legen
					stack[stackPos++] = neaDest;

				//Zeichenklasse löschen
				if( bra->cclClass )
				{
					//Speicher freigeben
					delete[] ( bra->cclClass );

					//zurücksetzen
					bra->cclClass = 0L;
				}

				//Zustandsübergangs-Struktur löschen
				delete( bra );

				//zurücksetzen
				bra = 0L;
			}

			//Array mit den Zustandsübergangs-Strukturen löschen
			if( indexStr->braStr )
			{
				//Speicher freigeben
				delete[] ( indexStr->braStr );

				//zurücksetzen
				indexStr->braStr = 0L;
			}

			/*
				STATE-STR dieses Zustands nicht löschnen, da sonst alle Zustandsübergänge angepasst
				werden müssten.
			*/
			indexStr->nea = 0L;
		}
	}

	//Speicher wieder freigeben
	delete[] ( stack );
	delete[] ( marked );

	//NEA freigeben
	delete( nea );
}


void ssLexClass::setState( NEA_STR *nea, ulong state, int type )
{
	//einen Zustand setzen
	//MARK_AS_NORMAL: normaler Zustand
	//MARK_AS_FINIT: End-Zustand
	//MARK_AS_LA: Lookahead-Zustand
	STATE_STR	*s1;

	//Teuger
	s1 = stateStr[state];

	//Welcher ist es denn?
	switch( type )
	{
		case MARK_AS_NORMAL:
		{
			//normaler Zustand
			s1->finit = false;
			s1->la = false;
			s1->nea = nea;
			break;
		}

		case MARK_AS_FINIT:
		{
			//End-Zustand
			s1->finit = true;
			s1->la = false;
			s1->nea = nea;
			break;
		}

		case MARK_AS_LA:
		{
			//Lookahead-Zustand
			s1->finit = false;
			s1->la = true;
			s1->nea = nea;
			break;
		}

		default:
		{
			//Fehler
			cerr << "sslex: Illegal state in setState!\n";

			//Fehler
//			err++;
		}
	}
}


void ssLexClass::outputNEA( NEA_STR *nea )
{
	//einen NEA ausgeben
	STATE_STR	*indexStr;
	BRA_STR		*bra;
	long		*stack, stackPos = 0;
	long		*doub, index;
	int			i, j;

	//den entsprechenden reg. Ausdruck ausgeben?
	if( nea->regText )
		//Ja
		cout << "\n" << nea->regText << "\n";

	//Speicher für den Zustands-Stack holen
	stack = new( long[stateStrCnt] );

	//Zustände nicht doppelt ausgeben
	doub = new( long[stateStrCnt] );

	//initialisieren
	memset( doub, 0, sizeof( long ) * stateStrCnt );

	//Start-Zustand auf den Stack
	stack[stackPos++] = nea->startState;

	//Ist es ein Lookahead-NEA?
	if( nea->laState == true )
		//Ja
		cout << "Lookahead-NEA\n";

	while( stackPos )
	{
		//Zustand holen
		index = stack[--stackPos];

		//Zeiger auf STATE_STR
		indexStr = stateStr[index];

		//ausgeben?
		if( !doub[index] )
		{
			//Ja, Zustandsnummer ausgeben
			cout << "\n\nZustand: " << index;

			//Start-Zustand?
			if( index == nea->startState )
				//Ja
				cout << "\tStartzustand\n";

			else if( indexStr->la == true )
				//ist ein Lookahead-Zustand
				cout << "\tLookahead-Zustand\n";

			else if( index == nea->endState )
				//Ja
				cout << "\tEnd-Zustand\n";

			else
				//normaler Zustand
				cout << "\n";

			//Zuständsübergänge ausgeben
			for( i = 0; i < indexStr->braStrCnt; i++ )
			{
				//Zeiger auf BRA_STR
				bra = indexStr->braStr[i];

				//ausgeben
				cout << "Übergang zu " << bra->bra << "\n";

				//gibt es eine?
				if( bra->cclClass )
				{
					//Zeichenklasse ausgeben
					cout << "Zeichenklasse\n";

					//Zeichen ausgeben
					for( j = 0; j < cclWidth; j++ )
					{
						//Zeichen gesetzt?
						if( bra->cclClass[j] )
						{
							//druckbar?
							if( isprint( j ) )
								//Ja, normal ausgeben
								fprintf( stdout, "%c", j );

							else
							{
								//ist ein nicht-druckbares Zeichen
								cout << "," << j << ",";
							}
						}
					}

					//nächste Zeile
					cout << "\n";
				}

				//Epsilon?
				if( bra->eps )
					//Ja
					cout << "Epsilon\n";

				//aus Stack schieben
				stack[stackPos++] = bra->bra;
			}

			//markieren
			doub[index] = 1;
		}
	}

	//Speicher wieder freigeben
	delete[] ( stack );
	delete[] ( doub );
}


void ssLexClass::insertSC( char *name, bool type )
{
	//eine in %definition definierte SC eintragen
	SC_STR	*tmp, *sc;

	//schon definiert?
	if( lookupSC( name ) < 0 )
	{
		//Speicher anfordern
		tmp = new( SC_STR[scStrAnz + 1] );

		//alte Daten kopieren
		memcpy( tmp, scStr, sizeof( SC_STR ) * scStrAnz );

		//alten Speicherbereich freigeben
		if( scStr )
			delete[] ( scStr );

		//neue Adresse
		scStr = tmp;

		//Zeiger auf Struktur holen
		sc = &scStr[scStrAnz++];

		//initialisieren
		memset( sc, 0, sizeof( SC_STR ) );

		//eintragen
		sc->name = name;

		//Typ eintragen
		sc->type = type;
	}

	else
	{
		//Fehler
		cerr << "sslex: line " << line << ": SC " << name << " already definied!\n";

		//Fehler
		err++;
	}
}


int ssLexClass::lookupSC( char *name )
{
	//eine in %definition definierte SC suchen
	int	i;

	//Alle Einträge
	for( i = 0; i < scStrAnz; i++ )
	{
		//Namen gleich
		if( !strcmp( scStr[i].name, name ) )
			//Ja
			return( i );
	}

	//war nicht dabei
	return( -1 );
}


void ssLexClass::insertSC( SC_STR *scStr, NEA_STR *nea )
{
	//einen NEA an eine SC einfügen
	NEA_STR	**tmp;
	bool	eof = nea->eof;

	//eof-NEA?
	if( ( eof == false ) || ( ( eof == true ) && ( ( insertEOFSC( scStr ) ) == false ) ) )
	{
		//genug Speicher anfordern
		tmp = new( NEA_STR *[scStr->neaArrCnt + 1] );

		//kopieren
		memcpy( tmp, scStr->neaArr, sizeof( NEA_STR * ) * scStr->neaArrCnt );

		//alten Speicher freigeben
		if( scStr->neaArr )
			delete[] ( scStr->neaArr );

		//Adressen
		scStr->neaArr = tmp;

		//NEA_STR eintragen
		scStr->neaArr[scStr->neaArrCnt++] = nea;

		//ist es ein NEA, der nur am Zeilenanfang stehen darf?
		if( nea->begLine == true )
			//Ja
			scStr->nea2Anz++;

		else
			//Nein, darf überall stehen
			scStr->nea1Anz++;
	}
}


void ssLexClass::insertInclSC( NEA_STR *nea )
{
	//einen NEA an alle inclusive SC einfügen
	SC_STR	*sc;
	long	i;
	bool	eof = nea->eof;

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger
		sc = &scStr[i];

		//inclusive?
		if( sc->type == false )
		{
			//eof-NEA?
			if( ( eof == false ) || ( ( eof == true ) && ( ( insertEOFSC( sc ) ) == false ) ) )
				//genug Speicher anfordern
				insertSC( sc, nea );
		}
	}
}


bool ssLexClass::insertEOFSC( SC_STR *scStr )
{
	//prüfen, ob mit der SC bereits ein EOF-NEA verbunden ist
	bool	ex = false;
	int		j;

	//alle NEAen dieser SC
	for( j = 0; j < scStr->neaArrCnt; j++ )
	{
		//Hat diese SC schon einen NEA mit <<EOF>>-Regel?
		if( scStr->neaArr[j]->eof == true )
			//Ja
			ex = true;
	}

	//gab es bereits einen NEA mit <<EOF>>?
	if( ex == true )
	{
		//Fehler
		cerr << "sslex: line " << line << ": SC " << scStr->name << " already has an <<EOF>>-Rule!\n";

		//Fehler
		err++;
	}

	//Alles OK
	return( ex );
}


void ssLexClass::extendNEAStack( void )
{
	/*
		den NEA-Stack vergrößern, wird benötig, falls mehrere NEAen diegleiche
		Aktion ausführen sollen (erstes Zeichen |).
	*/
	NEA_STR	**tmp;

	//Speicher anfordern
	tmp = new( NEA_STR *[neaStackCnt + 100] );

	//kopieren
	memcpy( tmp, neaStack, sizeof( NEA_STR * ) * neaStackCnt );

	//Speicher freigeben
	if( neaStack )
		delete[] ( neaStack );

	//Adresse
	neaStack = tmp;

	//neue Größe
	neaStackMax += 100;
}


void ssLexClass::insertNEAStack( NEA_STR *nea )
{
	//einen NEA auf den NEA-Stack packen
	if( neaStackCnt >= neaStackMax )
		//vergrößern
		extendNEAStack();

	//nun auf dem Stack packen
	neaStack[neaStackCnt++] = nea;
}


ECLOS_STR *ssLexClass::createEClos( void )
{
	//eine ECLOS_STR-Struktur vorbereiten
	ECLOS_STR	*tmp;

	//Speicher anfordern
	tmp = new( ECLOS_STR );

	//initialisieren
	memset( tmp, 0, sizeof( ECLOS_STR ) );

	//zurückliefern
	return( tmp );
}


void ssLexClass::removeEClos( ECLOS_STR *eclosStr )
{
	//ECLOS_STR freigeben

	//Zustände?
	if( eclosStr->from )
		delete[] ( eclosStr->from );

	//Zustände?
	if( eclosStr->to )
		delete[] ( eclosStr->to );

	delete( eclosStr );
}


void ssLexClass::insertFromEClos( ECLOS_STR *eclosStr, ulong index )
{
	/*
		einen Zustand in eine ECLOS_STR-Struktur eintragen, von dem aus die Epsilon-Übergänge berechnet
		werden sollen.
	*/
	ulong	*tmp, i;

	//genügend Speicher anfordern
	tmp = new( ulong[eclosStr->fromCnt + 1] );

	//kopieren
	memcpy( tmp, eclosStr->from, sizeof( ulong ) * eclosStr->fromCnt );

	//alten Speicher löschen
	if( eclosStr->from )
		delete[] ( eclosStr->from );

	//Zeiger
	eclosStr->from = tmp;


	//sortiert eintragen
	for( i = 0; i < eclosStr->fromCnt; i++ )
	{
		//vergleichen
		if( eclosStr->from[i] > index )
		{
			//an dieser Stelle eintragen
			memmove( &eclosStr->from[i + 1], &eclosStr->from[i], sizeof( ulong ) * ( eclosStr->fromCnt - i ) );

			//eintragen
			eclosStr->from[i] = index;

			//Ende
			break;
		}
	}

	//an letzter Stelle eintragen?
	if( i == eclosStr->fromCnt )
		//Ja
		eclosStr->from[i] = index;

	//ein Zustand weiter
	eclosStr->fromCnt++;
}


void ssLexClass::insertFromEClos( ECLOS_STR *eclosStr, ulong *index, ulong anz )
{
	/*
		mehrere Zustände in eine ECLOS_STR-Struktur eintragen, von denen aus die Epsilon-Übergänge
		berechnet werden sollen.
	*/
	ulong	i;

	//Alle Zustände eintragen
	for( i = 0; i < anz; i++ )
		//eintragen
		insertFromEClos( eclosStr, index[i] );
}


void ssLexClass::insertToEClos( ECLOS_STR *eclosStr, ulong index )
{
	/*
		einen Zustand in eine ECLOS_STR-Struktur eintragen, der von from aus über einen Epsilon-Übergänge
		erreicht wird.
	*/
	ulong	*tmp, i;

	//genügend Speicher anfordern
	tmp = new( ulong[eclosStr->toCnt + 1] );

	//kopieren
	memcpy( tmp, eclosStr->to, sizeof( ulong ) * eclosStr->toCnt );

	//alten Speicher löschen
	if( eclosStr->to )
		delete[] ( eclosStr->to );

	//Zeiger
	eclosStr->to = tmp;


	//sortiert eintragen
	for( i = 0; i < eclosStr->toCnt; i++ )
	{
		//vergleichen
		if( eclosStr->to[i] > index )
		{
			//an dieser Stelle eintragen
			memmove( &eclosStr->to[i + 1], &eclosStr->to[i], sizeof( ulong ) * ( eclosStr->toCnt - i ) );

			//eintragen
			eclosStr->to[i] = index;

			//Ende
			break;
		}
	}

	//an letzter Stelle eintragen?
	if( i == eclosStr->toCnt )
		//Ja
		eclosStr->to[i] = index;

	//ein Zustand weiter
	eclosStr->toCnt++;
}


bool ssLexClass::findToEClos( ECLOS_STR *eclosStr, ulong index )
{
	//sucht einen Index in to
	ulong	i;
	bool	er = false;

	//Alle Zustände in to
	for( i = 0; i < eclosStr->toCnt; i++ )
	{
		//Zustände gleich?
		if( eclosStr->to[i] == index )
		{
			//Ja
			er = true;
			break;
		}
	}

	//zurückliefern
	return( er );
}


void ssLexClass::generateEClos( ECLOS_STR *eclosStr )
{
	/*
		Nun die Zustände bestimmen, die über Epsilon-Übergänge von from aus erreichbar sind und
		in to eintragen.
	*/
	STATE_STR	*sc;
	BRA_STR		*braStr;
	ulong		*stack, stackPos = 0, i, index;

	//Speicher für den Stack anfordern
	stack = new( ulong[stateStrCnt] );

	//zuerst alle Zustände from selbst auf den Stack legen
	for( i = 0; i < eclosStr->fromCnt; i++ )
	{
		//auf Stack
		stack[stackPos++] = eclosStr->from[i];

		//initialisieren
		insertToEClos( eclosStr, eclosStr->from[i] );
	}

	//solange Zustände auf dem Stack sind
	while( stackPos )
	{
		//einen Index vom Stack holen
		index = stack[--stackPos];

		//Zeiger auf STATE_STR
		sc = stateStr[index];

		//Alle Zustandsübergänge von index
		for( i = 0; i < sc->braStrCnt; i++ )
		{
			//Zeiger auf BRA_STR
			braStr = sc->braStr[i];

			//Ist es ein epsilon-Übergang?
			if( braStr->eps == true )
			{
				//Ja, schon enthalten?
				if( findToEClos( eclosStr, braStr->bra ) == false )
				{
					//Nein, eintragen
					insertToEClos( eclosStr, braStr->bra );

					//auf den Stack legen
					stack[stackPos++] = braStr->bra;
				}
			}
		}
	}

	//Stack freigeben
	delete[] ( stack );
}


MOVE_STR *ssLexClass::createMove( uchar c )
{
	//eine MOVE_STR-Struktur vorbereiten
	MOVE_STR	*tmp;

	//Speicher anfordern
	tmp = new( MOVE_STR );

	//initialisieren
	memset( tmp, 0, sizeof( MOVE_STR ) );

	//Zeichen eintragen
	tmp->jump = c;

	//zurückliefern
	return( tmp );
}


void ssLexClass::removeMove( MOVE_STR *moveStr )
{
	//Speicher für moevStr freigeben
	if( moveStr->to )
		delete[] ( moveStr->to );

	if( moveStr->from )
		delete[] ( moveStr->from );

	delete( moveStr );
}


void ssLexClass::insertFromMove( MOVE_STR *moveStr, ulong index )
{
	/*
		einen Zustand in eine MOVE_STR-Struktur eintragen, von dem aus die Übergänge berechnet
		werden sollen.
	*/
	ulong	*tmp, i;

	//genügend Speicher anfordern
	tmp = new( ulong[moveStr->fromCnt + 1] );

	//kopieren
	memcpy( tmp, moveStr->from, sizeof( ulong ) * moveStr->fromCnt );

	//alten Speicher löschen
	if( moveStr->from )
		delete[] ( moveStr->from );

	//Zeiger
	moveStr->from = tmp;


	//sortiert eintragen
	for( i = 0; i < moveStr->fromCnt; i++ )
	{
		//vergleichen
		if( moveStr->from[i] > index )
		{
			//an dieser Stelle eintragen
			memmove( &moveStr->from[i + 1], &moveStr->from[i], sizeof( ulong ) * ( moveStr->fromCnt - i ) );

			//eintragen
			moveStr->from[i] = index;

			//Ende
			break;
		}
	}

	//an letzter Stelle eintragen?
	if( i == moveStr->fromCnt )
		//Ja
		moveStr->from[i] = index;

	//ein Zustand weiter
	moveStr->fromCnt++;
}


void ssLexClass::insertFromMove( MOVE_STR *moveStr, ulong *index, ulong anz )
{
	/*
		mehrere Zustände in eine MOVE_STR-Struktur eintragen, von denen aus die Übergänge
		berechnet werden sollen.
	*/
	ulong	i;

	//Alle Zustände eintragen
	for( i = 0; i < anz; i++ )
		//eintragen
		insertFromMove( moveStr, index[i] );
}


void ssLexClass::insertToMove( MOVE_STR *moveStr, ulong index )
{
	/*
		einen Zustand in eine MOVE_STR-Struktur eintragen, der von from aus über einen Übergänge
		erreicht wird.
	*/
	ulong	*tmp, i;

	//genügend Speicher anfordern
	tmp = new( ulong[moveStr->toCnt + 1] );

	//kopieren
	memcpy( tmp, moveStr->to, sizeof( ulong ) * moveStr->toCnt );

	//alten Speicher löschen
	if( moveStr->to )
		delete[] ( moveStr->to );

	//Zeiger
	moveStr->to = tmp;


	//sortiert eintragen
	for( i = 0; i < moveStr->toCnt; i++ )
	{
		//vergleichen
		if( moveStr->to[i] > index )
		{
			//an dieser Stelle eintragen
			memmove( &moveStr->to[i + 1], &moveStr->to[i], sizeof( ulong ) * ( moveStr->toCnt - i ) );

			//eintragen
			moveStr->to[i] = index;

			//Ende
			break;
		}
	}

	//an letzter Stelle eintragen?
	if( i == moveStr->toCnt )
		//Ja
		moveStr->to[i] = index;

	//ein Zustand weiter
	moveStr->toCnt++;
}


bool ssLexClass::findToMove( MOVE_STR *moveStr, ulong index )
{
	//sucht einen Index in to
	ulong	i;
	bool	er = false;

	//Alle Zustände in to
	for( i = 0; i < moveStr->toCnt; i++ )
	{
		//Zustände gleich?
		if( moveStr->to[i] == index )
		{
			//Ja
			er = true;
			break;
		}
	}

	//zurückliefern
	return( er );
}


void ssLexClass::generateMove( MOVE_STR *moveStr )
{
	/*
		Nun die Zustände bestimmen, die über moveStr->jump-Übergänge von from aus erreichbar sind und
		in to eintragen.
	*/
	STATE_STR	*sc;
	BRA_STR		*braStr;
	ulong		i, j, index;
	uchar		c = moveStr->jump;

	//solange Zustände auf dem Stack sind
	for( j = 0; j < moveStr->fromCnt; j++ )
	{
		//einen Index vom Stack holen
		index = moveStr->from[j];

		//Zeiger auf STATE_STR
		sc = stateStr[index];

		//Alle Zustandsübergänge von index
		for( i = 0; i < sc->braStrCnt; i++ )
		{
			//Zeiger auf BRA_STR
			braStr = sc->braStr[i];

			//Ist es ein epsilon-Übergang?
			if( braStr->cclClass && braStr->cclClass[c] )
			{
				//Ja, schon enthalten?
				if( findToMove( moveStr, braStr->bra ) == false )
					//Nein, eintragen
					insertToMove( moveStr, braStr->bra );
			}
		}
	}
}


void ssLexClass::initDStatesStack( void )
{
	//DSTATES wird als Stack implementiert.

	//initalisieren
	dstatesStack = 0L;
	dstatesStackPos = 0;
}


void ssLexClass::removeDStatesStack( void )
{
	//DSTATES deinitialisieren
	ulong	i;

	//Speicher belegt?
	if( dstatesStack )
	{
		//Alle Elemente auf dem Stack entfernen
		for( i = 0; i < dstatesStackPos; i++ )
			//freigeben
			delete( dstatesStack[i] );

		//freigeben
		delete[] ( dstatesStack );
	}

	//keine Elemente auf dem Stack
	dstatesStackPos = 0;
	dstatesStack = 0L;
}


long ssLexClass::insertDStates( ulong *index, ulong anz )
{
	//eine neue NEA-Zustandsmenge in DSTATES eintragen, d.h. einen neuen DEA-Zustand erzeugen
	DSTATES		*tmp, **tmp2;
	long		deaIndex;

	//gibt es den DEA-Zustand schon?
	if( ( deaIndex = lookupDStates( index, anz ) ) < 0 )
	{
		//den DEA-Zustand erzeugen
		deaIndex = insertDEAState( index, anz, false );

		//ist noch nicht enthalten
		tmp2 = new( DSTATES *[dstatesStackPos + 1] );

		//schon auf dem Stack enthaltende Zeiger kopieren
		memcpy( tmp2, dstatesStack, sizeof( DSTATES * ) * dstatesStackPos );

		//alten Speicher freigeben
		if( dstatesStack )
			delete[] ( dstatesStack );

		//Zeiger
		dstatesStack = tmp2;

		//neue DSTATES-Struktur anlegen
		tmp = new( DSTATES );

		//unmarkiert
		tmp->marked = false;

		//Index des DEA-Zustandes
		tmp->deaIndex = deaIndex;

		//auf dem Stack
		dstatesStack[dstatesStackPos++] = tmp;
	}

	//DEA-Zustands-Index zurückliefern
	return( deaIndex );
}


ulong ssLexClass::insertDEAState( ulong *index, ulong anz, bool dummy )
{
	//einen neuen DEA-Zustand
	DEA_STATES	**tmp1, *tmp2;
	STATE_STR	*s;
	ulong		i;

	//genug Speicher
	tmp1 = new( DEA_STATES *[DEAStatesCnt + 1] );

	//kopieren
	memcpy( tmp1, DEAStates, sizeof( DEA_STATES * ) * DEAStatesCnt );

	//alten Speicher freigeben
	if( DEAStates )
		delete[] ( DEAStates );

	//Zeiger
	DEAStates = tmp1;

	//Speicher für eine DEA_STATES-Struktur
	tmp2 = new( DEA_STATES );

	//Speicher für die NEA-Zustände
	tmp2->neaIndex = new( ulong[anz] );

	//kopieren
	memcpy( tmp2->neaIndex, index, sizeof( ulong ) * anz );

	//Anzahl der NEA-Zustände
	tmp2->neaIndexCnt = anz;

	//Index dieses DEA-Zustandes
	tmp2->index = DEAStatesCnt;

	//kein NEA
	tmp2->finitNEA = 0L;
	tmp2->laNEA = 0L;

	//Default
	tmp2->la = false;
	tmp2->finit = false;

	//ist es ein toter Zustand, der für die Zustandsminimierung benötigt wird?
	if( dummy == true )
		//Ja
		tmp2->dummy = true;

	else
		//Nein
		tmp2->dummy = false;

	//prüfen, ob es ein Finit-Zustand ist
	for( i = 0; i < anz; i++ )
	{
		//Zeiger auf NEA-Zustand
		s = stateStr[index[i]];

		//Finit-Zustand?
		if( s->finit == true )
		{
			//Ja
			tmp2->finit = true;

			//NEA_STR eintragen?
			if( !tmp2->finitNEA )
				//Ja, immer nur den ersten!
				tmp2->finitNEA = s->nea;
		}

		//Lookahead-Zustand?
		if( s->la == true )
		{
			//Ja
			tmp2->la = true;

			//NEA_STR eintragen?
			if( !tmp2->laNEA )
				//Ja, immer nur den ersten!
				tmp2->laNEA = s->nea;
		}
	}

	//eintragen
	DEAStates[DEAStatesCnt] = tmp2;

	//Index des Zustands zurückliefern
	return( DEAStatesCnt++ );
}


long ssLexClass::lookupDStates( ulong *index, ulong anz )
{
	//eine Menge von NEA-Zuständen, d.h. einen DEA-Zustand suchen
	DEA_STATES	*dea;
	DSTATES		*d;
	ulong		i;

	//Alle bisherigen DEA-Zustände
	for( i = 0; i < dstatesStackPos; i++)
	{
		//Zeiger
		d = dstatesStack[i];

		//Zeiger auf DEA-Zustand
		dea = DEAStates[d->deaIndex];

		//Anzahl der Einträge gleich?
		if( anz == dea->neaIndexCnt )
		{
			//Ja, vergleichen
			if( !memcmp( index, dea->neaIndex, sizeof( ulong ) * anz ) )
				//Ja, den DEA-Zustand gibt es bereits
				return( d->deaIndex );
		}
	}

	//den DEA-Zustand gibt es noch nicht
	return( -1 );
}


long ssLexClass::getUnmarkedDStates( void )
{
	//einen unmarkierten DEA-Zustand holen
	DSTATES		*d;
	ulong		i;

	//Alle bisherigen DEA-Zustände
	for( i = 0; i < dstatesStackPos; i++)
	{
		//Zeiger
		d = dstatesStack[i];

		//unmarkiert?
		if( d->marked == false )
			//Ja
			return( i );
	}

	//es gibt keine unmarkierten DEA-Zustände mehr
	return( -1 );
}


void ssLexClass::markDStates( ulong index )
{
	//einen unmarkierten DEA-Zustand markieren
	DSTATES		*d = dstatesStack[index];

	//markieren
	d->marked = true;
}


void ssLexClass::insertDTran( SC_STR *sc, int type, long from, long to, uchar c )
{
	//einen Zustandsübergang in die DEA-Übergangstabelle eintragen
	DTRAN	**tmp1, *tmp2, **myDTran;
	ulong	i, *myDTranCnt, index;

	//NEA darf nur am Zeilenanfang stehen?
	if( type == BEGLINE_NEA )
	{
		//Ja
		myDTran = sc->DTran2;

		//Anzahl der bisherigen Zustände
		myDTranCnt = &sc->DTran2Cnt;

		//Index des Zustands in der Tabelle
		index = from - sc->begLineDEAIndex;
	}

	else
	{
		//NEA darf überall stehen
		myDTran = sc->DTran1;

		//Anzahl der bisherigen Zustände
		myDTranCnt = &sc->DTran1Cnt;

		//Index des Zustands in der Tabelle
		index = from - sc->DEAIndex;
	}



	//neue Zeile erzeugen?
	if( !myDTran || ( ( *myDTranCnt - 1 ) < index ) )
	{
		//genug Speicher für alle Zeilen
		tmp1 = new( DTRAN *[index + 1] );

		//initialisieren
		memset( tmp1, 0, sizeof( DTRAN * ) * ( index + 1 ) );

		//umkopieren
		memcpy( tmp1, myDTran, sizeof( DTRAN * ) * *myDTranCnt );

		//Speicher für alle leeren Zeilen anfordern
		for( i = 0; i < ( index + 1 ); i++ )
		{
			//leer?
			if( !tmp1[i] )
			{
				//Ja, Speicher anfordern
				tmp2 = new( DTRAN );

				//initialisieren
				memset( tmp2, 0, sizeof( DTRAN ) );

				//Speicher für die Übergänge
				tmp2->to = new( ulong[cclWidth] );
#warning	tmp2->to = new( ulong[cclWidth] );

				//löschen
				memset( tmp2->to, 0, sizeof( int ) * cclWidth );

				//DEA-Index
				tmp2->index = from;

				//eintragen
				tmp1[i] = tmp2;

				//zählen
				(*myDTranCnt)++;
			}
		}

		//alten Speicher freigeben
		if( myDTran )
			delete[] ( myDTran );

		//Adresse
		myDTran = tmp1;
	}

	//Übergang eintragen
	myDTran[index]->index = from;
	myDTran[index]->to[c] = to;

	//NEA darf nur am Zeilenanfang stehen?
	if( type == BEGLINE_NEA )
		//Ja
		sc->DTran2 = myDTran;

	else
		//NEA darf überall stehen
		sc->DTran1 = myDTran;
}


void ssLexClass::NEA2DEA( void )
{
	//die NEAen in DEAen wandeln
	DEA_STATES	*dea;
	ECLOS_STR	*eclosStr;
	MOVE_STR	*moveStr;
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		i, j, k;
	ulong		dDEAIndex;
	uchar		c;
	long		dstatesIndex, newDEAIndex;
	char		hexChar[10];

	//Meldung?
	if( argv_str->verbose == true )
		//Meldung
		cout << "sslex: Generating dea states...\n";

	//alle DEA-Zustände werden fortlaufend nummeriert
	DEAStatesCnt = 0;
	DEAStates = 0L;

	//die DEA-Übergangstabelle aller SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

#ifdef DEBUG
		//Debug-Meldung
		cout << "SC: " << sc->name << "\n";
#endif

		//gibt es überhaupt NEAen, die überall stehen dürfen?
		if( sc->nea1Anz )
		{
			//den Start-Index des DEA merken, bei dem die NEA auch am Zeilenanfang stehen dürfen
			sc->DEAIndex = DEAStatesCnt;

			//WICHTIG: DSTATES initialisieren
			initDStatesStack();

			//e-clos für den ersten Zustand des DEA initialisieren
			eclosStr = createEClos();

			//der erste DEA-Zustand ist e-closure (Start-Zustände aller NEAen dieser SC)
			//keine <<EOF>>-NEAen!
			for( j = 0; j < sc->neaArrCnt; j++ )
			{
				//Zeiger auf NEA
				nea = sc->neaArr[j];

				//<<EOF>>-NEA?
				if( nea->eof == false )
				{
					//zuerst ohne NEAen, die nur am Zeilenanfang stehen dürfen
					if( nea->begLine == false )
					{
						//Zustand eintragen
						insertFromEClos( eclosStr, nea->startState );
#ifdef DEBUG
						//NEA ausgeben
						outputNEA( sc->neaArr[j] );
#endif
					}
				}
			}

			//e-clos generieren
			generateEClos( eclosStr );

			//diese Zustandsmenge in DSTATES eintragen
			insertDStates( eclosStr->to, eclosStr->toCnt );

			//Speicher für eclos freigeben
			removeEClos( eclosStr );

			//solange unmarkierte DEA-Zustände auf dem Stack sind
			while( ( dstatesIndex = getUnmarkedDStates() ) >= 0 )
			{
				//markieren
				markDStates( dstatesIndex );

				//Zeiger auf DSTATES
				dea = DEAStates[dstatesStack[dstatesIndex]->deaIndex];

				//alle Zeichen
				for( k = 0; k < cclWidth; k++ )
				{
					//für Debug-Zwecke
					c = k;

					//move( deaIndex, k ) bilden
					moveStr = createMove( k );

					//die NEA-Zustände des DEA-Zustandes deaIndex eintragen
					insertFromMove( moveStr, dea->neaIndex, dea->neaIndexCnt );

					//Übergänge generieren
					generateMove( moveStr );

					//nun e-closure( move( deaIndex, k ) ) bilden
					eclosStr = createEClos();

					//Zustände eintragen
					insertFromEClos( eclosStr, moveStr->to, moveStr->toCnt );

					//generieren
					generateEClos( eclosStr );

					//Wurden Zustände erzeugt?
					if( eclosStr->toCnt )
					{
						//diese neue NEA-Zustandsmenge ist ein DEA-Zustand, eintragen
						newDEAIndex = insertDStates( eclosStr->to, eclosStr->toCnt );
#ifdef DEBUG
						//Zeichen ausgeben
						outputChar( k, hexChar );

						//Debug-Meldung
						cout << "DTran[" << dea->index << "][" << hexChar << "] = " << newDEAIndex << "\n";
#endif
						//in DEA-Zustandsübergangstabelle eintragen
						insertDTran( sc, NORM_NEA, dea->index, newDEAIndex, k );
					}

					else
						//dieser Zustand hat für das Eingabesymbol k keinen Übergang
						//in DEA-Zustandsübergangstabelle eintragen
						insertDTran( sc, NORM_NEA, dea->index, -1, k );

					//Speicher für eclos freigeben
					removeEClos( eclosStr );

					//Speicher für moevStr freigeben
					removeMove( moveStr );
				}
			}

#ifdef DEBUG
			//die DEA-Zustände ausgeben
			outputDEAStates();
#endif
			//DSTATES deinitialisieren
			removeDStatesStack();
		}

		/*
			An diese Stelle wird auch gesprungen, wenn sc->nea1Anz = 0, d.h. wenn die SC keine
			NEAen hat, die überall stehen dürfen. In diesem Falle hat die SC für diese NEAen nur
			den "tote" Zustand. Dies wird bei der Zustandsminimierung in der Routine minDEA
			benötigt.
			Für die NEAen, die nur am Zeilenanfang stehen dürfen, ist dies nicht notwendig, da dann
			die NEAen aktiv sein werden, die überall stehen dürfen.
		*/

		//nun einen toten Zustand d erzeugen, s. Drache S. 172, für die Zustandsminimierung
		dDEAIndex = insertDEAState( 0L, 0, true );

		//hat die SC keine NEAen, die überall stehen dürfen?
		if( !sc->nea1Anz )
			//nein, toter Zustand d ist zugleich Startzustand der NEAen, die überall stehen dürfen
			sc->DEAIndex = dDEAIndex;

		//alle Zeichen
		for( k = 0; k < cclWidth; k++ )
			//in DEA-Zustandsübergangstabelle eintragen
			insertDTran( sc, NORM_NEA, dDEAIndex, dDEAIndex, k );




		//hat die SC NEAen, die ausschließlich am Zeilenanfang stehen dürfen?
		if( sc->nea1Anz || sc->nea2Anz )
		{
			//Nun die NEAen betrachten, die ausschließlich am Zeilenanfang stehen dürfen!

			//den Start-Index des DEA merken, bei dem die NEA auch am Zeilenanfang stehen dürfen
			sc->begLineDEAIndex = DEAStatesCnt;


			//WICHTIG: DSTATES initialisieren
			initDStatesStack();

			//e-clos für den ersten Zustand des DEA initialisieren
			eclosStr = createEClos();

			//der erste DEA-Zustand ist e-closure(Start-Zustände aller NEAen dieser SC)
			//keine <<EOF>>-NEAen!
			for( j = 0; j < sc->neaArrCnt; j++ )
			{
				//Zeiger auf NEA
				nea = sc->neaArr[j];

				//<<EOF>>-NEA?
				if( nea->eof == false )
				{
					//Zustand eintragen
					insertFromEClos( eclosStr, sc->neaArr[j]->startState );
#ifdef DEBUG
					//NEA ausgeben
					outputNEA( sc->neaArr[j] );
#endif
				}
			}

			//e-clos generieren
			generateEClos( eclosStr );

			//diese Zustandsmenge in DSTATES eintragen
			insertDStates( eclosStr->to, eclosStr->toCnt );

			//Speicher für eclos freigeben
			removeEClos( eclosStr );

			//solange unmarkierte DEA-Zustände auf dem Stack sind
			while( ( dstatesIndex = getUnmarkedDStates() ) >= 0 )
			{
				//markieren
				markDStates( dstatesIndex );

				//Zeiger auf DSTATES
				dea = DEAStates[dstatesStack[dstatesIndex]->deaIndex];

				//alle Zeichen
				for( k = 0; k < cclWidth; k++ )
				{
					//move( deaIndex, k ) bilden
					moveStr = createMove( k );

					//die NEA-Zustände des DEA-Zustandes deaIndex eintragen
					insertFromMove( moveStr, dea->neaIndex, dea->neaIndexCnt );

					//Übergänge generieren
					generateMove( moveStr );

					//nun e-closure( move( deaIndex, k ) ) bilden
					eclosStr = createEClos();

					//Zustände eintragen
					insertFromEClos( eclosStr, moveStr->to, moveStr->toCnt );

					//generieren
					generateEClos( eclosStr );

					//Wurden Zustände erzeugt?
					if( eclosStr->toCnt )
					{
						//diese neue NEA-Zustandsmenge ist ein DEA-Zustand, eintragen
						newDEAIndex = insertDStates( eclosStr->to, eclosStr->toCnt );
#ifdef DEBUG
						//Zeichen ausgeben
						outputChar( k, hexChar );

						//Debug-Meldung
						cout << "DTran[" << dea->index << "][" << hexChar << "] = " << newDEAIndex << "\n";
#endif
						//in DEA-Zustandsübergangstabelle eintragen
						insertDTran( sc, BEGLINE_NEA, dea->index, newDEAIndex, k );
					}

					else
						//dieser Zustand hat für das Eingabesymbol k keinen Übergang
						//in DEA-Zustandsübergangstabelle eintragen
						insertDTran( sc, BEGLINE_NEA, dea->index, -1, k );

					//Speicher für eclos freigeben
					removeEClos( eclosStr );

					//Speicher für moevStr freigeben
					removeMove( moveStr );
				}
			}

#ifdef DEBUG
			//die DEA-Zustände ausgeben
			outputDEAStates();
#endif
			//DSTATES deinitialisieren
			removeDStatesStack();
		}

		/*
			An diese Stelle wird auch gesprungen, wenn sc->nea1Anz = 0, d.h. wenn die SC keine
			NEAen hat, die überall stehen dürfen. In diesem Falle hat die SC für diese NEAen nur
			den "tote" Zustand. Dies wird bei der Zustandsminimierung in der Routine minDEA
			benötigt.
			Für die NEAen, die nur am Zeilenanfang stehen dürfen, ist dies nicht notwendig, da dann
			die NEAen aktiv sein werden, die überall stehen dürfen.
		*/

		//nun einen toten Zustand d erzeugen, s. Drache S. 172, für die Zustandsminimierung
		dDEAIndex = insertDEAState( 0L, 0, true );

		//hat die SC keine NEAen?
		if( !sc->nea1Anz && !sc->nea2Anz )
			//nein, toter Zustand d ist zugleich Startzustand der NEAen, die nur am Zeilenanfang
			//stehen dürfen
			sc->begLineDEAIndex = dDEAIndex;

		//alle Zeichen
		for( k = 0; k < cclWidth; k++ )
			//in DEA-Zustandsübergangstabelle eintragen
			insertDTran( sc, BEGLINE_NEA, dDEAIndex, dDEAIndex, k );
	}
}


void ssLexClass::findNoRules( void )
{
	/*	Finde Regeln, die nie ausgeführt werden. Hat ein DEA-Finit-Zustand mehrere NEA-Finit-Zustände, die
		zu verschiedenen NEAen gehören (und damit zu verschiedenen Aktionen), so wird der zuerst eingetragene
		bevorzugt.
	*/
	DEA_STATES	*dea;
	STATE_STR	*ffinits, *s;
	NEA_STR		*ffinitNea, *nea;
	SC_STR		*sc;
	ulong		*stack, stackPos = 0, state, ffinit, baseState, endIndex;
	ulong		*marked;
	ulong		i = 0, k, l, j;
	long		dest;

	//Meldung?
	if( argv_str->verbose == true )
		//Ja
		cout << "sslex: Searching never matching rules...\n";

	//Speicher für den Stack
	stack = new( ulong[DEAStatesCnt * cclWidth] );

	//Wenn ein Zustand geprüft wurde, wird er markiert, um Endelos-Schleifen zu vermeiden
	marked = new( ulong[DEAStatesCnt] );

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf Start-Condition
		sc = &scStr[i];

		//Hat die SC überhaupt NEAen?
		if( sc->neaArrCnt )
		{
			//Array für die Markierungen initialisieren
			memset( marked, 0, sizeof( ulong ) * DEAStatesCnt );

			//Hat die SC NEAen, die überall stehen dürfen?
			if( sc->DTran1Cnt )
			{
				//Start-Zustand der NEAen, die überall stehen dürfen, auf den Stack
				stack[stackPos++] = baseState = sc->DEAIndex;

				//solange Zustände auf dem Stack sind
				while( stackPos )
				{
					//Zustand holen
					state = stack[--stackPos];

					//schon markiert?
					if( !marked[state] )
					{
						//markieren
						marked[state]++;

						//prüfen, ob dieser DEA-Zustand mehrere NEA-Finit-Zustände besitzt
						dea = DEAStates[state];

						//hat er Finit-Zustände?
						if( dea->finit == true )
						{
							//Alle NEA-Zustände
							for( j = 0, ffinit = 0; j < dea->neaIndexCnt; j++ )
							{
								//Zeiger auf STATE_STR
								s = stateStr[dea->neaIndex[j]];

								//ist es ein NEA-Finit-Zustand?
								if( s->finit == true )
								{
									//der erste Finit-Zustand?
									if( !ffinit )
									{
										//Ja, merken
										ffinit = 1;

										//Regel wird ausgeführt
										s->isUseful = true;

										//STATE_STR merken
										ffinits = s;

										//die NEA-Strukur merken
										ffinitNea = s->nea;
									}

									else
									{
										//DEA-Zustand beinhaltet mehrere NEA-Finit-Zustände
										nea = s->nea;

										//Zeige Konflikte zwischen reg. Ausdrücken?
										if( argv_str->showConflicts == true )
											//Meldung
											cerr << "sslex: WARNING: Conflict between reg. Expession " << ffinitNea->regText << ", line " << ffinitNea->line << ", and reg. Expression " << nea->regText << ", line " << nea->line << "!\n";
									}
								}
							}
						}


						//Ziel-Zustände auf dem Stack
						for( k = 0; k < cclWidth; k++ )
						{
							//Zustand holen
							dest = sc->DTran1[state - baseState]->to[k];

							//Hat dieser DEA-Zustand einen Übergang für k?
							if( dest >= 0 )
							{
								//Ja, Zustand bereits markiert?
								if( !marked[dest] )
								{
									//Nein, ist dieser Zustand bereits auf dem Stack?
									for( l = 0; l < stackPos; l++ )
									{
										//Zustand dest?
										if( stack[l] == dest )
											//Ja, nicht schieben
											break;
									}

									//Zustand schon auf dem Stack?
									if( l == stackPos )
										//Nein
										stack[stackPos++] = dest;
								}
							}
						}
					}
				}
			}


			//Nun die NEAen, die ausschließlich am Zeilenanfang stehen dürfen
			if( sc->DTran2Cnt )
			{
				//Array für die Markierungen initialisieren
//				memset( marked, 0, sizeof( ulong ) * DEAStatesCnt );

				//Start-Zustand der NEAen, die ausschließlich am Zeilenanfang stehen dürfen, auf den Stack
				stack[stackPos++] = baseState = sc->begLineDEAIndex;

				//solange Zustände auf dem Stack sind
				while( stackPos )
				{
					//Zustand holen
					state = stack[--stackPos];

					//schon markiert?
					if( !marked[state] )
					{
						//markieren
						marked[state]++;

						//prüfen, ob dieser DEA-Zustand mehrere NEA-Finit-Zustände besitzt
						dea = DEAStates[state];

						//hat er Finit-Zustände?
						if( dea->finit == true )
						{
							//Alle NEA-Zustände
							for( j = 0, ffinit = 0; j < dea->neaIndexCnt; j++ )
							{
								//Zeiger auf STATE_STR
								s = stateStr[dea->neaIndex[j]];

								//ist es ein NEA-Finit-Zustand?
								if( s->finit == true )
								{
									//der erste Finit-Zustand?
									if( !ffinit )
									{
										//Ja, merken
										ffinit = 1;

										//Regel wird ausgeführt
										s->isUseful = true;

										//STATE_STR merken
										ffinits = s;

										//die NEA-Strukur merken
										ffinitNea = s->nea;
									}

									else
									{
										//DEA-Zustand beinhaltet mehrere NEA-Finit-Zustände
										nea = s->nea;

										//Zeige Konflikte zwischen reg. Ausdrücken?
										if( argv_str->showConflicts == true )
											//Meldung
											cerr << "sslex: WARNING: Conflict between reg. Expession " << ffinitNea->regText << ", line " << ffinitNea->line << ", and reg. Expression " << nea->regText << ", line " << nea->line << "!\n";
									}
								}
							}
						}


						//Ziel-Zustände auf dem Stack
						for( k = 0; k < cclWidth; k++ )
						{
							//Zustand holen
							dest = sc->DTran2[state - baseState]->to[k];

							//Hat dieser DEA-Zustand einen Übergang für k?
							if( dest >= 0 )
							{
								//Ja, Zustand bereits markiert?
								if( !marked[dest] )
								{
									//Nein, ist dieser Zustand bereits auf dem Stack?
									for( l = 0; l < stackPos; l++ )
									{
										//Zustand dest?
										if( stack[l] == dest )
											//Ja, nicht schieben
											break;
									}

									//Zustand schon auf dem Stack?
									if( l == stackPos )
										//Nein
										stack[stackPos++] = dest;
								}
							}
						}
					}
				}
			}


			//den End-Zustand berechnen
			if( sc->begLineDEAIndex >= 0 )
				//Ja
				endIndex = sc->begLineDEAIndex + sc->DTran2Cnt - 1;

			else
				//hat keine NEAen, die ausschließlich am Zeilenanfang stehen müssen
				endIndex = sc->DEAIndex + sc->DTran1Cnt - 1;

			//nach nicht erreichbaren Zuständen suchen
			for( k = sc->DEAIndex; k <= endIndex; k++ )
			{
				//Zeiger auf DEA-Struktur
				dea = DEAStates[k];

				//unmarkierter Zustand?
				if( !marked[k] && ( dea->dummy == false ) )
					//Ja, Meldung
					cerr << "sslex: DEA-State " << k << " in start condition " << sc->name << " will never be reached!\n";
			}
		}
	}

	//Speicher freigeben
	delete[] ( stack );
	delete[] ( marked );


	//prüfen, ob es Regeln gibt, die niemals ausgeführt werden
	for( i = 0; i < stateStrCnt; i++ )
	{
		//Zeiger auf NEA-Zustand
		s = stateStr[i];

		//Finit-Zustand?
		if( ( s->finit == true ) && ( s->isUseful == false ) && ( s->nea ) && ( s->nea->eof == false ) )
			//Regel wird nie ausgeführt
			cerr << "sslex: WARNING: line " << s->nea->line << ": Rule " << s->nea->regText << " will never be matched!\n";
	}
}


void ssLexClass::outputDEAStates( void )
{
	//die DEA-Zustände ausgeben mit den zugehörigen NEA-Zuständen
	DEA_STATES	*dea;
	DSTATES		*d;
	ulong		i, j;

	//die DEA-Zustände befinden sich in dstatesStack
	for( i = 0; i < dstatesStackPos; i++ )
	{
		//Zeiger auf DSTATES
		d = dstatesStack[i];

		//Zeiger auf DEA-Zustand
		dea = DEAStates[d->deaIndex];

		//ausgeben
		cout << "DEA(" << d->deaIndex << ") = { ";

		//Alle NEA-Zustände
		for( j = 0; j < dea->neaIndexCnt; j++ )
			cout << " " << dea->neaIndex[j] << " ";

		//abschließen
		cout << "}\n";
	}
}


void ssLexClass::outputCPPMinDEA( ofstream &file )
{
	/*
		Die Übergangstabelle ausgeben, mit Minimierung der DEA-Zustandsmenge. Jede Gruppe entspricht
		einem neuen DEA-Zustand (sofern sie nicht disabled ist).
	*/
	DEA_STATES	*dea;
	GROUP_STR	**grp, *tmp, *destGrp;
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		*transTable, *transState, baseDEAState = 0, index, state, dest;
	ulong		baseState, base1State, end1State, base2State, end2State;
	char		widthPuffer[10], *regText;
	int			i, j, k, l, width;


	//die Breite eines Zustandes bestimmen
	sprintf( widthPuffer, "%ld", numberOfGroups );
	width = strlen( widthPuffer );

	//Mindestbreite: 4
	if( width < 4 )
		width = 4;


	//Übersetzt Gruppen-Indices in DEA-Zustände
	transState = new( ulong[maxGroupIndex] );

	//Übersetzt die Gruppen-Indices in laufende Nummern
	transTable = new( ulong[maxGroupIndex] );

	//für die Erzeugung der Accept-Tabelle
	finitNEA = new( NEA_STR *[numberOfGroups] );

	//initialisieren
	memset( finitNEA, 0, sizeof( NEA_STR * ) * numberOfGroups );

	//für die Erzeugung der Lookahead-Tabelle
	laNEA = new( NEA_STR *[numberOfGroups] );

	//initialisieren
	memset( laNEA, 0, sizeof( NEA_STR * ) * numberOfGroups );


	//Header ausgeben
	file << "\n//Transition-Table\n";
	file << "long SSLEXScanner::ssLexTable[SSLEX_STATE][CCLWIDTH] = \n{\n";

	//alle Zeichen ausgeben
	file << "/*\n";

	//alle Zeichen ausgeben
	for( i = j = k = 0; i < cclWidth; i++, j++, k++ )
	{
		//Alle 32 Zeichen einen Zeilenwechsel
		if( k == 32 )
		{
			//Ja
			file << "\n";
			k = 0;
		}

		//Breite setzen
		file.width( width );

		//Zeichen schreiben
		outputChar( i, widthPuffer );

		//Zeichen ist druckbar
		file << widthPuffer;

		//letztes Element?
		if( j < 127 )
			//Komma ausgeben
			file << ",";
	}

	//abschließen
	file << "\n*/\n";



	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger
		sc = &scStr[i];


		//Anfangs- und Endzustand der NEAen, die überall stehen dürfen
		base1State = sc->DEAIndex;
		end1State = base1State + sc->DTran1Cnt - 1;

		//Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen dürfen
		base2State = sc->begLineDEAIndex;
		end2State = base2State + sc->DTran2Cnt - 1;


		//transTable initialisieren
		memset( transTable, 0, sizeof( ulong ) * maxGroupIndex );


		/*
			Die erste Gruppe ist der neue Startzustand der NEAen, die überall stehen dürfen.
			Die zweite Gruppe ist der neue Startzustand der NEAen, die nur am Zeilenanfang stehen dürfen.
		*/

		//Zeiger auf Gruppen-Strukturen
		grp = sc->grp;

		//Start-Zustand merken
		baseState = baseDEAState;


		//die neuen DEA-Zustände in die SC eintragen
		sc->firstStart = baseState;
		sc->secondStart = baseState + 1;


		//transTable aufbereiten
		for( j = 0; j < sc->grpCnt; j++ )
		{
			//Zeiger auf Gruppe
			tmp = grp[j];

			//laufende Nummer
			transTable[tmp->index] = j;

			//Gruppe valid?
			if( tmp->valid == true )
				//Da jede Gruppe einer Menge von äquivalenten DEA-Zuständen entspricht, wird jeder
				//Gruppe ein neuer "DEA-Zustand" zugewiesen.
				transState[tmp->index] = baseDEAState++;
		}

		//SC ausgeben
		file << "\n//Startcondition: " << sc->name << "\n";

		//Alle Gruppen
		for( l = 0; l < sc->grpCnt; l++ )
		{
			//ist die Gruppe disabled?
			if( grp[l]->valid == true )
			{
				//Nein, aus der Gruppe einen repräsentativen Zustand nehmen
				index = grp[l]->DEAIndex[0];

				//Zeiger auf DEA-Struktur
				dea = DEAStates[index];

				//aktueller Zustand
				state = transState[grp[l]->index];

				//state darf nicht >= max sein
				assert( state < numberOfGroups );

				//ist dieser Zustand ein akzeptierender Zustand?
				if( dea->finit == true )
					//Ja, Zeiger auf NEA merken
					finitNEA[state] = dea->finitNEA;

				//ist dieser Zustand ein Lookahead-Zustand?
				if( dea->la == true )
					//Ja, markieren
					laNEA[state] = dea->laNEA;

				//aktuellen Zustand ausgeben
				file << "/* " << state << " */\n{\n";

				//Alle Zeichen
				for( j = k = 0; j < cclWidth; j++, k++ )
				{
					//Alle 32 Zeichen einen Zeilenwechsel
					if( k == 32 )
					{
						//Ja
						file << "\n";
						k = 0;
					}

					//ausgeben
					file.width( width );

					//Index des Zielzustands
					if( index <= end1State )
						dest = sc->DTran1[index - base1State]->to[j];

					else
						dest = sc->DTran2[index - base2State]->to[j];

					//DEA-Struktur des Ziel-Zustands
					dea = DEAStates[dest];

					//Gruppe des Zielzustands
					destGrp = grp[transTable[dea->groupIndex]];

					//ist die Gruppe valid?
					if( ( destGrp->valid == true ) && ( dea->dummy == false ) )
						//ausgeben
						file << transState[destGrp->index];

					else
						//kein Übergang
						file << "-1";

					//letztes Element?
					if( j < ( cclWidth - 1 ) )
						//Komma ausgeben
						file << ",";
				}

				//letztes Element?
				if( state < ( numberOfGroups - 1 ) )
					//Komma ausgeben
					file << "\n},\n";

				else
					//Ohne Komma ausgeben
					file << "\n}\n";
			}
		}
	}


	//abschließen
	file << "\n};\n";

	//Nun das Array für die Accept-Zustände erzeugen
	file << "\n//Accept-Array\n";
	file << "ulong SSLEXScanner::ssLexAccept[SSLEX_STATE] = \n{\n";

	//Alle DEA-Zustände
	for( i = 0; i < numberOfGroups; i++ )
	{
		//Zustand ausgeben
		file << "/* " << i << " */\n";

		//Zeiger auf den entsprechenden NEA
		nea = finitNEA[i];

		//Finit-Zustand?
		if( nea )
		{
			//Ja, reg. Text des zugehörigen NEA ausgeben

			//reg. Ausdruck in Textform anpassen
			regText = toString( nea->regText );

			//ausgeben
			file << "\n//Line " << nea->line << ": " << regText << "\n";
			file << i;

			//Speicher freigeben
			delete[] ( regText );
		}

		else
			//nein
			file << "0";

		//letzter Zustand?
		if( i < ( numberOfGroups - 1 ) )
			//Nein, Komma
			file << ",\n";
	}

	//abschliessen
	file << "\n};\n\n";


	//Gibt es Lookahead-NEAs?
	if( laUsed == true )
	{
		//Nun das Array für die Lookahead-Zustände erzeugen
		file << "\n//Lookahead-Array\n";
		file << "ulong SSLEXScanner::ssLexLA[SSLEX_STATE] = \n{\n";

		//Alle DEA-Zustände
		for( i = 0; i < numberOfGroups; i++ )
		{
			//Zustand ausgeben
			file << "/* " << i << " */\n";

			//Zeiger auf den entsprechenden NEA
			nea = laNEA[i];

			//Lookahead-Zustand?
			if( nea )
			{
				//reg. Ausdruck in Textform anpassen
				regText = toString( nea->regText );

				//Ja, reg. Text des zugehörigen NEA ausgeben
				file << "\n//Line " << nea->line << ": " << regText << "\n";
				file << "1";

				//Speicher freigeben
				delete[] ( regText );
			}

			else
				//nein
				file << "0";

			//letzter Zustand?
			if( i < ( numberOfGroups - 1 ) )
				//Nein, Komma
				file << ",\n";
		}

		//abschliessen
		file << "\n};\n\n";
	}


	//Speicher freigeben
	delete[] ( transTable );
	delete[] ( transState );
}


void ssLexClass::outputCPPDebug( ofstream &file )
{
	//die Debug-Strukturen ausgeben
	DEA_STATES	*dea;
	STATE_STR	*s;
	GROUP_STR	**grp;
	DEBUG_STR	*debugStr, *d;
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		k, l, index, anzNEA = 0, cnt, DEACnt;
	ulong		*marked, *anzRegExp;
	long		i, j;
	char		*regText;

	//Debug-Makro ausgeben
	file << "\n#ifdef SSLEX_DEBUG\n";

	//initialisieren
	debugStrPos = 0;

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Anzahl der NEAen dieser SC
		anzNEA += sc->neaArrCnt;
	}

	//Speicher für die DEBUG_STR anfordern
	debugStr = new( DEBUG_STR[anzNEA] );

	//Nun die DEBUG_STR füllen
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Alle NEAen
		for( j = 0; j < sc->neaArrCnt; j++ )
		{
			//Zeiger auf NEA
			nea = sc->neaArr[j];

			//ist die NEA-Struktur bereits eingetragen?
			for( k = 0; k < debugStrPos; k++ )
			{
				//schon da?
				if( debugStr[k].nea == nea )
					//Ja
					break;
			}

			//war sie schon eingetragen?
			if( k ==debugStrPos )
			{
				//nein, eintragen
				debugStr[debugStrPos].index = debugStrPos;
				debugStr[debugStrPos++].nea = nea;
			}
		}
	}


	//die Debug-Struktur ausgeben
	file << "\n//Structure with regular expressions in text form\n";
	file << "char *SSLEXScanner::regText[regTextSize] = {\n";

	//Alle Einträge
	for( i = 0; i < debugStrPos; i++ )
	{
		//Zeiger
		d = &debugStr[i];

		//reg. Ausdruck in Textform anpassen
		regText = toString( d->nea->regText );

		//ausgeben
		file << "\"" << regText << "\"";

		//letzter Eintrag?
		if( i < ( debugStrPos - 1 ) )
			//nein
			file << ",";

		//ausgeben
		file << "\t// " << d->nea->regText << ", line " << d->nea->line << "\n";

		//Speicher freigeben
		delete[] ( regText );
	}

	//abschließen
	file << "};\n\n";



	//markierte Indices nicht ausgeben
	marked = new( ulong[debugStrPos] );

	//Anzahl der assoziierten regulären Ausdrücke eines Zustands merken
	anzRegExp = new( ulong[numberOfGroups] );

	//Nun die Arrays mit den Indices in regText ausgeben
	file << "\n//Array with indices in regText\n";

	//Alle SC
	for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Zeiger auf Gruppen-Array
		grp = sc->grp;

		//Alle Gruppen ( = reduzierte DEA-Zustände ) einer SC
		for( j = 0; j < sc->grpCnt; j++ )
		{
			//ist die Gruppe disabled?
			if( grp[j]->valid == true )
			{
				//ausgeben
				file << "ulong SSLEXScanner::regTextIndex" << DEACnt << "[] = { ";

				//inizialisieren
				memset( marked, 0, sizeof( ulong ) * debugStrPos );

				//aus der Gruppe einen repräsentativen Zustand nehmen
				index = grp[j]->DEAIndex[0];

				//Zeiger auf DEA-Struktur
				dea = DEAStates[index];

				//Alle NEA-Zustände dieses NEA-Zustands
				for( k = cnt = 0; k < dea->neaIndexCnt; k++ )
				{
					//Zeiger auf NEA-Zustand
					s = stateStr[dea->neaIndex[k]];

					//den NEA dieses Zustands in DEBUG_STR suchen
					for( l = 0; l < debugStrPos; l++ )
					{
						//gleich?
						if( ( debugStr[l].nea == s->nea ) && !marked[l] )
						{
							//Ja, ausgeben
							if( cnt )
								file << ", ";

							//Index ausgeben
							file << l;

							//markieren
							marked[l]++;

							//Zähler
							cnt++;
						}
					}
				}

				//Anzahl der regulären Ausdrücke merken
				anzRegExp[DEACnt++] = cnt;

				//abschliessen
				file << " };\n";
			}
		}
	}




	//Nun die DEBUG_STR ausgeben
	file << "\n\n//Structure with debugging information\n";
	file << "SSLEXDebugStr SSLEXScanner::debugStr[SSLEX_STATE] = {\n";

	//Alle SC
	for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Zeiger auf Gruppen-Array
		grp = sc->grp;

		//Alle Gruppen ( = reduzierte DEA-Zustände ) einer SC
		for( j = 0; j < sc->grpCnt; j++ )
		{
			//ist die Gruppe disabled?
			if( grp[j]->valid == true )
			{
				//ausgeben
				file << "{ " << DEACnt << ", regTextIndex" << DEACnt << ", " << anzRegExp[DEACnt] << " }";

				//nächster DEA-Zustand
				DEACnt++;

				//mit Komma abschliessen?
				if( DEACnt < numberOfGroups )
					//Ja
					file << ",\n";

				else
					//ist letzter Eintrag
					file << "\n";
			}
		}
	}

	//abschließen
	file << "};\n\n";



	//Nun das Array mit den reg. Ausdrücken bei Akzeptieren
	file << "\n//Array with regular expression at accepting\n";
	file << "char *SSLEXScanner::acceptRegText[SSLEX_STATE] = { ";

	//Alle SC
	for( i = 0, DEACnt = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Zeiger auf Gruppen-Array
		grp = sc->grp;

		//Alle Gruppen ( = reduzierte DEA-Zustände ) einer SC
		for( j = 0; j < sc->grpCnt; j++ )
		{
			//ist die Gruppe disabled?
			if( grp[j]->valid == true )
			{
				//aus der Gruppe einen repräsentativen Zustand nehmen
				index = grp[j]->DEAIndex[0];

				//Zeiger auf DEA-Struktur
				dea = DEAStates[index];

				//akzepierend?
				if( dea->finit == true )
				{
					//Ja, reg. Ausdruck in Textform anpassen
					regText = toString( dea->finitNEA->regText );

					//ausgeben
					file << "\"" << regText << "\"";

					//Speicher freigeben
					delete[] ( regText );
				}

				else
					//ist kein akzeptierender Zustand
					file << "0L";

				//folgen noch welche?
				if( DEACnt < ( numberOfGroups - 1 ) )
					//Komma ausgeben
					file << ",\n";

				else
					//nein
					file << "\n";

				//DEA-Zustände zählen
				DEACnt++;
			}
		}
	}

	//abschließen
	file << "\n};\n";


	//Debug-Makro ausgeben
	file << "#endif\n";


	//Start-Conditionen ausgeben
	file << "\n";
	file << "//name of the start conditions\n";
	file << "char *SSLEXScanner::scName[] = {\n";

	//die Namen der Start-Conditionen ausgeben
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//ausgeben
		file << "\t\"" << sc->name << "\", " << "\"NL_" << sc->name << "\"";

		//folgen noch welche?
		if( i < ( scStrAnz - 1 ) )
			//Komma ausgeben
			file << ",\n";
	}

	//abschließen
	file << "\n};\n";





	//Speicher freigeben
	delete[] ( debugStr );
	delete[] ( marked );
	delete[] ( anzRegExp );
}


char *ssLexClass::toString( char *text )
{
	//wandelt die Steuerzeichen in druckbare Zeichen
	ulong	len = strlen( text ), cnt = 0;
	char	*tmp, *pos;

	//doppelt soviel Speicher genügt
	tmp = new( char[2 * len + 1] );

	//Null-Byte
	tmp[0] = 0;

	//Anfang merken
	pos = tmp;

	while( text[cnt] )
	{
		//Steuerzeichen?
		switch( text[cnt] )
		{
			case '\"':
			{
				//Anführungszeichen
				*pos++ = '\\';
				*pos++ = '"';
				*pos = 0;
				break;
			}

			case '\\':
			{
				//druckbar machen
				*pos++ = '\\';
				*pos++ = '\\';

				//Null-Byte
				*pos = 0;
				break;
			}

			default:
				//Zeichen kopieren
				*pos++ = text[cnt];
		}

		//nächstes Zeichen
		cnt++;
	}

	//Null-Byte
	*pos = 0;

	//String zurückliefern
	return( tmp );
}


void ssLexClass::outputAction( ofstream &file )
{
	//Aktionen ausgeben
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		i, j, k, *fArr;

	//für Fehlerbehandlung
	file << "\n";
	file << "//Table for error handling\n";
	file << "int SSLEXScanner::err[scSize][CCLWIDTH] = { 0 };\n";
	file << "\n";
	file << "\n";




	//die Zustände ausgeben, an denen ein Wechsel der Start-Conditionen stattfindet, ausgeben
	file << "\n";
	file << "//state of start conditions\n";
	file << "ulong SSLEXScanner::scIndex[] = {\n";

	//die Namen der Start-Conditionen ausgeben
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//ausgeben
		file << "\t" << sc->firstStart << ",";

		//SC als Namen im Kommentar ausgeben
		file << " //" << sc->name << "\n";

		//ausgeben
		file << "\t" << sc->secondStart;

		//folgen noch welche?
		if( i < ( scStrAnz - 1 ) )
			//Komma ausgeben
			file << ",";

		//ausgeben
		file << " //NL_" << sc->name << "\n";
	}

	//abschließen
	file << "};\n";


	//Speicher für das Array, das angibt, welche Finit-Zustände bereits bearbeitet wurden
	fArr = new( ulong[numberOfGroups] );

	//initialisieren
	memset( fArr, 0, sizeof( ulong ) * numberOfGroups );


file << "\n";
file << "\n";
file << "SSLEXScanner::SSLEXScanner( char *data, ulong size )\n";
file << "{\n";
file << "	//initialize SSLEX\n";
file << "\n";
file << "	//no data?\n";
file << "	if( !data )\n";
file << "	{\n";
file << "		//error\n";
file << "		cerr << \"SSLEXScanner: No data!\\n\";\n";
file << "\n";
file << "		//exit\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//save length of text\n";
file << "	basePosLength = size;\n";
file << "\n";
file << "	//copy text to analyze due to unput\n";
file << "	pos = basePos = new( char[basePosLength + 1] );\n";
file << "\n";
file << "	//copy to analyze string. This is nesessary as there are zero-bytes allowed in scanning\n";
file << "	//text. But this would couse strlen to return only the length till the next zero-byte!\n";
file << "	memcpy( pos, data, sizeof( char ) * basePosLength );\n";
file << "	pos[basePosLength] = 0;\n";
file << "\n";
file << "	//end of scanning\n";
file << "	end = pos + basePosLength;\n";
file << "\n";
file << "	//start-condition INITIAL\n";
file << "	state = baseState = INITIAL;\n";
file << "\n";
file << "	//init with 8KB\n";
file << "	yyTextLen = 8*1024;\n";
file << "	yyText = new( char[yyTextLen + 1] );\n";
file << "	yyLeng = 0;\n";
file << "\n";
file << "	//SSLEX automatically counts line numbers\n";
file << "	yyLineno = 1;\n";
file << "\n";
file << "	//last accepting state\n";
file << "	lastAcceptingState = -1;\n";
file << "\n";
file << "	//do not concatenate token\n";
file << "	concatenate = false;\n";
file << "\n";
file << "	//no start conditions on stack\n";
file << "	scStackSize = 0;\n";
file << "	scStackPos = 0;\n";
file << "	scStack = 0L;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "SSLEXScanner::~SSLEXScanner()\n";
file << "{\n";
file << "	//free memory\n";
file << "	if( yyText )\n";
file << "		delete[] ( yyText );\n";
file << "\n";
file << "	if( scStack )\n";
file << "		delete[] ( scStack );\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "	//deinizialize user defined variables\n";
file << "	deinit();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::reset( void )\n";
file << "{\n";
file << "	//reset the whole scanner\n";
file << "\n";
file << "	//start position\n";
file << "	pos = basePos;\n";
file << "\n";
file << "	//end of scanning\n";
file << "	end = pos + basePosLength;\n";
file << "\n";
file << "	//need memory for yyText?\n";
file << "	if( !yyText )\n";
file << "	{\n";
file << "		//init with 8KB\n";
file << "		yyTextLen = 8*1024;\n";
file << "		yyText = new( char[yyTextLen + 1] );\n";
file << "	}\n";
file << "\n";
file << "	//start-condition INITIAL\n";
file << "	state = baseState = INITIAL;\n";
file << "\n";
file << "	//no token\n";
file << "	yyLeng = 0;\n";
file << "\n";
file << "	//SSLEX automatically counts line numbers\n";
file << "	yyLineno = 1;\n";
file << "\n";
file << "	//last accepting state\n";
file << "	lastAcceptingState = -1;\n";
file << "\n";
file << "	//do not concatenate token\n";
file << "	concatenate = false;\n";
file << "\n";
file << "	//no start conditions on stack\n";
file << "	scStackPos = 0;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::reset( char *data, ulong size )\n";
file << "{\n";
file << "	//reset the whole scanner and give him new input\n";
file << "\n";
file << "	//no data?\n";
file << "	if( !data )\n";
file << "	{\n";
file << "		//error\n";
file << "		cerr << \"SSLEXScanner: No data!\\n\";\n";
file << "\n";
file << "		//exit\n";
file << "		exit( 1 );\n";
file << "	}\n";
file << "\n";
file << "	//save length of text\n";
file << "	basePosLength = size;\n";
file << "\n";
file << "	//copy text to analyze due to unput\n";
file << "	pos = basePos = new( char[basePosLength + 1] );\n";
file << "\n";
file << "	//copy to analyze string. This is nesessary as there are zero-bytes allowed in scanning\n";
file << "	//text. But this would couse strlen to return only the length till the next zero-byte!\n";
file << "	memcpy( pos, data, sizeof( char ) * basePosLength );\n";
file << "	pos[basePosLength] = 0;\n";
file << "\n";
file << "	//end of scanning\n";
file << "	end = pos + basePosLength;\n";
file << "\n";
file << "	//start-condition INITIAL\n";
file << "	state = baseState = INITIAL;\n";
file << "\n";
file << "	//need memory for yyText?\n";
file << "	if( !yyText )\n";
file << "	{\n";
file << "		//init with 8KB\n";
file << "		yyTextLen = 8*1024;\n";
file << "		yyText = new( char[yyTextLen + 1] );\n";
file << "	}\n";
file << "\n";
file << "	//no token\n";
file << "	yyLeng = 0;\n";
file << "\n";
file << "	//SSLEX automatically counts line numbers\n";
file << "	yyLineno = 1;\n";
file << "\n";
file << "	//last accepting state\n";
file << "	lastAcceptingState = -1;\n";
file << "\n";
file << "	//do not concatenate token\n";
file << "	concatenate = false;\n";
file << "\n";
file << "	//no start conditions on stack\n";
file << "	scStackPos = 0;\n";
file << "\n";
file << "\n";
file << "#ifdef SSLEX_INIT\n";
file << "\n";
file << "	//inizialize user defined variables\n";
file << "	init();\n";
file << "#endif\n";
file << "}\n";
file << "\n";
file << "\n";
file << "int SSLEXScanner::yyLex( SSLR_TYPE *attributeStr )\n";
file << "{\n";
file << "	//start scanning\n";
file << "	unsigned char	c;\n";
file << "\n";
file << "	//Basis-Position für das Lexem\n";
file << "	startPos = pos;\n";
file << "\n";
file << "	//setup some stuff\n";
file << "	yyDoBeforeRule();\n";
file << "\n";
file << "	while( pos <= end )\n";
file << "	{\n";
file << "		//Zeichen\n";
file << "		c = *pos;\n";

	//7-Bit-Scanner?
	if( argv_str->cclWidth == _7BIT )
	{
		//Fehler abfangen
file << "\n";
file << "		//when we use a 7 bit scanner\n";
file << "		if( c > 127 )\n";
file << "		{\n";
file << "			//we need a 8 bit scanner\n";
file << "			cerr << \"SSLEXScanner::yyLex: Line \" << yyLineno << \": You need a 8 bit scanner to match the character \" << c << \"!\\n\";\n";
file << "\n";
file << "			//skip character\n";
file << "			pos++;\n";
file << "			continue;\n";
file << "		}\n";
	}

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro
		file << "\n#ifdef SSLEX_DEBUG";

		//Ja
		file << "\n";
		file << "		//print debugging information\n";
		file << "		mainDebug( c );\n";

		//Debug-Makro
		file << "#endif\n";
	}


file << "\n";
file << "		//schieben?\n";
file << "		if( ssLexTable[state][c] >= 0 )\n";
file << "		{\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro
		file << "\n#ifdef SSLEX_DEBUG\n";

		//Ja
		file << "			//print debugging information\n";
		file << "			shiftDebug( c );\n";

		//Debug-Makro
		file << "#endif\n\n";
	}

file << "			//akzeptieren?\n";
file << "			if( ssLexAccept[state] )\n";
file << "			{\n";
file << "				//Ja, merken\n";
file << "				lastAcceptingState = state;\n";
file << "				lastAcceptingPos = pos;\n";
file << "			}\n";
file << "\n";

	//wurden Lookahead-Regeln benutzt?
	if( laUsed == true )
	{
		//Ja
		file << "			//Lookahead-Zustand?\n";
		file << "			if( ssLexLA[state] )\n";
		file << "				//Ja, merken\n";
		file << "				lastLAPos = pos;\n";
		file << "\n";
	}

file << "			//shift new state\n";
file << "			state = ssLexTable[state][c];\n";
file << "\n";
file << "			//nächstes Zeichen\n";
file << "			pos++;\n";
file << "		}\n";
file << "\n";
file << "		else\n";
file << "		{\n";
file << "			//akzeptieren\n";
file << "			do\n";
file << "			{\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro
		file << "\n#ifdef SSLEX_DEBUG\n";

		//Ja
		file << "				//print debugging information\n";
		file << "				acceptDebug();\n";

		//Debug-Makro
		file << "#endif\n\n";
	}

file << "				switch( ssLexAccept[state] )\n";
file << "				{\n";

	//Nun alle Aktionen ausgeben
	for( i = 0; i < numberOfGroups; i++ )
	{
		//den ersten Eintrag finden
		if( finitNEA[i] && !fArr[i] )
		{
			//Ja, Zeiger auf NEA_STR
			nea = finitNEA[i];

			//markieren
			fArr[i] = 1;

			//entsprechenden reg. Ausdruck ausgeben
			file << "\t\t\t\t\t//" << nea->regText << "\n";

			//ausgeben
			file << "\t\t\t\t\tcase " << i << ":\n";

			//alle Zustände mit gleicher Aktion ausgeben
			for( j = i + 1; j < numberOfGroups; j++ )
			{
				//gleich?
				if( finitNEA[j] == nea )
				{
					//Ja, markieren
					fArr[j] = 1;

					//case ausgeben
					file << "\t\t\t\t\tcase " << j << ":\n";
				}
			}

			//in einem Block
			file << "\t\t\t\t\t{\n";

			//Ist es ein Lookahead-NEA?
			if( nea->laState == true )
				//erst die Position zurücksetzen, bevor yyText geschrieben wird
				file << "\t\t\t\t\t\t//set position back\n\t\t\t\t\t\tpos = lastLAPos;\n\n";

			//yyText setzen
			file << "\t\t\t\t\t\t//setup yyText\n\t\t\t\t\t\tsetupyyText();\n\n";

			//Alle Aktionen
			for( k = 0; k < nea->actionAnz; k++ )
				//ausgeben
				file << nea->action[k];

			//break
			file << "\t\t\t\t\t\tbreak;\n";

			//Block schließen
			file << "\t\t\t\t\t}\n\n";
		}
	}

file << "\n";
file << "					default:\n";
file << "					{\n";
file << "						//unable to accept, backtracking or error\n";
file << "						if( lastAcceptingState >= 0 )\n";
file << "						{\n";
file << "							//set back to last accept position\n";
file << "							state = lastAcceptingState;\n";
file << "							pos = lastAcceptingPos;\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLEX_DEBUG";

		//Meldung ausgeben
		file << "\n";
		file << "							//backtracking\n";
		file << "							cout << \"Backtracking, set new state \" << state << \"\\n\";\n";

		//Debug-Makro ausgeben
		file << "#endif";
	}

file << "\n";
file << "							//now accept with last accept position\n";
file << "							continue;\n";
file << "						}\n";
file << "\n";
file << "						else\n";
file << "						{\n";
file << "							//error\n";
file << "							error( *startPos );\n";
file << "\n";
file << "							//remove character\n";
file << "							pos++;\n";
file << "						}\n";
file << "\n";
file << "						break;\n";
file << "					}\n";
file << "				}\n";
file << "\n";
file << "				//setup some stuff\n";
file << "				yyDoBeforeRule();\n";
file << "\n";
file << "				//exit while-loop\n";
file << "				break;\n";
file << "\n";
file << "			}while( 1 );\n";
file << "\n";
file << "			//Ende der Eingabe erreicht?\n";
file << "			if( pos == end )\n";
file << "				//Ja\n";
file << "				break;\n";
file << "		}\n";
file << "	}\n";
file << "\n";
file << "	//call eof-rules\n";
file << "	return( endOfLine() );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyDoBeforeRule( void )\n";
file << "{\n";
file << "	//set some stuff before a new rule is scanned\n";
file << "\n";
file << "	//reset\n";
file << "	lastAcceptingState = -1;\n";
file << "\n";
file << "	//base position for lexem\n";
file << "	startPos = pos;\n";
file << "\n";
file << "	//are we at the beginning of a line?\n";
file << "	if( ( pos == basePos ) || ( pos[-1] == '\\n' ) )\n";
file << "		//setup state\n";
file << "		state = setupState( baseState );\n";
file << "\n";
file << "	else\n";
file << "		//base-State\n";
file << "		state = baseState;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::error( uchar c )\n";
file << "{\n";
file << "	//simple error handling routine\n";
file << "	ulong		i;\n";
file << "	char		*transChar[] = {\n";
file << "	  \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "	 \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "	\"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "	   \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "	   \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "	   \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "	   \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "	   \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "	   \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "	   \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "	   \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "	   \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "	   \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "	   \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "	   \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "	   \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "	   \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "	   \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "	   \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "	   \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "	   \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "	   \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "	   \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "	   \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "	//get current sc\n";
file << "	for( i = 0; i < scSize; i++ )\n";
file << "	{\n";
file << "		//equal?\n";
file << "		if( scIndex[i] == baseState )\n";
file << "			break;\n";
file << "	}\n";
file << "\n";
file << "	//did already an error occur in that sc?\n";
file << "	if( !err[i][c] )\n";
file << "	{\n";
file << "		//No, print an error message\n";


	//Debug-Version?
	if( argv_str->debug == true )
		//Ja, auch den Namen der SC ausgeben
		file << "		cerr << \"line \" << yyLineno << \": SC \" << scName[i] << \": Illegal character \" << transChar[c] << \"!\\n\";\n";

	else
		//Nein, nur Fehlermeldung
		file << "		cerr << \"line \" << yyLineno << \": Illegal character \" << transChar[c] << \"!\\n\";\n";


file << "\n";
file << "		//mark to avoid ever lasting loops\n";
file << "		err[i][c]++;\n";
file << "	}\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setupYYLineno( char *beg, char *end )\n";
file << "{\n";
file << "	//setup yyLineno\n";
file << "	ulong	len = end - beg, i;\n";
file << "	int		nl = 0;\n";
file << "\n";
file << "	//count newlines\n";
file << "	for( i = 0; i < len; i++ )\n";
file << "	{\n";
file << "		//newline?\n";
file << "		if( beg[i] == '\\n' )\n";
file << "			nl++;\n";
file << "	}\n";
file << "\n";
file << "	//add to yyLineno\n";
file << "	yyLineno += nl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setupyyText( void )\n";
file << "{\n";
file << "	//insert text in yytext\n";
file << "	ulong	len;\n";
file << "	char	*tmp;\n";
file << "\n";
file << "	//reg. expression one-character?\n";
file << "	if( pos == startPos )\n";
file << "		//yes, move to next character\n";
file << "		pos++;\n";
file << "\n";
file << "	//get length of lexem\n";
file << "	yyLeng = pos - startPos;\n";
file << "\n";
file << "	//concatenate token? (yyMore)\n";
file << "	if( concatenate == true )\n";
file << "	{\n";
file << "		//yes, append\n";
file << "		len = strlen( yyText );\n";
file << "\n";
file << "		//enough space?\n";
file << "		if( yyTextLen <= ( yyLeng + len ) )\n";
file << "		{\n";
file << "			//extend memory\n";
file << "\n";
file << "			//fix yyTextLen\n";
file << "			yyTextLen = yyLeng + len;\n";
file << "\n";
file << "			//get enough memory für lexem\n";
file << "			tmp = new( char[yyTextLen + 1] );\n";
file << "\n";
file << "			//copy string\n";
file << "			strcpy( tmp, yyText );\n";
file << "\n";
file << "			//release memory\n";
file << "			if( yyText )\n";
file << "				delete[] ( yyText );\n";
file << "\n";
file << "			//copy adress\n";
file << "			yyText = tmp;\n";
file << "		}\n";
file << "\n";
file << "		//append\n";
file << "		strncat( yyText, startPos, len );\n";
file << "\n";
file << "		//zero\n";
file << "		yyText[yyLeng + len] = 0;\n";
file << "\n";
file << "		//set up yyLeng\n";
file << "		yyLeng += len;\n";
file << "\n";
file << "		//next time we want to set up yyText as usual\n";
file << "		concatenate = false;\n";
file << "	}\n";
file << "\n";
file << "	else\n";
file << "	{\n";
file << "		//enough space?\n";
file << "		if( yyTextLen <= yyLeng )\n";
file << "		{\n";
file << "			//extend memory\n";
file << "			if( yyText )\n";
file << "				delete[] ( yyText );\n";
file << "\n";
file << "			//fix yyTextLen\n";
file << "			yyTextLen = yyLeng;\n";
file << "\n";
file << "			//get enough memory für lexem\n";
file << "			yyText = new( char[yyTextLen + 1] );\n";
file << "		}\n";
file << "\n";
file << "		//insert\n";
file << "		strncpy( yyText, startPos, yyLeng );\n";
file << "\n";
file << "		//end with zere\n";
file << "		yyText[yyLeng] = 0;\n";
file << "	}\n";
file << "\n";
file << "	//setup yyLineno\n";
file << "	setupYYLineno( startPos, pos );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::setupState( ulong baseState )\n";
file << "{\n";
file << "	//setup state for begin-of-line-rules\n";
file << "	ulong	state = baseState, i;\n";
file << "\n";
file << "	//test if the current state is valid\n";
file << "	switch( baseState )\n";
file << "	{\n";


	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Namen der SC ausgeben
		file << "\t\tcase " << sc->name << ":\n";
	}

	/*
		Wenn der Scanner auf ein Newline-Zeichen trifft, soll er den Startzustand nehmen, in dem auch die
		NEAen aktiviert sind, die ausschließlich am Zeilenanfang stehen dürfen.
		Dies ist der Zustand, der nach dem Startzustand der NEAen steht, die überall stehen dürfen.
		Ein schlichtes state++; genügt also.
		Hier wird trotzdem mit case gearbeitet, falls sich ein Zustand einschleicht, zu dem keine
		Startcondition gehört.
	*/

	//den Basis-Zustand setzen
	file << "		{\n";
	file << "			//it is right the next state;\n";
	file << "			state++;\n";
	file << "			break;\n";
	file << "		}\n";


file << "\n";
file << "		default:\n";
file << "		{\n";
file << "			//ups, unknown start condition\n";
file << "			cerr << \"SSLEXScanner::setupState: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "			exit( 1 );\n";
file << "		}\n";
file << "	}\n";
file << "\n";

		//Debug-Version?
		if( argv_str->debug == true )
		{
			//Debug-Makro ausgeben
			file << "#ifdef SSLEX_DEBUG\n";

			//Ja
			file << "	//get current sc\n";
			file << "	for( i = 0; i < scSize; i++ )\n";
			file << "	{\n";
			file << "		//equal?\n";
			file << "		if( scIndex[i] == baseState )\n";
			file << "			break;\n";
			file << "	}\n";
			file << "\n";
			file << "	//print debugging information\n";
			file << "	cout << \"switch to \" << scName[i] << \"\\n\";\n";

			//Debug-Makro ausgeben
			file << "#endif\n\n";
		}

file << "	//return state\n";
file << "	return( state );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::setStartCondition( ulong state )\n";
file << "{\n";
file << "	//set a new start condition\n";
file << "	switch( state )\n";
file << "	{\n";


	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Hat die SC überhaupt NEAen?
		if( sc->neaArrCnt )
		{
			//Index des Start-Zustandes ausgeben
			file << "\t\tcase " << sc->name << ":\n";

			//den Basis-Zustand setzen
			file << "		{\n";
			file << "			//set new start condition\n";
			file << "			baseState = " << sc->name << ";\n";
			file << "			break;\n";
			file << "		}\n\n";
		}
	}

file << "\n";
file << "		default:\n";
file << "		{\n";
file << "			//unknown start condition\n";
file << "			cerr << \"SSLEXScanner::setStartCondition: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "\n";
file << "			//ignore call\n";
file << "			break;\n";
file << "		}\n";
file << "	}\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::getYYLeng( void )\n";
file << "{\n";
file << "	//return length of yyText\n";
file << "	return( yyLeng );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::getYYLineno( void )\n";
file << "{\n";
file << "	//return line number\n";
file << "	return( yyLineno );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char *SSLEXScanner::getYYText( void )\n";
file << "{\n";
file << "	//return yyText\n";
file << "	return( yyText );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char *SSLEXScanner::yyStrCpy( char *txt )\n";
file << "{\n";
file << "	//return txt in it's own memory\n";
file << "	ulong	len;\n";
file << "	char	*tmp;\n";
file << "\n";
file << "	//length of txt\n";
file << "	len = strlen( txt );\n";
file << "\n";
file << "	//get memory for txt\n";
file << "	tmp = new( char[len + 1] );\n";
file << "\n";
file << "	//copy\n";
file << "	strcpy( tmp, txt );\n";
file << "\n";
file << "	//zero\n";
file << "	tmp[len] = 0;\n";
file << "\n";
file << "	//return\n";
file << "	return( tmp );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyLess( int n )\n";
file << "{\n";
file << "	//returns all but the first n characters of yyText back to the input\n";
file << "\n";
file << "	//check\n";
file << "	if( ( n < 0 ) || ( n > yyLeng ) )\n";
file << "	{\n";
file << "		//bad n\n";
file << "		cerr << \"SSLEXScanner::yyLess: Line \" << yyLineno << \": Bad argument!\\n\";\n";
file << "\n";
file << "		//ignore\n";
file << "		return;\n";
file << "	}\n";
file << "\n";
file << "	//zero\n";
file << "	yyText[n] = 0;\n";
file << "\n";
file << "	//return to input spring\n";
file << "	pos -= ( yyLeng - n );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyPushState( ulong newState )\n";
file << "{\n";
file << "	/*\n";
file << "		Pushes the current start condition onto the top of the start condition stack\n";
file << "		and switches to newState as though you have used BEGIN( newState ).\n";
file << "	*/\n";
file << "\n";
file << "	//enough memory\n";
file << "	if( scStackPos == scStackSize )\n";
file << "		//enlarge start condition stack\n";
file << "		enlargeSCStack();\n";
file << "\n";
file << "	//put on stack\n";
file << "	scStack[scStackPos++] = baseState;\n";
file << "\n";
file << "	//switch to new state\n";
file << "	BEGIN( newState );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyPopState( void )\n";
file << "{\n";
file << "	//pops the top of the start condition stack and switches to it\n";
file << "\n";
file << "	//underflow?\n";
file << "	if( scStackPos <= 0 )\n";
file << "		//error\n";
file << "		cerr << \"SSLEXScanner::yyPopState: Line \" << yyLineno << \": Start condition stack underflow!\\n\";\n";
file << "\n";
file << "	else\n";
file << "	{\n";
file << "		//get new SC state\n";
file << "		ulong	newState = scStack[--scStackPos];\n";
file << "\n";
file << "		//switch to it\n";
file << "		BEGIN( newState );\n";
file << "\n";
file << "		//set new state\n";
file << "		state = newState;\n";
file << "	}\n";
file << "}\n";
file << "\n";
file << "\n";
file << "ulong SSLEXScanner::yyTopState( void )\n";
file << "{\n";
file << "	//returns the top of the start condition stack without altering its contents\n";
file << "	return( scStack[scStackPos - 1] );\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::enlargeSCStack( void )\n";
file << "{\n";
file << "	//enlarge start condition stack\n";
file << "	ulong	*tmp;\n";
file << "\n";
file << "	//get enough memory\n";
file << "	tmp = new( ulong[scStackSize + SCStackSize] );\n";
file << "\n";
file << "	//copy old content\n";
file << "	memcpy( tmp, scStack, sizeof( ulong ) * scStackSize );\n";
file << "\n";
file << "	//free old memory?\n";
file << "	if( scStack )\n";
file << "		//yes\n";
file << "		delete[] ( scStack );\n";
file << "\n";
file << "	//set new adress\n";
file << "	scStack = tmp;\n";
file << "\n";
file << "	//add size\n";
file << "	scStackSize += SCStackSize;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyUnput( unsigned char c )\n";
file << "{\n";
file << "	//puts the character c back to the input stream\n";
file << "	ulong	len = basePosLength++;\n";
file << "	int		diff = pos - basePos;\n";
file << "	char	*txt;\n";
file << "\n";
file << "	//get enough memory to push back character\n";
file << "	txt = new( char[len + 2] );\n";
file << "\n";
file << "	//copy to current position\n";
file << "	memcpy( txt, basePos, sizeof( char ) * diff );\n";
file << "\n";
file << "	//now insert c\n";
file << "	txt[diff] = c;\n";
file << "\n";
file << "	//append rest of the input\n";
file << "	memcpy( &txt[diff + 1], pos, sizeof( char ) * ( len - diff ) );\n";
file << "\n";
file << "	//zero\n";
file << "	txt[len + 1] = 0;\n";
file << "\n";
file << "	//free old memory\n";
file << "	delete[] ( basePos );\n";
file << "\n";
file << "	//set new position\n";
file << "	pos = startPos = &txt[diff];\n";
file << "\n";
file << "	//set new end\n";
file << "	end = &txt[len + 1];\n";
file << "\n";
file << "	//set new beginning\n";
file << "	basePos = txt;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::yyUnput( char *str )\n";
file << "{\n";
file << "	//puts the string str back to the input stream\n";
file << "	ulong	len = basePosLength, strLen = strlen( str );\n";
file << "	int		diff = pos - basePos;\n";
file << "	char	*txt;\n";
file << "\n";
file << "	//get enough memory to push back character\n";
file << "	txt = new( char[len + strLen + 1] );\n";
file << "\n";
file << "	//copy to current position\n";
file << "	memcpy( txt, basePos, sizeof( char ) * diff );\n";
file << "\n";
file << "	//now append str\n";
file << "	strcpy( &txt[diff], str );\n";
file << "\n";
file << "	//append rest of the input\n";
file << "	memcpy( &txt[strLen + diff], pos, sizeof( char ) * ( len - diff ) );\n";
file << "\n";
file << "	//zero\n";
file << "	txt[len + strLen] = 0;\n";
file << "\n";
file << "	//free old memory\n";
file << "	delete[] ( basePos );\n";
file << "\n";
file << "	//set new position\n";
file << "	pos = startPos = &txt[diff];\n";
file << "\n";
file << "	//set new end\n";
file << "	end = &txt[len + strLen + 1];\n";
file << "\n";
file << "	//set new beginning\n";
file << "	basePos = txt;\n";
file << "\n";
file << "	//correct basePosLength\n";
file << "	basePosLength += strLen;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "char SSLEXScanner::yyInput( void )\n";
file << "{\n";
file << "	//return the next character to be scanned\n";
file << "	return( *pos++ );\n";
file << "}\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLEX_DEBUG\n";

file << "void SSLEXScanner::mainDebug( unsigned char c )\n";
file << "{\n";
file << "	//print debugging information\n";
file << "	SSLEXDebugStr	*d = &debugStr[state];\n";
file << "	ulong			i;\n";
file << "	char			tmp[200], *transChar[] = {\n";
file << "	  \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "	 \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "	\"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "	   \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "	   \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "	   \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "	   \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "	   \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "	   \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "	   \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "	   \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "	   \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "	   \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "	   \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "	   \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "	   \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "	   \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "	   \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "	   \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "	   \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "	   \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "	   \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "	   \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "	   \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "	//get current sc\n";
file << "	for( i = 0; i < scSize; i++ )\n";
file << "	{\n";
file << "		//equal?\n";
file << "		if( scIndex[i] == baseState )\n";
file << "			break;\n";
file << "	}\n";
file << "\n";
file << "	//current line\n";
file << "	cout << endl << \"current line: \" << getYYLineno() << endl;\n";
file << "\n";
file << "	//print the next 40 chars of the input\n";
file << "	txtFilter( pos, tmp, 40 );\n";
file << "	cout << \"current pos: \" << tmp << endl;\n";
file << "\n";
file << "	//current SC\n";
file << "	cout << \"current start condition: \" << scName[i] << endl;\n";
file << "\n";
file << "	//current state\n";
file << "	cout << \"current state: \" << state << endl;\n";
file << "\n";
file << "	//current character\n";
file << "	cout << \"current character: \" << transChar[c] << endl;\n";
file << "\n";
file << "	//print assocciated regular expression\n";
file << "	cout << \"associated regular expressions:\" << endl;\n";
file << "\n";
file << "	//all associated reg. expressions\n";
file << "	for( i = 0; i < d->indexCnt; i++ )\n";
file << "		//print\n";
file << "		cout << regText[d->index[i]] << endl;\n";
file << "\n";
file << "	//print ssLexTable\n";
file << "	cout << \"ssLexTable[\" << state << \"][\" << transChar[c] << \"] = \" << ssLexTable[state][c] << endl << endl;\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::shiftDebug( unsigned char c )\n";
file << "{\n";
file << "	//print debugging information\n";
file << "	SSLEXDebugStr	*d = &debugStr[state];\n";
file << "	ulong			i;\n";
file << "	char		*transChar[] = {\n";
file << "	  \"\\\\0\",   \"\\\\1\",   \"\\\\2\",   \"\\\\3\",   \"\\\\4\",   \"\\\\5\",   \"\\\\6\",  \"\\\\a\",  \"\\\\b\",  \"\\\\t\",  \"\\\\n\",  \"\\\\v\",\n";
file << "	 \"\\\\f\",  \"\\\\r\", \"0x0e\", \"0x0f\", \"0x10\", \"0x11\", \"0x12\", \"0x13\", \"0x14\", \"0x15\", \"0x16\", \"0x17\",\n";
file << "	\"0x18\", \"0x19\", \"0x1a\", \"0x1b\", \"0x1c\", \"0x1d\", \"0x1e\", \"0x1f\",    \" \",    \"!\",   \"\\\"\",    \"#\",\n";
file << "	   \"$\",    \"%\",    \"&\",    \"'\",    \"(\",    \")\",    \"*\",    \"+\",    \",\",    \"-\",    \".\",    \"/\",\n";
file << "	   \"0\",    \"1\",    \"2\",    \"3\",    \"4\",    \"5\",    \"6\",    \"7\",    \"8\",    \"9\",    \":\",    \";\",\n";
file << "	   \"<\",    \"=\",    \">\",    \"?\",    \"@\",    \"A\",    \"B\",    \"C\",    \"D\",    \"E\",    \"F\",    \"G\",\n";
file << "	   \"H\",    \"I\",    \"J\",    \"K\",    \"L\",    \"M\",    \"N\",    \"O\",    \"P\",    \"Q\",    \"R\",    \"S\",\n";
file << "	   \"T\",    \"U\",    \"V\",    \"W\",    \"X\",    \"Y\",    \"Z\",    \"[\",    \"\\\\\", \"]\",    \"^\",    \"_\",\n";
file << "	   \"`\",    \"a\",    \"b\",    \"c\",    \"d\",    \"e\",    \"f\",    \"g\",    \"h\",    \"i\",    \"j\",    \"k\",\n";
file << "	   \"l\",    \"m\",    \"n\",    \"o\",    \"p\",    \"q\",    \"r\",    \"s\",    \"t\",    \"u\",    \"v\",    \"w\",\n";
file << "	   \"x\",    \"y\",    \"z\",    \"{\",    \"|\",    \"}\",    \"~\",    \"DEL\",\n";
file << "	   \"128\",  \"129\",  \"130\",  \"131\",  \"132\",  \"133\",  \"134\",  \"135\",  \"136\",  \"137\",\n";
file << "	   \"138\",  \"139\",  \"140\",  \"141\",  \"142\",  \"143\",  \"144\",  \"145\",  \"146\",  \"147\",\n";
file << "	   \"148\",  \"149\",  \"150\",  \"151\",  \"152\",  \"153\",  \"154\",  \"155\",  \"156\",  \"157\",\n";
file << "	   \"158\",  \"159\",  \"160\",  \"161\",  \"162\",  \"163\",  \"164\",  \"165\",  \"166\",  \"167\",\n";
file << "	   \"168\",  \"169\",  \"170\",  \"171\",  \"172\",  \"173\",  \"174\",  \"175\",  \"176\",  \"177\",\n";
file << "	   \"178\",  \"179\",  \"180\",  \"181\",  \"182\",  \"183\",  \"184\",  \"185\",  \"186\",  \"187\",\n";
file << "	   \"188\",  \"189\",  \"190\",  \"191\",  \"192\",  \"193\",  \"194\",  \"195\",  \"196\",  \"197\",\n";
file << "	   \"198\",  \"199\",  \"200\",  \"201\",  \"202\",  \"203\",  \"204\",  \"205\",  \"206\",  \"207\",\n";
file << "	   \"208\",  \"209\",  \"210\",  \"211\",  \"212\",  \"213\",  \"214\",  \"215\",  \"216\",  \"217\",\n";
file << "	   \"218\",  \"219\",  \"220\",  \"221\",  \"222\",  \"223\",  \"224\",  \"225\",  \"226\",  \"227\",\n";
file << "	   \"228\",  \"229\",  \"230\",  \"231\",  \"232\",  \"233\",  \"234\",  \"235\",  \"236\",  \"237\",\n";
file << "	   \"238\",  \"239\",  \"240\",  \"241\",  \"242\",  \"243\",  \"244\",  \"245\",  \"246\",  \"247\",\n";
file << "	   \"248\",  \"249\",  \"250\",  \"251\",  \"252\",  \"253\",  \"254\" };\n";
file << "\n";
file << "	//shift?\n";
file << "	cout << \"shift ssLexTable[\" << state << \"][\" << transChar[c] << \"] = \" << ssLexTable[state][c] << \"\\n\";\n";
file << "\n";
file << "	//accepting state?\n";
file << "	if( ssLexAccept[state] )\n";
file << "		//yes\n";
file << "		cout << \"ssLexAccept[\" << state << \"] = \" << ssLexAccept[state] << \" -> \" << acceptRegText[ssLexAccept[state]] << \"\\n\";\n";
file << "\n";

		//Lookahead-Rules benutzt?
		if( laUsed == true )
		{
			//Ja, ausgeben
			file << "	//lookahead state?\n";
			file << "	if( ssLexLA[state] )\n";
			file << "		//yes\n";
			file << "		cout << \"lookahead state\\n\";\n";
			file << "\n";
		}

file << "	//all associated reg. expressions\n";
file << "	for( i = 0; i < d->indexCnt; i++ )\n";
file << "		//print\n";
file << "		cout << regText[d->index[i]] << \"\\n\";\n";
file << "\n";
file << "	//newline\n";
file << "	cout << \"\\n\";\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::acceptDebug( void )\n";
file << "{\n";
file << "	//print debugging information\n";
file << "\n";
file << "	//accept?\n";
file << "	if( ssLexAccept[state] )\n";
file << "		//yes\n";
file << "		cout << \"accepting with \" << acceptRegText[ssLexAccept[state]] << \"\\n\";\n";
file << "\n";
file << "	else\n";
file << "		//backtrack\n";
file << "		cout << \"backtracking to state \" << lastAcceptingState << \"\\n\";\n";
file << "\n";
file << "	//newline\n";
file << "	cout << \"\\n\";\n";
file << "}\n";
file << "\n";
file << "\n";
file << "void SSLEXScanner::txtFilter( char *from, char *to, ulong cnt )\n";
file << "{\n";
file << "	//copy cnt bytes from from to to, but transform escape sequences into\n";
file << "	//readable text form\n";
file << "	ulong	i;\n";
file << "	char	c, tmp[10], *base = to;\n";
file << "\n";
file << "	//init\n";
file << "	*to = 0;\n";
file << "\n";
file << "	//as long as there is another char\n";
file << "	for( i = 0; i < cnt; i++ )\n";
file << "	{\n";
file << "		//get char\n";
file << "		c = *from++;\n";
file << "\n";
file << "		//is it printable?\n";
file << "		if( !isprint( c ) )\n";
file << "		{\n";
file << "			//transform into readable\n";
file << "			switch( c )\n";
file << "			{\n";
file << "				//newline?\n";
file << "				case '\\n':\n";
file << "				{\n";
file << "					//newline\n";
file << "					strcat( to, \"\\\\n\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//Backspace\n";
file << "				case '\\b':\n";
file << "				{\n";
file << "					//Backspace\n";
file << "					strcat( to, \"\\\\b\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//Linefeed\n";
file << "				case '\\f':\n";
file << "				{\n";
file << "					//Linefeed\n";
file << "					strcat( to, \"\\\\f\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//carriage return\n";
file << "				case '\\r':\n";
file << "				{\n";
file << "					//carriage return\n";
file << "					strcat( to, \"\\\\r\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//Tabulator\n";
file << "				case '\\t':\n";
file << "				{\n";
file << "					//Tabulator\n";
file << "					strcat( to, \"\\\\t\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "#if __STDC__\n";
file << "				//bing\n";
file << "				case '\\a':\n";
file << "				{\n";
file << "					//bing\n";
file << "					strcat( to, \"\\\\a\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//vertical tab\n";
file << "				case '\\v':\n";
file << "				{\n";
file << "					//vertical tab\n";
file << "					strcat( to, \"\\\\v\" );\n";
file << "					break;\n";
file << "				}\n";
file << "#else\n";
file << "				//bing\n";
file << "				case '\\a':\n";
file << "				{\n";
file << "					//bing\n";
file << "					strcat( to, \"\\\\007\" );\n";
file << "					break;\n";
file << "				}\n";
file << "\n";
file << "				//vertical tab\n";
file << "				case '\\v':\n";
file << "				{\n";
file << "					//vertical tab\n";
file << "					strcat( to, \"\\\\013\" );\n";
file << "					break;\n";
file << "				}\n";
file << "#endif\n";
file << "\n";
file << "				default:\n";
file << "				{\n";
file << "					//neither of the above\n";
file << "					sprintf( tmp, \"%x\", c );\n";
file << "\n";
file << "					//append\n";
file << "					strcat( to, tmp );\n";
file << "				}\n";
file << "			}\n";
file << "		}\n";
file << "\n";
file << "		else\n";
file << "		{\n";
file << "			//yes, printable\n";
file << "			sprintf( tmp, \"%c\", c );\n";
file << "\n";
file << "			//append\n";
file << "			strcat( to, tmp );\n";
file << "		}\n";
file << "	}\n";
file << "}\n";

		//Debug-Makro ausgeben
		file << "#endif\n\n";
	}

	//Speicher freigeben
	delete[] ( finitNEA );
	delete[] ( laNEA );
	delete[] ( fArr );
}


void ssLexClass::outputIncl( ofstream &file )
{
	//Include-Anweisungen in das cpp-File ausgeben
	char	*incl = s->getInclude(), *beg;
	ulong	len;

	//gibt es include-Anweisungen?
	if( incl )
	{
		//am Anfang das \{ löschen
		while( !( ( incl[0] == '\\' ) && ( incl[1] == '{' ) ) )
			incl++;

		//löschen
		incl = &incl[2];

		//die Länge der Include-Anweisungen
		len = strlen( incl );

		//merken
		beg = &incl[len - 2];

		//am Ende das \{ löschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << incl;
	}
}


void ssLexClass::outputExt( ofstream &file )
{
	//eigene Erweiterungen in das cpp-File ausgeben
	char	*ext = s->getExtension(), *beg;
	ulong	len;

	//gibt es Extensionen?
	if( ext )
	{
		//am Anfang das \{ löschen
		while( !( ( ext[0] == '\\' ) && ( ext[1] == '{' ) ) )
			ext++;

		//löschen
		ext = &ext[2];

		//die Länge der eigenen Erweiterungen
		len = strlen( ext );

		//merken
		beg = &ext[len - 2];

		//am Ende das \{ löschen
		while( !( ( beg[0] == '\\' ) && ( beg[1] == '}' ) ) )
			beg--;

		//das Ende hat \}, abschneiden
		*beg = 0;

		//ausgeben
		file << ext;
	}
}


void ssLexClass::outputCPPDTran( ofstream &file )
{
	//die Übergangstabelle ausgeben, ohne Minimierung der DEA-Zustandsmenge
	DEA_STATES	*dea;
	SC_STR		*sc;
	ulong		state = 0, i;
	char		widthPuffer[512];
	int			j, k, l, width;

	//die Breite eines Zustandes bestimmen
	sprintf( widthPuffer, "%ld", DEAStatesCnt );
	width = strlen( widthPuffer );

	//Mindestbreite: 3
	if( width < 3 )
		width = 3;

	//Header ausgeben
	file << "\n//Transition-Table\n";
	file << "long SSLEXScanner::ssLexTable[SSLEX_STATE][CCLWIDTH] = \n{\n";

	//alle Zeichen ausgeben
	file << "/*\n";

	//alle Zeichen ausgeben
	for( i = j = k = 0; i < cclWidth; i++, j++, k++ )
	{
		//Alle 32 Zeichen einen Zeilenwechsel
		if( k == 32 )
		{
			//Ja
			file << "\n";
			k = 0;
		}

		//Breite setzen
		file.width( width );

		//Zeichen schreiben
		outputChar( i, widthPuffer );

		//Zeichen ist druckbar
		file << widthPuffer;

		//letztes Element?
		if( j < 127 )
			//Komma ausgeben
			file << ",";
	}

	//abschließen
	file << "\n*/\n";

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger
		sc = &scStr[i];

		//hat die SC eine Übergangstabelle für NEAen, die überall stehen dürfen?
		if( sc->DTran1 )
		{
			//Ja, ausgeben
			file << "\n//Startcondition: " << sc->name << "\n";

			//Alle Zustände dieses DEA dieser SC für NEAen, die überall stehen dürfen
			for( l = 0; l < sc->DTran1Cnt; l++ )
			{
				//ausgeben
				file << "/* " << state++ << " */\n{\n";

				//Alle Zeichen
				for( j = k = 0; j < cclWidth; j++, k++ )
				{
					//Alle 32 Zeichen einen Zeilenwechsel
					if( k == 32 )
					{
						//Ja
						file << "\n";
						k = 0;
					}

					//ausgeben
					file.width( width );
					file << sc->DTran1[l]->to[j];

					//letztes Element?
					if( j < 127 )
						//Komma ausgeben
						file << ",";
				}

				//letztes Element?
				if( state < ( DEAStatesCnt - 1 ) )
					//Komma ausgeben
					file << "\n},\n";

				else
					//Ohne Komma ausgeben
					file << "\n}\n";

				//Zustände zählen
//				state++;
			}
		}

		//hat die SC eine Übergangstabelle für NEAen, die nur am Zeilenanfang stehen dürfen?
		if( sc->DTran2 )
		{
			//Alle Zustände dieses DEA dieser SC für NEAen, die nur am Zeilenanfang stehen dürfen
			for( l = 0; l < sc->DTran2Cnt; l++ )
			{
				//Start-Zustand der NEAen ausgeben, die nur am Zeilenanfang stehen dürfen?
				if( state == sc->begLineDEAIndex )
					//Ja
					file << "/* " << "BOL-Startcondition: " << sc->name << " /*\n";

				//ausgeben
				file << "/* " << state++ << " */\n{\n";

				//Alle Zeichen
				for( j = k = 0; j < cclWidth; j++, k++ )
				{
					//Alle 32 Zeichen einen Zeilenwechsel
					if( k == 32 )
					{
						//Ja
						file << "\n";
						k = 0;
					}

					//ausgeben
					file.width( width );
					file << sc->DTran2[l]->to[j];

					//letztes Element?
					if( j < 127 )
						//Komma ausgeben
						file << ",";
				}

				//letztes Element?
				if( state < ( DEAStatesCnt - 1 ) )
					//Komma ausgeben
					file << "\n},\n";

				else
					//Ohne Komma ausgeben
					file << "\n}\n";

				//Zustände zählen
//				state++;
			}
		}
	}

	//abschließen
	file << "\n};\n";





	//Nun das Array für die Accept-Zustände erzeugen
	file << "\n//Accept-Array\n";
	file << "ulong SSLEXScanner::ssLexAccept[SSLEX_STATE] = \n{\n";

	//Alle DEA-Zustände
	for( i = 0; i < DEAStatesCnt; i++ )
	{
		//Zustand ausgeben
		file << "/* " << i << " */\n";

		//Zeiger auf Zustand
		dea = DEAStates[i];

		//Finit-Zustand?
		if( ( dea->finit == true ) && ( dea->finitNEA ) )
		{
			//Ja, reg. Text des zugehörigen NEA ausgeben
			file << "\n/* Line " << dea->finitNEA->line << ": " << dea->finitNEA->regText << " */\n";
			file << dea->index;
		}

		else
			//nein
			file << "0";

		//letzter Zustand?
		if( i < ( DEAStatesCnt - 1 ) )
			//Nein, Komma
			file << ",\n";
	}

	//abschliessen
	file << "\n};\n\n";




	//Nun das Array für die Lookahead-Zustände erzeugen
	file << "\n//Lookahead-Array\n";
	file << "ulong SSLEXScanner::ssLexLA[SSLEX_STATE] = \n{\n";

	//Alle DEA-Zustände
	for( i = 0; i < DEAStatesCnt; i++ )
	{
		//Zustand ausgeben
		file << "/* " << i << " */\n";

		//Zeiger auf Zustand
		dea = DEAStates[i];

		//Finit-Zustand?
		if( ( dea->la == true ) && ( dea->laNEA ) )
		{
			//Ja, reg. Text des zugehörigen NEA ausgeben
			file << "\n/* Line " << dea->laNEA->line << ": " << dea->laNEA->regText << " */\n";
			file << dea->index;
		}

		else
			//nein
			file << "0";

		//letzter Zustand?
		if( i < ( DEAStatesCnt - 1 ) )
			//Nein, Komma
			file << ",\n";
	}

	//abschliessen
	file << "\n};\n\n";
}



void ssLexClass::outputHHeader( ofstream &file )
{
	//das Header-File ausgeben
	SC_STR	*sc;
	ulong	i, cnt;
	char	**userDefHeader;
	int		userDefHeaderCnt, j;


file << "/***************************************************************************\n";
file << "                          sslexscanner.h  -  description\n";
file << "                             -------------------\n";
file << "    begin                : Mon Feb 24 2003\n";
file << "    copyright            : (C) 2003 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#ifndef SSLEXSCANNER_H\n";
file << "#define SSLEXSCANNER_H\n";
file << "\n";
file << "\n";

file << "/**\n";
file << "\t@author SSLEX V" << VERSION << "\n\t(c) 2002-2005 by Sven Schmidt\n\teMail: s.schmidt@lboro.ac.uk\n";
file << "  */\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug-version *\n";
		file << "****************************/\n\n\n";

		//Debug-Makro
		file << "//define debug-macro\n";
		file << "#define SSLEX_DEBUG\n";
		file << "//#undef SSLEX_DEBUG\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug-version *\n";
		file << "********************************/\n\n\n";
	}

file << "\n";
file << "using namespace std;\n";
file << "\n";
file << "#include <stdio.h>\n";
file << "#include <stdlib.h>\n";
file << "#include <iostream>\n";
file << "#include <string.h>\n";
file << "\n";
file << "\n";
file << "//type definition\n";
file << "typedef unsigned long	ulong;\n";
file << "typedef unsigned char	uchar;\n";
file << "\n";
file << "\n";


	//Header ausgeben
	file << "\n//Start-States of the different start conditions\n";

	//Alle SC
	for( i = cnt = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Index des Start-Zustandes ausgeben
		file << "#define " << sc->name << "\t" << sc->firstStart << "\n";

		//merken
		cnt++;
	}

	//abschliessen
	file << "\n\n";

	//Anzahl der Zustände
	file << "//Number of DEA-States\n#define\tSSLEX_STATE\t" << numberOfGroups << "\n\n";

	//7- oder 8-Bit-Scanner
	file << "//7- or 8-bit scanner\n#define\tCCLWIDTH\t" << cclWidth << "\n\n";

	//erlaubt Zugriff auf die Start-Condition
	file << "//current start condition\n";
	file << "#define\tYY_START\tbaseState\n";
	file << "#define\tYYSTATE\t\tYY_START\n\n";

	//Anzahl der Start-Conditionen
	file << "\n";
	file << "//number of start conditions\n";
	file << "#define scSize\t" << ( 2 * cnt ) << "\n";
	file << "\n";

	/*
		Der Benutzer kann eigene Variablen im erzeugten Header-File deklarieren, die u.U. auch
		initialisiert werden müssen.
		Dazu definiert man im %include-Teil das Makro SSLEX_INIT. Es wird dann eine Routine
		void init( void ); aufgerufen, die der Benutzer im %extension-Teil definieren muss.
		Defaultmäßig wird dies deaktiviert.
	*/
	file << "//do not inizialize user defined variables per default\n";
	file << "#undef SSLEX_INIT\n";
	file << "\n\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLEX_DEBUG\n\n";

		//Ja
		file << "//size of array with regular expressions\n";
		file << "#define regTextSize\t" << debugStrPos << "\n\n";
		file << "//Structure with debugging information\n";
		file << "typedef struct\n";
		file << "{\n";
		file << "	//DEA-State\n";
		file << "	ulong	state;\n";
		file << "\n";
		file << "	//assocciated regular expressions in this state\n";
		file << "	ulong	*index;\n";
		file << "\n";
		file << "	//number of assocciated regular expressions\n";
		file << "	ulong	indexCnt;\n";
		file << "\n";
		file << "}SSLEXDebugStr;\n";

		//Debug-Makro
		file << "#endif\n";
	}



file << "\n";
file << "class SSLEXScanner\n";
file << "{\n";
file << "public: \n";
file << "\n";
file << "	//initialize SSLEX\n";
file << "	SSLEXScanner( char *, ulong );\n";
file << "	~SSLEXScanner();\n";
file << "\n";
file << "	//Methods for public access\n";
file << "\n";
file << "	//start scanning\n";
file << "	int yyLex( SSLR_TYPE *attributeStr = 0L );\n";
file << "\n";
file << "	//return line number\n";
file << "	ulong getYYLineno( void );\n";
file << "\n";
file << "	//return length of yyText\n";
file << "	ulong getYYLeng( void );\n";
file << "\n";
file << "	//return yyText\n";
file << "	char *getYYText( void );\n";
file << "\n";
file << "	//reset the whole scanner\n";
file << "	void reset( void );\n";
file << "\n";
file << "	//reset the whole scanner and give him new input\n";
file << "	void reset( char *, ulong );\n";
file << "\n";
file << "\n";
file << "private:\n";
file << "\n";
file << "	//Base state of SSLEX, i.e. beginning state of a start condition\n";
file << "	ulong					baseState;\n";
file << "\n";
file << "	//current state\n";
file << "	ulong					state;\n";
file << "\n";
file << "	//Begin of scanning text\n";
file << "	char					*basePos;\n";
file << "\n";
file << "	//length of scanning text\n";
file << "	ulong					basePosLength;\n";
file << "\n";
file << "	//current scanning position\n";
file << "	char					*pos;\n";
file << "\n";
file << "	//end of scanning text\n";
file << "	char					*end;\n";
file << "\n";
file << "	//Position of the beginning of a lexem\n";
file << "	char					*startPos;\n";
file << " \n";
file << "	//last accepting position in scanning text\n";
file << "	char					*lastAcceptingPos;\n";
file << "\n";
file << "	//last accepting state in scanning text\n";
file << "	long					lastAcceptingState;\n";
file << "\n";
file << "	//Table for error handling\n";
file << "	static int				err[scSize][CCLWIDTH];\n";
file << "\n";
file << "	//transition table\n";
file << "	static long				ssLexTable[SSLEX_STATE][CCLWIDTH];\n";
file << "\n";
file << "	//Accept-Array\n";
file << "	static ulong			ssLexAccept[SSLEX_STATE];\n";
file << "\n";

	//Gab es Lookahead-NEAen?
	if( laUsed == true )
	{
		//Ja, ausgeben
file << "	//Position of last occurence of a lookahead state\n";
file << "	char					*lastLAPos;\n";
file << "\n";
file << "	//Lookahead-Array\n";
file << "	static ulong 			ssLexLA[SSLEX_STATE];\n";
file << "\n";
	}

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "#ifdef SSLEX_DEBUG\n";

		//Ja
		file << "	//structure with debugging info\n";
		file << "	static SSLEXDebugStr	debugStr[SSLEX_STATE];\n";
		file << "\n";
		file << "	//array with the regular expressions in text form\n";
		file << "	static char				*regText[regTextSize];\n";
		file << "\n";
		file << "	//Array with indices in regText\n";
		file << "	static ulong			*regTextIndex[SSLEX_STATE];\n";
		file << "\n";

		//die Indices in regText ausgeben
		file << "	//Array with indices in regText\n";

		//Alle Gruppen
		for( i = 0; i < numberOfGroups; i++ )
		{
			//die Indices in regText ausgeben
			file << "	static ulong	regTextIndex" << i << "[];";
			file << "\n";
		}

		file << "\n";
		file << "	//Array with regular expression at accepting\n";
		file << "	static char				*acceptRegText[SSLEX_STATE];\n";

		//Debug-Makro
		file << "#endif\n\n";
	}


file << "	//name of the start conditions\n";
file << "	static char				*scName[SSLEX_STATE];\n";
file << "\n";
file << "	//state of start conditions\n";
file << "	static ulong			scIndex[];\n";
file << "\n";
file << "	//memory for yyText\n";
file << "	ulong					yyTextLen;\n";
file << "\n";
file << "	//yyText: holds the accepted lexem\n";
file << "	char					*yyText;\n";
file << "\n";
file << "	//length of yyText\n";
file << "	ulong					yyLeng;\n";
file << "\n";
file << "	//SSLEX automatically counts line numbers\n";
file << "	ulong					yyLineno;\n";
file << "\n";
file << "	//concatenate token\n";
file << "	bool					concatenate;\n";
file << "\n";
file << "	//size of start condition stack\n";
file << "	ulong					scStackSize;\n";
file << "\n";
file << "	//numer of start xonditions on stack\n";
file << "	long					scStackPos;\n";
file << "\n";
file << "	//start condition stack\n";
file << "	ulong					*scStack;\n";
file << "\n";
file << "\n";

	//benutzerdefinierte Daten holen
	userDefHeader = s->getUserDefHeader( userDefHeaderCnt );

	//alle Zeilen
	for( j = 0; j < userDefHeaderCnt; j++ )
		//ausgeben
		file << userDefHeader[j];


file << "\n";
file << "\n";
file << "private:\n";
file << "\n";
file << "	//insert text in yytext\n";
file << "	void setupyyText( void );\n";
file << "\n";
file << "	//setup yyLineno\n";
file << "	void setupYYLineno( char *, char * );\n";
file << "\n";
file << "	//setup state for begin-of-line-rules\n";
file << "	ulong setupState( ulong );\n";
file << "\n";
file << "	//set a new start condition\n";
file << "	void setStartCondition( ulong );\n";
file << "\n";
file << "	//return txt in it's own memory\n";
file << "	char *yyStrCpy( char *txt );\n";
file << "\n";
file << "	//returns all but the first n characters of yyText back to the input\n";
file << "	void yyLess( int );\n";
file << "\n";
file << "	//enlarge start condition stack\n";
file << "	void enlargeSCStack( void );\n";
file << "\n";
file << "	/*\n";
file << "		Pushes the current start condition onto the top of the start condition stack\n";
file << "		and switches to newState as though you have used BEGIN( newState ).\n";
file << "	*/\n";
file << "	void yyPushState( ulong );\n";
file << "\n";
file << "	//pops the top of the start condition stack and switches to it\n";
file << "	void yyPopState( void );\n";
file << "\n";
file << "	//returns the top of the start condition stack without altering its contents\n";
file << "	ulong yyTopState( void );\n";
file << "\n";
file << "	//puts the character c back to the input stream\n";
file << "	void yyUnput( unsigned char );\n";
file << "	void yyUnput( char * );\n";
file << "\n";
file << "	//return the next character to be scanned\n";
file << "	char yyInput( void );\n";
file << "\n";
file << "	//call eof-rules\n";
file << "	int endOfLine( void );\n";
file << "\n";
file << "	//handle simple errors\n";
file << "	void error( uchar c );\n";
file << "\n";
file << "	//set some stuff before a new rule is scanned\n";
file << "	void yyDoBeforeRule( void );\n";


	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Makro ausgeben
		file << "\n#ifdef SSLEX_DEBUG";

		//Ja
		file << "\n";
		file << "	//print debugging information\n";
		file << "	void mainDebug( unsigned char );\n";
		file << "\n";
		file << "	//print debugging information\n";
		file << "	void shiftDebug( unsigned char );\n";
		file << "\n";
		file << "	//print debugging information\n";
		file << "	void acceptDebug( void );\n";
		file << "\n";
		file << "	//copy cnt bytes from from to to, but transform escape sequences into\n";
		file << "	//readable text form\n";
		file << "	void txtFilter( char *, char *, ulong );\n";

		//Debug-Makro
		file << "#endif\n";
	}


file << "};\n";
file << "\n";
file << "#endif\n";
}


void ssLexClass::generateFiles( void )
{
	//Hier werden die Klassenfiles des Scanners erzeugt.
	ofstream	cppFile( "sslexscanner.cpp" );
	ofstream	hFile( "sslexscanner.h" );

	//Meldung?
	if( argv_str->verbose == true )
		//Meldung
		cout << "sslex: Generating output files...\n";

	//den Header für das CPP-File ausgeben
	outputCPPHeader( cppFile );

	//etwaige Include-Anweisungen einfügen
	outputIncl( cppFile );

	//die Übergangstabelle ausgeben
#ifdef MINDEA
	outputCPPMinDEA( cppFile );
#else
	outputCPPDTran( cppFile );
#endif

	//Debug-Informationen ausgeben?
	if( argv_str->debug == true )
		//die Debug-Strukturen ausgeben
		outputCPPDebug( cppFile );

	//Aktionen ausgeben
	outputAction( cppFile );

	//<<EOF>>-NEAen ausgeben
	outputEOF( cppFile );

	//etwaige eigene Erweiterungen einfügen
	outputExt( cppFile );

	//das Header-File ausgeben
	outputHHeader( hFile );
}


void ssLexClass::outputChar( uchar c, char *dest )
{
	//gibt ein Zeichen aus, insbesondere die nicht-druckbaren in lesbarer Form
	char	*transChar[] = {
	  "\\0",   "\\1",   "\\2",   "\\3",   "\\4",   "\\5",   "\\6",  "\\a",  "\\b",  "\\t",  "\\n",  "\\v",
	 "\\f",  "\\r", "0x0e", "0x0f", "0x10", "0x11", "0x12", "0x13", "0x14", "0x15", "0x16", "0x17",
	"0x18", "0x19", "0x1a", "0x1b", "0x1c", "0x1d", "0x1e", "0x1f",    " ",    "!",   "\"",    "#",
	   "$",    "%",    "&",    "'",    "(",    ")",    "*",    "+",    ",",    "-",    ".",    "/",
	   "0",    "1",    "2",    "3",    "4",    "5",    "6",    "7",    "8",    "9",    ":",    ";",
	   "<",    "=",    ">",    "?",    "@",    "A",    "B",    "C",    "D",    "E",    "F",    "G",
	   "H",    "I",    "J",    "K",    "L",    "M",    "N",    "O",    "P",    "Q",    "R",    "S",
	   "T",    "U",    "V",    "W",    "X",    "Y",    "Z",    "[",   "\\",    "]",    "^",    "_",
	   "`",    "a",    "b",    "c",    "d",    "e",    "f",    "g",    "h",    "i",    "j",    "k",
	   "l",    "m",    "n",    "o",    "p",    "q",    "r",    "s",    "t",    "u",    "v",    "w",
	   "x",    "y",    "z",    "{",    "|",    "}",    "~",   "DEL",
	   "128",  "129",  "130",  "131",  "132",  "133",  "134",  "135",  "136",  "137",   "138", "139",
	   "140",  "141",  "142",  "143",  "144",  "145",  "146",  "147",  "148",  "149",   "150", "151",
	   "152",  "153",  "154",  "155",  "156",  "157",  "158",  "159",  "160",  "161",   "162", "163",
	   "164",  "165",  "166",  "167",  "168",  "169",  "170",  "171",  "172",  "173",   "174", "175",
	   "176",  "177",  "178",  "179",  "180",  "181",  "182",  "183",  "184",  "185",   "186", "187",
	   "188",  "189",  "190",  "191",  "192",  "193",  "194",  "195",  "196",  "197",   "198", "199",
	   "200",  "201",  "202",  "203",  "204",  "205",  "206",  "207",  "208",  "209",   "210", "211",
	   "212",  "213",  "214",  "215",  "216",  "217",  "218",  "219",  "220",  "221",   "222", "223",
	   "224",  "225",  "226",  "227",  "228",  "229",  "230",  "231",  "232",  "233",   "234", "235",
	   "236",  "237",  "238",  "239",  "240",  "241",  "242",  "243",  "244",  "245",   "246", "247",
	   "248",  "249",  "250",  "251",  "252",  "253",  "254" };

	//Zeichen eintragen
	strcpy( dest, transChar[c] );
}


GROUP_STR *ssLexClass::createGROUP( void )
{
	//eine neue Gruppe für die Zustandsminimierung erzeugen
	GROUP_STR	*tmp;

	//Speicher anfordern
	tmp = new( GROUP_STR );

	//initialisieren
	memset( tmp, 0, sizeof( GROUP_STR ) );

	//beinhaltet keinen Finit-Zustand
	tmp->finit = false;

	//beinhaltet keinen Lookahead-Zustand
	tmp->la = false;

	//Gruppe ist valid
	tmp->valid = true;

	//kein Start-Zustand
	tmp->startGroup = false;

	//zurückliefern
	return( tmp );
}


void ssLexClass::deleteGROUP( GROUP_STR *groupStr )
{
	//eine Gruppe löschen

	//sind DEA-Zustände eingetragen?
	if( groupStr->DEAIndex )
		//ja, Speicher freigeben
		delete[] ( groupStr->DEAIndex );

	//Speicher freigeben
	delete( groupStr );
}


void ssLexClass::insertGROUP( GROUP_STR *groupStr, ulong index )
{
	//einen DEA-Index zu einer Gruppe hinzufügen
	DEA_STATES	*dea = DEAStates[index];
	ulong		*tmp;
	ulong		i;

	/*
		ACHTUNG: In insertGROUP wird in die DEA-Struktur des einzutragenden
		DEA-Zustand der Gruppen-Index eingetragen. So kann man leicht feststellen,
		in welcher Gruppe ein DEA-Zustand ist!
	*/


	//Ist dieser Zustand bereits in der Gruppe?
	for( i = 0; i < groupStr->DEAIndexCnt; i++ )
	{
		//Zustand?
		if( groupStr->DEAIndex[i] == index )
			//Ja
			break;
	}

	//gleich?
	if( i == groupStr->DEAIndexCnt )
	{
		//genug Speicher
		tmp = new( ulong[groupStr->DEAIndexCnt + 1] );

		//umkopieren
		memcpy( tmp, groupStr->DEAIndex, sizeof( ulong ) * groupStr->DEAIndexCnt );

		//alten Speicher löschen
		if( groupStr->DEAIndex )
			delete[] ( groupStr->DEAIndex );

		//eintragen
		groupStr->DEAIndex = tmp;

		//an letzter Stelle eintragen
		groupStr->DEAIndex[groupStr->DEAIndexCnt] = index;

		//Gruppen-Index eintragen
		dea->groupIndex = groupStr->index;

		//Ist es ein Finit-Zustand?
		if( dea->finit == true )
		{
			//setzen
			groupStr->finit = true;

			//NEA in Gruppe eintragen
			groupStr->finitNEA = dea->finitNEA;
		}

		//Ist es ein Lookahead-Zustand?
		if( dea->la == true )
		{
			//setzen
			groupStr->la = true;

			//DEA-Index merken
			groupStr->laIndex = index;
		}

		//ein Zustand weiter
		groupStr->DEAIndexCnt++;
	}
}

/*
void ssLexClass::moveGROUP( GROUP_STR *from, GROUP_STR *to )
{
	//eine Gruppe kopieren
	ulong	i;

	//Alle Zustände
	for( i = 0; i < from->DEAIndexCnt; i++ )
		//eintragen
		insertGROUP( to, from->DEAIndex[i] );

	//Eigenschaften übertragen
	to->finit = from->finit;
	to->finitNEA = from->finitNEA;
	to->la = from->la;
	to->startGroup = from->startGroup;
	to->valid = from->valid;

	//eine invalide Gruppe darf hier nicht bearbeitet werden
	assert( from->valid == true );
}
*/

void ssLexClass::fixGROUP( GROUP_STR *from, GROUP_STR *to )
{
	//die speziellen Eigenschaften einer Gruppe übernehmen
	to->finit = from->finit;
	to->finitNEA = from->finitNEA;
	to->la = from->la;
	to->valid = from->valid;

	//eine invalide Gruppe darf hier nicht bearbeitet werden
	assert( from->valid == true );

	/*
		WICHTIG: Da nur eine Gruppe den Start-Zustand haben kann, darf diese Eigenschaft NICHT
		vererbt werden!
	*/
}


void ssLexClass::removeGROUP( GROUP_STR *groupStr, ulong index )
{
	//einen DEA-Index aus einer Gruppe löschen
	ulong	i;

	//Alle DEA-Zustände
	for( i = 0; i < groupStr->DEAIndexCnt; i++ )
	{
		//vergleichen
		if( groupStr->DEAIndex[i] == index )
		{
			//Ja, löschen
			memmove( &groupStr->DEAIndex[i], &groupStr->DEAIndex[i+1], sizeof( ulong ) * ( groupStr->DEAIndexCnt - i - 1 ) );

			//Anzahl der Zustände korrigieren
			groupStr->DEAIndexCnt--;

			//Ende
			break;
		}
	}
}


void ssLexClass::outputGROUP( GROUP_STR *groupStr )
{
	//eine Gruppe ausgeben
	ulong	j, l;
	char	widthPuffer[10];
	int		width;

	//Breite bestimmen
	sprintf( widthPuffer, "%ld", DEAStatesCnt );
	width = strlen( widthPuffer );

	//Gruppen-Index ausgeben
	cout << "\nGruppe: " << groupStr->index << ", ";

	//Gruppe mit Startzustand?
	if( groupStr->startGroup == true )
		//Ja
		cout << "Startgruppe, ";

	//eine Gruppe mit akzeptierenden Zuständen?
	if( groupStr->finit == true )
		//Ja
		cout << "akzeptierend, " << groupStr->finitNEA->regText << "\n";

	else
		//nein
		cout << "nicht-akzeptierend\n";

	//Meldung
	cout << "Zustände dieser Gruppe:\n";

	//Alle Zustände dieser Gruppe
	for( l = j = 0; l < groupStr->DEAIndexCnt; l++, j++ )
	{
		//neue Zeile?
		if( j == 20 )
		{
			//Ja
			cout << "\n";
			j = 0;
		}

		//Breite setzen
		cout.width( width + 1 );
		cout << groupStr->DEAIndex[l];
	}

	//Platz lassen
	cout << "\n\n";
}


void ssLexClass::checkGROUP( SC_STR *sc, GROUP_STR **grpStr, ulong grpStrCnt )
{
	//tote Zustände finden
	DEA_STATES	*dea, *destDEA;
	GROUP_STR	*grp, *destGrp;
	DTRAN		*dt;
	ulong		*transTable, i, max;
	ulong		*stack, stackPos = 0, *marked, index;
	ulong		grpIndex, destGrpIndex, repState, destState;
	ulong		base1State, end1State, base2State, end2State;
	int			k, l, dead, invalid, changed;

	//Anfangs- und Endzustand der NEAen, die überall stehen dürfen
	base1State = sc->DEAIndex;
	end1State = base1State + sc->DTran1Cnt - 1;

	//Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen dürfen
	base2State = sc->begLineDEAIndex;
	end2State = base2State + sc->DTran2Cnt - 1;


	//Zeiger der letzten Gruppe
	grp = grpStr[grpStrCnt - 1];

	//maximalen Index merken
	max = grp->index + 1;

	//Speicher für die Umwandlung der Gruppen-Indeces
	transTable = new( ulong[max] );

	//initialisieren
	memset( transTable, max, sizeof( ulong ) * max );

	//Alle Gruppen
	for( i = 0; i < grpStrCnt; i++ )
	{
		//Zeiger auf Gruppe
		grp = grpStr[i];

		//Gruppen-Index eintragen
		transTable[grp->index] = i;
	}


	//Speicher für den Zustands-Stack
	stack = new( ulong[DEAStatesCnt] );

	//Speicher zum markieren der Grupppen
	marked = new( ulong[max] );

	//initialisieren
	memset( marked, 0, sizeof( ulong ) * max );

	do
	{
		//Repräsentativen Zustand aus der Gruppe mit dem Startzustand pushen.
		stack[stackPos++] = base1State;
		stack[stackPos++] = base2State;

		//zurücksetzen
		changed = 0;

		//solange Zustände da sind
		while( stackPos )
		{
			//Zustand holen
			index = stack[--stackPos];

			//Zeiger auf DEA-Struktur
			dea = DEAStates[index];

			//Gruppen-Index von index
			grpIndex = dea->groupIndex;

			//grpIndex darf nicht > max sein
			assert( grpIndex < max );

			//ist die Gruppe bereits markiert?
			if( !marked[transTable[grpIndex]] )
			{
				//nein, markieren und prüfen
				marked[transTable[grpIndex]]++;

				//Zeiger auf diese Gruppe
				grp = grpStr[transTable[grpIndex]];

				//repräsentativen Zustand aus dieser Gruppe holen
				repState = grp->DEAIndex[0];

				//Zeiger auf Übergangs-Tabelle dieses Zustands
				if( repState <= end1State )
					dt = sc->DTran1[repState - base1State];

				else
					dt = sc->DTran2[repState - base2State];

				//für Übergänge zu toten Zuständen
				dead = 0;

				//für Übergänge zu invaliden Gruppen
				invalid = 0;

				//Alle Zeichen
				for( k =0; k < cclWidth; k++ )
				{
					//Ziel-Zustand holen
					destState = dt->to[k];

					//DEA-Struktur
					destDEA = DEAStates[destState];

					//Gruppen-Index dieses Zustands
					destGrpIndex = destDEA->groupIndex;

					//Zeiger auf Gruppe
					destGrp = grpStr[transTable[destGrpIndex]];

					//schon markiert?
					if( !marked[transTable[destGrpIndex]] )
					{
						//Nein, schon auf Stack?
						for( l = 0; l < stackPos; l++ )
						{
							//gleich?
							if( stack[l] == destState )
								//schon auf dem Stack
								break;
						}

						//War der Zustand schon auf dem Stack?
						if( l == stackPos )
							//Nein, eintragen
							stack[stackPos++] = destState;
					}

					//gleiche Gruppe?
					if( destGrpIndex == grpIndex )
						//ja
						dead++;

					//Ziel-Gruppe invalid?
					if( destGrp->valid == false )
						//Ja, merken
						invalid++;
				}

				//Übergänge zur selben Gruppe für alle Zeichen?
				if( ( dead == cclWidth ) && ( grp->finit == false ) && ( grp->startGroup == false ) )
				{
					//Ja, Gruppe ist invalid
					grp->valid = false;

					//invalide Gruppen werden übersprungen und zählen daher nicht (Ausnahme sind Gruppen,
					//die Startzustände beinhalten)
					numberOfGroups--;
				}

				//alle Übergänge zu einer invaliden Gruppe?
				if( ( invalid == cclWidth ) && ( grp->finit == false ) )
				{
					//Ja, Gruppe ist invalid
					grp->valid = false;

					//invalide Gruppen werden übersprungen und zählen daher nicht (Ausnahme sind Gruppen,
					//die Startzustände beinhalten)
					numberOfGroups--;

					//nochmal, für die Sprünge zu dieser Gruppe
					changed++;
				}
			}
		}

	}while( changed );

	//wurden alle Gruppen markiert?
	for( i = 0; i < grpStrCnt; i++ )
	{
		//Zeiger auf Gruppe
		grp = grpStr[i];

		//markiert und keine Gruppe, die einen Startzustand enthält?
		if( !marked[transTable[grp->index]] )
		{
			//nein, Meldung ausgeben
			cout << "ssLexClass::checkGROUP: SC " << sc->name << ": Group " << grp->index << " not marked!\n";

			//invalide Gruppen werden ünersprungen und zählen daher nicht
			numberOfGroups--;

			//invalide Gruppe
			grp->valid = false;
		}
	}

	//Speicher freigeben
	delete[] ( transTable );
	delete[] ( stack );
	delete[] ( marked );
}


void ssLexClass::minDEA( void )
{
	/*
		Hier wird die DEA-Zustandsmenge minimiert, wie es im Drachen, S. 172 beschrieben ist.

		Die Startzustände der NEAen, die überall stehen dürfen, sowie die derer, die nur am Zeilenanfang
		stehen dürfen, kommen auf JEDEN Fall in zwei unterschiedliche Gruppen. Somit können sie nicht in
		einem Zustand zu liegen kommen. Wichtig ist zu beachten, dass einer von beiden, oder gar beide,
		Finit-Zustände sein können. Und trotzdem MÜSSEN sie in unterschiedliche Gruppe liegen.
	*/
	DEA_STATES	*dea;
	GROUP_STR	**stack, *acceptGroup, *aGrp, *nGrp, *stGrp;
	GROUP_STR	*firstGroup, *secondGroup, *nonAcceptGroup;
	NEA_STR		*nea;
	SC_STR		*sc;
	ulong		stackPos = 0, refDest, dest;
	ulong		base1State, end1State, base2State, end2State;
	ulong		groupCnt, state;
	ulong		*tmpStack, tmpStackCnt;
	DTRAN		**DTran1, **DTran2, *d, *dt, *refDTran;
	uchar		c;
	char		hexChar[10];
	int			i, j, k, l, changed;

	//Meldung?
	if( argv_str->verbose == true )
		//Meldung
		cout << "sslex: Minimizing dea states...\n";

	//den maximalen Gruppenindex merken
	maxGroupIndex = 0;

	//auf dem Stack werden die Gruppen abgelegt
	stack = new( GROUP_STR *[DEAStatesCnt + 1] );

	/*
		Problem: Seien die Zustände 13, 24, 36 und 47 zusammen in einer Gruppe. Zustände 24 und 47 seien
		äquivalent. Es gilt (13,\n)=24 und (36,\n)=47. Wird nun Zustand 10 aus der Gruppe gelöscht,
		dann sind 10 und 47 kurzzeitig in verschiedene Gruppen. Der Test (13,\n)=24 und (36,\n)=47
		führt dann dazu, dass die Zustände 13 und 36 getrennt werden, obwohl sie zu Zuständen übergehen,
		die eigentlich in eine Gruppe gehören.

		Abhilfe: Die zu trennenden Zustände werden erst auf einen extra Stack geschoben. Erst, nachdem
		alle anderen Zustände der Gruppe getestet wurden, werden die zu löschenden Zustände auch wirklich
		entfernt. So werden die Verhältnisse während des Tests nicht verfälscht!
	*/
	tmpStack = new( ulong[DEAStatesCnt] );

	//noch keine Gruppe erzeugt
	numberOfGroups = 0;


	//Alle Start-Conditionen
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//Gruppen-Zähler
		groupCnt = 0;

		//Stack-Position zurücksetzen
		stackPos = 0;

		//Anfangs- und Endzustand der NEAen, die überall stehen dürfen
		base1State = sc->DEAIndex;
		end1State = base1State + sc->DTran1Cnt - 1;

		//Anfangs- und Endzustand der NEAen, die nur am Zeilenanfang stehen dürfen
		base2State = sc->begLineDEAIndex;
		end2State = base2State + sc->DTran2Cnt - 1;


		//reduzierte Übergangstabelle
		DTran1 = sc->DTran1;

		//Alle Zustände, die für k keinen Übergang haben, bekommen ihn für d
		for( l = 0; l < sc->DTran1Cnt; l++ )
		{
			//Zeiger auf DTran
			dt = DTran1[l];

			//Alle Übergänge
			for( k = 0; k < cclWidth; k++ )
			{
				//kein Übergang?
				if( dt->to[k] == -1 )
					//Ja, Übergang zu toten Zustand d
					dt->to[k] = end1State;
			}
		}


		//reduzierte Übergangstabelle
		DTran2 = sc->DTran2;


		//Alle Zustände, die für k keinen Übergang haben, bekommen ihn für d
		for( l = 0; l < sc->DTran2Cnt; l++ )
		{
			//Zeiger auf DTran
			dt = DTran2[l];

			//Alle Übergänge
			for( k = 0; k < cclWidth; k++ )
			{
				//kein Übergang?
				if( dt->to[k] == -1 )
					//Ja, Übergang zu toten Zustand d
					dt->to[k] = end2State;
			}
		}


		/*
			An dieser Stelle werden die Gruppen für die Zustandsminimierung erzeugt.
			Genauso wie es sich bei DEA-Zuständen um eine Menge von NEA-Zuständen handelt, handelt
			es sich bei einer Gruppe um eine Menge von DEA-Zuständen.

			In der ersten Gruppe befindet sich der Startzustand für die NEAen, die überall stehen
			dürfen. In der zweiten Gruppe befindet sich der Startzustand der NEAen, die nur
			am Zeilenanfang stehen dürfen.
			Alle DEA-Finit-Zustände, die zu ein und demselben NEA gehören, kommen zusammen in eine
			Gruppe. WICHTIG: die kann auch die erste oder zweite Gruppe sein, wenn der entsprechende
			Start-Zustand zugleich ein Finit-Zustand ist.

			Hat eine SC keine NEAen, werden nur die Dummy-DEA-Zustanände eingetragen. Sie haben für
			alle Eingabezeichen KEINE Übergänge, führen also zu Fehlermeldungen während des
			Scannings und können so wertvolle Hilfe beim Debuggen liefern.
			Hat eine SC keine NEAen, die überall stehen dürfen bzw. hat sie nur welche, die am
			Zeilenanfang stehen dürfen, so hat die erste Gruppe nur einen Dummy-Zustand.
		*/

		//Gruppe mit den nicht-akzeptierenden Zuständen
		nonAcceptGroup = 0L;


		//erste Gruppe mit den Startzustand der NEAen, die überall stehen dürfen
		firstGroup = createGROUP();

		//den Index der Gruppe setzen
		firstGroup->index = groupCnt++;

		//den Startzustand in die Gruppe eintragen
		insertGROUP( firstGroup, base1State );

		//Gruppe beinhaltet den Startzustand
		firstGroup->startGroup = true;

		//auf den Stack
		stack[stackPos++] = firstGroup;

		//ist der Startzustand ein Finit-Zustand?
		if( firstGroup->finit == false )
			//Ja, alle anderen nicht-akzeptierenden Zustände in diese Gruppe eintragen
			nonAcceptGroup = firstGroup;


		//zweite Gruppe mit dem Startzustand der NEAen, die nur am Zeilenanfang stehen dürfen
		secondGroup = createGROUP();

		//den Index der Gruppe setzen
		secondGroup->index = groupCnt++;

		//den Startzustand in die Gruppe eintragen
		insertGROUP( secondGroup, base2State );

		//Gruppe beinhaltet den Startzustand
		secondGroup->startGroup = true;

		//auf den Stack
		stack[stackPos++] = secondGroup;

		//ist der Startzustand ein Finit-Zustand?
		if( !nonAcceptGroup && ( secondGroup->finit == false ) )
			//Ja, alle anderen nicht-akzeptierenden Zustände in diese Gruppe eintragen
			nonAcceptGroup = secondGroup;

		else if( !nonAcceptGroup )
		{
			//jeweils beide Startzustände sind zugleich Finit-Zustände
			nonAcceptGroup = createGROUP();

			//den Index der Gruppe setzen
			nonAcceptGroup->index = groupCnt++;

			//auf den Stack
			stack[stackPos++] = nonAcceptGroup;

			//Gruppen zählen
			numberOfGroups++;
		}

		//Zahl der erzeugten Gruppen
		numberOfGroups += 2;





		/*
			Die Finit-Zustände der NEAen, die überall stehen dürfen, kommen in eine Gruppe, die alle
			zum selben NEA gehören.
			Jeder NEA hat genau einen Finit-Zustand!
		*/
		for( l = base1State; l <= end1State; l++ )
		{
			//DEA-Zustand
			dea = DEAStates[l];

			//akzeptierender Zustand?
			if( dea->finit == true )
			{
				//entsprechenden NEA holen
				nea = dea->finitNEA;

				//Ist die Gruppe auf dem Stack?
				for( j = 0; j < stackPos; j++ )
				{
					//Zeiger auf Gruppe
					acceptGroup = stack[j];

					//richtige Gruppe?
					if( acceptGroup->finitNEA == nea )
					{
						//Ja, hier eintragen
						insertGROUP( acceptGroup, l );

						//Schleife verlassen
						break;
					}
				}

				//war die Gruppe auf dem Stack?
				if( j == stackPos )
				{
					//Nein, Gruppe erzeugen
					acceptGroup = createGROUP();

					//Index setzen
					acceptGroup->index = groupCnt++;

					//Ja, hier eintragen
					insertGROUP( acceptGroup, l );

					//NEA eintragen
					acceptGroup->finitNEA = nea;

					//ist eine Gruppe mit akzeptierenden Zuständen
					acceptGroup->finit = true;

					//auf Stack
					stack[stackPos++] = acceptGroup;

					//Zahl der erzeugten Gruppen
					numberOfGroups++;
				}
			}

			else
				//nicht-akzeptierender Zustand
				insertGROUP( nonAcceptGroup, l );
		}




		/*
			Die Finit-Zustände der NEAen, die nur am Zeilenanfang stehen dürfen, kommen in eine Gruppe,
			die alle zum selben NEA gehören.
			Jeder NEA hat genau einen Finit-Zustand!
		*/
		for( l = base2State; l <= end2State; l++ )
		{
			//DEA-Zustand
			dea = DEAStates[l];

			//akzeptierender Zustand?
			if( dea->finit == true )
			{
				//entsprechenden NEA holen
				nea = dea->finitNEA;

				//Ist die Gruppe auf dem Stack?
				for( j = 0; j < stackPos; j++ )
				{
					//Zeiger auf Gruppe
					acceptGroup = stack[j];

					//richtige Gruppe?
					/*
						Der Startzustand der NEAen, die nur am Zeilenanfang stehen dürfen, darf nicht
						in Gruppe j=0 eingetragen werden, denn dort steht der Startzustand der NEAen, die
						überall stehen dürfen!
					*/
					if( ( acceptGroup->finitNEA == nea ) && j )
					{
						//Ja, hier eintragen
						insertGROUP( acceptGroup, l );

						//Schleife verlassen
						break;
					}
				}

				//war die Gruppe auf dem Stack?
				if( j == stackPos )
				{
					//Nein, Gruppe erzeugen
					acceptGroup = createGROUP();

					//Index setzen
					acceptGroup->index = groupCnt++;

					//Ja, hier eintragen
					insertGROUP( acceptGroup, l );

					//NEA eintragen
					acceptGroup->finitNEA = nea;

					//ist eine Gruppe mit akzeptierenden Zuständen
					acceptGroup->finit = true;

					//auf Stack
					stack[stackPos++] = acceptGroup;

					//Zahl der erzeugten Gruppen
					numberOfGroups++;
				}
			}

			else
			{
				//nicht-akzeptierender Zustand

				//Startzustand der NEAen, die nur am Zeilenanfang stehen dürfen?
				//dieser ist ja bereits in der zweiten Gruppe enthalten und darf nicht in eine
				//andere Gruppe eingetragen werden.
				if( l != base2State )
					//Nein
					insertGROUP( nonAcceptGroup, l );
			}
		}




		//Zustandsgruppen trennen
		do
		{
			//keine Änderungen
			changed = 0;
#ifdef DEBUG
			//Gruppen ausgeben
			for( j = 0; j < stackPos; j++ )
			{
				//Zeiger auf Gruppe
				stGrp = stack[j];

				//Meldung
				outputGROUP( stGrp );
			}
#endif

			//Alle Gruppen
			for( j = 0; j < stackPos; j++ )
			{
				/*
					Zustände werden nicht unmittelbar aus einer Gruppe gelöscht. Sie werden erst in tmpStack
					eingetragen und erst NACH dem kompletten Test aller Zustände einer Gruppe aus dieser
					gelöscht. S. oben!
				*/
				tmpStackCnt = 0;


				//neue Gruppe erzeugen für akzeptierende Zustände
				aGrp = createGROUP();
				aGrp->index = groupCnt++;

				//neue Gruppe erzeugen für nicht-akzeptierende Zustände
				nGrp = createGROUP();
				nGrp->index = groupCnt++;

				//Zeiger auf Gruppe
				stGrp = stack[j];


				//alle Zustände dieser Gruppe mit dem ersten vergleichen
				//gehört der Referenzzustand zu den NEAen, die überall stehen dürfen?
				if( stGrp->DEAIndex[0] <= end1State )
					//Ja
					refDTran = DTran1[stGrp->DEAIndex[0] - base1State];

				else
					//Nein, gehört zu den NEAen, die nur am Zeilenanfang stehen dürfen
					refDTran = DTran2[stGrp->DEAIndex[0] - base2State];

				//die Zustandsübergänge des Referenzzustands mit allen anderen in seiner
				//Gruppe vergleichen
				for( l = 1; l < stGrp->DEAIndexCnt; l++ )
				{
					//Zeiger auf DTran
					if( stGrp->DEAIndex[l] <= end1State )
						//Zustand gehört zu den NEAen, die überall stehen dürfen
						d = DTran1[stGrp->DEAIndex[l] - base1State];

					else
						//Zustand gehört zu den NEAen, die nur am Zeilenanfang stehen dürfen
						d = DTran2[stGrp->DEAIndex[l] - base2State];

					//Alle Zustandsübergänge
					for( k = 0; k < cclWidth; k++ )
					{
						//für Debug-Zwecke
						c = k;

						//Ziel-Gruppe von Zustand 1
						refDest = DEAStates[refDTran->to[k]]->groupIndex;

						//Ziel-Gruppe von Zustand l
						dest = DEAStates[d->to[k]]->groupIndex;

						//ungleich?
						if( refDest != dest )
						{
#ifdef DEBUG
							//Zeichen ausgeben
							outputChar( c, hexChar );

							//Debug-Meldung
							cout << "Gruppe " << stGrp->index << ":\n";
							cout << "(" << stGrp->DEAIndex[0] << "," << hexChar << ")=" << refDTran->to[k] << " in " << refDest << "\n";
							cout << "(" << stGrp->DEAIndex[l] << "," << hexChar << ")=" << d->to[k] << " in " << dest << "\n";

//							cout << c << ": insert Zustand " << stGrp->DEAIndex[l] << " in  Gruppe " << grp->index << "...\n";
							cout << c << ": delete Zustand " << stGrp->DEAIndex[l] << " aus Gruppe " << stGrp->index << "...\n\n";
#endif
							/*
								ACHTUNG: In insertGROUP wird in die DEA-Struktur des einzutragenden
								DEA-Zustands der Gruppen-Index eingetragen. So kann man leicht feststellen,
								in welcher Gruppe ein DEA-Zustand ist!
							*/
							tmpStack[tmpStackCnt++] = stGrp->DEAIndex[l];

							//raus aus der k Schleife
							break;
						}
					}
				}

				/*
					Jetzt sind alle Zustände der Gruppe geprüft. Nun die zu löschenden Zustände
					auch wirklich aus der Gruppe entfernen.
				*/
				for( k = 0; k < tmpStackCnt; k++ )
				{
					//Zustand holen
					state = tmpStack[k];

					//Ist es ein akzeptierender Zustand?
					if( DEAStates[state]->finit == true )
						//in die Gruppe der akzeptierenden Zustände eintragen
						insertGROUP( aGrp, state );

					else
						//in die Gruppe der nicht-akzeptierenden Zustände eintragen
						insertGROUP( nGrp, state );

					//Zustand aus Gruppe löschen
					removeGROUP( stGrp, state );
				}


				//wurde eine Gruppe aufgespalten?
				if( !aGrp->DEAIndexCnt )
					//Nein, Speicher freigeben
					deleteGROUP( aGrp );

				else
				{
					//Ja, Gruppe auf Stack
					stack[stackPos++] = aGrp;

					//die speziellen Eigenschaften der Gruppe aktGrp übernehmen
					fixGROUP( stGrp, aGrp );

					//Zahl der erzeugten Gruppen
					numberOfGroups++;

					//markieren
					changed++;
				}

				//wurde eine Gruppe aufgespalten?
				if( !nGrp->DEAIndexCnt )
					//Nein, Speicher freigeben
					deleteGROUP( nGrp );

				else
				{
					//Ja, Gruppe auf Stack
					stack[stackPos++] = nGrp;

					//die speziellen Eigenschaften der Gruppe aktGrp übernehmen
					fixGROUP( stGrp, nGrp );

					//Zahl der erzeugten Gruppen
					numberOfGroups++;

					//markieren
					changed++;
				}
			}

		}while( changed );

		//größten Gruppenindex nehmen
		maxGroupIndex = ( groupCnt > maxGroupIndex ) ? groupCnt : maxGroupIndex;

#ifdef DEBUG
		//Gruppen ausgeben
		for( j = 0; j < stackPos; j++ )
		{
			//Zeiger auf Gruppe
			stGrp = stack[j];

			//Meldung
			outputGROUP( stGrp );
		}
#endif

		//Gruppe überprüfen
		checkGROUP( sc, stack, stackPos );

		//Gruppen in die SC eintragen
		sc->grp = new( GROUP_STR *[stackPos] );

		//Zeiger auf die Gruppen-Strukturen
		for( j = 0; j < stackPos; j++ )
			//Zeiger auf Gruppe
			sc->grp[j] = stack[j];

		//Anzahl der Gruppen eintragen
		sc->grpCnt = stackPos;
	}

	//Speicher freigeben
	delete[] ( stack );
	delete[] ( tmpStack );
}


void ssLexClass::outputCPPHeader( ofstream &file )
{
	//den Header des CPP-Files ausgeben

	//Header des cpp-Files
file << "/***************************************************************************\n";
file << "                          sslrparser.cpp  -  description\n";
file << "                             -------------------\n";
file << "    copyright            : (C) 2002 by Sven Schmidt\n";
file << "    email                : s.schmidt@lboro.ac.uk\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "/***************************************************************************\n";
file << " *                                                                         *\n";
file << " *   This program is free software; you can redistribute it and/or modify  *\n";
file << " *   it under the terms of the GNU General Public License as published by  *\n";
file << " *   the Free Software Foundation; either version 2 of the License, or     *\n";
file << " *   (at your option) any later version.                                   *\n";
file << " *                                                                         *\n";
file << " ***************************************************************************/\n";
file << "\n";
file << "#include \"sslexscanner.h\"\n";
file << "#include <iostream>\n";
file << "\n";
file << "\n";

	//Debug-Version?
	if( argv_str->debug == true )
	{
		//Debug-Version
		file << "/****************************\n";
		file << "* This is the debug-version *\n";
		file << "****************************/\n\n\n";
	}

	else
	{
		//ist nicht die Debug-Version
		file << "/********************************\n";
		file << "* This is the non-debug-version *\n";
		file << "********************************/\n\n\n";
	}

file << "\n";
file << "\n";
file << "//Define macro ECHO\n";
file << "#define ECHO	cout << yyText\n";
file << "\n";
file << "//set a new start condition in user-defined action\n";
file << "#define BEGIN	setStartCondition\n";
file << "\n";
file << "//current start condition\n";
file << "#define YY_START	baseState\n";
file << "\n";
file << "//yyTerminate\n";
file << "#define yyTerminate()	return( ACCEPT )\n";
file << "\n";
file << "\n";
file << "//concatenate lexem\n";
file << "#define yyMore()	concatenate = true\n";
file << "\n";
file << "\n";
file << "//Size of start condition stack\n";
file << "#define SCStackSize	100\n";
file << "\n";
file << "\n";
}


void ssLexClass::outputEOF( ofstream &file )
{
	//<<EOF>>-NEAen ausgeben
	NEA_STR	*nea;
	SC_STR	*sc;
	ulong	i, j, k;

file << "int SSLEXScanner::endOfLine( void )\n";
file << "{\n";
file << "	//call eof-rules\n";
file << "\n";
file << "	//action depends on start condition\n";
file << "	switch( baseState )\n";
file << "	{\n";

	//Alle SC
	for( i = 0; i < scStrAnz; i++ )
	{
		//Zeiger auf SC
		sc = &scStr[i];

		//den Namen der SC ausgeben
		file << "		case " << sc->name << ":\n";
		file << "		{\n";

		//Hat die SC einen EOF-NEA?
		for( j = 0; j < sc->neaArrCnt; j++ )
		{
			//Zeiger auf NEA
			nea = sc->neaArr[j];

			//<<EOF>>?
			if( nea->eof == true )
			{
				//Ja, ausgeben

				//Alle Aktionen
				for( k = 0; k < nea->actionAnz; k++ )
					//ausgeben
					file << nea->action[k];

				//abschließen
				file << "\n\t\t}\n\n";

				//Schleife verlassen
				break;
			}
		}

		//hatte die SC <<EOF>>-NEAen?
		if( j == sc->neaArrCnt )
		{
			//Nein, die hatte keine
file << "			//default action\n";
file << "			yyTerminate();\n";
file << "\n";
file << "			break;\n";
file << "		}\n";
file << "\n";
		}
	}

file << "\n";
file << "		default:\n";
file << "		{\n";
file << "			//Unknown start condition\n";
file << "			cerr << \"SSLEXScanner::endOfLine: Line \" << yyLineno << \": Unknown start condition!\\n\";\n";
file << "\n";
file << "			//ignore\n";
file << "			break;\n";
file << "		}\n";
file << "	}\n";
file << "\n";
file << "	//this should never be executed!\n";
file << "	return( 0 );\n";
file << "}\n";
file << "\n\n";

}


void ssLexClass::outputInfo( void )
{
	//Informationen ausgeben

	//Anzahl der Regeln
	cout << "sslex: Number of rules: " << ruleCnt << "\n";

	//Anzahl der NEA-Zustände
	cout << "sslex: Number of nea states: " << stateStrCnt << "\n";

	//Anzahl der DEA-Zustände
	cout << "sslex: Number of dea states before minDEA: " << DEAStatesCnt << ", after: " << numberOfGroups << "\n";

	//Zahl der SC
	cout << "sslex: Number of start conditions: " << scStrAnz << "\n\n";
}

